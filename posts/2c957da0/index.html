<!DOCTYPE html><html lang="zh-CN"><head><title>老C的笔记本</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="stylesheet" href="../../layui/css/layui.css"><link rel="stylesheet" href="../../css/common.css"><link rel="stylesheet" href="../../css/post.css"><link rel="stylesheet" href="../../lib/prism/prism.css"><link rel="shortcut icon" href="../../img/favicon.ico"><link rel="stylesheet" href="../../lib/iconfont/iconfont.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="老C的搬砖日记" type="application/atom+xml"></head><body style="overflow:hidden" data-prismjs-copy="复制" data-prismjs-copy-success="复制成功!"><div class="qy-nav"><ul class="layui-nav" lay-filter="" lay-bar="disabled" lay-unselect><li class="hide-xs layui-nav-item" id="searchBtn" style="float:right"><a class="searchBtn" href="javascript:void(0);"><i class="layui-icon layui-icon-search"></i> 搜索</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/study"><i class="layui-icon layui-icon-video"></i> 前端教程</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://github.com/heliufang"><i class="icon iconfont icon-github"></i> github</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://gitee.com/heliufang"><i class="icon iconfont icon-gitee"></i> gitee</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf"><i class="icon iconfont icon-cnblogs"></i> 博客园</a></li><li class="layui-nav-item"><a class="title" href="/" style="padding:0"><i class="layui-anim layui-anim-rotate layui-anim-loop layui-icon layui-icon-star-fill"></i> 老C的笔记本</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/about"><i class="layui-icon layui-icon-friends"></i> 关于</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/archives"><i class="layui-icon layui-icon-date"></i> 归档</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/tags"><i class="layui-icon layui-icon-note"></i> 标签</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/categories"><i class="layui-icon layui-icon-template-1"></i> 分类</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/"><i class="layui-icon layui-icon-home"></i> 首页</a></li><li class="layui-nav-item hide-sm hide-md hide-lg" style="float:right"><a href="javascript:;">菜单</a><dl class="layui-nav-child"><dd><a href="/">首页</a></dd><dd><a href="/archives">归档</a></dd><dd><a href="/tags">标签</a></dd><dd><a href="/categories">分类</a></dd><dd><a href="/about">关于</a></dd><dd><a href="/study">前端教程</a></dd><dd><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github">github</a></dd><dd><a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee">gitee</a></dd><dd><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园">博客园</a></dd><dd><a href="javascript:void(0)" onclick='document.querySelector("#searchShade").style.display="block"'>搜索</a></dd></dl></li></ul><div id="loadingBox" class="loadingBox"><img src="/img/loading.gif"></div></div><div id="searchShade" class="searchShade"><div id="searchLayer"><div id="closeBtn" class="close"><i class="layui-icon layui-icon-close"></i></div><input id="searchTxt" type="text" placeholder="搜索文章(只支持文章标题关键字)" autofocus><div id="searchResult"></div></div></div><div class="layui-container center" id="top"><div class="layui-row layui-col-space20"><div class="layui-col-md3 hide-xs hide-sm"><div class="layui-card"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-speaker"></i> 公告</div><div class="layui-card-body"><div class="userinfo"><img src="/head.png"><div class="name">淡泊明志，宁静致远</div><div class="icons"><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github"><i class="icon iconfont icon-github"></i></a> <a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee"><i class="icon iconfont icon-gitee"></i></a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园"><i class="icon iconfont icon-cnblogs"></i></a></div><div class="other"><div class="item"><a class="title" style="color:#ff5722" href="/"><p class="num">59</p><div>文章</div></a></div><div class="item"><a style="color:#009688" href="/categories"><div class="num">9</div><div class="title">分类</div></a></div><div class="item"><a class="title" style="color:#01aaed" href="/tags"><div class="num">58</div><div>标签</div></a></div></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-website"></i> 网站资讯</div><div class="layui-card-body"><div class="webInfo-item"><div class="title">本站文章字数合计</div><div class="content">230.6k</div></div><div class="webInfo-item"><div class="title">本站Hexo版本</div><div class="content">6.1.0</div></div><div class="webInfo-item"><div class="title">本站Node版本</div><div class="content">13.14.0</div></div><div class="webInfo-item"><div class="title">本站已运行时间</div><div class="content"><span id="runDays" data-since-date="2020-12-24"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span>天</div></div><div class="webInfo-item"><div class="title">最后更新时间</div><div class="content" id="lastUpdate" data-last-update="2024-01-12 22:00:40"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-time"></i> 最新文章</div><div class="layui-card-body"><ul><li><a href="/posts/8088d2b5/">1.nuxt2笔记整理</a></li><li><a href="/posts/31559881/">2.js格式化时间间隔</a></li><li><a href="/posts/b1adc31a/">3.vue和react封装echart组件</a></li><li><a href="/posts/b4b4770b/">4.Nextjs入门笔记</a></li><li><a href="/posts/a35b4e10/">5.vue中window.open父子窗口通信</a></li></ul></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-template-1"></i> 文章分类</div><div class="layui-card-body left-a-color"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../categories/docker/">docker</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/java/">java</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/vue/">vue</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/web%E5%89%8D%E7%AB%AF/">web前端</a><span class="category-list-count">29</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/">公众号和小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/">其它技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li></ul></div></div><div style="height:calc(100% - 60px - 60px);width:267px" id="toc-area" class="layui-card ahover"><div class="layui-card-header"><i class="layui-icon layui-icon-align-center"></i> 本文目录</div><div id="tocMain" class="layui-card-body" style="overflow:auto;height:calc(100% - 60px - 60px)"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SPA"><span class="toc-text">SPA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E8%B7%AF%E7%94%B1"><span class="toc-text">vue路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">入门案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6"><span class="toc-text">创建组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99"><span class="toc-text">定义路由规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main-js%E6%8C%82%E8%BD%BD%E8%B7%AF%E7%94%B1"><span class="toc-text">main.js挂载路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#app-vue%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AF%BC%E8%88%AA"><span class="toc-text">app.vue展示组件和导航</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D"><span class="toc-text">动态路由匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">响应路由参数的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">通配符 (*)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">匹配优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1-%E5%A4%9A%E7%BA%A7%E8%B7%AF%E7%94%B1"><span class="toc-text">嵌套路由(多级路由)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1"><span class="toc-text">命名路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA"><span class="toc-text">编程式导航</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#router-push"><span class="toc-text">router.push()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router-replace"><span class="toc-text">router.replace()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router-go"><span class="toc-text">router.go()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE"><span class="toc-text">命名视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D"><span class="toc-text">重定向和别名</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%AB%E5%90%8D"><span class="toc-text">别名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82"><span class="toc-text">路由组件传参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F"><span class="toc-text">布尔模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">对象模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">函数模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#history%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">history工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-text">导航守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB"><span class="toc-text">全局前置守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E5%AE%88%E5%8D%AB"><span class="toc-text">全局后置守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E5%AE%88%E5%8D%AB"><span class="toc-text">路由独享守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%8B%AC%E4%BA%AB%E5%AE%88%E5%8D%AB"><span class="toc-text">组件独享守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#activated%E5%92%8Cdeactivated"><span class="toc-text">activated和deactivated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-text">完整的导航解析流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF"><span class="toc-text">路由元信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">路由懒加载</span></a></li></ol></div><div class="readprocess"><div><i class="layui-icon layui-icon-read"></i> 已阅读：<span id="progressTxt"></span>%</div><div class="layui-progress" lay-filter="demo"><div class="layui-progress-bar" lay-percent="10%"></div></div></div></div></div><div class="layui-col-md9 markdown-body" style="background:#fff;margin-top:10px"><div class="article-title"><p><span><i class="layui-icon layui-icon-template-1"></i> 分类: <span class="layui-badge layui-bg-cyan">vue</span> </span>| <span><i class="layui-icon layui-icon-note"></i> 标签: <span class="layui-badge layui-bg-black">vue</span> <span class="layui-badge layui-bg-black">vue-router</span></span></p><h1>vue-router笔记</h1><p><span><i class="layui-icon layui-icon-survey"></i> 发表于: 2022-07-06 21:13:28 </span>| <span><i class="layui-icon layui-icon-app"></i> 字数统计: 4.7k </span>| <span><i class="layui-icon layui-icon-log"></i> 阅读时长预计: 23分钟</span></p></div><div id="article"><p>vue-router官网：<a target="_blank" rel="noopener" href="https://v3.router.vuejs.org/zh/guide/essentials/navigation.html">https://v3.router.vuejs.org/zh/guide/essentials/navigation.html</a></p><h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>只有一个页面，切换页面不通过服务器刷新页面，而是通过路由和ajax。</p><h2 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h2><p>用 Vue.js + Vue Router 创建单页应用</p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3><p>Bar.vue</p><pre><code class="html">&lt;template&gt;
    &lt;div&gt;bar组件&lt;/div&gt;
&lt;/template&gt;
</code></pre><p>Foo.vue</p><pre><code class="html">&lt;template&gt;
    &lt;div&gt;foo组件&lt;/div&gt;
&lt;/template&gt;
</code></pre><h3 id="定义路由规则"><a href="#定义路由规则" class="headerlink" title="定义路由规则"></a>定义路由规则</h3><p>router&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;
import VueRouter from &#39;vue-router&#39;
import Foo from &#39;../views/Foo.vue&#39;
import Bar from &#39;../views/Bar.vue&#39;

Vue.use(VueRouter)

const routes = [
  &#123;
    path: &#39;/foo&#39;, // 匹配的路径
    component: Foo // 匹配的组件
  &#125;,
  &#123;
    path: &#39;/bar&#39;,
    component: Bar
  &#125;
]
const router = new VueRouter(&#123;
  routes
&#125;)
export default router
</code></pre><h3 id="main-js挂载路由"><a href="#main-js挂载路由" class="headerlink" title="main.js挂载路由"></a>main.js挂载路由</h3><pre><code class="js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import router from &#39;./router&#39;
import store from &#39;./store&#39;

Vue.config.productionTip = false

new Vue(&#123;
  router,//挂载路由
  store,
  render: h =&gt; h(App)
&#125;).$mount(&#39;#app&#39;)
</code></pre><h3 id="app-vue展示组件和导航"><a href="#app-vue展示组件和导航" class="headerlink" title="app.vue展示组件和导航"></a>app.vue展示组件和导航</h3><pre><code class="html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;h2&gt;APP组件&lt;/h2&gt;
    &lt;!--router-link 组件来导航： 通过传入 `to` 属性指定链接
    &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签
      active-class:表示激活的样式
      --&gt;
    &lt;router-link to=&quot;/foo&quot; active-class=&quot;active&quot;&gt;foo&lt;/router-link&gt;&amp;nbsp;
    &lt;router-link to=&quot;/bar&quot; active-class=&quot;active&quot;&gt;bar&lt;/router-link&gt;
    &lt;!-- --&gt;
    &lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style lang=&quot;less&quot;&gt;
  .active&#123;
    color: red;
  &#125;
&lt;/style&gt;
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.router.js中定义路由</p><p>2.main.js中挂载路由</p><p>3.router-link定义路由导航 router-view 定义路由展示区域</p><p>4.main.js中注入路由器之后，在任何组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由</p><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>其实就是restful风格的路径传参</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>第一步：创建组件</p><pre><code class="html">&lt;template&gt;
    &lt;!-- 获取路由的路径参数 $route.params --&gt;
    &lt;div&gt;user组件id: &#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;
&lt;/template&gt;
</code></pre><p>第二步：router&#x2F;index.js配置路由</p><pre><code class="js">import Vue from &#39;vue&#39;
import VueRouter from &#39;vue-router&#39;
import Foo from &#39;../views/Foo.vue&#39;
import Bar from &#39;../views/Bar.vue&#39;
import User from &#39;../views/User.vue&#39;

Vue.use(VueRouter)

const routes = [
  //....
  &#123;
    path: &#39;/user/:id&#39;,// 动态路径参数 以冒号开头
    component: User
  &#125;
]
const router = new VueRouter(&#123;
  routes
&#125;)
export default router
</code></pre><p>第三步：app.vue中使用</p><pre><code class="html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;h2&gt;APP组件&lt;/h2&gt;
    &lt;!--此处传递一个666参数,对应路由的id--&gt;
    &lt;router-link to=&quot;/user/666&quot; active-class=&quot;active&quot;&gt;User&lt;/router-link&gt;&amp;nbsp;
    &lt;!-- --&gt;
    &lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre><p>也可以在一个路由中设置多段“路径参数”，对应的值都会设置到 <code>$route.params</code> 中。例如：</p><table><thead><tr><th>模式</th><th>匹配路径</th><th>$route.params</th></tr></thead><tbody><tr><td>&#x2F;user&#x2F;:username</td><td>&#x2F;user&#x2F;evan</td><td><code>&#123; username: &#39;evan&#39; &#125;</code></td></tr><tr><td>&#x2F;user&#x2F;:username&#x2F;post&#x2F;:post_id</td><td>&#x2F;user&#x2F;evan&#x2F;post&#x2F;123</td><td><code>&#123; username: &#39;evan&#39;, post_id: &#39;123&#39; &#125;</code></td></tr></tbody></table><p>如果是通过？传参那么对应的值会设置到<code>$route.query</code>中</p><pre><code class="html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;h2&gt;APP组件&lt;/h2&gt;
    &lt;!--通过？传参那么对应的值会设置到`$route.query`--&gt;
    &lt;router-link to=&quot;/user?id=1&amp;name=tom&quot; active-class=&quot;active&quot;&gt;User&lt;/router-link&gt;&amp;nbsp;
    &lt;!-- --&gt;
    &lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre><h3 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h3><p>从 <code>/user/1</code> 导航到 <code>/user/2</code>，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子(destroyed)不会再被调用</strong>。</p><p>例如: 从666切换到777的时候，user组件的destroyed方法不会被调用</p><ul><li>app.vue</li></ul><pre><code class="html">&lt;router-link to=&quot;/user/666&quot; active-class=&quot;active&quot;&gt;User666&lt;/router-link&gt;&amp;nbsp;
&lt;router-link to=&quot;/user/777&quot; active-class=&quot;active&quot;&gt;User777&lt;/router-link&gt;&amp;nbsp;
</code></pre><ul><li>user.vue</li></ul><pre><code class="html">&lt;template&gt;
    &lt;!-- 获取路由的路径参数 --&gt;
    &lt;div&gt;user组件id: &#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  destroyed () &#123;
    console.log(&#39;User组件被销毁&#39;)
  &#125;,
  //   watch: &#123;
  //     $route (to, from) &#123;
  //       console.log(to, from)
  //     &#125;
  //   &#125;,
  beforeRouteUpdate (to, from, next) &#123;
    console.log(to, from)
    next()
  &#125;
&#125;
&lt;/script&gt;
</code></pre><p>两种方式： 监听路由参数的变化作出响应</p><p>第一种：watch监听</p><pre><code class="html">watch: &#123;
    $route (to, from) &#123;
      console.log(to, from)
    &#125;
  &#125;
</code></pre><p>第二种：使用组件内路由守卫<code>beforeRouteUpdate</code>这个路由钩子</p><pre><code class="js"> beforeRouteUpdate (to, from, next) &#123;
    console.log(to, from)
    next() //千万别忘了放行
  &#125;
</code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符 (*)"></a>通配符 (*)</h3><p>匹配所有。一般把这个放到最后面用来展示404错误页面</p><pre><code class="js">&#123;
    path: &#39;*&#39;,
    component: Error
  &#125;
</code></pre><p>匹配以xxx开头</p><pre><code class="js">&#123;
    path: &#39;/user-*&#39;,
    component: Test
  &#125;
</code></pre><p>当使用一个<em>通配符</em>时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过<em>通配符</em>被匹配的部分.也就是user-后面的部分</p><pre><code class="js">// 给出一个路由 &#123; path: &#39;/user-*&#39; &#125;
this.$router.push(&#39;/user-admin&#39;)
this.$route.params.pathMatch // &#39;admin&#39;
// 给出一个路由 &#123; path: &#39;*&#39; &#125;
this.$router.push(&#39;/non-existing&#39;)
this.$route.params.pathMatch // &#39;/non-existing&#39;
</code></pre><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><p>路由定义得越早，优先级就越高。</p><h2 id="嵌套路由-多级路由"><a href="#嵌套路由-多级路由" class="headerlink" title="嵌套路由(多级路由)"></a>嵌套路由(多级路由)</h2><p>在路由中新增一个children数组,数组中的每一个对象就是子路由.</p><p>注意： 子路由的path不要写 &#x2F;</p><p>router&#x2F;index.js</p><pre><code class="js">&#123;
    path: &#39;/user&#39;,
    component: User,
    children: [
      &#123;
        path: &#39;add&#39;,
        component: UserAdd
      &#125;,
      &#123;
        path: &#39;update&#39;,
        component: UserUpdate
      &#125;
    ]
  &#125;
</code></pre><p>user.vue组件</p><pre><code class="html">&lt;template&gt;
    &lt;div class=&quot;main&quot;&gt;
      &lt;h1&gt;user组件&lt;/h1&gt;
      &lt;router-link to=&quot;/user/add&quot;&gt;添加用户&lt;/router-link&gt;
      &lt;router-link to=&quot;/user/update&quot;&gt;修改用户&lt;/router-link&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre><p>UserAdd.vue组件</p><pre><code class="html">&lt;template&gt;
  &lt;div&gt;新增用户组件&lt;/div&gt;
&lt;/template&gt;
</code></pre><p>UserUpdate.vue组件</p><pre><code class="html">&lt;template&gt;
  &lt;div&gt;修改用户组件&lt;/div&gt;
&lt;/template&gt;
</code></pre><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候</p><pre><code class="js">&#123;
      path: &#39;/user/:userId&#39;,
      name: &#39;user&#39;, //给路由起个名字
      component: User
    &#125;
</code></pre><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p><h3 id="router-push"><a href="#router-push" class="headerlink" title="router.push()"></a>router.push()</h3><p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td><td><code>router.push(...)</code></td></tr></tbody></table><p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p><pre><code class="js">// 字符串
router.push(&#39;home&#39;)

// 对象
router.push(&#123; path: &#39;home&#39; &#125;)

// 命名的路由
router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)

// 带查询参数，变成 /register?plan=private
router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)
</code></pre><p>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。</p><pre><code class="js">const userId = &#39;123&#39;
router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user/123
router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123
// 这里的 params 不生效
router.push(&#123; path: &#39;/user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user
</code></pre><p>记忆： <strong>pp不能组合（path和params）</strong></p><h3 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace()"></a>router.replace()</h3><p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td><td><code>router.replace(...)</code></td></tr></tbody></table><h3 id="router-go"><a href="#router-go" class="headerlink" title="router.go()"></a>router.go()</h3><pre><code class="js">// 在浏览器记录中前进一步，等同于 history.forward()
router.go(1)

// 后退一步记录，等同于 history.back()
router.go(-1)

// 前进 3 步记录
router.go(3)

// 如果 history 记录不够用，那就默默地失败呗
router.go(-100)
router.go(100)
</code></pre><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p><pre><code class="html">&lt;router-view&gt;&lt;/router-view&gt;
&lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;
&lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt;
</code></pre><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 s)：</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;/&#39;,
      components: &#123; //这里变为components
        default: Foo,
        a: Bar, //a,b为名字和router-view中的name属性值对应
        b: Baz
      &#125;
    &#125;
  ]
&#125;)
</code></pre><h2 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123; path: &#39;/a&#39;, redirect: &#39;/b&#39; &#125;
  ]
&#125;)
</code></pre><p>重定向的目标也可以是一个命名的路由：</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123; path: &#39;/a&#39;, redirect: &#123; name: &#39;foo&#39; &#125;&#125;
  ]
&#125;)
</code></pre><p>甚至是一个方法，动态返回重定向目标：</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123; path: &#39;/a&#39;, redirect: to =&gt; &#123;
      // 方法接收 目标路由 作为参数
      // return 重定向的 字符串路径/路径对象
    &#125;&#125;
  ]
&#125;)
</code></pre><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>“重定向”的意思是，当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢？</p><p><strong><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</strong></p><p>上面对应的路由配置为：</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123; path: &#39;/a&#39;, component: A, alias: &#39;/b&#39; &#125;
  ]
&#125;)
</code></pre><p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p><h2 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h2><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。使用 <code>props</code> 将组件和路由解耦：（简化这种写法 $route.params.id）</p><h3 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h3><p>如果 <code>props</code> 被设置为 <code>true</code>，<code>route.params</code> 将会被设置为组件属性（类似父组件给子组件传值）。</p><pre><code class="js">const User = &#123;
  props: [&#39;id&#39;], //这里和父组件给子组件传值一样
  template: &#39;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#39;
&#125;
const router = new VueRouter(&#123;
  routes: [
    &#123; path: &#39;/user/:id&#39;, component: User, props: true &#125;,//props设置为true

    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：
    &#123;
      path: &#39;/user/:id&#39;,
      components: &#123; default: User, sidebar: Sidebar &#125;,
      props: &#123; default: true, sidebar: false &#125;
    &#125;
  ]
&#125;)
</code></pre><h3 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h3><p><code>props</code> 是对象，它会被按原样设置为组件属性。当 <code>props</code> 是<strong>静态</strong>的时候有用。（props后对象是写死的）</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;/promotion/from-newsletter&#39;,
      component: Promotion,
      props: &#123; newsletterPopup: false &#125;
    &#125;
  ]
&#125;)
</code></pre><h3 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h3><p>你可以创建一个函数返回 <code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;/search&#39;,
      component: SearchUser,
      props: route =&gt; (&#123; query: route.query.q &#125;)
    &#125;
  ]
&#125;)
</code></pre><p>URL <code>/search?q=vue</code> 会将 <code>&#123;query: &#39;vue&#39;&#125;</code> 作为属性传递给 <code>SearchUser</code> 组件。</p><p>请尽可能保持 <code>props</code> 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 <code>props</code>，请使用包装组件，这样 Vue 才可以对状态变化做出反应。</p><h2 id="history工作模式"><a href="#history工作模式" class="headerlink" title="history工作模式"></a>history工作模式</h2><p>hash模式，页面不会重新加载，带# ，url不好看</p><p>history模式, 页面会重新加载，但是需要后端配合配置，否则就报错了。url好看</p><pre><code class="js">const router = new VueRouter(&#123;
  mode: &#39;history&#39;,
  routes: [...]
&#125;)
</code></pre><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>导航守卫主要用来通过跳转或取消的方式守卫导航。分为：全局的, 单个路由独享的,和组件级的</p><p>记住<strong>参数或查询的改变并不会触发进入&#x2F;离开的导航守卫</strong>。你可以通过<a target="_blank" rel="noopener" href="https://v3.router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">观察 <code>$route</code> 对象</a>来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫。例如：&#x2F;user&#x2F;1 和 &#x2F;user&#x2F;2</p><p>守卫说白了，类似拦截器</p><h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p><pre><code class="js">const router = new VueRouter(&#123; ... &#125;)

router.beforeEach((to, from, next) =&gt; &#123;
  // ...
&#125;)
</code></pre><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p><p>每个守卫方法接收三个参数：</p><ul><li><strong><code>to: Route</code></strong>: 即将要进入的目标 <a target="_blank" rel="noopener" href="https://v3.router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1">路由对象</a></li><li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</li><li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。<ul><li><strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li><li><strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li><li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a target="_blank" rel="noopener" href="https://v3.router.vuejs.org/zh/api/#to"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a target="_blank" rel="noopener" href="https://v3.router.vuejs.org/zh/api/#router-push"><code>router.push</code></a> 中的选项。</li><li><strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a target="_blank" rel="noopener" href="https://v3.router.vuejs.org/zh/api/#router-onerror"><code>router.onError()</code></a> 注册过的回调。</li></ul></li></ul><p><strong>确保 <code>next</code> 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错</strong>。这里有一个在用户未能验证身份时重定向到 <code>/login</code> 的示例：</p><pre><code class="js">// BAD
router.beforeEach((to, from, next) =&gt; &#123;
  if (to.name !== &#39;Login&#39; &amp;&amp; !isAuthenticated) next(&#123; name: &#39;Login&#39; &#125;)
  // 如果用户未能验证身份，则 `next` 会被调用两次
  next()
&#125;)
// GOOD
router.beforeEach((to, from, next) =&gt; &#123;
  if (to.name !== &#39;Login&#39; &amp;&amp; !isAuthenticated) next(&#123; name: &#39;Login&#39; &#125;)
  else next()
&#125;)
</code></pre><h3 id="全局后置守卫"><a href="#全局后置守卫" class="headerlink" title="全局后置守卫"></a>全局后置守卫</h3><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p><pre><code class="js">router.afterEach((to, from) =&gt; &#123;
  // ...
&#125;)
</code></pre><h3 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h3><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;/foo&#39;,
      component: Foo,
      beforeEnter: (to, from, next) =&gt; &#123;
        // ...
      &#125;
    &#125;
  ]
&#125;)
</code></pre><p>这些守卫与全局前置守卫的方法参数是一样的。</p><h3 id="组件独享守卫"><a href="#组件独享守卫" class="headerlink" title="组件独享守卫"></a>组件独享守卫</h3><p>可以在路由组件内直接定义以下路由导航守卫：</p><ul><li><code>beforeRouteEnter</code> <strong>通过路由进入组件之前</strong></li><li><code>beforeRouteUpdate</code> (2.2 新增) <strong>当前路由改变，但是该组件被复用时调用</strong></li><li><code>beforeRouteLeave</code> <strong>通过路由离开组件之前</strong></li></ul><pre><code class="js">const Foo = &#123;
  template: `...`,
  beforeRouteEnter(to, from, next) &#123;
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  &#125;,
  beforeRouteUpdate(to, from, next) &#123;
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  &#125;,
  beforeRouteLeave(to, from, next) &#123;
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  &#125;
&#125;
</code></pre><h3 id="activated和deactivated"><a href="#activated和deactivated" class="headerlink" title="activated和deactivated"></a>activated和deactivated</h3><p>当在router-view开启组件缓存的时候,组件不会调用destoryd生命周期方法,此时可以通过activated和deactivated这两个方法判断当前组件是激活状态还是失活状态。</p><pre><code class="html">&lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;
    &lt;keep-alive include=&quot;Foo&quot;&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/keep-alive&gt;
</code></pre><p>Foo.vue</p><pre><code class="html">&lt;template&gt;
    &lt;!-- &lt;div&gt;foo组件：&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt; --&gt;
    &lt;div&gt;foo组件：&#123;&#123;query&#125;&#125;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;Foo&#39;,
  props: [&#39;query&#39;],
  beforeRouteUpdate (to, from, next) &#123;
    console.log(&#39;Foo组件独享守卫--beforeRouteUpdate&#39;, to, from)
    next()
  &#125;,
  activated () &#123; // 组件被激活了
    console.log(&#39;Foo组件activated&#39;)
  &#125;,
  deactivated () &#123;
    console.log(&#39;Foo组件deactivated&#39;)
  &#125;
&#125;
&lt;/script&gt;
</code></pre><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>定义路由的时候可以配置 <code>meta</code> 字段，那么如何访问这个 <code>meta</code> 字段呢？<code>$route.matched</code> 数组</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;/foo&#39;,
      component: Foo,
      children: [
        &#123;
          path: &#39;bar&#39;,
          component: Bar,
          // a meta field
          meta: &#123; requiresAuth: true &#125;
        &#125;
      ]
    &#125;
  ]
&#125;)
</code></pre><p>下面例子展示在全局导航守卫中检查元字段：</p><pre><code class="js">router.beforeEach((to, from, next) =&gt; &#123;
  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;
    // this route requires auth, check if logged in
    // if not, redirect to login page.
    if (!auth.loggedIn()) &#123;
      next(&#123;
        path: &#39;/login&#39;,
        query: &#123; redirect: to.fullPath &#125;
      &#125;)
    &#125; else &#123;
      next()
    &#125;
  &#125; else &#123;
    next() // 确保一定要调用 next()
  &#125;
&#125;)
</code></pre><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>结合 Vue 的<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6">异步组件 (opens new window)</a>和 Webpack 的<a target="_blank" rel="noopener" href="https://doc.webpack-china.org/guides/code-splitting-async/#require-ensure-/">代码分割功能 (opens new window)</a>，轻松实现路由组件的懒加载。</p><pre><code class="js">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)
const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)
const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)
</code></pre><p>webpackChunkName为打包分块的名称</p></div><div class="post-ending"><div class="end-txt">------ 本文结束，感谢您的阅读 ------</div><blockquote class="layui-elem-quote layui-quote-nm" style="padding:10px"><div><span class="title">本文作者: </span>贺刘芳</div><div><span class="title">本文链接: </span><a target="_blank" href="https://heliufang.github.io/posts/2c957da0/">https://heliufang.github.io/posts/2c957da0/</a></div><div><span class="title">版权声明: </span>本文采用知识共享署名-非商业性使用-禁止演绎 2.5 中国大陆许可协议进行许可。</div></blockquote><div id="vcomments"></div></div></div></div></div><ul id="toTopBtn" class="layui-fixbar" style="right:-70px" title="置顶"><div><a href="javascript:void(0)" class="icon iconfont icon-huojian"></a></div></ul><div class="qy-footer"><div class="font-Area"><p>访客数 <span style="color:red" id="busuanzi_value_site_uv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 人次 | 访问量 <span style="color:red" id="busuanzi_value_site_pv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 次 | 本站已运行 <span style="color:red" id="runDaysFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 天 | 本站文章字数合计 <span style="color:red">230.6k</span> | 最后更新于 <span style="color:red" id="lastUpdateFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span></p><p>由 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a> <span style="color:red" class="layui-icon layui-icon-find-fill layui-anim layui-anim-rotate layui-anim-loop"></span> 强力驱动 v6.1.0</p><p>Copyright © 2020 ~<span id="currentYear">2022</span> <span class="layui-icon layui-icon-heart-fill footer-heart"></span> HeLiuFang</p></div></div></body><script src="../../js/jquery.min.js"></script><script src="../../js/moment.min.js"></script><script src="../../layui/layui.js"></script><script src="../../lib/prism/prism.js"></script><script>$("#searchBtn").click(function(){$("#searchShade").show(),$("#searchLayer").addClass("layui-anim layui-anim-scaleSpring")}),$("#closeBtn").click(function(){$("#searchShade").hide()});var searchFunc=function(e,o,a){$.ajax({url:e,dataType:"json",success:function(e){var t=document.getElementById(o),n=document.getElementById(a);t.addEventListener("input",function(){var t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(e){var n=!0,o=e.title.trim().toLowerCase(),e=e.url;""!=o&&a.forEach(function(e,t){o.indexOf(e)<0?n=!1:o=o.replace(new RegExp(e,"g"),'<span style="color:red">'+e+"</span>")}),n&&(t=t+"<li><a href='"+e+"' class='search-result-title'>"+o+"</a></li>")}),t+="</ul>",n.innerHTML=t)})}})};function DynamicLine(){function e(e,t,n){return e.getAttribute(t)||n}function t(e){return document.getElementsByTagName(e)}function n(){s=a.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,r=a.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function c(){var n,o,a,i,l;m.clearRect(0,0,s,r),y.forEach(function(e,t){for(e.x+=e.xa,e.y+=e.ya,e.xa*=e.x>s||e.x<0?-1:1,e.ya*=e.y>r||e.y<0?-1:1,m.fillRect(e.x-.5,e.y-.5,1,1),o=t+1;o<d.length;o++)null!==(n=d[o]).x&&null!==n.y&&(a=e.x-n.x,i=e.y-n.y,(l=a*a+i*i)<n.max)&&(n===h&&l>=n.max/2&&(e.x-=.03*a,e.y-=.03*i),a=(n.max-l)/n.max,m.beginPath(),m.lineWidth=a/2,m.strokeStyle="rgba("+u.c+","+(.2+a)+")",m.moveTo(e.x,e.y),m.lineTo(n.x,n.y),m.stroke())}),w(c)}var s,r,d,o,a=document.createElement("canvas"),u=(i=(o=t("script")).length,o=o[i-1],{l:i,z:e(o,"zIndex",-1),o:e(o,"opacity",.5),c:e(o,"color","0,0,50"),n:e(o,"count",99)}),i="c_n"+u.l,m=a.getContext("2d"),w=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(e,1e3/45)},l=Math.random,h={x:null,y:null,max:2e4};a.id=i,a.style.cssText="position:fixed;top:0;left:0;z-index:"+u.z+";opacity:"+u.o,t("body")[0].appendChild(a),n(),window.onresize=n,window.onmousemove=function(e){e=e||window.event,h.x=e.clientX,h.y=e.clientY},window.onmouseout=function(){h.x=null,h.y=null};for(var y=[],x=0;x<u.n;x++){var f=l()*s,p=l()*r,$=2*l()-1,v=2*l()-1;y.push({x:f,y:p,xa:$,ya:v,max:6e3})}d=y.concat([h]),setTimeout(function(){c()},100)}searchFunc("/search.json","searchTxt","searchResult"),DynamicLine(),document.querySelector("#currentYear").innerText=(new Date).getFullYear();var days=moment().diff($("#runDays")[0].dataset.sinceDate,"days"),lastUpdate=($("#runDays").html(days),$("#runDaysFooter").html(days),moment($("#lastUpdate")[0].dataset.lastUpdate,"YYYY-MM-DD HH:mm:ss").locale("zh-CN").fromNow());$("#lastUpdate").html(lastUpdate),$("#lastUpdateFooter").html(lastUpdate),$("#toTopBtn").click(function(){var e=$(window).scrollTop(),t=parseInt(e/60),n=setInterval(function(){$(window).scrollTop($(window).scrollTop()-t),0===$(window).scrollTop()&&clearInterval(n)},1)}),$.event.add(window,"scroll",function(){$("#toTopBtn").css("transform",0<$(window).scrollTop()?"translateX(-85px)":"translateX(85px)"),$("#toTopBtn").css("transition","all 0.5s")}),$("#loadingBox").hide(),$("body").css("overflow","auto")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var element=null;layui.use(["element"],function(){element=layui.element}),$(function(){var e=$("#toc-area"),t=$(e).offset().top;$.event.add(window,"scroll",function(){var o=$(".markdown-body").height(),o=(($(window).scrollTop()+t)/o*100).toFixed(2);element.progress("demo",(o=0==(o=99<o?100:o)?0:o)+"%"),$("#progressTxt").text(o),console.log("percent",o),$(e).css("position",$(window).scrollTop()>t?"fixed":"static"),$(e).css("top",$(window).scrollTop()>t?"60px":""),$("#tocMain").scrollTop($("#tocMain .toc").height()*o*.01)}),$("pre code").each(function(){var o=$(this).attr("class");o="language-"+(null==o||""==o||null==o?"plaintext":o),$(this).attr("class",o)}),$("pre").prepend('<div class="copy-to-clipboard-button"></div>')})</script></html>