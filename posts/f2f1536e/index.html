<!DOCTYPE html><html lang="zh-CN"><head><title>贺刘芳的笔记本</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="stylesheet" href="../../layui/css/layui.css"><link rel="stylesheet" href="../../css/common.css"><link rel="stylesheet" href="../../css/post.css"><link rel="stylesheet" href="../../lib/prism/prism.css"><link rel="shortcut icon" href="../../img/favicon.ico"><link rel="stylesheet" href="../../lib/iconfont/iconfont.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="贺刘芳的搬砖日记" type="application/atom+xml"></head><body style="overflow:hidden" data-prismjs-copy="复制" data-prismjs-copy-success="复制成功!"><div class="qy-nav"><ul class="layui-nav" lay-filter="" lay-bar="disabled" lay-unselect><li class="hide-xs layui-nav-item" id="searchBtn" style="float:right"><a class="searchBtn" href="javascript:void(0);"><i class="layui-icon layui-icon-search"></i> 搜索</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://github.com/heliufang"><i class="icon iconfont icon-github"></i> github</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://gitee.com/heliufang"><i class="icon iconfont icon-gitee"></i> gitee</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf"><i class="icon iconfont icon-cnblogs"></i> 博客园</a></li><li class="layui-nav-item"><a class="title" href="/" style="padding:0"><i class="layui-anim layui-anim-rotate layui-anim-loop layui-icon layui-icon-star-fill"></i> 贺刘芳的笔记本</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/about"><i class="layui-icon layui-icon-friends"></i> 关于</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/archives"><i class="layui-icon layui-icon-date"></i> 归档</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/tags"><i class="layui-icon layui-icon-note"></i> 标签</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/categories"><i class="layui-icon layui-icon-template-1"></i> 分类</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/"><i class="layui-icon layui-icon-home"></i> 首页</a></li><li class="layui-nav-item hide-sm hide-md hide-lg" style="float:right"><a href="javascript:;">菜单</a><dl class="layui-nav-child"><dd><a href="/">首页</a></dd><dd><a href="/archives">归档</a></dd><dd><a href="/tags">标签</a></dd><dd><a href="/categories">分类</a></dd><dd><a href="/about">关于</a></dd><dd><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github">github</a></dd><dd><a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee">gitee</a></dd><dd><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园">博客园</a></dd><dd><a href="javascript:void(0)" onclick='document.querySelector("#searchShade").style.display="block"'>搜索</a></dd></dl></li></ul><div id="loadingBox" class="loadingBox"><img src="/img/loading.gif"></div></div><div id="searchShade" class="searchShade"><div id="searchLayer"><div id="closeBtn" class="close"><i class="layui-icon layui-icon-close"></i></div><input id="searchTxt" type="text" placeholder="搜索文章(只支持文章标题关键字)" autofocus><div id="searchResult"></div></div></div><div class="layui-container center" id="top"><div class="layui-row layui-col-space20"><div class="layui-col-md3 hide-xs hide-sm"><div class="layui-card"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-speaker"></i> 公告</div><div class="layui-card-body"><div class="userinfo"><img src="/head.png"><div class="name">淡泊明志，宁静致远</div><div class="icons"><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github"><i class="icon iconfont icon-github"></i></a> <a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee"><i class="icon iconfont icon-gitee"></i></a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园"><i class="icon iconfont icon-cnblogs"></i></a></div><div class="other"><div class="item"><a class="title" style="color:#ff5722" href="/"><p class="num">40</p><div>文章</div></a></div><div class="item"><a style="color:#009688" href="/categories"><div class="num">7</div><div class="title">分类</div></a></div><div class="item"><a class="title" style="color:#01aaed" href="/tags"><div class="num">44</div><div>标签</div></a></div></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-website"></i> 网站资讯</div><div class="layui-card-body"><div class="webInfo-item"><div class="title">已运行时间</div><div class="content"><span id="runDays" data-since-date="2020-12-24"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span>天</div></div><div class="webInfo-item"><div class="title">本站文章字数合计</div><div class="content">200.8k</div></div><div class="webInfo-item"><div class="title">最后更新时间</div><div class="content" id="lastUpdate" data-last-update="2023-01-13 23:27:30"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-time"></i> 最新文章</div><div class="layui-card-body"><ul><li><a href="/posts/27fcdfc0/">1.react笔记</a></li><li><a href="/posts/304cd95d/">2.vue3.2新特性笔记</a></li><li><a href="/posts/f2f1536e/">3.node笔记</a></li><li><a href="/posts/73c9868e/">4.vue3笔记</a></li><li><a href="/posts/9d362be7/">5.TypeScript笔记</a></li></ul></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-template-1"></i> 文章分类</div><div class="layui-card-body left-a-color"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../categories/java/">java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/vue/">vue</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/web%E5%89%8D%E7%AB%AF/">web前端</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/">公众号和小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/">其它技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li></ul></div></div><div style="height:calc(100% - 60px - 60px);width:267px" id="toc-area" class="layui-card ahover"><div class="layui-card-header"><i class="layui-icon layui-icon-align-center"></i> 本文目录</div><div id="tocMain" class="layui-card-body" style="overflow:auto;height:calc(100% - 60px - 60px)"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">node基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">node是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodejs%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">nodejs与浏览器的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodejs%E5%8F%AF%E4%BB%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">nodejs可以干什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E5%AE%89%E8%A3%85"><span class="toc-text">node安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8Cnode%E7%A8%8B%E5%BA%8F"><span class="toc-text">运行node程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#repl%E6%96%B9%E5%BC%8F"><span class="toc-text">repl方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E6%89%A7%E8%A1%8Cjs%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F-%E6%8E%8C%E6%8F%A1"><span class="toc-text">node执行js文件方式(掌握)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">node常用模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#global%E6%A8%A1%E5%9D%97-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">global模块(全局变量)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs%E6%A8%A1%E5%9D%97-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="toc-text">fs模块(操作文件)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E6%96%87%E4%BB%B6"><span class="toc-text">追加文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-text">文件的同步与异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96api%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">其他api（了解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E6%A8%A1%E5%9D%97"><span class="toc-text">http模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-text">创建服务器基本步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#request%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3"><span class="toc-text">request对象详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#response%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3"><span class="toc-text">response对象详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C%E8%AF%B7%E6%B1%82%E8%BE%93%E5%87%BA%E4%B8%8D%E5%90%8C%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE"><span class="toc-text">根据不同请求输出不同响应数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6"><span class="toc-text">服务器响应文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MIME%E7%B1%BB%E5%9E%8B"><span class="toc-text">MIME类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mime%E6%A8%A1%E5%9D%97"><span class="toc-text">mime模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#url%E6%A8%A1%E5%9D%97"><span class="toc-text">url模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#path%E6%A8%A1%E5%9D%97"><span class="toc-text">path模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5"><span class="toc-text">路径拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-text">获取文件名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%89%A9%E5%B1%95%E5%90%8D"><span class="toc-text">获取扩展名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-npm"><span class="toc-text">包管理器-npm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#npm%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">npm的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">npm基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E5%92%8C%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85"><span class="toc-text">本地安装和全局安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package-json%E6%96%87%E4%BB%B6"><span class="toc-text">package.json文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F-nrm"><span class="toc-text">npm下载加速-nrm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nodemon-%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF"><span class="toc-text">nodemon 自动重启</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#art-template-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="toc-text">art-template 模板引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">服务端重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#post%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-text">post请求参数处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E6%A8%A1%E5%9D%97%E5%88%86%E7%B1%BB"><span class="toc-text">node模块分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="toc-text">模块的导入导出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5"><span class="toc-text">模块导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%87%BA"><span class="toc-text">模块导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#module-exports%E4%B8%8Eexports"><span class="toc-text">module.exports与exports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E4%BA%86%E8%A7%A3"><span class="toc-text">第三方模块代码执行流程(了解)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonJS-%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-text">CommonJS 规范参考文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">node操作mysql数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-mysql-%E6%A8%A1%E5%9D%97"><span class="toc-text">配置 mysql 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E6%93%8D%E4%BD%9Cmysql%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">node操作mysql增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-text">添加数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">查询数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-text">修改数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-text">删除数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E6%93%8D%E4%BD%9Cmongodb%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">node操作mongodb数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">数据增删改查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Express%E6%A1%86%E6%9E%B6"><span class="toc-text">Express框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-text">托管静态资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request%E5%92%8Cresponse"><span class="toc-text">request和response</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#request%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">request常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#response%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">response常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#expres%E4%B8%AD%E4%BD%BF%E7%94%A8art-template"><span class="toc-text">expres中使用art-template</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-text">路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">全局中间件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">局部中间件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%88%86%E7%B1%BB"><span class="toc-text">中间件分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">应用级别的中间件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BA%A7%E5%88%AB%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">路由级别的中间件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%BA%A7%E5%88%AB%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">错误级别的中间件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">内置中间件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">第三方中间件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="toc-text">CORS 跨域资源共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS-%E5%B8%B8%E8%A7%81%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">CORS 常见响应头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS-%E8%AF%B7%E6%B1%82%E5%88%86%E7%B1%BB"><span class="toc-text">CORS 请求分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82"><span class="toc-text">预检请求</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#express%E4%B8%AD%E4%BD%BF%E7%94%A8cors"><span class="toc-text">express中使用cors</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-text">身份认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt%E8%AE%A4%E8%AF%81"><span class="toc-text">jwt认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">Session 的局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-text">JWT 工作原理图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">JWT 组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">JWT的使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Express-%E4%BD%BF%E7%94%A8-JWT%E8%AE%A4%E8%AF%81"><span class="toc-text">Express 使用 JWT认证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session%E8%AE%A4%E8%AF%81"><span class="toc-text">session认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#session%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86"><span class="toc-text">session认证原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Express%E4%B8%AD%E4%BD%BF%E7%94%A8session%E8%AE%A4%E8%AF%81"><span class="toc-text">Express中使用session认证</span></a></li></ol></li></ol></li></ol></div><div class="readprocess"><div><i class="layui-icon layui-icon-read"></i> 已阅读：<span id="progressTxt"></span>%</div><div class="layui-progress" lay-filter="demo"><div class="layui-progress-bar" lay-percent="10%"></div></div></div></div></div><div class="layui-col-md9 markdown-body" style="background:#fff;margin-top:10px"><div class="article-title"><p><span><i class="layui-icon layui-icon-template-1"></i> 分类: <span class="layui-badge layui-bg-cyan">web前端</span> </span>| <span><i class="layui-icon layui-icon-note"></i> 标签: <span class="layui-badge layui-bg-black">node</span></span></p><h1>node笔记</h1><p><span><i class="layui-icon layui-icon-survey"></i> 发表于: 2022-10-30 19:19:28 </span>| <span><i class="layui-icon layui-icon-app"></i> 字数统计: 10.6k </span>| <span><i class="layui-icon layui-icon-log"></i> 阅读时长预计: 52分钟</span></p></div><div id="article"><h2 id="node基本概念"><a href="#node基本概念" class="headerlink" title="node基本概念"></a>node基本概念</h2><h3 id="node是什么"><a href="#node是什么" class="headerlink" title="node是什么"></a>node是什么</h3><p>node.js，也叫作node，或者nodejs，指的都是一个东西。</p><ol><li><a target="_blank" rel="noopener" href="https://nodejs.org/">node.js官方网站</a></li><li><a target="_blank" rel="noopener" href="http://nodejs.cn/">node.js中文网</a></li><li><a target="_blank" rel="noopener" href="https://cnodejs.org/">node.js 中文社区</a></li><li><a target="_blank" rel="noopener" href="https://www.runoob.com/nodejs/nodejs-tutorial.html">菜鸟教程-node</a></li></ol><p>Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。</p><ul><li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</li></ul><pre><code>1. nodejs是在服务端运行javascript的运行环境
2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。
3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎。
</code></pre><ul><li>Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，使其轻量又高效。</li><li>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li></ul><p><strong>nodejs的本质：不是一门新的编程语言，nodejs是javascript运行在服务端的运行环境，编程语言还是javascript</strong></p><h3 id="nodejs与浏览器的区别"><a href="#nodejs与浏览器的区别" class="headerlink" title="nodejs与浏览器的区别"></a>nodejs与浏览器的区别</h3><p>相同点：nodejs与浏览器都是浏览器的运行环境，都能够解析js程序。对于ECMAScript语法来说，在nodejs和浏览器中都能运行。</p><p>不同点：<code>nodejs无法使用DOM和BOM的操作</code>，浏览器无法执行nodejs中的文件操作等功能</p><p><img src="/posts/f2f1536e/image-20221024215658030.png" alt="image-20221024215658030"></p><h3 id="nodejs可以干什么？"><a href="#nodejs可以干什么？" class="headerlink" title="nodejs可以干什么？"></a>nodejs可以干什么？</h3><ol><li>开发服务端程序</li><li>开发命令行工具（CLI），比如npm,webpack,gulp,less,sass等</li><li>开发桌面应用程序（借助 node-webkit、<code>electron</code> 等框架实现）</li></ol><h2 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h2><p>下载地址</p><ul><li><a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">当前版本</a></li><li><a target="_blank" rel="noopener" href="https://nodejs.org/en/download/releases/">历史版本</a></li></ul><p>官网术语解释</p><ul><li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li><li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入。</li></ul><p>下载之后一直点下一步即可完成安装，安装之后查看node版本</p><pre><code class="bash">node -v
</code></pre><h2 id="运行node程序"><a href="#运行node程序" class="headerlink" title="运行node程序"></a>运行node程序</h2><h3 id="repl方式"><a href="#repl方式" class="headerlink" title="repl方式"></a>repl方式</h3><ol><li>REPL 全称: Read-Eval-Print-Loop（交互式解释器）<ul><li>R 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</li><li>E 执行 - 执行输入的数据结构</li><li>P 打印 - 输出结果</li><li>L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。</li></ul></li><li>在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能）<ul><li>直接在控制台输入 <code>node</code> 命令进入 REPL 环境</li></ul></li><li>按两次 Control + C 退出REPL界面 或者 输入 <code>.exit</code> 退出 REPL 界面<ul><li>按住 control 键不要放开, 然后按两下 c 键</li></ul></li></ol><p><img src="/posts/f2f1536e/image-20221024220716342.png" alt="image-20221024220716342"></p><h3 id="node执行js文件方式-掌握"><a href="#node执行js文件方式-掌握" class="headerlink" title="node执行js文件方式(掌握)"></a>node执行js文件方式(掌握)</h3><ul><li>创建js文件 <code>helloworld.js</code></li></ul><ul><li>写nodejs的内容：<code>console.log(&#39;hello nodejs&#39;)</code></li><li>打开命令窗口 <code>cmd</code><ul><li>shift加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li><li>给vscode安装<code>terminal</code>插件，直接在vscode中执行</li></ul></li><li>执行命令：<code>node helloworld.js</code></li></ul><p>注意：<strong style="color:red">在nodejs中是无法使用DOM和BOM的内容的，因此<code>document, window</code>等内容是无法使用的。</strong></p><h2 id="node常用模块"><a href="#node常用模块" class="headerlink" title="node常用模块"></a>node常用模块</h2><h3 id="global模块-全局变量"><a href="#global模块-全局变量" class="headerlink" title="global模块(全局变量)"></a>global模块(全局变量)</h3><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p><p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 <code>global</code>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p><p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p><p>常用的global属性</p><pre><code class="js">console: //用于打印日志
setTimeout/clearTimeout: //设置清除延时器
setInterval/clearInterval: //设置清除定时器

__dirname: //当前文件的路径，不包括文件名
__filename： //获取当前文件的路径，包括文件名

//与模块化相关的，模块化的时候会用到
require
exports
module
</code></pre><h3 id="fs模块-操作文件"><a href="#fs模块-操作文件" class="headerlink" title="fs模块(操作文件)"></a>fs模块(操作文件)</h3><blockquote><p>fs模块是nodejs中最常用的一个模块，因此掌握fs模块非常的有必要，fs模块的方法非常多,用到了哪个查哪个即可。</p><p>文档地址：<a target="_blank" rel="noopener" href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p></blockquote><p>在nodejs中，提供了fs模块，这是node的核心模块</p><p>注意：</p><ol><li>除了global模块中的内容可以直接使用，其他<strong style="color:red">模块都是需要加载的</strong>。</li><li>fs模块不是全局的，不能直接使用。因此需要导入才能使用。</li></ol><pre><code class="js">let fs = require(&quot;fs&quot;);
</code></pre><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><blockquote><p>语法：fs.readFile(path[,options], callback</p><p>path: 带文件名称的文件路径</p><p>options： 文件编码(可选) 若不传则返回buffer对象</p><p>callback(err,data): 文件读完的回调</p></blockquote><p>方式1：不传编码参数,回调函数中可以得到buffer对象,需要使用toString转化成字符串</p><pre><code class="js">let fs = require(&#39;fs&#39;)
fs.readFile(&#39;1.txt&#39;,(err,data) =&gt; &#123;
    console.log(data) //打印buffer对象
    console.log(data.toString()) //正常打印字符串
&#125;)
</code></pre><p>方式2： 传编码参数,回调函数中可以得到读取到的字符串</p><pre><code class="js">let fs = require(&#39;fs&#39;)
fs.readFile(&#39;1.txt&#39;,&#39;utf-8&#39;,(err,data) =&gt; &#123;
    console.log(&#39;data :&gt;&gt; &#39;, data);
&#125;)
</code></pre><p>关于Buffer对象</p><pre><code>1. Buffer对象是Nodejs用于处理二进制数据的。
2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制。
3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象
4. Buffer对象可以调用toString()方法转换成字符串。
</code></pre><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><blockquote><p>语法：fs.writeFile(filepath, data[, options], callback)</p><p>filepath：带文件名称的文件路径</p><p>data： 要写入的文件内容</p><p>callback(err)： 写入成功之后的回调</p></blockquote><p>注意：此方式会把之前文件的内容覆盖</p><pre><code class="js">let fs = require(&#39;fs&#39;)
fs.writeFile(&#39;2.txt&#39;,&#39;node写文件&#39;,err =&gt; &#123;
    console.log(&#39;写入成功！&#39;)
&#125;)
</code></pre><h4 id="追加文件"><a href="#追加文件" class="headerlink" title="追加文件"></a>追加文件</h4><blockquote><p>语法：fs.appendFile(filepath, data[, options], callback)</p><p>filepath：带文件名称的文件路径</p><p>data： 要追加的文件内容</p><p>callback(err)： 追加成功之后的回调</p></blockquote><pre><code class="js">let fs = require(&#39;fs&#39;)
fs.appendFile(&#39;2.txt&#39;,&#39;我是追加的&#39;,err =&gt; &#123;
    console.log(&#39;追加成功！&#39;)
&#125;)
</code></pre><p>思考：如果没有appendFile，通过readFile与writeFile应该怎么实现？</p><pre><code>先把之前的内容readFile读取
再将之前的内容+新内容拼串
最后把拼接好的内容通过writeFile写入文件
</code></pre><h4 id="文件的同步与异步"><a href="#文件的同步与异步" class="headerlink" title="文件的同步与异步"></a>文件的同步与异步</h4><blockquote><p>fs中所有的文件操作，都提供了异步和同步两种方式</p></blockquote><p>异步方式：不会阻塞代码的执行</p><pre><code class="js">//异步方式
var fs = require(&quot;fs&quot;);

console.log(111);
fs.readFile(&quot;2.txt&quot;, &quot;utf8&quot;, function(err, data)&#123;
  if(err) &#123;
    return console.log(&quot;读取文件失败&quot;, err);
  &#125;
  console.log(data);
&#125;);
console.log(&quot;222&quot;);
</code></pre><p>同步方式：会阻塞代码的执行</p><pre><code class="js">//同步方式
console.log(111);
var result = fs.readFileSync(&quot;2.txt&quot;, &quot;utf-8&quot;);
console.log(result);
console.log(222);
</code></pre><p><strong style="color:red">总结</strong>：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p><h4 id="其他api（了解）"><a href="#其他api（了解）" class="headerlink" title="其他api（了解）"></a>其他api（了解）</h4><p>方法有很多，但是用起来都非常的简单，学会查文档。文档：<a target="_blank" rel="noopener" href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>fs.readFile(path, callback)</code></td><td>读取文件内容（异步）</td></tr><tr><td><code>fs.readFileSync(path)</code></td><td>读取文件内容（同步）</td></tr><tr><td><code>fs.writeFile(path, data, callback)</code></td><td>写入文件内容（异步）</td></tr><tr><td><code>fs.writeFileSync(path, data)</code></td><td>写入文件内容（同步）</td></tr><tr><td><code>fs.appendFile(path, data, callback)</code></td><td>追加文件内容（异步）</td></tr><tr><td><code>fs.appendFileSync(path, data)</code></td><td>追加文件内容（同步）</td></tr><tr><td><code>fs.rename(oldPath, newPath, callback)</code></td><td>重命名文件（异步）</td></tr><tr><td><code>fs.renameSync(oldPath, newPath)</code></td><td>重命名文件（同步）</td></tr><tr><td><code>fs.unlink(path, callback)</code></td><td>删除文件（异步）</td></tr><tr><td><code>fs.unlinkSync(path)</code></td><td>删除文件（同步）</td></tr><tr><td><code>fs.mkdir(path, mode, callback)</code></td><td>创建文件夹（异步）</td></tr><tr><td><code>fs.mkdirSync(path, mode)</code></td><td>创建文件夹（同步）</td></tr><tr><td><code>fs.rmdir(path, callback)</code></td><td>删除文件夹（异步）</td></tr><tr><td><code>fs.rmdirSync(path)</code></td><td>删除文件夹（同步）</td></tr><tr><td><code>fs.readdir(path, option, callback)</code></td><td>读取文件夹内容（异步）</td></tr><tr><td><code>fs.readdirSync(path, option)</code></td><td>读取文件夹内容（同步）</td></tr><tr><td><code>fs.stat(path, callback)</code></td><td>查看文件状态（异步）</td></tr><tr><td><code>fs.statSync(path)</code></td><td>查看文件状态（同步）</td></tr></tbody></table><h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><h4 id="创建服务器基本步骤"><a href="#创建服务器基本步骤" class="headerlink" title="创建服务器基本步骤"></a>创建服务器基本步骤</h4><pre><code class="js">//1. 导入http模块，http模块是node的核心模块，作用是用来创建http服务器的。
let http = require(&quot;http&quot;);

//2. 创建服务器-createServer方法
let server = http.createServer();

//3. 服务器处理请求-on监听request事件
server.on(&quot;request&quot;, function() &#123;
  console.log(&quot;我接收到请求了&quot;);
&#125;);

//4. 启动服务器，监听某个端口-通过listen监听某个端口来启动服务
server.listen(9999, function()&#123;
  console.log(&quot;服务器启动成功了, 请访问： http://localhost:9999&quot;);
&#125;);
</code></pre><p>详细说明</p><ol><li>给服务器注册request事件，只要服务器接收到了客户端的请求，就会触发request事件</li><li>request事件有两个参数，request表示请求对象，可以获取所有与请求相关的信息，response是响应对象，可以获取所有与响应相关的信息。</li><li>服务器监听的端口范围为：1-65535之间，推荐使用3000以上的端口，因为3000以下的端口一般留给系统使用</li></ol><h4 id="request对象详解"><a href="#request对象详解" class="headerlink" title="request对象详解"></a>request对象详解</h4><p>文档地址：<a target="_blank" rel="noopener" href="http://nodejs.cn/api/http.html#http_message_headers">http://nodejs.cn/api/http.html#http_message_headers</a></p><p>常见属性：</p><pre><code class="javascript">method： 请求的方式
url： 请求的地址
headers: 所有的请求头信息
rawHeaders： 所有的请求头信息（数组的方式）
</code></pre><p>例如</p><pre><code class="js">let http = require(&#39;http&#39;)

let server = http.createServer()

server.on(&#39;request&#39;,(request,response) =&gt; &#123;
    let &#123;method,url&#125; = request
    console.log(&#39;method :&gt;&gt; &#39;, method);
    console.log(&#39;url :&gt;&gt; &#39;, url);
&#125;)

server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))
</code></pre><p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求。</p><p>小结：request对象中，常用的就是<code>method</code>和<code>url</code>两个参数</p><h4 id="response对象详解"><a href="#response对象详解" class="headerlink" title="response对象详解"></a>response对象详解</h4><p>文档地址：<a target="_blank" rel="noopener" href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p><p>常见的属性和方法：</p><pre><code class="javascript">res.write(data): 给浏览器发送请求体，可以调用多次，从而提供连续的请求体
res.end();   通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成。
res.end(data); 结束请求，并且响应一段内容，相当于res.write(data) + res.end()
res.statusCode: 响应的的状态码 200 404 500
res.statusMessage: 响应的状态信息， OK Not Found ,会根据statusCode自动设置。
res.setHeader(name, value); 设置响应头信息， 比如content-type
res.writeHead(statusCode, statusMessage, options); 设置响应头，同时可以设置状态码和状态信息。
</code></pre><p><strong>注意：必须先设置响应头，才能设置响应体。</strong></p><p>案例</p><pre><code class="js">let http = require(&#39;http&#39;)

let server = http.createServer()

server.on(&#39;request&#39;,(req,res) =&gt; &#123;
    // res.writeHead(200,&#123;&#39;content-type&#39;: &#39;application/json&#39;&#125;)
    // res.write(JSON.stringify(&#123;name: &#39;tom&#39; , age: 18&#125;))
    // res.end()

    //res.setHeader(&#39;content-type&#39;, &#39;application/json&#39;)
    res.end(JSON.stringify(&#123;name: &#39;jerry&#39; , age: 18&#125;))
&#125;)

server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))
</code></pre><h4 id="根据不同请求输出不同响应数据"><a href="#根据不同请求输出不同响应数据" class="headerlink" title="根据不同请求输出不同响应数据"></a>根据不同请求输出不同响应数据</h4><ul><li><a target="_blank" rel="noopener" href="http://nodejs.cn/api/http.html#http_message_url">request.url</a></li><li><code>req.url</code>：获取请求路径<ul><li>例如：请求<code>http://127.0.0.1:3000/index</code> 获取到的是：<code>/index</code></li><li>例如：请求<code>http://127.0.0.1:3000/</code> 获取到的是：<code>/</code></li><li>例如：请求<code>http://127.0.0.1:3000</code> 获取到的是：<code>/</code></li></ul></li></ul><pre><code class="js">let http = require(&#39;http&#39;)

let server = http.createServer()

server.on(&#39;request&#39;,(req,res) =&gt; &#123;
    let &#123;url&#125; = req
    console.log(&#39;url :&gt;&gt; &#39;, url);
    let pageName = &#39;未知页面&#39;
    if(&#39;/&#39; === url)&#123;
        pageName = &#39;首页&#39;
    &#125;else if(&#39;/login&#39; === url)&#123;   
        pageName = &#39;登录页&#39;
    &#125;
    res.setHeader(&#39;content-type&#39;, &#39;application/json&#39;)
    res.end(pageName)
&#125;)

server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))
</code></pre><h4 id="服务器响应文件"><a href="#服务器响应文件" class="headerlink" title="服务器响应文件"></a>服务器响应文件</h4><p>浏览器中输入的URL地址，仅仅是一个标识，不与服务器中的目录一致。</p><p>也就是说：返回什么内容是由服务端的逻辑决定</p><pre><code class="js">let http = require(&#39;http&#39;)
let fs = require(&#39;fs&#39;)

let server = http.createServer()

server.on(&#39;request&#39;,(req,res) =&gt; &#123;
    let &#123;url&#125; = req
    console.log(&#39;url :&gt;&gt; &#39;, url);
    let pageName = &#39;error.html&#39;
    if(&#39;/&#39; === url)&#123;
        pageName = &#39;index.html&#39;
    &#125;else if(&#39;/login&#39; === url)&#123;   
        pageName = &#39;login.html&#39;
    &#125;
    //读取不同的文件,返回
    fs.readFile(`./pages/$&#123;pageName&#125;`,&#39;utf-8&#39;,(err,data) =&gt; &#123;
        res.setHeader(&#39;content-type&#39;, &#39;text/html&#39;)
        res.end(data)
    &#125;)
&#125;)

server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))
</code></pre><h4 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h4><ul><li>MIME(Multipurpose Internet Mail Extensions)多用途Internet邮件扩展类型 是一种表示文档性质和格式的标准化方式</li><li>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的MIME类型附加到响应对象的头部是非常重要的</li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types">MIME 类型</a></li></ul><h5 id="mime模块"><a href="#mime模块" class="headerlink" title="mime模块"></a>mime模块</h5><ul><li>作用：获取文件的MIME类型</li><li>安装：<code>npm i mime</code></li></ul><pre><code class="js">let mime = require(&#39;mime&#39;)

// 获取路径对应的MIME类型
mime.getType(&#39;txt&#39;)                    // ⇨ &#39;text/plain&#39;
// 根据MIME获取到文件后缀名
mime.getExtension(&#39;text/plain&#39;)        // ⇨ &#39;txt&#39;
</code></pre><h3 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h3><ul><li>说明：用于 URL 处理与解析</li><li>注意：通过url拿到的查询参数都是字符串格式</li></ul><pre><code class="js">// 导入url模块
let url = require(&#39;url&#39;)

// 解析 URL 字符串并返回一个 URL 对象
// 第一个参数：表示要解析的URL字符串
// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象
let res = url.parse(&#39;http://localhost:3000/details?id=1&amp;name=jack&#39;, true)
console.log(res.query) // &#123; id: &#39;1&#39;, name: &#39;jack&#39; &#125;
</code></pre><h3 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h3><h4 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h4><p>语法：path.join(path1,path2…)</p><p>作用：用来拼接字符串</p><pre><code class="js">const path = require(&#39;path&#39;)
//1 基本用法(掌握)
const res1 = path.join(__dirname,&#39;1.txt&#39;)
console.log(&#39;res1:&#39;,res1) // res1: D:\webcode\node-test\6.path模块\1.txt
//2 一个../ 会抵消一个上一级目录(了解)
const res2 = path.join(__dirname,&#39;../&#39;,&#39;1.txt&#39;)
console.log(&#39;res2:&#39;,res2) // res2: D:\webcode\node-test\1.txt
//3 ./ 会被忽略(了解)
const res3 = path.join(__dirname,&#39;./&#39;,&#39;1.txt&#39;)
console.log(&#39;res3:&#39;,res3) // res3: D:\webcode\node-test\6.path模块\1.txt
</code></pre><h4 id="获取文件名"><a href="#获取文件名" class="headerlink" title="获取文件名"></a>获取文件名</h4><p>使用 <code>path.basename()</code> 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名</p><p>语法：path.basename(path[, ext])</p><ul><li>path: 文件路径</li><li>ext: 文件扩展名（可选）</li></ul><pre><code class="js">const path = require(&#39;path&#39;)
const filepath = &#39;D:/webcode/node-test/1.txt&#39;
//获取文件名带后缀
console.log(path.basename(filepath))//1.txt 
//获取文件名不带后缀
console.log(path.basename(filepath,&#39;.txt&#39;))//1 
</code></pre><h4 id="获取扩展名"><a href="#获取扩展名" class="headerlink" title="获取扩展名"></a>获取扩展名</h4><p>语法：<code>path.extname(filepath)</code></p><pre><code class="js">const filepath = &#39;D:/webcode/node-test/1.txt&#39;
//获取扩展名
console.log(path.extname(filepath)) //.txt
</code></pre><h2 id="包管理器-npm"><a href="#包管理器-npm" class="headerlink" title="包管理器-npm"></a>包管理器-npm</h2><h3 id="npm的基本概念"><a href="#npm的基本概念" class="headerlink" title="npm的基本概念"></a>npm的基本概念</h3><ul><li>node package manager</li><li><a target="_blank" rel="noopener" href="https://npmjs.com/">npm官网</a></li><li><a target="_blank" rel="noopener" href="https://www.npmjs.com.cn/">npm中文文档</a></li></ul><pre><code>1. npm 是node的包管理工具，
2. 它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。
3. 来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。

npm 由三个独立的部分组成：
    网站
    注册表（registry）
    命令行工具 (CLI)
</code></pre><ul><li>作用：通过<code>npm</code>来快速安装开发中使用的包</li><li>npm不需要安装，只要安装了node，就自带了<code>npm</code></li></ul><h3 id="npm基本使用"><a href="#npm基本使用" class="headerlink" title="npm基本使用"></a>npm基本使用</h3><ul><li>初始化包</li></ul><pre><code class="js">npm init;    //这个命令用于初始化一个包，创建一个package.json文件，我们的项目都应该先执行npm init
npm init -y;  //快速的初始化一个包， 不能是一个中文名
</code></pre><ul><li>安装包</li></ul><pre><code class="js">npm install 包名;  //安装指定的包名的最新版本到项目中
npm install 包名@版本号;  //安装指定包的指定版本

npm i 包名； //简写
</code></pre><ul><li>卸载包</li></ul><pre><code class="js">npm uninstall 包名;  //卸载已经安装的包

npm uni 包名；//简写
</code></pre><h3 id="本地安装和全局安装"><a href="#本地安装和全局安装" class="headerlink" title="本地安装和全局安装"></a>本地安装和全局安装</h3><p>有两种方式用来安装 npm 包：本地安装和全局安装。选用哪种方式来安装，取决于你如何使用这个包。</p><ul><li>全局安装：如果你想将其作为一个命令行工具，那么你应该将其安装到全局。这种安装方式后可以让你在任何目录下使用这个命令。比如less命令，webpack命令。</li><li>本地安装：如果你自己的模块依赖于某个包，并通过 Node.js 的 <code>require</code> 加载，那么你应该选择本地安装，这种方式也是 <code>npm install</code> 命令的默认行为。</li></ul><pre><code class="js">// 全局安装,会把npm包安装到C:\Users\cc\AppData\Roaming\npm目录下，作为命令行工具使用
npm install -g 包名;

//本地安装，会把npm包安装到当前项目的node_modules文件中，作为项目的依赖
npm install 包名;  
</code></pre><h3 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h3><p>package.json文件，包（项目）描述文件，用来管理组织一个包（项目），它是一个纯JSON格式的。</p><ul><li>作用：描述当前项目（包）的信息，描述当前包（项目）的依赖项</li><li>如何生成：<code>npm init</code>或者<code>npm init -y</code></li><li>作用<ul><li>作为一个标准的包，必须要有<code>package.json</code>文件进行描述</li><li>一个项目的node_modules目录通常都会很大，不用拷贝node_modules目录，可以通过package.json文件配合<code>npm install</code>直接安装项目所有的依赖项</li></ul></li><li>描述内容</li></ul><pre><code class="js">&#123;
  &quot;name&quot;: &quot;03-npm&quot;,  //描述了包的名字，不能有中文
  &quot;version&quot;: &quot;1.0.0&quot;,  //描述了包的的版本信息， x.y.z  如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。
  &quot;description&quot;: &quot;&quot;, //包的描述信息
  &quot;main&quot;: &quot;index.js&quot;, //入口文件（模块化加载规则的时候详细的讲）
  &quot;scripts&quot;: &#123;  //配置一些脚本，在vue的时候会用到，现在体会不到
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [],  //关键字（方便搜索）
  &quot;author&quot;: &quot;&quot;,  //作者的信息
  &quot;license&quot;: &quot;ISC&quot;,  //许可证，开源协议
  &quot;dependencies&quot;: &#123;   //重要，项目的依赖， 方便代码的共享  通过 npm install可以直接安装所有的依赖项
    &quot;bootstrap&quot;: &quot;^3.3.7&quot;,
    &quot;jquery&quot;: &quot;^3.3.1&quot;
  &#125;
&#125;
</code></pre><p><strong>注意：一个合法的package.json，必须要有name和version两个属性</strong></p><p>如果安装失败， 可以通过以下命令清除npm缓存：</p><pre><code class="js">npm cache clean -f  // -f强制清除
</code></pre><h3 id="npm下载加速-nrm"><a href="#npm下载加速-nrm" class="headerlink" title="npm下载加速-nrm"></a>npm下载加速-nrm</h3><ul><li>nrm：npm registry manager（npm仓库地址管理工具）</li><li>安装：<code>npm i -g nrm</code></li></ul><pre><code class="bash"># 带*表示当前正在使用的地址

# 查看仓库地址列表
nrm ls

# 切换仓库地址
nrm use taobao
</code></pre><h2 id="nodemon-自动重启"><a href="#nodemon-自动重启" class="headerlink" title="nodemon 自动重启"></a>nodemon 自动重启</h2><ul><li>作用：监视到js文件修改后，自动重启node程序</li><li>安装：<code>npm i -g nodemon</code></li><li>使用：<code>nodemon app.js</code> 运行node程序</li></ul><h2 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art-template 模板引擎"></a>art-template 模板引擎</h2><ul><li><a target="_blank" rel="noopener" href="https://aui.github.io/art-template/zh-cn/docs/">文档</a></li><li>安装： <code>npm install art-template</code></li></ul><ul><li>核心方法</li></ul><pre><code class="js">// 基于模板路径渲染模板
//参数1：文件的路径
//参数2：数据
//返回值：返回渲染后的内容
// template(filename, data)
let html = template(path.join(__dirname, &quot;pages&quot;, &quot;index.html&quot;), &#123;name:&quot;大吉大利，今晚吃鸡&quot;&#125;);
</code></pre><p><strong>注意点：文件的路径必须是绝对路径</strong></p><h2 id="服务端重定向"><a href="#服务端重定向" class="headerlink" title="服务端重定向"></a>服务端重定向</h2><ul><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 状态码说明</a></li><li><a target="_blank" rel="noopener" href="http://shuai.be/archives/301-302-redirection/">301 和 302</a></li><li>说明：服务端可以通过HTTP状态码让浏览器中的页面重定向</li></ul><pre><code class="js">res.writeHead(302, &#123;
  &#39;Location&#39;: &#39;/&#39;
&#125;)
res.end()
</code></pre><h2 id="post请求参数处理"><a href="#post请求参数处理" class="headerlink" title="post请求参数处理"></a>post请求参数处理</h2><p>说明：POST请求可以发送大量数据，没有大小限制</p><pre><code class="js">// 接受POST参数
var postData = []

// 给req注册一个data事件， 只要浏览器给服务器发送post请求，data事件就会触发
// post请求发送的数据量可以很大， 这个data事件会触发多次，一块一块的传输
// 要把所有的chunk都拼接起来
// data事件：用来接受客户端发送过来的POST请求数据
var result = &quot;&quot;;
req.on(&#39;data&#39;, function (chunk) &#123;
  result += chunk;
&#125;)

// end事件：当POST数据接收完毕时，触发
req.on(&#39;end&#39;, function () &#123;
  cosnole.log(result); 
&#125;)
</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化规范：</p><ul><li>AMD: requirejs</li><li>CMD: seajs 玉伯 浏览器端的模块</li><li>commonJS： nodejs 服务端的模块</li></ul><blockquote><p>在nodejs中，应用由模块组成，nodejs中采用commonJS模块规范。</p></blockquote><ol><li>一个js文件就是一个模块</li><li>每个模块都是一个独立的作用域，在这个而文件中定义的变量、函数、对象都是私有的，对其他文件不可见。</li></ol><h3 id="node模块分类"><a href="#node模块分类" class="headerlink" title="node模块分类"></a>node模块分类</h3><ul><li><p>1 核心模块</p><ul><li>由 node 本身提供，不需要单独安装（npm），可直接引入使用。例如：fs模块、path模块等</li></ul></li><li><p>2 第三方模块</p><ul><li>由社区或个人提供，需要通过npm安装后使用。</li></ul></li><li><p>3 自定义模块</p><ul><li><p>由开发人员创建的模块（JS文件）</p></li><li><p>基本使用：1 创建模块 2 引入模块</p></li><li><p>注意：自定义模块的路径必须以<code>./</code>获取<code>../</code>开头</p></li><li><pre><code class="js">// 加载模块
require(&#39;./a&#39;)     // 推荐使用，省略.js后缀！

require(&#39;./a.js&#39;)
</code></pre></li></ul></li></ul><h3 id="模块的导入导出"><a href="#模块的导入导出" class="headerlink" title="模块的导入导出"></a>模块的导入导出</h3><h4 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h4><ul><li>通过<code>require(&quot;fs&quot;)</code>来加载模块</li><li>如果是第三方模块，需要先使用npm进行下载</li><li>如果是自定义模块，需要加上相对路径<code>./</code>或者<code>../</code>,可以省略<code>.js</code>后缀，如果文件名是<code>index.js</code>那么index.js也可以省略。</li><li>模块可以被多次导入，但是<code>只会在第一次加载</code></li></ul><h4 id="模块导出"><a href="#模块导出" class="headerlink" title="模块导出"></a>模块导出</h4><p>在模块的内部，<strong style="color:red">module变量代表的就是当前模块</strong>，它的<code>exports</code>属性就是对外的接口，加载某个模块，加载的就是<code>module.exports</code>属性，这个属性指向一个空的对象。</p><pre><code class="js">//module.exports指向的是一个对象，我们给对象增加属性即可。
//module.exports.num = 123;
//module.exports.age = 18;

//通过module.exports也可以导出一个值，但是多次导出会覆盖
module.exports = &#39;123&#39;;
module.exports = &quot;abc&quot;;
</code></pre><h4 id="module-exports与exports"><a href="#module-exports与exports" class="headerlink" title="module.exports与exports"></a>module.exports与exports</h4><ul><li><code>exports</code> 是 <code>module.exports</code> 的引用</li><li>注意：给 <code>module.exports</code> 赋值会<code>切断</code>与 <code>exports</code> 之间的联系<ul><li>1 直接添加属性两者皆可</li><li>2 赋值操作时，只能使用 <code>module.exports</code></li></ul></li></ul><pre><code class="js">console.log( module.exports === exports ) // ==&gt; true

// 等价操作
module.exports.num = 123
exports.num = 123

// 赋值操作：不要使用 exports = &#123;&#125;
module.exports = &#123;&#125;
</code></pre><h4 id="第三方模块代码执行流程-了解"><a href="#第三方模块代码执行流程-了解" class="headerlink" title="第三方模块代码执行流程(了解)"></a>第三方模块代码执行流程(了解)</h4><p>以mime包为例</p><ul><li>先基于当前文件模块所属目录找 node_modules 目录</li><li>如果找到，则去该目录中找 mime 目录</li><li>如果找到 mime 目录，则找该目录中的 package.json 文件</li><li>如果找到 package.json 文件，则找该文件中的 main 属性</li><li>如果找到 main 属性，则拿到该属性对应的文件路径</li><li>如果找到 mime 目录之后<ul><li>发现没有 package.json</li><li>或者 有 package.json 没有 main 属性</li><li>或者 有 main 属性，但是指向的路径不存在</li><li>则 node 会默认去看一下 mime 目录中有没有 index.js index.node index.json 文件</li></ul></li><li>如果找不到 index 或者找不到 mime 或者找不到 node_modules</li><li>则进入上一级目录找 node_moudles 查找规则同上</li><li>如果上一级还找不到，继续向上，一直到当前文件所属磁盘根目录</li><li>如果最后到磁盘根目录还找不到，最后报错：<code>can not find module xxx</code></li></ul><h3 id="CommonJS-规范参考文档"><a href="#CommonJS-规范参考文档" class="headerlink" title="CommonJS 规范参考文档"></a>CommonJS 规范参考文档</h3><ul><li><a target="_blank" rel="noopener" href="http://nodejs.cn/api/modules.html">module (模块)</a></li><li><a target="_blank" rel="noopener" href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS规范</a></li><li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/09ffac7a3b2c">浅析JS模块规范：AMD，CMD，CommonJS</a></li></ul><h2 id="node操作mysql数据库"><a href="#node操作mysql数据库" class="headerlink" title="node操作mysql数据库"></a>node操作mysql数据库</h2><p>数据库准备：</p><p>1.安装mysql5数据库</p><p>2.在mysql中创建nodedb这个数据库（可利用Navicat图形工具）</p><p>3.在nodedb数据库中添加users表 （可利用Navicat图形工具）</p><p>建表sql语句如下：</p><pre><code class="sql">SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) ,
  `password` varchar(255) ,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

SET FOREIGN_KEY_CHECKS = 1;
</code></pre><h3 id="配置-mysql-模块"><a href="#配置-mysql-模块" class="headerlink" title="配置 mysql 模块"></a>配置 mysql 模块</h3><ol><li>安装 mysql 模块</li></ol><pre><code class="bash">npm install mysql
</code></pre><ol start="2"><li>建立连接</li></ol><pre><code class="js">const mysql = require(&#39;mysql&#39;)

const db = mysql.createPool(&#123;
  host: &#39;127.0.0.1&#39;,
  user: &#39;root&#39;, //mysql账号
  password: &#39;root&#39;,//mysql密码
  database: &#39;nodedb&#39;, //自己创建的mysql库 
&#125;)
</code></pre><ol start="3"><li>测试是否正常工作</li></ol><pre><code class="js">db.query(&#39;select 1&#39;, (err, results) =&gt; &#123;
  if (err) console.log(err.message)
  console.log(results)
&#125;)
</code></pre><h3 id="node操作mysql增删改查"><a href="#node操作mysql增删改查" class="headerlink" title="node操作mysql增删改查"></a>node操作mysql增删改查</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>第一种添加方式：</p><pre><code class="js">//1.准备数据
const &#123;name,username,password&#125; = &#123;name: &#39;汤姆&#39;, username: &#39;tom&#39;, password: &#39;123&#39;&#125;
//2.准备sql ?标识占位符
const sqlStr = &#39;insert into users (name,username, password) values(?,?,?)&#39;
//3.执行sql 参数1：sql字符串  参数2：占位符对应的数据 参数3：插入之后的回调
db.query(sqlStr,[name,username,password],(err,res) =&gt; &#123;
  if(err) console.log(&#39;err :&gt;&gt; &#39;, err);
  console.log(&#39;res :&gt;&gt; &#39;, res);
  if(res.affectedRows == 1) console.log(&#39;插入成功！&#39;)
&#125;)
</code></pre><p>第二种添加方式：向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据：</p><pre><code class="js">const obj = &#123;name: &#39;汤姆&#39;, username: &#39;tom&#39;, password: &#39;123&#39;&#125;
db.query(&#39;insert into  users set ?&#39;,obj,(err,res) =&gt; &#123;
   if(err) console.log(&#39;err :&gt;&gt; &#39;, err)
   console.log(&#39;res :&gt;&gt; &#39;, res);
   if(res.affectedRows == 1) console.log(&#39;插入成功11！&#39;)
&#125;)
</code></pre><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code class="js">//查询数据
db.query(&#39;select * from users&#39;,(err,res) =&gt; &#123;
  console.log(&#39;res :&gt;&gt; &#39;, res);
&#125;)
</code></pre><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><pre><code class="js">const &#123;username,password,name,id&#125; = &#123;id: 3, name: &#39;杰瑞&#39;, username: &#39;jerry&#39;, password: &#39;456&#39;&#125;
const sqlStr = &#39;update users set username=?,password=?,name=? where id=?&#39;
db.query(sqlStr,[username,password,name,id],(err,res) =&gt; &#123;//注意第二个参数的顺序
   if(err) console.log(&#39;err :&gt;&gt; &#39;, err)
   if(res.affectedRows == 1) console.log(&#39;修改成功！&#39;)
&#125;)
</code></pre><p>快捷修改方式</p><pre><code class="js">const obj = &#123;id: 3, name: &#39;杰瑞1&#39;, username: &#39;jerry1&#39;, password: &#39;4516&#39;&#125;
const sqlStr = &#39;update users set ? where id=?&#39;
db.query(sqlStr,[obj,obj.id],(err,res) =&gt; &#123;//注意第二个参数的顺序
  if(err) console.log(&#39;err :&gt;&gt; &#39;, err)
  if(res.affectedRows == 1) console.log(&#39;修改成功！&#39;)
&#125;)
</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre><code class="js">db.query(&#39;delete from users where id=?&#39;,[1],(err,res) =&gt; &#123;
  if(res.affectedRows == 1) console.log(&#39;删除成功！&#39;)
&#125;)
</code></pre><h2 id="node操作mongodb数据库"><a href="#node操作mongodb数据库" class="headerlink" title="node操作mongodb数据库"></a>node操作mongodb数据库</h2><p>安装：<code>npm i mongodb</code></p><pre><code class="js">// 导入 mongodb，并获取到客户端对象
const MongoClient = require(&#39;mongodb&#39;).MongoClient

// 连接数据库服务地址
const url = &#39;mongodb://localhost:27017&#39;

// 连接数据库
MongoClient.connect(url, function (err, client) &#123;
  if (err) &#123;
    return console.log(&#39;链接数据库失败&#39;, err)
  &#125;

  console.log(&#39;数据库链接成功&#39;);

  // 获取集合对象
  const db = client.db(&#39;nodedb&#39;)

  // 关闭数据库链接
  client.close()
&#125;)
</code></pre><h3 id="数据增删改查"><a href="#数据增删改查" class="headerlink" title="数据增删改查"></a>数据增删改查</h3><ul><li>添加数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)

// 添加
db.collection(&#39;users&#39;)
  // 添加一条数据
  .insert(&#123;name: &#39;rose&#39;, age: 19&#125;, function (err, data) &#123;
    console.log(data);
  &#125;)
  // 添加多条数据
  .insertMany([&#123; name: &#39;tom&#39;, age: 20 &#125;, &#123; name: &#39;jerry&#39;, age: 21 &#125;], function (err, data) &#123;
    console.log(data);
  &#125;)
</code></pre><ul><li>查询数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)

// 查询
db.collection(&#39;users&#39;).find().toArray(function (err, data) &#123;
  console.log(data)
&#125;)
</code></pre><ul><li>修改数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)

db.collection(&#39;users&#39;).update(&#123; name: &#39;tom&#39; &#125;, &#123; $set: &#123; age: 22 &#125; &#125;, function (err, result) &#123;
    console.log(result);
  &#125;)
</code></pre><ul><li>删除数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)

db.collection(&#39;users&#39;)
  // 删除一条数据：
  .deleteOne(&#123;name: &#39;rose&#39;&#125;, function (err, result) &#123;
    console.log(result);
  &#125;)
  // 删除多条数据：
  .deleteMany(&#123;age: &#123;$lt: 20&#125;&#125;, function (err, result) &#123;
    console.log(result);
  &#125;)
</code></pre><h2 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>安装express</li></ul><pre><code class="bash">npm i express
</code></pre><ul><li>案例</li></ul><pre><code class="js">// 导入 express
var express = require(&#39;express&#39;)
// 创建 express实例，也就是创建 express服务器
var app = express()

// 路由
app.get(&#39;/&#39;, function (req, res) &#123;
  res.send(&#39;Hello World!&#39;)
&#125;)

// 启动服务器
app.listen(3000, function () &#123;
  console.log(&#39;服务器已启动&#39;)
&#125;)
</code></pre><p>参数说明</p><ul><li><code>express()</code>：创建一个Express应用，并返回，即：app</li><li><code>app.get()</code>：注册一个GET类型的路由<ul><li>注意：只要注册了路由，所有的请求都会被处理（未配置的请求路径，响应404）</li></ul></li><li><code>res.send()</code>：发送数据给客户端，并自动设置Content-Type<ul><li>参数可以是：字符串、数组、对象、Buffer</li><li>注意：只能使用一次</li></ul></li><li><code>req</code> 和 <code>res</code>：与http模块中的作用相同，是扩展后的请求和响应对象</li></ul><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ul><li>通过 <code>express.static()</code> 方法可创建静态资源服务器，向外开放访问静态资源。</li><li>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，<strong style="color:red">存放静态文件的目录名不会出现在 URL 中</strong></li><li>访问静态资源时，会根据托管顺序查找文件</li><li>可为静态资源访问路径添加前缀</li></ul><pre><code class="js">app.use(express.static(&#39;static&#39;))
app.use(&#39;/web&#39;, express.static(&#39;web&#39;))

//可直接访问 static 目录下的静态资源
http://localhost:3000/img/2.jpg

//通过带有 /web 前缀的地址访问 bruce 目录下的文件
http://localhost:8080/web/img/1.jpg
</code></pre><h3 id="request和response"><a href="#request和response" class="headerlink" title="request和response"></a>request和response</h3><h4 id="request常用方法"><a href="#request常用方法" class="headerlink" title="request常用方法"></a>request常用方法</h4><ul><li>query属性：获取get请求参数，是一个对象</li></ul><pre><code class="js">//传参：http://localhost:8088/user?name=jerry&amp;age=18

//处理请求
app.get(&#39;/user&#39;,(req,resp) =&gt; &#123;
    resp.send(req.query)//将get参数直接返回
&#125;)
</code></pre><ul><li>body：获取POST请求参数，需要配置<code>body-parser</code>模块， POST请求参数</li></ul><pre><code class="js">//导入bodyParser模块
const bodyParser = require(&#39;body-parser&#39;)
//将POST请求参数转化为对象，存储到req.body中 (application/x-www-form-urlencoded方式)
app.use(bodyParser.urlencoded(&#123; extended: true &#125;))
app.post(&#39;/user&#39;,(req,resp) =&gt; &#123;
    resp.send(req.body)//将post参数直接返回
&#125;)
</code></pre><ul><li>params：获取restful风格的参数</li></ul><pre><code class="js">//传参：http://localhost:8088/user/jerry/19

app.put(&#39;/user/:name/:age&#39;,(req,resp) =&gt; &#123;
    resp.send(req.params)//将restful参数直接返回
&#125;)
</code></pre><h4 id="response常用方法"><a href="#response常用方法" class="headerlink" title="response常用方法"></a>response常用方法</h4><pre><code class="js">// send() 发送数据给客户端，并自动设置Content-Type
res.send()

// 发送文件给浏览器，并根据文件后缀名自动设置Content-Type
// 注意：文件路径必须是绝对路径
res.sendFile(path.join(__dirname, &#39;index.html&#39;))

// 设置HTTP响应码
res.status(200)；

// 设置响应头
res.set(&#39;Content-Type&#39;, &#39;text/plain&#39;)
res.set(&#123;
  &#39;Content-Type&#39;: &#39;text/plain&#39;,
  &#39;cute&#39;: &#39;fangfang&#39;
&#125;)

// 重定向
res.redirect(&#39;/index&#39;)
</code></pre><h3 id="expres中使用art-template"><a href="#expres中使用art-template" class="headerlink" title="expres中使用art-template"></a>expres中使用art-template</h3><p>安装</p><pre><code class="bash">npm install art-template 
npm install express-art-template
</code></pre><p>给express绑定一个模版引擎</p><pre><code class="js">//给express设置模版引擎
//参数1： 模版引擎的后缀名，  以后的模版文件都应该是 html结尾
//参数2： 使用什么模版引擎
app.engine(&quot;html&quot;, require(&#39;express-art-template&#39;))
</code></pre><p>通过<code>res.render()</code>渲染模版引擎</p><pre><code class="js">//参数1； 模版文件的路径,相对路径，回去views目录下查找
//参数2： 数据
res.render(path.join(__dirname, &quot;index.html&quot;), &#123;name:&quot;zs&quot;&#125;)
</code></pre><p>关于模版引擎的配置（了解）</p><pre><code class="js">//模版文件默认去aa目录下查找  默认值：  views
app.set(&quot;views&quot;, &quot;aa&quot;);

//设置模板引擎的默认后缀
app.set(&quot;view engine&quot;, &quot;html&quot;);
</code></pre><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>创建路由模块：</p><pre><code class="js">// router.js

const express = require(&#39;express&#39;)
// 创建路由对象
const router = express.Router()

// 挂载具体路由
router.get(&#39;/user/list&#39;, (req, res) =&gt; &#123;
  res.send(&#39;Get user list.&#39;)
&#125;)
router.post(&#39;/user/add&#39;, (req, res) =&gt; &#123;
  res.send(&#39;Add new user.&#39;)
&#125;)

// 向外导出路由对象
module.exports = router
</code></pre><p>注册路由模块：</p><pre><code class="js">const express = require(&#39;express&#39;)
const router = require(&#39;./router&#39;)

const app = express()

// 注册路由模块，添加访问前缀
app.use(&#39;/api&#39;, router) //测试时记得代码 /api 前缀

app.listen(8088, () =&gt; &#123;
  console.log(&#39;http://127.0.0.1&#39;)
&#125;)
</code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li>中间件是指流程的中间处理环节</li><li>服务器收到请求后，可先调用中间件进行预处理(比如登录拦截、错误拦截等)</li><li>中间件是一个函数，包含 <code>req, res, next</code> 三个参数，<code>next()</code> 参数把流转关系交给下一个中间件或路由</li></ul><p>中间件注意事项；</p><ul><li>在注册路由之前注册中间件（错误级别中间件除外）</li><li>中间件可连续调用多个</li><li>别忘记调用 <code>next()</code> 函数</li><li><code>next()</code> 函数后别写代码</li><li>多个中间件共享 <code>req</code>、 <code>res</code>对象</li></ul><h4 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h4><ul><li>通过 <code>app.use()</code> 定义的中间件为全局中间件</li></ul><pre><code class="js">const express = require(&#39;express&#39;)
const app = express()

// 定义第一个全局中间件
app.use((req, res, next) =&gt; &#123;
  console.log(&#39;调用了第1个全局中间件&#39;)
  next()
&#125;)
// 定义第二个全局中间件
app.use((req, res, next) =&gt; &#123;
  console.log(&#39;调用了第2个全局中间件&#39;)
  next()
&#125;)

app.get(&#39;/user&#39;, (req, res) =&gt; &#123;
  res.send(&#39;User page.&#39;)
&#125;)

app.listen(80, () =&gt; &#123;
  console.log(&#39;http://127.0.0.1&#39;)
&#125;)
</code></pre><h4 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h4><pre><code class="js">const express = require(&#39;express&#39;)
const app = express()

// 定义中间件函数
const mw1 = (req, res, next) =&gt; &#123;
  console.log(&#39;调用了第一个局部生效的中间件&#39;)
  next()
&#125;

const mw2 = (req, res, next) =&gt; &#123;
  console.log(&#39;调用了第二个局部生效的中间件&#39;)
  next()
&#125;

// 两种定义局部中间件的方式
app.get(&#39;/hello&#39;, mw2, mw1, (req, res) =&gt; res.send(&#39;hello page.&#39;))
app.get(&#39;/about&#39;, [mw1, mw2], (req, res) =&gt; res.send(&#39;about page.&#39;))

app.get(&#39;/user&#39;, (req, res) =&gt; res.send(&#39;User page.&#39;))

app.listen(80, function () &#123;
  console.log(&#39;Express server running at http://127.0.0.1&#39;)
&#125;)
</code></pre><h4 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h4><h5 id="应用级别的中间件"><a href="#应用级别的中间件" class="headerlink" title="应用级别的中间件"></a>应用级别的中间件</h5><p>通过 <code>app.use()</code> 或 <code>app.get()</code> 或 <code>app.post()</code> ，绑定到 <code>app</code> 实例上的中间件</p><h5 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h5><p>绑定到 <code>express.Router()</code> 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 <code>app</code> 实例上，路由级别中间件绑定到 <code>router</code> 实例上。</p><pre><code class="js">const app = express()
const router = express.Router()

router.use(function (req, res, next) &#123;
  console.log(1)
  next()
&#125;)

app.use(&#39;/&#39;, router)
</code></pre><h5 id="错误级别的中间件"><a href="#错误级别的中间件" class="headerlink" title="错误级别的中间件"></a>错误级别的中间件</h5><ul><li>用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</li><li>错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 <code>(err, req, res, next)</code> 。</li><li>错误级别的中间件必须注册在所有路由之后</li></ul><pre><code class="js">const express = require(&#39;express&#39;)
const app = express()

app.get(&#39;/&#39;, (req, res) =&gt; &#123;
  throw new Error(&#39;服务器内部发生了错误！&#39;)
  res.send(&#39;Home page.&#39;)
&#125;)

// 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃
app.use((err, req, res, next) =&gt; &#123;
  console.log(&#39;发生了错误！&#39; + err.message)
  res.send(&#39;Error：&#39; + err.message)
&#125;)

app.listen(80, function () &#123;
  console.log(&#39;Express server running at http://127.0.0.1&#39;)
&#125;)
</code></pre><h5 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h5><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p><ul><li><code>express.static</code> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li><li><code>express.json</code> 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li><li><code>express.urlencoded</code> 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li></ul><pre><code class="js">app.use(express.json())
app.use(express.urlencoded(&#123; extended: false &#125;))
</code></pre><h5 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h5><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><ul><li>CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</li><li>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</li><li>CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li><li>CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</li></ul><h4 id="CORS-常见响应头"><a href="#CORS-常见响应头" class="headerlink" title="CORS 常见响应头"></a>CORS 常见响应头</h4><ul><li><code>Access-Control-Allow-Origin</code>：制定了允许访问资源的外域 URL</li></ul><pre><code class="js">res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://bruceblog.io&#39;)
res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)
</code></pre><ul><li><code>Access-Control-Allow-Headers</code></li><li>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：<code>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</code></li><li>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 A<code>ccess-Control-Allow-Headers</code> 对额外的请求头进行声明，否则这次请求会失败！</li></ul><pre><code class="js">res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type, X-Custom-Header&#39;)
</code></pre><ul><li><code>Access-Control-Allow-Methods</code></li><li>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 <code>Access-Control-Alow-Methods</code> 来指明实际请求所允许使用的 HTTP 方法</li></ul><pre><code class="js">res.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, GET, DELETE, HEAD&#39;)
res.setHEader(&#39;Access-Control-Allow-Methods&#39;, &#39;*&#39;)
</code></pre><h4 id="CORS-请求分类"><a href="#CORS-请求分类" class="headerlink" title="CORS 请求分类"></a>CORS 请求分类</h4><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><ul><li>请求方式：GET、POST、HEAD 三者之一</li><li>HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application&#x2F;x-www-formurlencoded、multipart&#x2F;form-data、text&#x2F;plain）</li></ul><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><ul><li>请求方式为 GET、POST、HEAD 之外的请求 Method 类型</li><li>请求头中包含自定义头部字段</li><li>向服务器发送了 application&#x2F;json 格式的数据</li></ul><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p><h4 id="express中使用cors"><a href="#express中使用cors" class="headerlink" title="express中使用cors"></a>express中使用cors</h4><p>安装中间件：<code>npm install cors</code><br>导入中间件：<code>const cors = require(&#39;cors&#39;)</code><br>配置中间件：<code>app.use(cors())</code></p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><h3 id="jwt认证"><a href="#jwt认证" class="headerlink" title="jwt认证"></a>jwt认证</h3><p>前后端分离推荐使用 JWT（JSON Web Token）认证机制，是目前最流行的跨域认证解决方案</p><h4 id="Session-的局限性"><a href="#Session-的局限性" class="headerlink" title="Session 的局限性"></a>Session 的局限性</h4><ul><li>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</li><li>当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。</li><li>当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制</li></ul><h4 id="JWT-工作原理图"><a href="#JWT-工作原理图" class="headerlink" title="JWT 工作原理图"></a>JWT 工作原理图</h4><p>用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p><p><img src="/posts/f2f1536e/image-20221030192657149.png" alt="image-20221030192657149"></p><h4 id="JWT-组成部分"><a href="#JWT-组成部分" class="headerlink" title="JWT 组成部分"></a>JWT 组成部分</h4><ul><li>Header、Payload、Signature</li><li>Payload 是真正的用户信息，加密后的字符串</li><li>Header 和 Signature 是安全性相关部分，保证 Token 安全性</li><li>三者使用 <code>.</code> 分隔</li></ul><pre><code class="js">Header.Payload.Signature

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTcsInVzZXJuYW1lIjoiQnJ1Y2UiLCJwYXNzd29yZCI6IiIsIm5pY2tuYW1lIjoiaGVsbG8iLCJlbWFpbCI6InNjdXRAcXEuY29tIiwidXNlcl9waWMiOiIiLCJpYXQiOjE2NDE4NjU3MzEsImV4cCI6MTY0MTkwMTczMX0.bmqzAkNSZgD8IZxRGGyVlVwGl7EGMtWitvjGD-a5U5c
</code></pre><h4 id="JWT的使用方式"><a href="#JWT的使用方式" class="headerlink" title="JWT的使用方式"></a>JWT的使用方式</h4><ul><li>客户端会把 JWT 存储在 localStorage 或 sessionStorage 中</li><li>此后客户端与服务端通信需要携带 JWT 进行身份认证，将 JWT 存在 HTTP 请求头 Authorization 字段中</li><li>加上 Bearer 前缀</li></ul><pre><code class="text">Authorization: Bearer &lt;token&gt;
</code></pre><h4 id="Express-使用-JWT认证"><a href="#Express-使用-JWT认证" class="headerlink" title="Express 使用 JWT认证"></a>Express 使用 JWT认证</h4><ol><li>安装：<code>jsonwebtoken</code> 用于生成 JWT 字符串;<code>express-jwt</code> 用于将 JWT 字符串解析还原成 JSON 对象</li></ol><pre><code class="bash">npm install jsonwebtoken express-jwt
</code></pre><ol start="2"><li>定义 secret 密钥</li></ol><ul><li>为保证 JWT 字符串的安全性，防止其在网络传输过程中被破解，需定义用于加密和解密的 secret 密钥</li><li>生成 JWT 字符串时，使用密钥加密信息，得到加密好的 JWT 字符串</li><li>把 JWT 字符串解析还原成 JSON 对象时，使用密钥解密</li></ul><pre><code class="js">const jwt = require(&#39;jsonwebtoken&#39;)
const expressJWT = require(&#39;express-jwt&#39;)

// 密钥为任意字符串
const secretKey = &#39;hlf&#39;
</code></pre><ol start="3"><li>生成 JWT 字符串</li></ol><pre><code class="js">app.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;
  ...
  res.send(&#123;
    status: 200,
    message: &#39;登录成功&#39;,
    // jwt.sign() 生成 JWT 字符串
    // 参数：用户信息对象、加密密钥、配置对象-token有效期
    // 尽量不保存敏感信息，因此只有用户名，没有密码
    token: jwt.sign(&#123;username: userInfo.username&#125;, secretKey, &#123;expiresIn: &#39;10h&#39;&#125;)
  &#125;)
&#125;)
</code></pre><ol start="4"><li>JWT 字符串还原为 JSON 对象</li></ol><ul><li>客户端访问有权限的接口时，需通过请求头的 <code>Authorization</code> 字段，将 Token 字符串发送到服务器进行身份认证</li><li>服务器可以通过 express-jwt 中间件将客户端发送过来的 Token 解析还原成 JSON 对象</li></ul><pre><code class="js">// unless(&#123; path: [/^\/api\//] &#125;) 指定哪些接口无需jwt认证
app.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\/api\//] &#125;))
</code></pre><ol start="5"><li>获取用户信息</li></ol><ul><li>当 express-jwt 中间件配置成功后，即可在那些有权限的接口中，使用 <code>req.user</code> 对象，来访问从 JWT 字符串中解析出来的用户信息</li></ul><pre><code class="js">app.get(&#39;/admin/getinfo&#39;, (req, res) =&gt; &#123;
  console.log(req.user)
  res.send(&#123;
    status: 200,
    message: &#39;获取信息成功&#39;,
    data: req.user,
  &#125;)
&#125;)
</code></pre><ol start="6"><li>捕获解析 JWT 失败后产生的错误</li></ol><ul><li>当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行</li><li>通过 Express 的错误中间件，捕获这个错误并进行相关的处理</li></ul><pre><code class="js">app.use((err, req, res, next) =&gt; &#123;
  if (err.name === &#39;UnauthorizedError&#39;) &#123;
    return res.send(&#123; status: 401, message: &#39;Invalid token&#39; &#125;)
  &#125;
  res.send(&#123; status: 500, message: &#39;Unknown error&#39; &#125;)
&#125;)
</code></pre><h3 id="session认证"><a href="#session认证" class="headerlink" title="session认证"></a>session认证</h3><p>服务端渲染推荐使用 Session 认证机制</p><h4 id="session认证原理"><a href="#session认证原理" class="headerlink" title="session认证原理"></a>session认证原理</h4><p><img src="/posts/f2f1536e/image-20221030194211947.png" alt="image-20221030194211947"></p><h4 id="Express中使用session认证"><a href="#Express中使用session认证" class="headerlink" title="Express中使用session认证"></a>Express中使用session认证</h4><ol><li>安装 express-session 中间件</li></ol><pre><code class="bash">npm install express-session
</code></pre><ol start="2"><li>配置中间件</li></ol><pre><code class="js">const session = require(&#39;express-session&#39;)
app.use(
  session(&#123;
    secret: &#39;hlf&#39;, // secret 的值为任意字符串
    resave: false,
    saveUninitalized: true,
  &#125;)
)
</code></pre><ol start="3"><li>向 session 中存数据</li></ol><p>中间件配置成功后，可通过 <code>req.session</code> 访问 session 对象，存储用户信息</p><pre><code class="js">app.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;
  req.session.user = req.body
  req.session.isLogin = true

  res.send(&#123; status: 0, msg: &#39;login done&#39; &#125;)
&#125;)
</code></pre><ol start="4"><li>从 session 取数据</li></ol><pre><code class="js">app.get(&#39;/api/username&#39;, (req, res) =&gt; &#123;
  if (!req.session.isLogin) &#123;
    return res.send(&#123; status: 1, msg: &#39;fail&#39; &#125;)
  &#125;
  res.send(&#123; status: 0, msg: &#39;success&#39;, username: req.session.user.username &#125;)
&#125;)
</code></pre><ol start="5"><li>清空 session</li></ol><pre><code class="js">app.post(&#39;/api/logout&#39;, (req, res) =&gt; &#123;
  // 清空当前客户端的session信息
  req.session.destroy()
  res.send(&#123; status: 0, msg: &#39;logout done&#39; &#125;)
&#125;)
</code></pre></div><div class="post-ending"><div class="end-txt">------ 本文结束，感谢您的阅读 ------</div><blockquote class="layui-elem-quote layui-quote-nm" style="padding:10px"><div><span class="title">本文作者: </span>贺刘芳</div><div><span class="title">本文链接: </span><a target="_blank" href="https://heliufang.github.io/posts/f2f1536e/">https://heliufang.github.io/posts/f2f1536e/</a></div><div><span class="title">版权声明: </span>本文采用知识共享署名-非商业性使用-禁止演绎 2.5 中国大陆许可协议进行许可。</div></blockquote><div id="vcomments"></div></div></div></div></div><ul id="toTopBtn" class="layui-fixbar" style="right:-70px" title="置顶"><div><a href="javascript:void(0)" class="icon iconfont icon-huojian"></a></div></ul><div class="qy-footer"><div class="font-Area"><p>访客数 <span style="color:red" id="busuanzi_value_site_uv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 人次 | 访问量 <span style="color:red" id="busuanzi_value_site_pv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 次 | 本站已运行 <span style="color:red" id="runDaysFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 天 | 本站文章字数合计 <span style="color:red">200.8k</span> | 最后更新于 <span style="color:red" id="lastUpdateFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span></p><p>由 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a> <span style="color:red" class="layui-icon layui-icon-find-fill layui-anim layui-anim-rotate layui-anim-loop"></span> 强力驱动</p><p>Copyright © 2020 ~<span id="currentYear">2022</span> <span class="layui-icon layui-icon-heart-fill footer-heart"></span> HeLiuFang</p></div></div></body><script src="../../js/jquery.min.js"></script><script src="../../js/moment.min.js"></script><script src="../../layui/layui.js"></script><script src="../../lib/prism/prism.js"></script><script>$("#searchBtn").click(function(){$("#searchShade").show(),$("#searchLayer").addClass("layui-anim layui-anim-scaleSpring")}),$("#closeBtn").click(function(){$("#searchShade").hide()});var searchFunc=function(t,i,o){$.ajax({url:t,dataType:"json",success:function(t){var e=document.getElementById(i),n=document.getElementById(o);e.addEventListener("input",function(){var e='<ul class="search-result-list">',o=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(t.forEach(function(t){var n=!0,i=t.title.trim().toLowerCase(),t=t.url;""!=i&&o.forEach(function(t,e){i.indexOf(t)<0?n=!1:i=i.replace(new RegExp(t,"g"),'<span style="color:red">'+t+"</span>")}),n&&(e=e+"<li><a href='"+t+"' class='search-result-title'>"+i+"</a></li>")}),e+="</ul>",n.innerHTML=e)})}})};function DynamicLine(){function t(t,e,n){return t.getAttribute(e)||n}function e(t){return document.getElementsByTagName(t)}function n(){r=o.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,c=o.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function l(){var n,i,o,a,s;u.clearRect(0,0,r,c),y.forEach(function(t,e){for(t.x+=t.xa,t.y+=t.ya,t.xa*=t.x>r||t.x<0?-1:1,t.ya*=t.y>c||t.y<0?-1:1,u.fillRect(t.x-.5,t.y-.5,1,1),i=e+1;i<d.length;i++)null!==(n=d[i]).x&&null!==n.y&&(o=t.x-n.x,a=t.y-n.y,(s=o*o+a*a)<n.max)&&(n===w&&s>=n.max/2&&(t.x-=.03*o,t.y-=.03*a),o=(n.max-s)/n.max,u.beginPath(),u.lineWidth=o/2,u.strokeStyle="rgba("+h.c+","+(.2+o)+")",u.moveTo(t.x,t.y),u.lineTo(n.x,n.y),u.stroke())}),m(l)}var r,c,d,i,o=document.createElement("canvas"),h=(a=(i=e("script")).length,i=i[a-1],{l:a,z:t(i,"zIndex",-1),o:t(i,"opacity",.5),c:t(i,"color","0,0,50"),n:t(i,"count",99)}),a="c_n"+h.l,u=o.getContext("2d"),m=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){window.setTimeout(t,1e3/45)},s=Math.random,w={x:null,y:null,max:2e4};o.id=a,o.style.cssText="position:fixed;top:0;left:0;z-index:"+h.z+";opacity:"+h.o,e("body")[0].appendChild(o),n(),window.onresize=n,window.onmousemove=function(t){t=t||window.event,w.x=t.clientX,w.y=t.clientY},window.onmouseout=function(){w.x=null,w.y=null};for(var y=[],p=0;p<h.n;p++){var f=s()*r,x=s()*c,g=2*s()-1,v=2*s()-1;y.push({x:f,y:x,xa:g,ya:v,max:6e3})}d=y.concat([w]),setTimeout(function(){l()},100)}function clickEffect(){let o=[],n=!1,e,i=0,a,s,l,t,r;const c=["#F73859","#14FFEC","#00E0FF","#FF99FE","#FAF15D"],d=document.createElement("canvas"),h=(document.body.appendChild(d),d.setAttribute("style","width: 100%; height: 100%; top: 0; left: 0; z-index: 99999; position: fixed; pointer-events: none;"),document.createElement("span"));function u(){d.width=2*window.innerWidth,d.height=2*window.innerHeight,d.style.width=window.innerWidth+"px",d.style.height=window.innerHeight+"px",r.scale(2,2),a=d.width=window.innerWidth,s=d.height=window.innerHeight,l={x:a/2,y:s/2},t={x:a/2,y:s/2}}h.classList.add("pointer"),document.body.appendChild(h),d.getContext&&window.addEventListener?(r=d.getContext("2d"),u(),window.addEventListener("resize",u,!1),function t(){r.fillStyle="rgba(255, 255, 255, 0)";r.clearRect(0,0,d.width,d.height);for(let e=0;e<o.length;e++){let t=o[e];t.r<0||(r.fillStyle=t.color,r.beginPath(),r.arc(t.x,t.y,t.r,0,2*Math.PI,!1),r.fill(),t.update())}1==n?i+=.2:!n&&0<=i&&(i-=.4);p();requestAnimationFrame(t)}(),window.addEventListener("mousedown",function(t){w(y(10,20),t.clientX,t.clientY),document.body.classList.add("is-pressed"),e=setTimeout(function(){document.body.classList.add("is-longpress"),n=!0},500)},!1),window.addEventListener("mouseup",function(t){clearInterval(e),1==n&&(document.body.classList.remove("is-longpress"),w(y(50+Math.ceil(i),100+Math.ceil(i)),t.clientX,t.clientY),n=!1),document.body.classList.remove("is-pressed")},!1),window.addEventListener("mousemove",function(t){var e=t.clientX,t=t.clientY;h.style.top=t+"px",h.style.left=e+"px"},!1)):console.log("canvas or addEventListener is unsupported!");class m{constructor(t=l.x,e=l.y){this.x=t,this.y=e,this.angle=2*Math.PI*Math.random(),1==n?this.multiplier=y(14+i,15+i):this.multiplier=y(6,12),this.vx=(this.multiplier+.5*Math.random())*Math.cos(this.angle),this.vy=(this.multiplier+.5*Math.random())*Math.sin(this.angle),this.r=y(8,12)+3*Math.random(),this.color=c[Math.floor(Math.random()*c.length)]}update(){this.x+=this.vx-t.x,this.y+=this.vy-t.y,t.x=-2/window.innerWidth*Math.sin(this.angle),t.y=-2/window.innerHeight*Math.cos(this.angle),this.r-=.3,this.vx*=.9,this.vy*=.9}}function w(e=1,n=l.x,i=l.y){for(let t=0;t<e;t++)o.push(new m(n,i))}function y(t,e){return Math.floor(Math.random()*e)+t}function p(){for(let t=0;t<o.length;t++){var e=o[t];(e.x+e.r<0||e.x-e.r>a||e.y+e.r<0||e.y-e.r>s||e.r<0)&&o.splice(t,1)}}}searchFunc("/search.json","searchTxt","searchResult"),DynamicLine(),clickEffect(),document.querySelector("#currentYear").innerText=(new Date).getFullYear();var days=moment().diff($("#runDays")[0].dataset.sinceDate,"days"),lastUpdate=($("#runDays").html(days),$("#runDaysFooter").html(days),moment($("#lastUpdate")[0].dataset.lastUpdate,"YYYY-MM-DD HH:mm:ss").locale("zh-CN").fromNow());$("#lastUpdate").html(lastUpdate),$("#lastUpdateFooter").html(lastUpdate),$("#toTopBtn").click(function(){var t=$(window).scrollTop(),e=parseInt(t/60),n=setInterval(function(){$(window).scrollTop($(window).scrollTop()-e),0===$(window).scrollTop()&&clearInterval(n)},1)}),$.event.add(window,"scroll",function(){$("#toTopBtn").css("transform",0<$(window).scrollTop()?"translateX(-85px)":"translateX(85px)"),$("#toTopBtn").css("transition","all 0.5s")}),$("#loadingBox").hide(),$("body").css("overflow","auto")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var element=null;layui.use(["element"],function(){element=layui.element}),$(function(){var e=$("#toc-area"),t=$(e).offset().top;$.event.add(window,"scroll",function(){var o=$(".markdown-body").height(),o=(($(window).scrollTop()+t)/o*100).toFixed(2);element.progress("demo",(o=0==(o=99<o?100:o)?0:o)+"%"),$("#progressTxt").text(o),console.log("percent",o),$(e).css("position",$(window).scrollTop()>t?"fixed":"static"),$(e).css("top",$(window).scrollTop()>t?"60px":""),$("#tocMain").scrollTop($("#tocMain .toc").height()*o*.01)}),$("pre code").each(function(){var o=$(this).attr("class");o="language-"+(null==o||""==o||null==o?"plaintext":o),$(this).attr("class",o)}),$("pre").prepend('<div class="copy-to-clipboard-button"></div>')})</script></html>