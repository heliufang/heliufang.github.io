<!DOCTYPE html><html lang="zh-CN"><head><title>贺刘芳的笔记本</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="stylesheet" href="../../layui/css/layui.css"><link rel="stylesheet" href="../../css/common.css"><link rel="stylesheet" href="../../css/post.css"><link rel="stylesheet" href="../../lib/prism/prism.css"><link rel="shortcut icon" href="../../img/favicon.ico"><link rel="stylesheet" href="../../lib/iconfont/iconfont.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="贺刘芳的搬砖日记" type="application/atom+xml"></head><body style="overflow:hidden" data-prismjs-copy="复制" data-prismjs-copy-success="复制成功!"><div class="qy-nav"><ul class="layui-nav" lay-filter="" lay-bar="disabled" lay-unselect><li class="hide-xs layui-nav-item" id="searchBtn" style="float:right"><a class="searchBtn" href="javascript:void(0);"><i class="layui-icon layui-icon-search"></i> 搜索</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/study"><i class="layui-icon layui-icon-video"></i> 前端教程</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://github.com/heliufang"><i class="icon iconfont icon-github"></i> github</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://gitee.com/heliufang"><i class="icon iconfont icon-gitee"></i> gitee</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf"><i class="icon iconfont icon-cnblogs"></i> 博客园</a></li><li class="layui-nav-item"><a class="title" href="/" style="padding:0"><i class="layui-anim layui-anim-rotate layui-anim-loop layui-icon layui-icon-star-fill"></i> 贺刘芳的笔记本</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/about"><i class="layui-icon layui-icon-friends"></i> 关于</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/archives"><i class="layui-icon layui-icon-date"></i> 归档</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/tags"><i class="layui-icon layui-icon-note"></i> 标签</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/categories"><i class="layui-icon layui-icon-template-1"></i> 分类</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/"><i class="layui-icon layui-icon-home"></i> 首页</a></li><li class="layui-nav-item hide-sm hide-md hide-lg" style="float:right"><a href="javascript:;">菜单</a><dl class="layui-nav-child"><dd><a href="/">首页</a></dd><dd><a href="/archives">归档</a></dd><dd><a href="/tags">标签</a></dd><dd><a href="/categories">分类</a></dd><dd><a href="/about">关于</a></dd><dd><a href="/study">前端教程</a></dd><dd><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github">github</a></dd><dd><a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee">gitee</a></dd><dd><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园">博客园</a></dd><dd><a href="javascript:void(0)" onclick='document.querySelector("#searchShade").style.display="block"'>搜索</a></dd></dl></li></ul><div id="loadingBox" class="loadingBox"><img src="/img/loading.gif"></div></div><div id="searchShade" class="searchShade"><div id="searchLayer"><div id="closeBtn" class="close"><i class="layui-icon layui-icon-close"></i></div><input id="searchTxt" type="text" placeholder="搜索文章(只支持文章标题关键字)" autofocus><div id="searchResult"></div></div></div><div class="layui-container center" id="top"><div class="layui-row layui-col-space20"><div class="layui-col-md3 hide-xs hide-sm"><div class="layui-card"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-speaker"></i> 公告</div><div class="layui-card-body"><div class="userinfo"><img src="/head.png"><div class="name">淡泊明志，宁静致远</div><div class="icons"><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github"><i class="icon iconfont icon-github"></i></a> <a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee"><i class="icon iconfont icon-gitee"></i></a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园"><i class="icon iconfont icon-cnblogs"></i></a></div><div class="other"><div class="item"><a class="title" style="color:#ff5722" href="/"><p class="num">45</p><div>文章</div></a></div><div class="item"><a style="color:#009688" href="/categories"><div class="num">7</div><div class="title">分类</div></a></div><div class="item"><a class="title" style="color:#01aaed" href="/tags"><div class="num">49</div><div>标签</div></a></div></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-website"></i> 网站资讯</div><div class="layui-card-body"><div class="webInfo-item"><div class="title">本站文章字数合计</div><div class="content">218.2k</div></div><div class="webInfo-item"><div class="title">本站Hexo版本</div><div class="content">6.1.0</div></div><div class="webInfo-item"><div class="title">本站Node版本</div><div class="content">16.14.0</div></div><div class="webInfo-item"><div class="title">本站已运行时间</div><div class="content"><span id="runDays" data-since-date="2020-12-24"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span>天</div></div><div class="webInfo-item"><div class="title">最后更新时间</div><div class="content" id="lastUpdate" data-last-update="2023-03-15 23:25:44"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-time"></i> 最新文章</div><div class="layui-card-body"><ul><li><a href="/posts/2ea11abc/">1.angular笔记</a></li><li><a href="/posts/b3a0e706/">2.angularjs笔记</a></li><li><a href="/posts/3c6138e1/">3.js的防抖和节流</a></li><li><a href="/posts/1e33e6ff/">4.pinia笔记</a></li><li><a href="/posts/27fcdfc0/">5.react笔记</a></li></ul></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-template-1"></i> 文章分类</div><div class="layui-card-body left-a-color"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../categories/java/">java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/vue/">vue</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/web%E5%89%8D%E7%AB%AF/">web前端</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/">公众号和小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/">其它技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li></ul></div></div><div style="height:calc(100% - 60px - 60px);width:267px" id="toc-area" class="layui-card ahover"><div class="layui-card-header"><i class="layui-icon layui-icon-align-center"></i> 本文目录</div><div id="tocMain" class="layui-card-body" style="overflow:auto;height:calc(100% - 60px - 60px)"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-js-01"><span class="toc-text">Vue.js-01</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-text">课程介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFVue-js"><span class="toc-text">什么是Vue.js</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%B5%81%E8%A1%8C%E6%A1%86%E6%9E%B6"><span class="toc-text">为什么要学习流行框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%92%8C%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">框架和库的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node%EF%BC%88%E5%90%8E%E7%AB%AF%EF%BC%89%E4%B8%AD%E7%9A%84-MVC-%E4%B8%8E-%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84-MVVM-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-js-%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81-%E5%92%8C-MVVM-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-text">Vue.js 基本代码 和 MVVM 之间的对应关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-cloak"><span class="toc-text">v-cloak</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E6%8C%87%E4%BB%A4%E4%B9%8Bv-text%E5%92%8Cv-html"><span class="toc-text">Vue指令之v-text和v-html</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E6%8C%87%E4%BB%A4%E4%B9%8Bv-bind%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="toc-text">Vue指令之v-bind的三种用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E6%8C%87%E4%BB%A4%E4%B9%8Bv-on%E5%92%8C%E8%B7%91%E9%A9%AC%E7%81%AF%E6%95%88%E6%9E%9C"><span class="toc-text">Vue指令之v-on和跑马灯效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E6%8C%87%E4%BB%A4%E4%B9%8Bv-on%E7%9A%84%E7%BC%A9%E5%86%99%E5%92%8C%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">Vue指令之v-on的缩写和事件修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A"><span class="toc-text">事件修饰符：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E6%8C%87%E4%BB%A4%E4%B9%8Bv-model%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-text">Vue指令之v-model和双向数据绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">简易计算器案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%B7%E5%BC%8F"><span class="toc-text">在Vue中使用样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8class%E6%A0%B7%E5%BC%8F"><span class="toc-text">使用class样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F"><span class="toc-text">使用内联样式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E6%8C%87%E4%BB%A4%E4%B9%8Bv-for%E5%92%8Ckey%E5%B1%9E%E6%80%A7"><span class="toc-text">Vue指令之v-for和key属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E6%8C%87%E4%BB%A4%E4%B9%8Bv-if%E5%92%8Cv-show"><span class="toc-text">Vue指令之v-if和v-show</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7vue-devtools"><span class="toc-text">Vue调试工具vue-devtools</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">私有过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">全局过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%9B%98%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">键盘修饰符以及自定义键盘修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-x%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%9B%98%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%90%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%E3%80%91"><span class="toc-text">1.x中自定义键盘修饰符【了解即可】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-x%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%9B%98%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">2.x中自定义键盘修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">自定义指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0"><span class="toc-text">相关文章</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-js-02"><span class="toc-text">Vue.js-02</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%81%E7%89%8C%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B"><span class="toc-text">品牌管理案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%93%81%E7%89%8C"><span class="toc-text">添加新品牌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%93%81%E7%89%8C"><span class="toc-text">删除品牌</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E5%93%81%E7%89%8C"><span class="toc-text">根据条件筛选品牌</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-resource-%E5%AE%9E%E7%8E%B0-get-post-jsonp%E8%AF%B7%E6%B1%82"><span class="toc-text">vue-resource 实现 get, post, jsonp请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E7%94%BB%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-text">使用动画钩子函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E7%9A%84%E5%88%97%E8%A1%A8%E8%BF%87%E6%B8%A1"><span class="toc-text">v-for 的列表过渡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E8%BF%87%E6%B8%A1"><span class="toc-text">列表的排序过渡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0-1"><span class="toc-text">相关文章</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-js-03"><span class="toc-text">Vue.js-03</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89Vue%E7%BB%84%E4%BB%B6"><span class="toc-text">定义Vue组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">全局组件定义的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%B1%95%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%92%8C%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6"><span class="toc-text">组件中展示数据和响应事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E5%B1%9E%E6%80%A7%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-text">【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8components%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E5%B1%80%E9%83%A8%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-text">使用components属性定义局部子组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8flag%E6%A0%87%E8%AF%86%E7%AC%A6%E7%BB%93%E5%90%88v-if%E5%92%8Cv-else%E5%88%87%E6%8D%A2%E7%BB%84%E4%BB%B6"><span class="toc-text">使用flag标识符结合v-if和v-else切换组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC"><span class="toc-text">子组件向父组件传值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#app"><span class="toc-text">这是一个大大的H1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#app"><span class="toc-text">登录组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#app"><span class="toc-text">注册组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1%E9%AB%98%E4%BA%AE"><span class="toc-text">设置路由高亮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2%E5%8A%A8%E6%95%88"><span class="toc-text">设置路由切换动效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0"><span class="toc-text">在路由规则中定义参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-children-%E5%B1%9E%E6%80%A7%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E5%B5%8C%E5%A5%97"><span class="toc-text">使用 children 属性实现路由嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE%E5%AE%9E%E7%8E%B0%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80"><span class="toc-text">命名视图实现经典布局</span></a></li></ol></li></ol></div><div class="readprocess"><div><i class="layui-icon layui-icon-read"></i> 已阅读：<span id="progressTxt"></span>%</div><div class="layui-progress" lay-filter="demo"><div class="layui-progress-bar" lay-percent="10%"></div></div></div></div></div><div class="layui-col-md9 markdown-body" style="background:#fff;margin-top:10px"><div class="article-title"><p><span><i class="layui-icon layui-icon-template-1"></i> 分类: <span class="layui-badge layui-bg-cyan">vue</span> </span>| <span><i class="layui-icon layui-icon-note"></i> 标签: <span class="layui-badge layui-bg-black">vue</span> <span class="layui-badge layui-bg-black">vue-router</span></span></p><h1>vue学习笔记</h1><p><span><i class="layui-icon layui-icon-survey"></i> 发表于: 2020-06-11 21:20:28 </span>| <span><i class="layui-icon layui-icon-app"></i> 字数统计: 14.5k </span>| <span><i class="layui-icon layui-icon-log"></i> 阅读时长预计: 72分钟</span></p></div><div id="article"><h1 id="Vue-js-01"><a href="#Vue-js-01" class="headerlink" title="Vue.js-01"></a>Vue.js-01</h1><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><p>前5天： 都在学习Vue基本的语法和概念；打包工具 Webpack , Gulp<br>后5天： 以项目驱动教学；</p><h3 id="什么是Vue-js"><a href="#什么是Vue-js" class="headerlink" title="什么是Vue.js"></a>什么是Vue.js</h3><ul><li><p>Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</p></li><li><p>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并成为前端三大主流框架！</p></li><li><p>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</p></li><li><p>前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；</p></li></ul><h2 id="为什么要学习流行框架"><a href="#为什么要学习流行框架" class="headerlink" title="为什么要学习流行框架"></a>为什么要学习流行框架</h2><ul><li>企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；</li></ul><ul><li>企业中，使用框架，能够提高开发的效率；</li></ul><ul><li>提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js &#x2F; Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】）</li><li>在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑；</li></ul><h2 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h2><ul><li>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</li></ul><ul><li>node 中的 express；</li></ul><ul><li>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。</li></ul><ul><li><ol><li>从Jquery 切换到 Zepto</li></ol></li><li><ol start="2"><li>从 EJS 切换到 art-template</li></ol></li></ul><h2 id="Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别"><a href="#Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别" class="headerlink" title="Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别"></a>Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别</h2><ul><li>MVC 是后端的分层开发概念；</li><li>MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</li><li>为什么有了MVC还要有MVVM</li></ul><p><img src="/posts/f9940255/01.MVC%E5%92%8CMVVM%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%A7%A3.png" alt="01.MVC和MVVM的关系图解"></p><h2 id="Vue-js-基本代码-和-MVVM-之间的对应关系"><a href="#Vue-js-基本代码-和-MVVM-之间的对应关系" class="headerlink" title="Vue.js 基本代码 和 MVVM 之间的对应关系"></a>Vue.js 基本代码 和 MVVM 之间的对应关系</h2><pre><code class="html"> &lt;div id=&quot;app&quot;&gt;
        &#123;&#123; msg &#125;&#125;
    &lt;/div&gt;
    &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        var vm = new Vue(&#123;
            el:&quot;#app&quot;,
            data:&#123;
                msg:&quot;Hello Vue!&quot;
            &#125;
        &#125;)
    &lt;/script&gt;
</code></pre><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a><code>v-cloak</code></h2><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        [v-clock]&#123;
            display: none;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
       &lt;p v-clock&gt; &#123;&#123; msg &#125;&#125;&lt;/p&gt;
    &lt;/div&gt;
    &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        var vm = new Vue(&#123;
            el:&quot;#app&quot;,
            data:&#123;
                msg:&quot;Hello Vue!&quot;
            &#125;
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="Vue指令之v-text和v-html"><a href="#Vue指令之v-text和v-html" class="headerlink" title="Vue指令之v-text和v-html"></a>Vue指令之<code>v-text</code>和<code>v-html</code></h2><pre><code class="html"> &lt;div id=&quot;app&quot;&gt;
       &lt;div v-text=&quot;htmlStr&quot;&gt;&lt;/div&gt;
       &lt;div v-html=&quot;htmlStr&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        var vm = new Vue(&#123;
            el:&quot;#app&quot;,
            data:&#123;
                htmlStr:&quot;&lt;h2&gt;我是h2&lt;/h2&gt;&quot;
            &#125;
        &#125;)
    &lt;/script&gt;
</code></pre><h2 id="Vue指令之v-bind的三种用法"><a href="#Vue指令之v-bind的三种用法" class="headerlink" title="Vue指令之v-bind的三种用法"></a>Vue指令之<code>v-bind</code>的三种用法</h2><ol><li>直接使用指令<code>v-bind</code></li><li>使用简化指令<code>:</code></li><li>在绑定的时候，拼接绑定内容：<code>:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot;</code></li></ol><pre><code class="html">    &lt;div id=&quot;app&quot;&gt;
      &lt;button v-bind:title=&quot;msg&quot;&gt;登录&lt;/button&gt;
      &lt;button :title=&quot;msg&quot;&gt;登录&lt;/button&gt;
      &lt;button :title=&quot;btnTitle+&#39;hello world&#39;&quot;&gt;登录&lt;/button&gt;
    &lt;/div&gt;
    &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        var vm = new Vue(&#123;
            el:&quot;#app&quot;,
            data:&#123;
                msg:&quot;你等着&quot;,
                btnTitle:&quot;这是登录按钮提示信息&quot;
            &#125;
        &#125;)
    &lt;/script&gt;
</code></pre><h2 id="Vue指令之v-on和跑马灯效果"><a href="#Vue指令之v-on和跑马灯效果" class="headerlink" title="Vue指令之v-on和跑马灯效果"></a>Vue指令之<code>v-on</code>和<code>跑马灯效果</code></h2><pre><code class="html">&lt;div id=&quot;app&quot;&gt;
      &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt;
      &lt;button v-on:click=&quot;go&quot;&gt;开始&lt;/button&gt;
      &lt;button @click=&quot;stop&quot;&gt;停止&lt;/button&gt;
    &lt;/div&gt;
    &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        var vm = new Vue(&#123;
            el:&quot;#app&quot;,
            data:&#123;
                info:&quot;猥琐发育，别浪&quot;,
                intervalId:null
            &#125;,
            methods:&#123;
                go()&#123;
                    if(this.intervalId)&#123;return&#125;
                    this.intervalId = setInterval(()=&gt;&#123;
                        this.info = this.info.substring(1)+this.info.substring(0,1);
                    &#125;,500)
                &#125;,
                stop()&#123;
                    clearInterval(this.intervalId)
                    this.intervalId = null;
                &#125;
            &#125;
        &#125;)
    &lt;/script&gt;
</code></pre><h2 id="Vue指令之v-on的缩写和事件修饰符"><a href="#Vue指令之v-on的缩写和事件修饰符" class="headerlink" title="Vue指令之v-on的缩写和事件修饰符"></a>Vue指令之<code>v-on的缩写</code>和<code>事件修饰符</code></h2><h3 id="事件修饰符："><a href="#事件修饰符：" class="headerlink" title="事件修饰符："></a>事件修饰符：</h3><ul><li><p>.stop 阻止冒泡</p></li><li><p>.prevent 阻止默认事件</p></li><li><p>.capture 添加事件侦听器时使用事件捕获模式</p></li><li><p>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调</p></li><li><p>.once 事件只触发一次</p></li></ul><pre><code class="html">&lt;div id=&quot;app&quot;&gt;
    &lt;a @click.prevent=&#39;alert(&quot;阻止默认行为&quot;)&#39; href=&quot;https://www.baidu.com&quot;&gt;点我不会跳转&lt;/a&gt;
&lt;/div&gt;
&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var vm = new Vue(&#123;
        el:&quot;#app&quot;,
        data:&#123;

        &#125;
    &#125;)
&lt;/script&gt;
</code></pre><h2 id="Vue指令之v-model和双向数据绑定"><a href="#Vue指令之v-model和双向数据绑定" class="headerlink" title="Vue指令之v-model和双向数据绑定"></a>Vue指令之<code>v-model</code>和<code>双向数据绑定</code></h2><p>使用vue-devtools查看下面表单双向绑定效果：</p><pre><code class="html">    &lt;div id=&quot;app&quot;&gt;
      姓名：&lt;input v-model=&quot;name&quot;&gt;&lt;br&gt;
      性别：男：&lt;input type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;true&quot;&gt;
            女：&lt;input type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;false&quot;&gt;&lt;br&gt;
      爱好：篮球：&lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;lanqiu&quot;&gt;
           足球：  &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;zuqiu&quot;&gt;
            排球： &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;paiqiu&quot;&gt;&lt;br&gt;
      个人说明：&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot; v-model=&quot;desc&quot;&gt;&lt;/textarea&gt;&lt;br&gt;
      民族：&lt;select v-model=&quot;mingzu&quot;&gt;
                &lt;option value=&quot;hanzu&quot;&gt;汉族&lt;/option&gt;
                &lt;option value=&quot;miaozu&quot;&gt;苗族&lt;/option&gt;
                &lt;option value=&quot;weiwuerzu&quot;&gt;维吾尔族&lt;/option&gt;
                &lt;option disabled value=&quot;&quot;&gt;请选择民族&lt;/option&gt;
            &lt;/select&gt;
    &lt;/div&gt;
    &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        var vm = new Vue(&#123;
            el:&quot;#app&quot;,
            data:&#123;
                name:&#39;&#39;,
                gender:false,
                hobby:[],
                desc:&#39;&#39;,
                mingzu:&#39;&#39;
            &#125;
        &#125;)
    &lt;/script&gt;
</code></pre><h2 id="简易计算器案例"><a href="#简易计算器案例" class="headerlink" title="简易计算器案例"></a>简易计算器案例</h2><ol><li>HTML 代码结构</li></ol><pre><code>
  &lt;div id=&quot;app&quot;&gt;

    &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt;

    &lt;select v-model=&quot;opt&quot;&gt;

      &lt;option value=&quot;0&quot;&gt;+&lt;/option&gt;

      &lt;option value=&quot;1&quot;&gt;-&lt;/option&gt;

      &lt;option value=&quot;2&quot;&gt;*&lt;/option&gt;

      &lt;option value=&quot;3&quot;&gt;÷&lt;/option&gt;

    &lt;/select&gt;

    &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt;

    &lt;input type=&quot;button&quot; value=&quot;=&quot; v-on:click=&quot;getResult&quot;&gt;

    &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt;

  &lt;/div&gt;
</code></pre><ol start="2"><li>Vue实例代码：</li></ol><pre><code>
    // 创建 Vue 实例，得到 ViewModel

    var vm = new Vue(&#123;

      el: &#39;#app&#39;,

      data: &#123;

        n1: 0,

        n2: 0,

        result: 0,

        opt: &#39;0&#39;

      &#125;,

      methods: &#123;

        getResult() &#123;

          switch (this.opt) &#123;

            case &#39;0&#39;:

              this.result = parseInt(this.n1) + parseInt(this.n2);

              break;

            case &#39;1&#39;:

              this.result = parseInt(this.n1) - parseInt(this.n2);

              break;

            case &#39;2&#39;:

              this.result = parseInt(this.n1) * parseInt(this.n2);

              break;

            case &#39;3&#39;:

              this.result = parseInt(this.n1) / parseInt(this.n2);

              break;

          &#125;

        &#125;

      &#125;

    &#125;);
</code></pre><h2 id="在Vue中使用样式"><a href="#在Vue中使用样式" class="headerlink" title="在Vue中使用样式"></a>在Vue中使用样式</h2><h3 id="使用class样式"><a href="#使用class样式" class="headerlink" title="使用class样式"></a>使用class样式</h3><ol><li><p>数组</p><pre><code>&lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;
</code></pre></li><li><p>数组中使用三元表达式</p><pre><code>&lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;, isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;
</code></pre></li><li><p>数组中嵌套对象</p><pre><code>&lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;, &#123;&#39;active&#39;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;
</code></pre></li><li><p>直接使用对象</p><pre><code>&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;/h1&gt;
</code></pre></li></ol><p>案例：</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;
        &lt;h1 :class=&quot;[&#39;red&#39;,&#39;thin&#39;]&quot;&gt;使用数组添加样式&lt;/h1&gt;
        &lt;h1 :class=&quot;[&#39;red&#39;,&#39;thin&#39;,isactive?&#39;active&#39;:&#39;&#39;]&quot;&gt;使用三元表达式添加样式&lt;/h1&gt;
        &lt;h1 :class=&quot;[&#39;red&#39;,&#39;thin&#39;,&#123;&#39;active&#39;:isactive&#125;]&quot;&gt;数组中嵌套对象添加样式&lt;/h1&gt;
        &lt;h1 :class=&quot;&#123;red:true,thin:false&#125;&quot;&gt;直接使用对象添加样式&lt;/h1&gt;
    &lt;/div&gt;
    &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        var vm = new Vue(&#123;
            el:&quot;#app&quot;,
            data:&#123;
                isactive:true
            &#125;
        &#125;)
    &lt;/script&gt;
</code></pre><h3 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h3><ol><li><p>直接在元素上通过 <code>:style</code> 的形式，书写样式对象</p><pre><code>&lt;h1 :style=&quot;&#123;color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;&#125;&quot;&gt;这是一个善良的H1&lt;/h1&gt;
</code></pre></li><li><p>将样式对象，定义到 <code>data</code> 中，并直接引用到 <code>:style</code> 中</p></li></ol><ul><li>在data上定义样式：<pre><code>data: &#123;
     h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;
&#125;
</code></pre></li><li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<pre><code>&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt;
</code></pre></li></ul><ol start="3"><li>在 <code>:style</code> 中通过数组，引用多个 <code>data</code> 上的样式对象</li></ol><ul><li>在data上定义样式：<pre><code>data: &#123;
     h1StyleObj: &#123; color: &#39;red&#39;, &#39;font-size&#39;: &#39;40px&#39;, &#39;font-weight&#39;: &#39;200&#39; &#125;,
     h1StyleObj2: &#123; fontStyle: &#39;italic&#39; &#125;
&#125;
</code></pre></li><li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<pre><code>&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt;
</code></pre></li></ul><h2 id="Vue指令之v-for和key属性"><a href="#Vue指令之v-for和key属性" class="headerlink" title="Vue指令之v-for和key属性"></a>Vue指令之<code>v-for</code>和<code>key</code>属性</h2><ol><li>迭代数组(注意加上：key)</li></ol><pre><code>&lt;ul&gt;
  &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;item.id&quot;&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><ol start="2"><li>迭代对象中的属性</li></ol><pre><code>
    &lt;!-- 循环遍历对象身上的属性 --&gt;

    &lt;div v-for=&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt;
</code></pre><ol start="3"><li>迭代数字</li></ol><pre><code>
&lt;p v-for=&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt;
</code></pre><blockquote><p>2.2.0+ 的版本里，<strong>当在组件中使用</strong> v-for 时，key 现在是必须的。</p></blockquote><p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “<strong>就地复用</strong>” 策略。如果数据项的顺序被改变，Vue将<strong>不是移动 DOM 元素来匹配数据项的顺序</strong>， 而是<strong>简单复用此处每个元素</strong>，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给 Vue 一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，你需要为每项提供一个唯一 key 属性。</p><pre><code class="html">&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;
  &lt;!-- 内容 --&gt;
&lt;/div&gt;
</code></pre><h2 id="Vue指令之v-if和v-show"><a href="#Vue指令之v-if和v-show" class="headerlink" title="Vue指令之v-if和v-show"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h2><blockquote><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p></blockquote><pre><code class="html">&lt;div id=&quot;app&quot;&gt;
        &lt;p v-if=&quot;sceen&quot;&gt;我是v-if&lt;/p&gt;
        &lt;p v-show=&quot;sceen&quot;&gt;我是v-show&lt;/p&gt;
        &lt;button @click=&quot;toggle&quot;&gt;切换&lt;/button&gt;
    &lt;/div&gt;
    &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        var vm = new Vue(&#123;
            el:&quot;#app&quot;,
            data:&#123;
                sceen:false
            &#125;,
            methods:&#123;
                toggle()&#123;
                    this.sceen = !this.sceen;
                &#125;
            &#125;
        &#125;)
</code></pre><ol start="2"><li>在2.x版本中<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html#%E6%98%BE%E7%A4%BA%E8%BF%87%E6%BB%A4-%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C">手动实现筛选的方式</a>：</li></ol><ul><li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li></ul><pre><code>
&lt;hr&gt; 输入筛选名称：

&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt;
</code></pre><ul><li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li></ul><pre><code>
&lt;tbody&gt;

      &lt;tr v-for=&quot;item in search(searchName)&quot;&gt;

        &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;

        &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;

        &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt;

        &lt;td&gt;

          &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt;

        &lt;/td&gt;

      &lt;/tr&gt;

    &lt;/tbody&gt;
</code></pre><ul><li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li></ul><pre><code>
search(name) &#123;

  return this.list.filter(x =&gt; &#123;

    return x.name.indexOf(name) != -1;

  &#125;);

&#125;
</code></pre><h2 id="Vue调试工具vue-devtools"><a href="#Vue调试工具vue-devtools" class="headerlink" title="Vue调试工具vue-devtools"></a>Vue调试工具<code>vue-devtools</code></h2><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p><h3 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h3><ol><li>HTML元素：</li></ol><pre><code>
&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt;
</code></pre><ol start="2"><li>私有 <code>filters</code> 定义方式：</li></ol><pre><code>
filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用

    dataFormat(input, pattern = &quot;&quot;) &#123; // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错

      var dt = new Date(input);

      // 获取年月日

      var y = dt.getFullYear();

      var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);

      var d = dt.getDate().toString().padStart(2, &#39;0&#39;);



      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日

      // 否则，就返回  年-月-日 时：分：秒

      if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) &#123;

        return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`;

      &#125; else &#123;

        // 获取时分秒

        var hh = dt.getHours().toString().padStart(2, &#39;0&#39;);

        var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;);

        var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;);



        return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`;

      &#125;

    &#125;

  &#125;
</code></pre><blockquote><p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString&#x3D;’’) 或 String.prototype.padEnd(maxLength, fillString&#x3D;’’)来填充字符串；</p></blockquote><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><pre><code>
// 定义一个全局过滤器,注意全局过滤器要写在new Vue()之前,否则会报错

Vue.filter(&#39;dataFormat&#39;, function (input, pattern = &#39;&#39;) &#123;

  var dt = new Date(input);

  // 获取年月日

  var y = dt.getFullYear();

  var m = (dt.getMonth() + 1).toString().padStart(2, &#39;0&#39;);

  var d = dt.getDate().toString().padStart(2, &#39;0&#39;);



  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日

  // 否则，就返回  年-月-日 时：分：秒

  if (pattern.toLowerCase() === &#39;yyyy-mm-dd&#39;) &#123;

    return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`;

  &#125; else &#123;

    // 获取时分秒

    var hh = dt.getHours().toString().padStart(2, &#39;0&#39;);

    var mm = dt.getMinutes().toString().padStart(2, &#39;0&#39;);

    var ss = dt.getSeconds().toString().padStart(2, &#39;0&#39;);



    return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`;

  &#125;

&#125;);
</code></pre><blockquote><p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p></blockquote><h2 id="键盘修饰符以及自定义键盘修饰符"><a href="#键盘修饰符以及自定义键盘修饰符" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h2><h3 id="1-x中自定义键盘修饰符【了解即可】"><a href="#1-x中自定义键盘修饰符【了解即可】" class="headerlink" title="1.x中自定义键盘修饰符【了解即可】"></a>1.x中自定义键盘修饰符【了解即可】</h3><pre><code>
Vue.directive(&#39;on&#39;).keyCodes.f2 = 113;
</code></pre><h3 id="2-x中自定义键盘修饰符"><a href="#2-x中自定义键盘修饰符" class="headerlink" title="2.x中自定义键盘修饰符"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/events.html#%E9%94%AE%E5%80%BC%E4%BF%AE%E9%A5%B0%E7%AC%A6">2.x中自定义键盘修饰符</a></h3><ol><li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li></ol><pre><code>
Vue.config.keyCodes.f2 = 113;
</code></pre><ol start="2"><li>使用自定义的按键修饰符：</li></ol><pre><code>
&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt;
</code></pre><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/custom-directive.html">自定义指令</a></h2><ol><li>自定义全局和局部的 自定义指令：</li></ol><pre><code>
    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：

    Vue.directive(&#39;focus&#39;, &#123;

      inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用

        el.focus();

      &#125;

    &#125;);



    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：

      directives: &#123;

        color: &#123; // 为元素设置指定的字体颜色

          bind(el, binding) &#123;

            el.style.color = binding.value;

          &#125;

        &#125;,

        &#39;font-weight&#39;: function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数

          el.style.fontWeight = binding2.value;

        &#125;

      &#125;
</code></pre><ol start="2"><li>自定义指令的使用方式：</li></ol><pre><code>
&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&#39;red&#39;&quot; v-font-weight=&quot;900&quot;&gt;
</code></pre><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ol><li><a target="_blank" rel="noopener" href="https://v1-cn.vuejs.org/">vue.js 1.x 文档</a></li><li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">vue.js 2.x 文档</a></li><li><a target="_blank" rel="noopener" href="http://www.css88.com/archives/7715">String.prototype.padStart(maxLength, fillString)</a></li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/wuhua1/p/6686237.html">js 里面的键盘事件对应的键码</a></li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/kidney/p/6052935.html">Vue.js双向绑定的实现原理</a></li></ol><h1 id="Vue-js-02"><a href="#Vue-js-02" class="headerlink" title="Vue.js-02"></a>Vue.js-02</h1><h2 id="品牌管理案例"><a href="#品牌管理案例" class="headerlink" title="品牌管理案例"></a>品牌管理案例</h2><h3 id="添加新品牌"><a href="#添加新品牌" class="headerlink" title="添加新品牌"></a>添加新品牌</h3><h3 id="删除品牌"><a href="#删除品牌" class="headerlink" title="删除品牌"></a>删除品牌</h3><h3 id="根据条件筛选品牌"><a href="#根据条件筛选品牌" class="headerlink" title="根据条件筛选品牌"></a>根据条件筛选品牌</h3><ol><li>1.x 版本中的filterBy指令，在2.x中已经被废除：</li></ol><p><a target="_blank" rel="noopener" href="https://v1-cn.vuejs.org/api/#filterBy">filterBy - 指令</a></p><pre><code>
&lt;tr v-for=&quot;item in list | filterBy searchName in &#39;name&#39;&quot;&gt;

  &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;

  &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;

  &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt;

  &lt;td&gt;

    &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt;

  &lt;/td&gt;

&lt;/tr&gt;
</code></pre><ol start="2"><li>在2.x版本中<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html#%E6%98%BE%E7%A4%BA%E8%BF%87%E6%BB%A4-%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%9C">手动实现筛选的方式</a>：</li></ol><ul><li>筛选框绑定到 VM 实例中的 <code>searchName</code> 属性：</li></ul><pre><code>
&lt;hr&gt; 输入筛选名称：

&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt;
</code></pre><ul><li>在使用 <code>v-for</code> 指令循环每一行数据的时候，不再直接 <code>item in list</code>，而是 <code>in</code> 一个 过滤的methods 方法，同时，把过滤条件<code>searchName</code>传递进去：</li></ul><pre><code>
&lt;tbody&gt;

      &lt;tr v-for=&quot;item in search(searchName)&quot;&gt;

        &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;

        &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;

        &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt;

        &lt;td&gt;

          &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt;

        &lt;/td&gt;

      &lt;/tr&gt;

    &lt;/tbody&gt;
</code></pre><ul><li><code>search</code> 过滤方法中，使用 数组的 <code>filter</code> 方法进行过滤：</li></ul><pre><code>
search(name) &#123;

  return this.list.filter(x =&gt; &#123;

    return x.name.indexOf(name) != -1;

  &#125;);

&#125;
</code></pre><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">vue实例的生命周期</a></p><ul><li>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</li><li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">生命周期钩子</a>：就是生命周期事件的别名而已；</li><li>生命周期钩子 &#x3D; 生命周期函数 &#x3D; 生命周期事件</li><li>主要的生命周期函数分类：</li></ul><ul><li><p>创建期间的生命周期函数：</p><ul><li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li><li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</li><li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li><li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li></ul></li><li><p>运行期间的生命周期函数：</p><ul><li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li></ul></li><li><p>销毁期间的生命周期函数：</p><ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul></li></ul><p><img src="/posts/f9940255/lifecycle.png" alt="lifecycle"></p><p>【生命周期案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2 id=&quot;h2&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt;
        &lt;button @click=&quot;msg = &#39;no&#39;&quot;&gt;改变数据&lt;/button&gt;
    &lt;/div&gt;
   &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
   &lt;script&gt;
       var vm = new Vue(&#123;
            el:&quot;#app&quot;,
            data:&#123;
               msg:&quot;yes&quot;
            &#125;,
            methods:&#123;
                show()&#123;
                    console.log(&#39;这是show方法&#39;);
                &#125;
            &#125;,
            beforeCreate()&#123;
                //此时data和methods还没初始化
                //console.log(this.msg);//undefined
                //console.log(this.show());
            &#125;,
            created()&#123;
                //此时data和methods已经初始化
                // console.log(this.msg);
                // this.show()
            &#125;,
            beforeMount()&#123;
                //此时已经在内存中编译好了模板，只是还未同步到页面
                // console.log(&quot;页面中：&quot;+document.getElementById(&quot;h2&quot;).innerText);//&#123;&#123;msg&#125;&#125;
                // console.log(&quot;data中:&quot;+this.msg);//yes
            &#125;,
            mounted()&#123;
                //此时已经将编译好的模板同步到页面了,标识vue创建阶段完毕，进入运行阶段
                // console.log(&quot;页面中：&quot;+document.getElementById(&quot;h2&quot;).innerText);//yes
                // console.log(&quot;data中:&quot;+this.msg);//yes
            &#125;,
            beforeUpdate()&#123;
                //当数据改变调用此方法,但数据还未与页面同步
                // console.log(&quot;页面中：&quot;+document.getElementById(&quot;h2&quot;).innerText);//yes
                // console.log(&quot;data中:&quot;+this.msg);//no
            &#125;,
            updated()&#123;
                //此时页面和数据已经同步
                // console.log(&quot;页面中：&quot;+document.getElementById(&quot;h2&quot;).innerText);//yes
                // console.log(&quot;data中:&quot;+this.msg);//yes
            &#125;
       &#125;);
   &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="vue-resource-实现-get-post-jsonp请求"><a href="#vue-resource-实现-get-post-jsonp请求" class="headerlink" title="vue-resource 实现 get, post, jsonp请求"></a><a target="_blank" rel="noopener" href="https://github.com/pagekit/vue-resource">vue-resource 实现 get, post, jsonp请求</a></h2><p>除了 vue-resource 之外，还可以使用 <code>axios</code> 的第三方包实现实现数据的请求</p><ol><li>之前的学习中，如何发起数据请求？</li><li>常见的数据请求类型？ get post jsonp</li><li>测试的URL请求资源地址：</li></ol><ul><li>get请求地址： <a target="_blank" rel="noopener" href="http://vue.studyit.io/api/getlunbo">http://vue.studyit.io/api/getlunbo</a></li><li>post请求地址：<a target="_blank" rel="noopener" href="http://vue.studyit.io/api/post">http://vue.studyit.io/api/post</a></li><li>jsonp请求地址：<a target="_blank" rel="noopener" href="http://vue.studyit.io/api/jsonp">http://vue.studyit.io/api/jsonp</a></li></ul><ol start="4"><li>JSONP的实现原理</li></ol><ul><li><p>由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；</p></li><li><p>可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；</p></li><li><p>具体实现过程：</p><ul><li>先在客户端定义一个回调方法，预定义对数据的操作；</li><li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；</li><li>服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；</li><li>客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；</li></ul></li><li><p>带大家通过 Node.js ，来手动实现一个JSONP的请求例子；<br>&#96;&#96;&#96;<br>const http &#x3D; require(‘http’);<br>&#x2F;&#x2F; 导入解析 URL 地址的核心模块<br>const urlModule &#x3D; require(‘url’);</p><p>const server &#x3D; http.createServer();<br>&#x2F;&#x2F; 监听 服务器的 request 请求事件，处理每个请求<br>server.on(‘request’, (req, res) &#x3D;&gt; {<br>const url &#x3D; req.url;</p><p>&#x2F;&#x2F; 解析客户端请求的URL地址<br>var info &#x3D; urlModule.parse(url, true);</p><p>&#x2F;&#x2F; 如果请求的 URL 地址是 &#x2F;getjsonp ，则表示要获取JSONP类型的数据<br>if (info.pathname &#x3D;&#x3D;&#x3D; ‘&#x2F;getjsonp’) {<br>&#x2F;&#x2F; 获取客户端指定的回调函数的名称<br>var cbName &#x3D; info.query.callback;<br>&#x2F;&#x2F; 手动拼接要返回给客户端的数据对象<br>var data &#x3D; {<br>name: ‘zs’,<br>age: 22,<br>gender: ‘男’,<br>hobby: [‘吃饭’, ‘睡觉’, ‘运动’]<br>}<br>&#x2F;&#x2F; 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法：<br>var result &#x3D; <code>$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)</code>;<br>&#x2F;&#x2F; 将拼接好的方法的调用，返回给客户端去解析执行<br>res.end(result);<br>} else {<br>res.end(‘404’);<br>}<br>});</p><p>server.listen(3000, () &#x3D;&gt; {<br>console.log(‘server running at <a href="http://127.0.0.1:3000&#39;">http://127.0.0.1:3000&#39;</a>);<br>});</p></li></ul><pre><code>5. vue-resource 的配置步骤：
+ 直接在页面中，通过`script`标签，引入 `vue-resource` 的脚本文件；
+ 注意：引用的先后顺序是：先引用 `Vue` 的脚本文件，再引用 `vue-resource` 的脚本文件；
6. 发送get请求：
</code></pre><p>getInfo() { &#x2F;&#x2F; get 方式获取数据<br>this.$http.get(‘<a target="_blank" rel="noopener" href="http://127.0.0.1:8899/api/getlunbo&#39;).then">http://127.0.0.1:8899/api/getlunbo&#39;).then</a>(res &#x3D;&gt; {<br>console.log(res.body);<br>})<br>}</p><pre><code>7. 发送post请求：
</code></pre><p>postInfo() {<br>var url &#x3D; ‘<a target="_blank" rel="noopener" href="http://127.0.0.1:8899/api/post&#39;">http://127.0.0.1:8899/api/post&#39;</a>;<br>&#x2F;&#x2F; post 方法接收三个参数：<br>&#x2F;&#x2F; 参数1： 要请求的URL地址<br>&#x2F;&#x2F; 参数2： 要发送的数据对象<br>&#x2F;&#x2F; 参数3： 指定post提交的编码类型为 application&#x2F;x-www-form-urlencoded<br>this.$http.post(url, { name: ‘zs’ }, { emulateJSON: true }).then(res &#x3D;&gt; {<br>console.log(res.body);<br>});<br>}</p><pre><code>8. 发送JSONP请求获取数据：
</code></pre><p>jsonpInfo() { &#x2F;&#x2F; JSONP形式从服务器获取数据<br>var url &#x3D; ‘<a target="_blank" rel="noopener" href="http://127.0.0.1:8899/api/jsonp&#39;">http://127.0.0.1:8899/api/jsonp&#39;</a>;<br>this.$http.jsonp(url).then(res &#x3D;&gt; {<br>console.log(res.body);<br>});<br>}</p><pre><code>
## 配置本地数据库和数据接口API
1. 先解压安装 `PHPStudy`;
2. 解压安装 `Navicat` 这个数据库可视化工具，并激活；
3. 打开 `Navicat` 工具，新建空白数据库，名为 `dtcmsdb4`;
4. 双击新建的数据库，连接上这个空白数据库，在新建的数据库上`右键` -&gt; `运行SQL文件`，选择并执行 `dtcmsdb4.sql` 这个数据库脚本文件；如果执行不报错，则数据库导入完成；
5. 进入文件夹 `vuecms3_nodejsapi` 内部，执行 `npm i` 安装所有的依赖项；
6. 先确保本机安装了 `nodemon`, 没有安装，则运行 `npm i nodemon -g` 进行全局安装，安装完毕后，进入到 `vuecms3_nodejsapi`目录 -&gt; `src`目录 -&gt; 双击运行 `start.bat`
7. 如果API启动失败，请检查 PHPStudy 是否正常开启，同时，检查 `app.js` 中第 `14行` 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是root，默认的密码也是root

## 品牌管理改造
### 展示品牌列表

### 添加品牌数据

### 删除品牌数据

## [Vue中的动画](https://cn.vuejs.org/v2/guide/transitions.html)
为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；

### 使用过渡类名
1. HTML结构：
</code></pre><div id="app"><input type="button" value="动起来" @click="myAnimate"><transition name="fade"><div v-show="isshow">动画哦</div></transition></div>``` 2. VM 实例： ``` // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { isshow: false }, methods: { myAnimate() { this.isshow = !this.isshow; } } }); ``` 3. 定义两组类样式： ``` /* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active { transition: all 0.2s ease; position: absolute; }<pre><code>/* 定义进入过渡的开始状态 和 离开过渡的结束状态 */
.fade-enter,
.fade-leave-to &#123;
  opacity: 0;
  transform: translateX(100px);
&#125;
</code></pre><pre><code>
### [使用第三方 CSS 动画库](https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名)
1. 导入动画类库：
</code></pre><link rel="stylesheet" type="text/css" href="./lib/animate.css">``` 2. 定义 transition 及属性： ```<transition enter-active-class="fadeInRight" leave-active-class="fadeOutRight" :duration="{ enter: 500, leave: 800 }"><div class="animated" v-show="isshow">动画哦</div></transition>```<h3 id="使用动画钩子函数"><a href="#使用动画钩子函数" class="headerlink" title="使用动画钩子函数"></a>使用动画钩子函数</h3><ol><li>定义 transition 组件以及三个钩子函数：<pre><code>&lt;div id=&quot;app&quot;&gt;
 &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt;
 &lt;transition
 @before-enter=&quot;beforeEnter&quot;
 @enter=&quot;enter&quot;
 @after-enter=&quot;afterEnter&quot;&gt;
   &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt;
 &lt;/transition&gt;
  &lt;/div&gt;
</code></pre></li><li>定义三个 methods 钩子方法：<pre><code>methods: &#123;
     beforeEnter(el) &#123; // 动画进入之前的回调
       el.style.transform = &#39;translateX(500px)&#39;;
     &#125;,
     enter(el, done) &#123; // 动画进入完成时候的回调
       el.offsetWidth;
       el.style.transform = &#39;translateX(0px)&#39;;
       done();
     &#125;,
     afterEnter(el) &#123; // 动画进入完成之后的回调
       this.isshow = !this.isshow;
     &#125;
   &#125;
</code></pre></li><li>定义动画过渡时长和样式：<pre><code>.show&#123;
   transition: all 0.4s ease;
 &#125;
</code></pre></li></ol><h3 id="v-for-的列表过渡"><a href="#v-for-的列表过渡" class="headerlink" title="v-for 的列表过渡"></a><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/transitions.html#%E5%88%97%E8%A1%A8%E7%9A%84%E8%BF%9B%E5%85%A5%E5%92%8C%E7%A6%BB%E5%BC%80%E8%BF%87%E6%B8%A1">v-for 的列表过渡</a></h3><ol><li>定义过渡样式：<br>&#96;&#96;&#96;<style>.list-enter,.list-leave-to{opacity:0;transform:translateY(10px)}.list-enter-active,.list-leave-active{transition:all .3s ease}</style><p></p><pre><code>2. 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：
</code></pre><div id="app"><input type="text" v-model="txt" @keyup.enter="add"><pre><code>&lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt;
  &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
&lt;/transition-group&gt;
</code></pre></div>``` 3. 定义 VM中的结构： ``` // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { txt: '', list: [1, 2, 3, 4] }, methods: { add() { this.list.push(this.txt); this.txt = ''; } } }); ```<h3 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a>列表的排序过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，<strong>还可以改变定位</strong>。要使用这个新功能只需了解新增的 <code>v-move</code> 特性，<strong>它会在元素的改变定位的过程中应用</strong>。</p><ul><li><code>v-move</code> 和 <code>v-leave-active</code> 结合使用，能够让列表的过渡更加平缓柔和：<pre><code>.v-move&#123;
transition: all 0.8s ease;
&#125;
.v-leave-active&#123;
position: absolute;
&#125;
</code></pre></li></ul><h2 id="相关文章-1"><a href="#相关文章-1" class="headerlink" title="相关文章"></a>相关文章</h2><ol><li><a target="_blank" rel="noopener" href="https://v1-cn.vuejs.org/">vue.js 1.x 文档</a></li><li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">vue.js 2.x 文档</a></li><li><a target="_blank" rel="noopener" href="http://www.css88.com/archives/7715">String.prototype.padStart(maxLength, fillString)</a></li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/wuhua1/p/6686237.html">js 里面的键盘事件对应的键码</a></li><li><a target="_blank" rel="noopener" href="https://github.com/pagekit/vue-resource">pagekit&#x2F;vue-resource</a></li><li><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/a65957f4976aad24e67f9b9b.html">navicat如何导入sql文件和导出sql文件</a></li><li><a target="_blank" rel="noopener" href="http://cubic-bezier.com/#.4,-0.3,1,.33">贝塞尔在线生成器</a></li></ol><h1 id="Vue-js-03"><a href="#Vue-js-03" class="headerlink" title="Vue.js-03"></a>Vue.js-03</h1><h2 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h2><p>什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；<br>组件化和模块化的不同：</p><ul><li>模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一；</li><li>组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；<h3 id="全局组件定义的三种方式"><a href="#全局组件定义的三种方式" class="headerlink" title="全局组件定义的三种方式"></a>全局组件定义的三种方式</h3></li></ul><ol><li>使用 Vue.extend 配合 Vue.component 方法：<pre><code>var login = Vue.extend(&#123;
   template: &#39;&lt;h1&gt;登录&lt;/h1&gt;&#39;
 &#125;);
 Vue.component(&#39;login&#39;, login);
</code></pre></li><li>直接使用 Vue.component 方法：<pre><code>Vue.component(&#39;register&#39;, &#123;
   template: &#39;&lt;h1&gt;注册&lt;/h1&gt;&#39;
 &#125;);
</code></pre></li><li>将模板字符串，定义到script标签种：<pre><code>&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt;
   &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;
 &lt;/script&gt;
</code></pre>同时，需要使用 Vue.component 来定义组件：<pre><code>Vue.component(&#39;account&#39;, &#123;
   template: &#39;#tmpl&#39;
 &#125;);
</code></pre></li></ol><blockquote><p>注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！</p></blockquote><h3 id="组件中展示数据和响应事件"><a href="#组件中展示数据和响应事件" class="headerlink" title="组件中展示数据和响应事件"></a>组件中展示数据和响应事件</h3><ol><li>在组件中，<code>data</code>需要被定义为一个方法，例如：<pre><code>Vue.component(&#39;account&#39;, &#123;
   template: &#39;#tmpl&#39;,
   data() &#123;
     return &#123;
       msg: &#39;大家好！&#39;
     &#125;
   &#125;,
   methods:&#123;
     login()&#123;
       alert(&#39;点击了登录按钮&#39;);
     &#125;
   &#125;
 &#125;);
</code></pre></li><li>在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的<code>data</code>属性中的值，需要使用<code>this</code>来访问；</li></ol><h3 id="【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象"><a href="#【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象" class="headerlink" title="【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象"></a>【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象</h3><ol><li>通过计数器案例演示</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
      &lt;counter&gt;&lt;/counter&gt;
      &lt;hr&gt;
      &lt;counter&gt;&lt;/counter&gt;
      &lt;hr&gt;
      &lt;counter&gt;&lt;/counter&gt;
    &lt;/div&gt;

    &lt;!-- 定义模板 --&gt;
    &lt;template id=&quot;tmpl&quot;&gt;
      &lt;div&gt;
        &lt;h2&gt;&#123;&#123;count&#125;&#125;&lt;/h2&gt;
        &lt;button type=&quot;button&quot; @click=&quot;increment&quot;&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    &lt;/template&gt;

    &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;
    
    &lt;script&gt;
      // var dataObj = &#123;count:0&#125;
      Vue.component(&quot;counter&quot;,&#123;
        template:&quot;#tmpl&quot;,
        data()&#123;
          return &#123;count:0&#125;;
        &#125;,
        methods:&#123;
          increment()&#123;
            this.count++;
          &#125;
        &#125;
      &#125;)
      
      var vm = new Vue(&#123;
        el: &quot;#app&quot;
      &#125;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="使用components属性定义局部子组件"><a href="#使用components属性定义局部子组件" class="headerlink" title="使用components属性定义局部子组件"></a>使用<code>components</code>属性定义局部子组件</h3><ol><li>组件实例定义方式：<pre><code>&lt;script&gt;
 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue(&#123;
   el: &#39;#app&#39;,
   data: &#123;&#125;,
   methods: &#123;&#125;,
   components: &#123; // 定义子组件
     account: &#123; // account 组件
       template: &#39;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;&#39;, // 在这里使用定义的子组件
       components: &#123; // 定义子组件的子组件
         login: &#123; // login 组件
           template: &quot;&lt;h3&gt;这是登录组件&lt;/h3&gt;&quot;
         &#125;
       &#125;
     &#125;
   &#125;
 &#125;);
  &lt;/script&gt;
</code></pre></li><li>引用组件：<pre><code>&lt;div id=&quot;app&quot;&gt;
 &lt;account&gt;&lt;/account&gt;
  &lt;/div&gt;
</code></pre></li></ol><h2 id="使用flag标识符结合v-if和v-else切换组件"><a href="#使用flag标识符结合v-if和v-else切换组件" class="headerlink" title="使用flag标识符结合v-if和v-else切换组件"></a>使用<code>flag</code>标识符结合<code>v-if</code>和<code>v-else</code>切换组件</h2><ol><li>页面结构：<pre><code class="html">&lt;div id=&quot;app&quot;&gt;
 &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt;
 &lt;!-- 组件名称定义为驼峰时,标签要用-分开 --&gt;
 &lt;my-com1 v-if=&quot;flag&quot;&gt;&lt;/my-com1&gt;
 &lt;my-com2 v-else=&quot;flag&quot;&gt;&lt;/my-com2&gt;
  &lt;/div&gt;
</code></pre></li><li>Vue实例定义：<br>&#96;&#96;&#96;js<script>Vue.component('myCom1', {
   template: '<h3>奔波霸</h3>'
 })

 Vue.component('myCom2', {
   template: '<h3>霸波奔</h3>'
 })

 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '#app',
   data: {
     flag: true
   },
   methods: {}
 });</li>
</ol>
<p></script><p></p><pre><code>
## 使用`:is`属性来切换不同的子组件,并添加切换动画
1. 组件实例定义方式：
</code></pre><p>&#x2F;&#x2F; 登录组件<br>const login &#x3D; Vue.extend({<br>template: <code>&lt;div&gt; &lt;h3&gt;登录组件&lt;/h3&gt; &lt;/div&gt;</code><br>});<br>Vue.component(‘login’, login);</p><pre><code>// 注册组件
const register = Vue.extend(&#123;
  template: `&lt;div&gt;
    &lt;h3&gt;注册组件&lt;/h3&gt;
  &lt;/div&gt;`
&#125;);
Vue.component(&#39;register&#39;, register);

// 创建 Vue 实例，得到 ViewModel
var vm = new Vue(&#123;
  el: &#39;#app&#39;,
  data: &#123; comName: &#39;login&#39; &#125;,
  methods: &#123;&#125;
&#125;);
</code></pre><pre><code>2. 使用`component`标签，来引用组件，并通过`:is`属性来指定要加载的组件：
</code></pre><div id="app"><a href="#" @click.prevent="comName='login'">登录</a> <a href="#" @click.prevent="comName='register'">注册</a><hr><transition mode="out-in"><component :is="comName"></component></transition></div>``` 3. 添加切换样式： ```<style>.v-enter,.v-leave-to{opacity:0;transform:translateX(30px)}</style><p></p><pre><code>
## 父组件向子组件传值
1. 组件实例定义方式，注意：一定要使用`props`属性来定义父组件传递过来的数据
</code></pre><script>var vm=new Vue({el:"#app",data:{msg:"这是父组件中的消息"},components:{son:{template:"<h1>这是子组件 --- </h1>",props:["finfo"]}}})</script><pre><code>2. 使用`v-bind`或简化指令，将数据传递到子组件中：
</code></pre><div id="app"><son :finfo="msg"></son></div>```<h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><ol><li>原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去；</li><li>父组件将方法的引用传递给子组件，其中，<code>getMsg</code>是父组件中<code>methods</code>中定义的方法名称，<code>func</code>是子组件调用传递过来方法时候的方法名称<pre><code>&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt;
</code></pre></li><li>子组件内部通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>方式，来调用父组件中的方法，同时把数据传递给父组件使用<br>&#96;&#96;&#96;<div id="app"><son @func="getMsg"></son><script type="x-template" id="son"><div>
     <input type="button" value="向父组件传值" @click="sendMsg" />
   </div></script></div></li></ol><script>Vue.component("son",{template:"#son",methods:{sendMsg(){this.$emit("func","OK")}}});var vm=new Vue({el:"#app",data:{},methods:{getMsg(e){alert(e)}}})</script><pre><code>
## 评论列表案例
目标：主要练习父子组件之间传值

## 使用 `this.$refs` 来获取元素和组件
</code></pre><div id="app"><div><input type="button" value="获取元素内容" @click="getElement"><h1 ref="myh1">这是一个大大的H1</h1><pre><code>  &lt;hr&gt;
  &lt;!-- 使用 ref 获取子组件 --&gt;
  &lt;my-com ref=&quot;mycom&quot;&gt;&lt;/my-com&gt;
&lt;/div&gt;
</code></pre></div><script>Vue.component("my-com",{template:"<h5>这是一个子组件</h5>",data(){return{name:"子组件"}}});var vm=new Vue({el:"#app",data:{},methods:{getElement(){console.log(this.$refs.myh1.innerText),console.log(this.$refs.mycom.name)}}})</script><pre><code>
## 什么是路由
1. 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；

2. 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；

3. 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；

## 在 vue 中使用 vue-router
1. 导入 vue-router 组件类库：
```html
&lt;!-- 1. 导入 vue-router 组件类库 --&gt;
  &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt;
</code></pre><ol start="2"><li><p>使用 router-link 组件来导航</p><pre><code class="html">&lt;!-- 2. 使用 router-link 组件来导航 --&gt;
&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;
&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;
</code></pre></li><li><p>使用 router-view 组件来显示匹配到的组件</p><pre><code class="html">&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;
&lt;router-view&gt;&lt;/router-view&gt;
</code></pre></li><li><p>创建使用<code>Vue.extend</code>创建组件<br>&#96;&#96;&#96;js<br>&#x2F;&#x2F; 4.1 使用 Vue.extend 来创建登录组件<br>var login &#x3D; Vue.extend({<br>template: ‘</p><h1>登录组件</h1>‘<br>});<p></p><p>&#x2F;&#x2F; 4.2 使用 Vue.extend 来创建注册组件<br>var register &#x3D; Vue.extend({<br>template: ‘</p><h1>注册组件</h1>‘<br>});<p></p></li></ol><pre><code>5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则
```js
// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则
    var router = new VueRouter(&#123;
        //这样这里不是routers而是routes
      routes: [
        &#123; path: &#39;/login&#39;, component: login &#125;,
        &#123; path: &#39;/register&#39;, component: register &#125;
      ]
    &#125;);
</code></pre><ol start="6"><li>使用 router 属性来使用路由规则<pre><code class="js">// 6. 创建 Vue 实例，得到 ViewModel
 var vm = new Vue(&#123;
   el: &#39;#app&#39;,
   router: router // 使用 router 属性来使用路由规则
 &#125;);
</code></pre></li></ol><h2 id="设置路由高亮"><a href="#设置路由高亮" class="headerlink" title="设置路由高亮"></a>设置路由高亮</h2><h2 id="设置路由切换动效"><a href="#设置路由切换动效" class="headerlink" title="设置路由切换动效"></a>设置路由切换动效</h2><h2 id="在路由规则中定义参数"><a href="#在路由规则中定义参数" class="headerlink" title="在路由规则中定义参数"></a>在路由规则中定义参数</h2><blockquote><p>比如访问路径：<a target="_blank" rel="noopener" href="http://localhost:8080/register/123123123123">http://localhost:8080/register/123123123123</a></p></blockquote><ol><li>在规则中定义参数：<pre><code>&#123; path: &#39;/register/:id&#39;, component: register &#125;
</code></pre></li><li>通过 <code>this.$route.params</code>来获取路由中的参数：<pre><code>var register = Vue.extend(&#123;
   template: &#39;&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;&#39;
 &#125;);
</code></pre></li></ol><h2 id="使用-children-属性实现路由嵌套"><a href="#使用-children-属性实现路由嵌套" class="headerlink" title="使用 children 属性实现路由嵌套"></a>使用 <code>children</code> 属性实现路由嵌套</h2><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;
    &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt;

    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;

  &lt;script&gt;
    // 父路由中的组件
    const account = Vue.extend(&#123;
      template: `&lt;div&gt;
        这是account组件
        &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | 
        &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
      &lt;/div&gt;`
    &#125;);

    // 子路由中的 login 组件
    const login = Vue.extend(&#123;
      template: &#39;&lt;div&gt;登录组件&lt;/div&gt;&#39;
    &#125;);

    // 子路由中的 register 组件
    const register = Vue.extend(&#123;
      template: &#39;&lt;div&gt;注册组件&lt;/div&gt;&#39;
    &#125;);

    // 路由实例
    var router = new VueRouter(&#123;
      routes: [
        &#123; path: &#39;/&#39;, redirect: &#39;/account/login&#39; &#125;, // 使用 redirect 实现路由重定向
        &#123;
          path: &#39;/account&#39;,
          component: account,
          //注意这里是children不是childrens
          children: [ // 通过 children 数组属性，来实现路由的嵌套
            &#123; path: &#39;login&#39;, component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符
            &#123; path: &#39;register&#39;, component: register &#125;
          ]
        &#125;
      ]
    &#125;);

    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;&#125;,
      methods: &#123;&#125;,
      components: &#123;
        account
      &#125;,
      router: router
    &#125;);
  &lt;/script&gt;
</code></pre><h2 id="命名视图实现经典布局"><a href="#命名视图实现经典布局" class="headerlink" title="命名视图实现经典布局"></a>命名视图实现经典布局</h2><ol><li>标签代码结构：<pre><code>&lt;div id=&quot;app&quot;&gt;
 &lt;router-view&gt;&lt;/router-view&gt;
 &lt;div class=&quot;content&quot;&gt;
   &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;
   &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt;
 &lt;/div&gt;
  &lt;/div&gt;
</code></pre></li><li>JS代码：<br>&#96;&#96;&#96;<script>var header = Vue.component('header', {
   template: '<div class="header">header</div>'
 });

 var sidebar = Vue.component('sidebar', {
   template: '<div class="sidebar">sidebar</div>'
 });

 var mainbox = Vue.component('mainbox', {
   template: '<div class="mainbox">mainbox</div>'
 });

 // 创建路由对象
 var router = new VueRouter({
   routes: [
     {
       path: '/', components: {
         default: header,
         a: sidebar,
         b: mainbox
       }
     }
   ]
 });

 // 创建 Vue 实例，得到 ViewModel
 var vm = new Vue({
   el: '#app',
   data: {},
   methods: {},
   router
 });</li>
</ol>
<p></script><p></p><pre><code>3. CSS 样式：
</code></pre><style>.header{border:1px solid red}.content{display:flex}.sidebar{flex:2;border:1px solid green;height:500px}.mainbox{flex:8;border:1px solid #00f;height:500px}</style><pre><code>
## `watch`属性的使用
考虑一个问题：想要实现 `名` 和 `姓` 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？）

1. 监听`data`中属性的改变：
</code></pre><div id="app"><input type="text" v-model="firstName"> + <input type="text" v-model="lastName"> = <span></span></div><script>var vm=new Vue({el:"#app",data:{firstName:"jack",lastName:"chen",fullName:"jack - chen"},methods:{},watch:{firstName:function(a,e){this.fullName=a+" - "+this.lastName},lastName:function(a,e){this.fullName=this.firstName+" - "+a}}})</script><pre><code>2. 监听路由对象的改变：
</code></pre><div id="app"><router-link to="/login">登录</router-link><router-link to="/register">注册</router-link><pre><code>&lt;router-view&gt;&lt;/router-view&gt;
</code></pre></div><script>var login=Vue.extend({template:"<h1>登录组件</h1>"}),register=Vue.extend({template:"<h1>注册组件</h1>"}),router=new VueRouter({routes:[{path:"/login",component:login},{path:"/register",component:register}]}),vm=new Vue({el:"#app",data:{},methods:{},router:router,watch:{$route:function(e,t){"/login"===e.path&&console.log("这是登录组件")}}})</script><pre><code>
## `computed`计算属性的使用
1. 默认只有`getter`的计算属性：
</code></pre><div id="app"><input type="text" v-model="firstName"> + <input type="text" v-model="lastName"> = <span></span></div><script>var vm=new Vue({el:"#app",data:{firstName:"jack",lastName:"chen"},methods:{},computed:{fullName(){return this.firstName+" - "+this.lastName}}})</script><pre><code>2. 定义有`getter`和`setter`的计算属性：
</code></pre><div id="app"><input type="text" v-model="firstName"> <input type="text" v-model="lastName"> <input type="button" value="修改fullName" @click="changeName"><pre><code>&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;
</code></pre></div><script>var vm=new Vue({el:"#app",data:{firstName:"jack",lastName:"chen"},methods:{changeName(){this.fullName="TOM - chen2"}},computed:{fullName:{get:function(){return this.firstName+" - "+this.lastName},set:function(e){e=e.split(" - ");this.firstName=e[0],this.lastName=e[1]}}}})</script><pre><code>
## `watch`、`computed`和`methods`之间的对比
1. `computed`属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；
2. `methods`方法表示一个具体的操作，主要书写业务逻辑；
3. `watch`一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是`computed`和`methods`的结合体；

## `nrm`的安装使用
作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；
什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；

1. 运行`npm i nrm -g`全局安装`nrm`包；
2. 使用`nrm ls`查看当前所有可用的镜像源地址以及当前所使用的镜像源地址；
3. 使用`nrm use npm`或`nrm use taobao`切换不同的镜像源地址；

## 相关文件
1. [URL中的hash（井号）](http://www.cnblogs.com/joyho/articles/4430148.html)



# Vue.js -04

## 在网页中会引用哪些常见的静态资源？
+ JS
 - .js  .jsx  .coffee  .ts（TypeScript  类 C# 语言）
+ CSS
 - .css  .less   .sass  .scss
+ Images
 - .jpg   .png   .gif   .bmp   .svg
+ 字体文件（Fonts）
 - .svg   .ttf   .eot   .woff   .woff2
+ 模板文件
 - .ejs   .jade  .vue【这是在webpack中定义组件的方式，推荐这么用】


## 网页中引入的静态资源多了以后有什么问题？？？
1. 网页加载速度慢， 因为 我们要发起很多的二次请求；
2. 要处理错综复杂的依赖关系


## 如何解决上述两个问题
1. 合并、压缩、精灵图、图片的Base64编码
2. 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系；

## 什么是webpack?
webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具；


## 如何完美实现上述的2种解决方案
1. 使用Gulp， 是基于 task 任务的；
2. 使用Webpack， 是基于整个项目进行构建的；
+ 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。
+ 根据官网的图片介绍webpack打包的过程
+ [webpack官网](http://webpack.github.io/)

## webpack安装的两种方式
1. 运行`npm i webpack@3.6.0 -g`全局安装webpack，这样就能在全局使用webpack的命令
2. 在项目根目录中运行`npm i webpack --save -dev`安装到项目依赖中

## 初步使用webpack打包构建列表隔行变色案例
1. 运行`npm init -y`初始化项目，使用npm管理项目中的依赖包
2. 创建项目基本的目录结构
3. 使用`cnpm i jquery --save`安装jquery类库
4. 创建`main.js`并书写各行变色的代码逻辑：
</code></pre><pre><code>// 导入jquery类库
import $ from &#39;jquery&#39;

// 设置偶数行背景色，索引从0开始，0是偶数
$(&#39;#list li:even&#39;).css(&#39;backgroundColor&#39;,&#39;lightblue&#39;);
// 设置奇数行背景色
$(&#39;#list li:odd&#39;).css(&#39;backgroundColor&#39;,&#39;pink&#39;);
</code></pre><pre><code>5. 直接在页面上引用`main.js`会报错，因为浏览器不认识`import`这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；
6. 运行`webpack 入口文件路径 输出文件路径`对`main.js`进行处理：

**注意**：webpack4.x需要加上`-o`参数才行,不然会报错！！
</code></pre><p>webpack src&#x2F;js&#x2F;main.js -o dist&#x2F;bundle.js</p><pre><code>
## 使用webpack的配置文件简化打包时候的命令

1. 在项目根目录中创建`webpack.config.js`
2. 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在`webpack.config.js`中配置这两个路径：
</code></pre><pre><code>// 导入处理路径的模块
var path = require(&#39;path&#39;);

// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理
module.exports = &#123;
    entry: path.resolve(__dirname, &#39;src/js/main.js&#39;), // 项目入口文件
    output: &#123; // 配置输出选项
        path: path.resolve(__dirname, &#39;dist&#39;), // 配置输出的路径
        filename: &#39;bundle.js&#39; // 配置输出的文件名
    &#125;
&#125;
</code></pre><pre><code>
## 实现webpack的实时打包构建
1. 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用`webpack-dev-server`来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。
2. 先在项目本地安装`npm i webpack@3.0.0`,然后`cnpm i webpack-dev-server@2.9.3 --save -dev`安装到开发依赖
3. 安装完成之后，在命令行直接运行`webpack-dev-server`来进行打包，发现报错，此时需要借助于`package.json`文件中的指令，来进行运行`webpack-dev-server`命令，在`package.json文件的scripts`节点下新增`&quot;dev&quot;: &quot;webpack-dev-server&quot;`指令，发现可以进行实时打包，但是dist目录下并没有生成`bundle.js`文件，这是因为`webpack-dev-server`将打包好的文件放在了内存中
 + 把`bundle.js`放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快
 + 这个时候访问webpack-dev-server启动的`http://localhost:8080/`网站，发现是一个文件夹的面板，需要点击到src目录下，才能打开我们的index首页，此时引用不到bundle.js文件，需要修改index.html中script的src属性为:`&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt;`
 + 为了能在访问`http://localhost:8080/`的时候直接访问到index首页，可以使用`--contentBase src`指令来修改dev指令，指定启动的根目录：
</code></pre><p>“dev”: “webpack-dev-server –contentBase src”</p><pre><code>同时修改index页面中script的src属性为`&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;`

**注意**：webpack4.x版本要安装这个：`npm i webpack-cli` 否则会报错

* 启动项目：经过上一步的配置，在终端输入下面命令即可启动项目访问默认页面。
</code></pre><p>npm run dev</p><pre><code>
## 使用`html-webpack-plugin`插件配置启动页面
由于使用`--contentBase`指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中script标签的src属性，所以推荐大家使用`html-webpack-plugin`插件配置启动页面.
1. 运行`cnpm i html-webpack-plugin@3 --save-dev`安装到开发依赖
2. 修改`webpack.config.js`配置文件如下：
</code></pre><pre><code>// 导入处理路径的模块
var path = require(&#39;path&#39;);
// 导入自动生成HTMl文件的插件
var htmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

module.exports = &#123;
    entry: path.resolve(__dirname, &#39;src/js/main.js&#39;), // 项目入口文件
    output: &#123; // 配置输出选项
        path: path.resolve(__dirname, &#39;dist&#39;), // 配置输出的路径
        filename: &#39;bundle.js&#39; // 配置输出的文件名
    &#125;,
    plugins:[ // 添加plugins节点配置插件
        new htmlWebpackPlugin(&#123;
            template:path.resolve(__dirname, &#39;src/index.html&#39;),//模板路径
            filename:&#39;index.html&#39;//自动生成的HTML文件的名称
        &#125;)
    ]
&#125;
</code></pre><pre><code>3. 修改`package.json`中`script`节点中的dev指令如下：
</code></pre><p>“dev”: “webpack-dev-server”</p><pre><code>4. 将index.html中script标签注释掉，因为`html-webpack-plugin`插件会自动把bundle.js注入到index.html页面中！

## 实现自动打开浏览器、热更新和配置浏览器的默认端口号
**注意：热更新在JS中表现的不明显，可以从一会儿要讲到的CSS身上进行介绍说明！**

### 方式1：
+ 修改`package.json`的script节点如下，其中`--open`表示自动打开浏览器，`--port 4321`表示打开的端口号为4321，`--hot`表示启用浏览器热更新：
</code></pre><p>“dev”: “webpack-dev-server –hot –port 4321 –open”</p><pre><code>
### 方式2：

0. 修改`package.json`的script节点
</code></pre><p>“dev”: “webpack-dev-server”</p><pre><code>
1. 修改`webpack.config.js`文件，新增`devServer`节点如下：
</code></pre><p>devServer:{<br>hot:true,<br>open:true,<br>port:4321<br>}</p><pre><code>2. 在头部引入`webpack`模块：
</code></pre><p>var webpack &#x3D; require(‘webpack’);</p><pre><code>3. 在新增`plugins`节点,并在节点下新增：
</code></pre><p>new webpack.HotModuleReplacementPlugin()</p><pre><code>
## 使用webpack打包css文件

0. ==在main.js中导入css文件==
</code></pre><p>import ‘.&#x2F;css&#x2F;index.css’</p><pre><code>
1. 默认只能导入js文件,所以需要安装`loader`,运行`cnpm i style-loader@2 css-loader@3 --save-dev`
2. 修改`webpack.config.js`这个配置文件：
</code></pre><p>module: { &#x2F;&#x2F; 用来配置第三方loader模块的<br>rules: [ &#x2F;&#x2F; 文件的匹配规则<br>{ test: &#x2F;.css$&#x2F;, use: [‘style-loader’, ‘css-loader’] }&#x2F;&#x2F;处理css文件的规则<br>]<br>}</p><pre><code>3. 注意：`use`表示使用哪些模块来处理`test`所匹配到的文件；`use`中相关loader模块的调用顺序是从后向前调用的；

## 使用webpack打包less文件
1. 运行`cnpm i less-loader@3 less@2 -D`
2. 修改`webpack.config.js`这个配置文件：
</code></pre><p>{ test: &#x2F;.less$&#x2F;, use: [‘style-loader’, ‘css-loader’, ‘less-loader’] },</p><pre><code>
## 使用webpack打包sass文件
1. 运行`cnpm i sass-loader@6 node-sass@4 --save-dev`
2. 在`webpack.config.js`中添加处理sass文件的loader模块：
</code></pre><p>{ test: &#x2F;.scss$&#x2F;, use: [‘style-loader’, ‘css-loader’, ‘sass-loader’] }</p><pre><code>
## 使用webpack处理css中的路径
1. 运行`cnpm i url-loader@0 file-loader@1 --save-dev`
2. 在`webpack.config.js`中添加处理url路径的loader模块：
</code></pre><p>{ test: &#x2F;.(png|jpg|gif)$&#x2F;, use: ‘url-loader’ }</p><pre><code>3. 可以通过`limit`指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码：
</code></pre><p>{ test: &#x2F;.(png|jpg|gif)$&#x2F;, use: ‘url-loader?limit&#x3D;43960’ },</p><pre><code>
**注意**：也可以来处理字体文件。

## 使用babel处理高级JS语法

1. 运行`cnpm i babel-core babel-loader@7 babel-plugin-transform-runtime --save-dev`安装babel的相关loader包

   **注意**：这里babel-loader@7 否则会下载8版本

   https://blog.csdn.net/weixin_33727510/article/details/93264765

2. 运行`cnpm i babel-preset-env babel-preset-stage-0 --save-dev`安装babel转换的语法

3. 在`webpack.config.js`中添加相关loader模块，其中需要注意的是，一定要把`node_modules`文件夹添加到排除项：
</code></pre><p>{ test: &#x2F;.js$&#x2F;, use: ‘babel-loader’, exclude: &#x2F;node_modules&#x2F; }</p><pre><code>4. 在项目根目录中添加`.babelrc`文件，并修改这个配置文件如下：
</code></pre><p>{<br>“presets”:[“env”, “stage-0”],<br>“plugins”:[“transform-runtime”]<br>}</p><pre><code>5. **注意：语法插件`babel-preset-es2015`可以更新为`babel-preset-env`，它包含了所有的ES相关的语法；**

## 相关文章
[babel-preset-env：你需要的唯一Babel插件](https://segmentfault.com/p/1210000008466178)
[Runtime transform 运行时编译es6](https://segmentfault.com/a/1190000009065987)

# Vue.js-05

## 注意：

有时候使用`npm i node-sass -D`装不上，这时候，就必须使用 `cnpm i node-sass -D`

## 在普通页面中使用render函数渲染组件



## 在webpack中配置.vue组件页面的解析

1. 运行`cnpm i vue -S`将vue安装为运行依赖；

2. 运行`cnpm i vue-loader@14 vue-template-compiler -D`将解析转换vue的包安装为开发依赖；

3. 运行`cnpm i style-loader css-loader -D`将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式；

4. 在`webpack.config.js`中，添加如下`module`规则：
</code></pre><p>module: {</p><pre><code>rules: [

  &#123; test: /\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] &#125;,

  &#123; test: /\.vue$/, use: &#39;vue-loader&#39; &#125;

]
</code></pre><p>}</p><pre><code>
5. 创建`App.vue`组件页面：
</code></pre><pre><code>&lt;template&gt;

  &lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt;

  &lt;div&gt;

    &lt;h1&gt;这是APP组件 - &#123;&#123;msg&#125;&#125;&lt;/h1&gt;

    &lt;h3&gt;我是h3&lt;/h3&gt;

  &lt;/div&gt;

&lt;/template&gt;



&lt;script&gt;

// 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象

export default &#123;

  data() &#123;

    return &#123;

      msg: &#39;OK&#39;

    &#125;

  &#125;

&#125;

&lt;/script&gt;



&lt;style scoped&gt;

h1 &#123;

  color: red;

&#125;

&lt;/style&gt;
</code></pre><pre><code>
6. 创建`main.js`入口文件：
</code></pre><pre><code>// 导入 Vue 组件

import Vue from &#39;vue&#39;



// 导入 App组件

import App from &#39;./components/App.vue&#39;



// 创建一个 Vue 实例，使用 render 函数，渲染指定的组件

var vm = new Vue(&#123;

  el: &#39;#app&#39;,

  render: c =&gt; c(App)

&#125;);
</code></pre><pre><code>
## 在使用webpack构建的Vue项目中使用模板对象？
1. 在`webpack.config.js`中添加`resolve`属性：
</code></pre><p>resolve: {<br>alias: {<br>‘vue$’: ‘vue&#x2F;dist&#x2F;vue.esm.js’<br>}<br>}</p><pre><code>


## ES6中语法使用总结

1. 使用 `export default` 和 `export` 导出模块中的成员; 对应ES5中的 `module.exports` 和 `export`

2. 使用 `import ** from **` 和 `import &#39;路径&#39;` 还有 `import &#123;a, b&#125; from &#39;模块标识&#39;` 导入其他模块

3. 使用箭头函数：`(a, b)=&gt; &#123; return a-b; &#125;`



## 在vue组件页面中，集成vue-router路由模块

[vue-router官网](https://router.vuejs.org/)

1. 导入路由模块：
</code></pre><p>import VueRouter from ‘vue-router’</p><pre><code>
2. 安装路由模块：
</code></pre><p>Vue.use(VueRouter);</p><pre><code>
3. 导入需要展示的组件:
</code></pre><p>import login from ‘.&#x2F;components&#x2F;account&#x2F;login.vue’</p><p>import register from ‘.&#x2F;components&#x2F;account&#x2F;register.vue’</p><pre><code>
4. 创建路由对象:
</code></pre><p>var router &#x3D; new VueRouter({</p><p>routes: [</p><pre><code>&#123; path: &#39;/&#39;, redirect: &#39;/login&#39; &#125;,

&#123; path: &#39;/login&#39;, component: login &#125;,

&#123; path: &#39;/register&#39;, component: register &#125;
</code></pre><p>]</p><p>});</p><pre><code>
5. 将路由对象，挂载到 Vue 实例上:
</code></pre><p>var vm &#x3D; new Vue({</p><p>el: ‘#app’,</p><p>&#x2F;&#x2F; render: c &#x3D;&gt; { return c(App) }</p><p>render(c) {</p><pre><code>return c(App);
</code></pre><p>},</p><p>router &#x2F;&#x2F; 将路由对象，挂载到 Vue 实例上</p><p>});</p><pre><code>
6. 改造App.vue组件，在 template 中，添加`router-link`和`router-view`：
</code></pre><pre><code>&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;

&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;



&lt;router-view&gt;&lt;/router-view&gt;
</code></pre><pre><code>


## 组件中的css作用域问题



## 抽离路由为单独的模块



## 使用 饿了么的 MintUI 组件

[Github 仓储地址](https://github.com/ElemeFE/mint-ui)

[Mint-UI官方文档](http://mint-ui.github.io/#!/zh-cn)

1. 导入所有MintUI组件：
</code></pre><p>import MintUI from ‘mint-ui’</p><pre><code>
2. 导入样式表：
</code></pre><p>import ‘mint-ui&#x2F;lib&#x2F;style.css’</p><pre><code>
3. 在 vue 中使用 MintUI：
</code></pre><p>Vue.use(MintUI)</p><pre><code>
4. 使用的例子：
</code></pre><p><mt-button type="primary" size="large">primary</mt-button></p><pre><code>


## 使用 MUI 组件

[官网首页](http://dev.dcloud.net.cn/mui/)

[文档地址](http://dev.dcloud.net.cn/mui/ui/)

1. 导入 MUI 的样式表：
</code></pre><p>import ‘..&#x2F;lib&#x2F;mui&#x2F;css&#x2F;mui.min.css’</p><pre><code>
2. 在`webpack.config.js`中添加新的loader规则：
</code></pre><p>{ test: &#x2F;.(png|jpg|gif|ttf)$&#x2F;, use: ‘url-loader’ }</p><pre><code>
3. 根据官方提供的文档和example，尝试使用相关的组件



## 将项目源码托管到oschina中

1. 点击头像 -&gt; 修改资料 -&gt; SSH公钥 [如何生成SSH公钥](http://git.mydoc.io/?t=154712)

2. 创建自己的空仓储，使用 `git config --global user.name &quot;用户名&quot;` 和 `git config --global user.email ***@**.com` 来全局配置提交时用户的名称和邮箱

3. 使用 `git init` 在本地初始化项目

4. 使用 `touch README.md` 和 `touch .gitignore` 来创建项目的说明文件和忽略文件；

5. 使用 `git add .` 将所有文件托管到 git 中

6. 使用 `git commit -m &quot;init project&quot;` 将项目进行本地提交

7. 使用 `git remote add origin 仓储地址`将本地项目和远程仓储连接，并使用origin最为远程仓储的别名

8. 使用 `git push -u origin master` 将本地代码push到仓储中



## App.vue 组件的基本设置

1. 头部的固定导航栏使用 `Mint-UI` 的 `Header` 组件；

2. 底部的页签使用 `mui` 的 `tabbar`;

3. 购物车的图标，使用 `icons-extra` 中的 `mui-icon-extra mui-icon-extra-cart`，同时，应该把其依赖的字体图标文件 `mui-icons-extra.ttf`，复制到 `fonts` 目录下！

4. 将底部的页签，改造成 `router-link` 来实现单页面的切换；

5. Tab Bar 路由激活时候设置高亮的两种方式：

 + 全局设置样式如下：
</code></pre><pre><code> .router-link-active&#123;

      color:#007aff !important;

&#125;
</code></pre><pre><code>
+ 或者在 `new VueRouter` 的时候，通过 `linkActiveClass` 来指定高亮的类：
</code></pre><pre><code> // 创建路由对象

var router = new VueRouter(&#123;

  routes: [

    &#123; path: &#39;/&#39;, redirect: &#39;/home&#39; &#125;

  ],

  linkActiveClass: &#39;mui-active&#39;

&#125;);
</code></pre><pre><code>


## 实现 tabbar 页签不同组件页面的切换

1. 将 tabbar 改造成 `router-link` 形式，并指定每个连接的 `to` 属性；

2. 在入口文件中导入需要展示的组件，并创建路由对象：
</code></pre><pre><code>// 导入需要展示的组件

import Home from &#39;./components/home/home.vue&#39;

import Member from &#39;./components/member/member.vue&#39;

import Shopcar from &#39;./components/shopcar/shopcar.vue&#39;

import Search from &#39;./components/search/search.vue&#39;



// 创建路由对象

var router = new VueRouter(&#123;

  routes: [

    &#123; path: &#39;/&#39;, redirect: &#39;/home&#39; &#125;,

    &#123; path: &#39;/home&#39;, component: Home &#125;,

    &#123; path: &#39;/member&#39;, component: Member &#125;,

    &#123; path: &#39;/shopcar&#39;, component: Shopcar &#125;,

    &#123; path: &#39;/search&#39;, component: Search &#125;

  ],

  linkActiveClass: &#39;mui-active&#39;

&#125;);
</code></pre><pre><code>


## 使用 mt-swipe 轮播图组件

1. 假数据：
</code></pre><p>lunbo: [</p><pre><code>    &#39;http://www.itcast.cn/images/slidead/BEIJING/2017440109442800.jpg&#39;,

    &#39;http://www.itcast.cn/images/slidead/BEIJING/2017511009514700.jpg&#39;,

    &#39;http://www.itcast.cn/images/slidead/BEIJING/2017421414422600.jpg&#39;

  ]
</code></pre><pre><code>
2. 引入轮播图组件：
</code></pre><pre><code>&lt;div class=&quot;home-swipe&quot;&gt;

  &lt;mt-swipe :auto=&quot;4000&quot;&gt;

    &lt;mt-swipe-item v-for=&quot;(item, i) in lunbo&quot; :key=&quot;i&quot;&gt;

      &lt;img :src=&quot;item&quot; alt=&quot;&quot;&gt;

    &lt;/mt-swipe-item&gt;

  &lt;/mt-swipe&gt;

&lt;/div&gt;
</code></pre></li></ol></div><pre><code>


## 在`.vue`组件中使用`vue-resource`获取数据

1. 运行`cnpm i vue-resource -S`安装模块

2. 导入 vue-resource 组件
</code></pre><p>import VueResource from ‘vue-resource’</p><pre><code>
3. 在vue中使用 vue-resource 组件
</code></pre><p>Vue.use(VueResource);</p><pre><code>


</code></pre></li></ol></li></ol></div><div class="post-ending"><div class="end-txt">------ 本文结束，感谢您的阅读 ------</div><blockquote class="layui-elem-quote layui-quote-nm" style="padding:10px"><div><span class="title">本文作者: </span>贺刘芳</div><div><span class="title">本文链接: </span><a target="_blank" href="https://heliufang.gitee.io/posts/f9940255/">https://heliufang.gitee.io/posts/f9940255/</a></div><div><span class="title">版权声明: </span>本文采用知识共享署名-非商业性使用-禁止演绎 2.5 中国大陆许可协议进行许可。</div></blockquote><div id="vcomments"></div></div></div></div></div><ul id="toTopBtn" class="layui-fixbar" style="right:-70px" title="置顶"><div><a href="javascript:void(0)" class="icon iconfont icon-huojian"></a></div></ul><div class="qy-footer"><div class="font-Area"><p>访客数 <span style="color:red" id="busuanzi_value_site_uv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 人次 | 访问量 <span style="color:red" id="busuanzi_value_site_pv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 次 | 本站已运行 <span style="color:red" id="runDaysFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 天 | 本站文章字数合计 <span style="color:red">218.2k</span> | 最后更新于 <span style="color:red" id="lastUpdateFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span></p><p>由 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a> <span style="color:red" class="layui-icon layui-icon-find-fill layui-anim layui-anim-rotate layui-anim-loop"></span> 强力驱动 v6.1.0</p><p>Copyright © 2020 ~<span id="currentYear">2022</span> <span class="layui-icon layui-icon-heart-fill footer-heart"></span> HeLiuFang</p></div></div></body><script src="../../js/jquery.min.js"></script><script src="../../js/moment.min.js"></script><script src="../../layui/layui.js"></script><script src="../../lib/prism/prism.js"></script><script>$("#searchBtn").click(function(){$("#searchShade").show(),$("#searchLayer").addClass("layui-anim layui-anim-scaleSpring")}),$("#closeBtn").click(function(){$("#searchShade").hide()});var searchFunc=function(e,o,a){$.ajax({url:e,dataType:"json",success:function(e){var t=document.getElementById(o),n=document.getElementById(a);t.addEventListener("input",function(){var t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(e){var n=!0,o=e.title.trim().toLowerCase(),e=e.url;""!=o&&a.forEach(function(e,t){o.indexOf(e)<0?n=!1:o=o.replace(new RegExp(e,"g"),'<span style="color:red">'+e+"</span>")}),n&&(t=t+"<li><a href='"+e+"' class='search-result-title'>"+o+"</a></li>")}),t+="</ul>",n.innerHTML=t)})}})};function DynamicLine(){function e(e,t,n){return e.getAttribute(t)||n}function t(e){return document.getElementsByTagName(e)}function n(){s=a.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,r=a.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function c(){var n,o,a,i,l;m.clearRect(0,0,s,r),y.forEach(function(e,t){for(e.x+=e.xa,e.y+=e.ya,e.xa*=e.x>s||e.x<0?-1:1,e.ya*=e.y>r||e.y<0?-1:1,m.fillRect(e.x-.5,e.y-.5,1,1),o=t+1;o<d.length;o++)null!==(n=d[o]).x&&null!==n.y&&(a=e.x-n.x,i=e.y-n.y,(l=a*a+i*i)<n.max)&&(n===h&&l>=n.max/2&&(e.x-=.03*a,e.y-=.03*i),a=(n.max-l)/n.max,m.beginPath(),m.lineWidth=a/2,m.strokeStyle="rgba("+u.c+","+(.2+a)+")",m.moveTo(e.x,e.y),m.lineTo(n.x,n.y),m.stroke())}),w(c)}var s,r,d,o,a=document.createElement("canvas"),u=(i=(o=t("script")).length,o=o[i-1],{l:i,z:e(o,"zIndex",-1),o:e(o,"opacity",.5),c:e(o,"color","0,0,50"),n:e(o,"count",99)}),i="c_n"+u.l,m=a.getContext("2d"),w=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(e,1e3/45)},l=Math.random,h={x:null,y:null,max:2e4};a.id=i,a.style.cssText="position:fixed;top:0;left:0;z-index:"+u.z+";opacity:"+u.o,t("body")[0].appendChild(a),n(),window.onresize=n,window.onmousemove=function(e){e=e||window.event,h.x=e.clientX,h.y=e.clientY},window.onmouseout=function(){h.x=null,h.y=null};for(var y=[],x=0;x<u.n;x++){var f=l()*s,p=l()*r,$=2*l()-1,v=2*l()-1;y.push({x:f,y:p,xa:$,ya:v,max:6e3})}d=y.concat([h]),setTimeout(function(){c()},100)}searchFunc("/search.json","searchTxt","searchResult"),DynamicLine(),document.querySelector("#currentYear").innerText=(new Date).getFullYear();var days=moment().diff($("#runDays")[0].dataset.sinceDate,"days"),lastUpdate=($("#runDays").html(days),$("#runDaysFooter").html(days),moment($("#lastUpdate")[0].dataset.lastUpdate,"YYYY-MM-DD HH:mm:ss").locale("zh-CN").fromNow());$("#lastUpdate").html(lastUpdate),$("#lastUpdateFooter").html(lastUpdate),$("#toTopBtn").click(function(){var e=$(window).scrollTop(),t=parseInt(e/60),n=setInterval(function(){$(window).scrollTop($(window).scrollTop()-t),0===$(window).scrollTop()&&clearInterval(n)},1)}),$.event.add(window,"scroll",function(){$("#toTopBtn").css("transform",0<$(window).scrollTop()?"translateX(-85px)":"translateX(85px)"),$("#toTopBtn").css("transition","all 0.5s")}),$("#loadingBox").hide(),$("body").css("overflow","auto")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var element=null;layui.use(["element"],function(){element=layui.element}),$(function(){var e=$("#toc-area"),t=$(e).offset().top;$.event.add(window,"scroll",function(){var o=$(".markdown-body").height(),o=(($(window).scrollTop()+t)/o*100).toFixed(2);element.progress("demo",(o=0==(o=99<o?100:o)?0:o)+"%"),$("#progressTxt").text(o),console.log("percent",o),$(e).css("position",$(window).scrollTop()>t?"fixed":"static"),$(e).css("top",$(window).scrollTop()>t?"60px":""),$("#tocMain").scrollTop($("#tocMain .toc").height()*o*.01)}),$("pre code").each(function(){var o=$(this).attr("class");o="language-"+(null==o||""==o||null==o?"plaintext":o),$(this).attr("class",o)}),$("pre").prepend('<div class="copy-to-clipboard-button"></div>')})</script></html>