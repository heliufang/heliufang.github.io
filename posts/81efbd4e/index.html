<!DOCTYPE html><html lang="zh-CN"><head><title>老C的笔记本</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="stylesheet" href="../../layui/css/layui.css"><link rel="stylesheet" href="../../css/common.css"><link rel="stylesheet" href="../../css/post.css"><link rel="stylesheet" href="../../lib/prism/prism.css"><link rel="shortcut icon" href="../../img/favicon.ico"><link rel="stylesheet" href="../../lib/iconfont/iconfont.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="老C的搬砖日记" type="application/atom+xml"></head><body style="overflow:hidden" data-prismjs-copy="复制" data-prismjs-copy-success="复制成功!"><div class="qy-nav"><ul class="layui-nav" lay-filter="" lay-bar="disabled" lay-unselect><li class="hide-xs layui-nav-item" id="searchBtn" style="float:right"><a class="searchBtn" href="javascript:void(0);"><i class="layui-icon layui-icon-search"></i> 搜索</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/study"><i class="layui-icon layui-icon-video"></i> 前端教程</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://github.com/heliufang"><i class="icon iconfont icon-github"></i> github</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://gitee.com/heliufang"><i class="icon iconfont icon-gitee"></i> gitee</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf"><i class="icon iconfont icon-cnblogs"></i> 博客园</a></li><li class="layui-nav-item"><a class="title" href="/" style="padding:0"><i class="layui-anim layui-anim-rotate layui-anim-loop layui-icon layui-icon-star-fill"></i> 老C的笔记本</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/about"><i class="layui-icon layui-icon-friends"></i> 关于</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/archives"><i class="layui-icon layui-icon-date"></i> 归档</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/tags"><i class="layui-icon layui-icon-note"></i> 标签</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/categories"><i class="layui-icon layui-icon-template-1"></i> 分类</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/"><i class="layui-icon layui-icon-home"></i> 首页</a></li><li class="layui-nav-item hide-sm hide-md hide-lg" style="float:right"><a href="javascript:;">菜单</a><dl class="layui-nav-child"><dd><a href="/">首页</a></dd><dd><a href="/archives">归档</a></dd><dd><a href="/tags">标签</a></dd><dd><a href="/categories">分类</a></dd><dd><a href="/about">关于</a></dd><dd><a href="/study">前端教程</a></dd><dd><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github">github</a></dd><dd><a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee">gitee</a></dd><dd><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园">博客园</a></dd><dd><a href="javascript:void(0)" onclick='document.querySelector("#searchShade").style.display="block"'>搜索</a></dd></dl></li></ul><div id="loadingBox" class="loadingBox"><img src="/img/loading.gif"></div></div><div id="searchShade" class="searchShade"><div id="searchLayer"><div id="closeBtn" class="close"><i class="layui-icon layui-icon-close"></i></div><input id="searchTxt" type="text" placeholder="搜索文章(只支持文章标题关键字)" autofocus><div id="searchResult"></div></div></div><div class="layui-container center" id="top"><div class="layui-row layui-col-space20"><div class="layui-col-md3 hide-xs hide-sm"><div class="layui-card"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-speaker"></i> 公告</div><div class="layui-card-body"><div class="userinfo"><img src="/head.png"><div class="name">淡泊明志，宁静致远</div><div class="icons"><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github"><i class="icon iconfont icon-github"></i></a> <a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee"><i class="icon iconfont icon-gitee"></i></a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园"><i class="icon iconfont icon-cnblogs"></i></a></div><div class="other"><div class="item"><a class="title" style="color:#ff5722" href="/"><p class="num">64</p><div>文章</div></a></div><div class="item"><a style="color:#009688" href="/categories"><div class="num">10</div><div class="title">分类</div></a></div><div class="item"><a class="title" style="color:#01aaed" href="/tags"><div class="num">61</div><div>标签</div></a></div></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-website"></i> 网站资讯</div><div class="layui-card-body"><div class="webInfo-item"><div class="title">本站文章字数合计</div><div class="content">243.7k</div></div><div class="webInfo-item"><div class="title">本站Hexo版本</div><div class="content">6.1.0</div></div><div class="webInfo-item"><div class="title">本站Node版本</div><div class="content">16.14.2</div></div><div class="webInfo-item"><div class="title">本站已运行时间</div><div class="content"><span id="runDays" data-since-date="2020-12-24"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span>天</div></div><div class="webInfo-item"><div class="title">最后更新时间</div><div class="content" id="lastUpdate" data-last-update="2024-09-17 22:37:24"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-time"></i> 最新文章</div><div class="layui-card-body"><ul><li><a href="/posts/81efbd4e/">1.Python面向对象笔记</a></li><li><a href="/posts/3d8035a5/">2.Python基础笔记</a></li><li><a href="/posts/8898569d/">3.基于nodejs的http-server搭建静态资源服务</a></li><li><a href="/posts/9183fda2/">4.springboot整合websocket</a></li><li><a href="/posts/134dc9cc/">5.jquery封装echart插件</a></li></ul></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-template-1"></i> 文章分类</div><div class="layui-card-body left-a-color"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../categories/docker/">docker</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/java/">java</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/python/">python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/vue/">vue</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/web%E5%89%8D%E7%AB%AF/">web前端</a><span class="category-list-count">31</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/">公众号和小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/">其它技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li></ul></div></div><div style="height:calc(100% - 60px - 60px);width:267px" id="toc-area" class="layui-card ahover"><div class="layui-card-header"><i class="layui-icon layui-icon-align-center"></i> 本文目录</div><div id="tocMain" class="layui-card-body" style="overflow:auto;height:calc(100% - 60px - 60px)"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#dir-%E5%87%BD%E6%95%B0"><span class="toc-text">dir()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-text">定义类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self%E5%8F%82%E6%95%B0"><span class="toc-text">self参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-text">内置方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">身份运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">私有属性和私有方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-text">定义方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">继承的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%A0%E9%80%92%E6%80%A7"><span class="toc-text">继承的传递性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">父类的私有属性和私有方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">多继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">类方法和静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-text">捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%8D%95%E8%8E%B7%E8%AF%AD%E6%B3%95"><span class="toc-text">简单的捕获语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%E6%8D%95%E6%8D%89"><span class="toc-text">错误类型捕捉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%AE%8C%E6%95%B4%E8%AF%AD%E6%B3%95"><span class="toc-text">异常捕获完整语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">异常的传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BAraise%E5%BC%82%E5%B8%B8"><span class="toc-text">抛出raise异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AF%BC%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">模块的两种导入方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#import%E5%AF%BC%E5%85%A5"><span class="toc-text">import导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#from%E2%80%A6import%E2%80%A6%E5%AF%BC%E5%85%A5"><span class="toc-text">from…import…导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F"><span class="toc-text">模块的搜索顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pip%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97"><span class="toc-text">pip安装第三方模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">文件的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0-x2F-%E6%96%B9%E6%B3%95"><span class="toc-text">操作文件的函数&#x2F;方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#read%E6%96%B9%E6%B3%95"><span class="toc-text">read方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88-%E4%BA%86%E8%A7%A3"><span class="toc-text">文件指针(了解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">打开文件的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E8%A1%8C%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">按行读取文件内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">案例-复制文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-x2F-%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C"><span class="toc-text">文件&#x2F;目录的常用管理操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eval%E5%87%BD%E6%95%B0"><span class="toc-text">eval函数</span></a></li></ol></div><div class="readprocess"><div><i class="layui-icon layui-icon-read"></i> 已阅读：<span id="progressTxt"></span>%</div><div class="layui-progress" lay-filter="demo"><div class="layui-progress-bar" lay-percent="10%"></div></div></div></div></div><div class="layui-col-md9 markdown-body" style="background:#fff;margin-top:10px"><div class="article-title"><p><span><i class="layui-icon layui-icon-template-1"></i> 分类: <span class="layui-badge layui-bg-cyan">python</span> </span>| <span><i class="layui-icon layui-icon-note"></i> 标签: <span class="layui-badge layui-bg-black">python</span></span></p><h1>Python面向对象笔记</h1><p><span><i class="layui-icon layui-icon-survey"></i> 发表于: 2024-09-17 22:32:33 </span>| <span><i class="layui-icon layui-icon-app"></i> 字数统计: 5.6k </span>| <span><i class="layui-icon layui-icon-log"></i> 阅读时长预计: 27分钟</span></p></div><div id="article"><h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h2><p>使用内置函数 dir传入标识符&#x2F;数据，可以查看对象内的 所有属性及方法</p><pre><code class="python">a = &quot;1234&quot;
print(dir(a))  # [&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;.......]
</code></pre><p>扩展</p><pre><code>__方法名__ 格式的方法是python提供的内置方法/属性

__new__ 创建对象时自动调用
__init__ 对象被初始化时自动调用
__del__ 对象被从内存中销毁前自动调用
__str__ 返回对象的描述信息
</code></pre><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><pre><code class="python">class 类名: 
  def 方法1(self,参数列表): 
    pass
  def 方法2(self,参数列表): 
    pass
</code></pre><p>方法和之前定义的函数一样，区别是第一个参数必须是self</p><blockquote><p>注意：类名要符合驼峰命名</p></blockquote><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><pre><code>变量 = 类名()
</code></pre><p>【例如】</p><pre><code class="python">class Cat:
    def eat(self):
        print(&#39;Eating&#39;)

    def drink(self):
        print(&#39;Drinking&#39;)
# 创建对象
a = Cat()
a.eat()
a.drink()
</code></pre><h3 id="self参数"><a href="#self参数" class="headerlink" title="self参数"></a>self参数</h3><p>由 哪一个对象 调用方法，方法内的 self 就是 哪一个对象的引用，类似Java类中的this关键字.</p><pre><code>调用方法时，不需要传递 self参数在方法内部
可以通过 self.访问对象的属性
也可以通过 self.调用其他的对象方法
</code></pre><p>【案例】</p><pre><code class="python">class Cat:
    def eat(self):
        print(&#39;%s Eating&#39; % self.name)

    def drink(self):
        print(&#39;%s Drinking&#39; % self.name)

    def sleep(self):
        print(&#39;Sleeping&#39;)
        self.eat() # 通过self调用其它方法

c = Cat()
c.name = &#39;tom&#39;
c.eat()
c.drink()
c.sleep()
</code></pre><h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><ul><li>在日常开发中，不推荐在 类的外部 给对象增加属性</li><li>如果在运行时，没有找到属性，程序会报错。对象应该包含有哪些属性，应该 封装在类的内部</li></ul><pre><code>当使用 类名()创建对象时，会自动 执行以下操作:
1.为对象在内存中 分配空间 --创建对象
2.为对象的属性 设置初始值 --初始化方法( init )
这个 初始化方法 就是__init__方法，__init__ 是对象的内置方法
</code></pre><p>初始化方法是专门用来定义一个类 具有哪些属性的方法!</p><p>【案例】</p><pre><code class="python">class Cat:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def eat(self):
        print(&#39;%s %s Eating&#39; % (self.name, self.age))

    def drink(self):
        print(&#39;%s Drinking&#39; % self.name)


a = Cat(&#39;Jack&#39;, 22)
a.eat()
b = Cat(&#39;lucy&#39;, 18)
b.drink()
</code></pre><h3 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h3><pre><code>__del__ 方法 对象被从内存中销毁前，会被 自动 调用 (了解)
__str__ 方法 返回对象的描述信息，print 函数输出使用 (类似Java的toString方法)
</code></pre><p>【案例】</p><pre><code class="python">class Cat:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return &quot;我是猫咪【%s】&quot; % self.name

a = Cat(&quot;汤姆&quot;) # a是一个全局变量
print(a)
</code></pre><blockquote><p>在定义属性时，如果 不知道设置什么初始值，可以设置为 None</p><p>在 封装的 方法内部，还可以让 自己的 使用其他类创建的对象属性 调用已经 封装好的方法</p></blockquote><h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>身份运算符用于 比较 两个对象的 内存地址 是否一致 –是否是对同一个对象的引用。</p><p>在Python 中针对None比较时，建议使用is判断</p><pre><code>is 是判断两个标识符是不是引用同一个对象 eg: x is y,类似 id(x)== id(y)
is not 是判断两个标识符是不是引用不同对象 eg: x is not y, 类似 id(a) != id(b)
</code></pre><ul><li>is和&#x3D;&#x3D;的区别</li></ul><p>is 用于判断 两个变量 引用对象是否为同一个</p><p>&#x3D;&#x3D; 用于判断 引用变量的值 是否相等</p><pre><code class="python">arr1 = [1, 2, 3]
arr2 = [1, 2, 3]

print(arr1 is arr2) # False
print(arr1 == arr2) # True
</code></pre><h3 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到<br>私有属性 就是 对象 不希望公开的 属性<br>私有方法 就是 对象 不希望公开的 方法</p><h4 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h4><p>在 属性名或者方法名前 增加 两个下划线，定义的就是 私有 属性或方法</p><pre><code class="python">class Cat:
    def __init__(self,name,age):
        self.name = name
        self.__age = age
        self.__secret()
    def print_age(self):
        print(self.__age)

    def __secret(self):
        print(&quot;secret&quot;)

a = Cat(&quot;tom&quot;,18)
# a.__secret() # error
# print(a.__age) # error
a.print_age()
</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象三大特性</p><pre><code>封装 根据 职贵 将 属性 和 方法 封装 到一个抽象的 类中
继承 实现代码的重用，相同的代码不需要重复的编写
多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度
</code></pre><p>继承的概念:子类 拥有 父类 的所有 方法 和 属性</p><p><img src="/posts/81efbd4e/image-20240916104417068.png" alt="image-20240916104417068"></p><h4 id="继承的语法"><a href="#继承的语法" class="headerlink" title="继承的语法"></a>继承的语法</h4><pre><code class="python">class 类名(父类名): 
  pass
</code></pre><ul><li><p>子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发</p></li><li><p>子类 中 根据 职责，封装 子类特有的 属性和方法</p></li></ul><p>子类 &#x3D; 派生类 ，父类 &#x3D; 基类</p><h4 id="继承的传递性"><a href="#继承的传递性" class="headerlink" title="继承的传递性"></a>继承的传递性</h4><p>C类从 B类继承，B类又从A类继承。那么C类就具有 B类和 A类的所有属性和方法</p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>子类 拥有 父类 的所有 方法 和 属性<br>子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发</p><p><strong>应用场景</strong></p><p>当 父类 的方法实现不能满足子类需求时，可以对方法进行 重写(override)</p><pre><code>重写父类方法有两种情况:
1)覆盖父类的方法
如果在开发中，父类的方法实现 和 子类的方法实现，完全不同就可以使用 覆盖 的方式，在子类中 重新编写 父类的方法实现
具体的实现方式，就相当于在 子类中 定义了一个和【父类同名的方法】并且实现重写之后，在运行时，只会调用 子类中重写的方法，而不再会调用 父类封装的方法

2)对父类方法进行扩展
如果在开发中，子类的方法实现 中 包含 父类的方法实现。父类原本封装的方法实现 是 子类方法的一部分就可以使用 扩展 的方式
1.在子类中重写父类的方法
2.在需要的位置使用 super()父类方法 来调用父类方法的执行
3.代码其他的位置针对子类的需求，编写 子类特有的代码实现
</code></pre><h4 id="父类的私有属性和私有方法"><a href="#父类的私有属性和私有方法" class="headerlink" title="父类的私有属性和私有方法"></a>父类的私有属性和私有方法</h4><pre><code>a.子类对象 不能 在自己的方法内部，直接 访问 父类的 私有属性 或 私有方法
b.子类对象 可以通过 父类 的 公有方法 间接 访问到 私有属性 或 私有方法

私有属性、方法 是对象的隐私，不对外公开，外界以及 子类 都不能直接访问
私有属性、方法 通常用于做一些内部的事情
</code></pre><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><pre><code>子类 可以拥有 多个父类，并且具有 所有父类 的 属性 和 方法。
例如:孩子 会继承自己 父亲 和 母亲 的 特性
</code></pre><p>语法</p><pre><code class="python">class 子类名(父类名1,父类名2...)
  pass
</code></pre><p>注意：如果父类之间 存在 同名的属性或者方法，应该尽量避免 使用多继承</p><p><img src="/posts/81efbd4e/image-20240916143441100.png" alt="image-20240916143441100"></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre><code>面向对象三大特性
a. 封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类中
   定义类的准则
b.继承 实现代码的重用，相同的代码不需要重复的编写
   设计类的技巧
   子类针对自己特有的需求，编写特定的代码
c.多态 不同的 子类对象 调用相同的 父类方法，产生不同的执行结果
  多态 可以 增加代码的灵活度
  以 继承 和 重写父类方法 为前提
  是调用方法的技巧，不会影响到类的内部设计
</code></pre><p>术语</p><pre><code>a. 创建出来的 对象 叫做 类 的 实例
b. 创建对象的 动作 叫做 实例化
c. 对象的属性 叫做 实例属性
d. 对象调用的方法 叫做 实例方法

在程序执行时:
1).对象各自拥有自己的 实例属性
2).调用对象方法，可以通过  self. 访问自己的属性和调用自己的方法

结论
1）每一个对象 都有自己 独立的内存空间，保存各自不同的属性
2）多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用传递到方法内部
</code></pre><h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>类是一个特殊的对象</p><pre><code>在程序运行时，类 同样 会被加载到内存
在Python 中，类是一个特殊的对象--类对象
在程序运行时，类对象 在内存中 只有一份，使用 一个类 可以创建出 很多个对象实例
除了封装 实例 的 属性 和 方法外，【类对象】 还可以拥有自己的 【属性】 和 【方法】

通过 类名. 的方式可以访问类的属性或者调用类的方法
</code></pre><p><img src="/posts/81efbd4e/image-20240916153445680.png" alt="image-20240916153445680"></p><p>【案例】</p><pre><code class="python">class Tool:
    # 使用赋值语句，定义类属性，记录创建工具对象的总数
    count = 0

    def __init__(self, name):
        self.name = name
        Tool.count += 1

tool1 = Tool(&quot;111&quot;)
tool2 = Tool(&quot;222&quot;)
tool3 = Tool(&quot;333&quot;)
print(Tool.count)
</code></pre><p><img src="/posts/81efbd4e/image-20240916154058358.png" alt="image-20240916154058358"></p><h3 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h3><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><pre><code>a.类属性 就是针对 类对象 定义的属性
使用 赋值语句 在 class 关键字下方可以定义 类属性
类属性 用于记录 与这个类相关 的特征
b.类方法 就是针对 类对象 定义的方法
在 类方法 内部可以直接访问 类属性 或者调用其他的 类方法
</code></pre><p>语法</p><pre><code class="python">@classmethod
def 类方法名(cls): 
    pass

a.类方法需要用 修饰器 @classmethod 来标识，告诉解释器这是一个类方法
b.类方法的 第一个参数 应该是 cls
    由 哪一个类 调用的方法，方法内的 cls 就是 哪一个类的引用
    这个参数和 实例方法 的第一个参数是self 类似
    使用其他名称也可以，不过习惯使用cls
c.通过 类名.调用 类方法，调用方法时，不需要传递cls 参数
d.在方法内部 通过 cls.访问类的属性或通过 cls.调用其他的类方法
</code></pre><p>【案例】</p><pre><code class="python">class Tool:
    # 使用赋值语句，定义类属性，记录创建工具对象的总数
    count = 0

    @classmethod
    def show_tool_count(cls):
        print(&quot;总数 %s&quot; % cls.count)

    def __init__(self, name):
        self.name = name
        Tool.count += 1

tool1 = Tool(&quot;111&quot;)
tool2 = Tool(&quot;222&quot;)
tool3 = Tool(&quot;333&quot;)

Tool.show_tool_count() # 总数 3
</code></pre><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><pre><code>在开发时，如果需要在 类 中封装一个方法，这个方法:
    既 不需要 访问 实例属性 或者调用 实例方法。
    也 不需要 访问 类属性 或者调用 类方法
那么就可以定义成一个静态方法
</code></pre><p>语法</p><pre><code class="python">@staticmethod
def 静态方法名(): 
    pass

静态方法 需要用 修饰器 @staticmethod 来标识
通过 类名. 调用静态方法
</code></pre><p>【案例】</p><pre><code class="python">class Tool:

    @staticmethod
    def sum(a,b):
        return a + b

print(Tool.sum(1,2))
</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><pre><code>实例方法： 可以访问【实例属性】并且可以通过 类名. 访问【类属性】
类方法： 只能访问【类属性】
静态方法： 不能访问类属性和实例属性
</code></pre><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="简单的捕获语法"><a href="#简单的捕获语法" class="headerlink" title="简单的捕获语法"></a>简单的捕获语法</h3><pre><code class="python">try: 
    尝试执行的代码
except: 
    出现错误的处理
</code></pre><p>【案例】</p><pre><code class="python">try:
    num = int(input(&quot;Enter a number: &quot;))
except:
    print(&quot;请输入正确的数字&quot;)
</code></pre><h3 id="错误类型捕捉"><a href="#错误类型捕捉" class="headerlink" title="错误类型捕捉"></a>错误类型捕捉</h3><p>在程序执行时，可能会遇到 不同类型的异常，并且需要 针对不同类型的异常，做出不同的响应，这个时候，就需要捕获错误类型了</p><p>语法</p><pre><code class="python">try: 
    #尝试执行的代码
    pass 
except 错误类型1： 
    #针对错误类型1执行的代码
    pass
except 错误类型2： 
    #针对错误类型2执行的代码
    pass
except Exception as result:  # 针对未知错误执行的代码
    print(&quot;未知错误 %s&quot; % result)
</code></pre><h3 id="异常捕获完整语法"><a href="#异常捕获完整语法" class="headerlink" title="异常捕获完整语法"></a>异常捕获完整语法</h3><pre><code class="python">try: 
    #尝试执行的代码
    pass 
except 错误类型1： 
    print(&quot;针对错误类型1执行的代码&quot;)
except 错误类型2： 
    print(&quot;针对错误类型2执行的代码&quot;)
except Exception as result:
    print(&quot;未知错误 %s&quot; % result)
else: 
    print(&quot;没有异常才会执行的代码&quot;)
finally: 
    print(&quot;无论是否异常都会执行的代码&quot;)
</code></pre><h3 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h3><pre><code>当 函数/方法 执行 出现异常，会 将异常传递 给 函数/方法 的 【调用一方】
如果 传递到主程序，仍然 没有异常处理，程序才会被终止

在开发中，可以在主函数中增加 异常捕获
而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 异常捕获 中
这样就不需要在代码中，增加大量的 异常捕获，能够保证代码的整洁
</code></pre><p>【案例】</p><pre><code class="python">def demo1():
    return int(input(&quot;请输入一个整数&quot;))

def demo2(): 
    return demo1()

try:
    print(demo2())
except ValueError: 
    print(&quot;请输入正确的整数&quot;)
except Exception as result: 
    print(&quot;未知错误 %s&quot; % result)
</code></pre><h3 id="抛出raise异常"><a href="#抛出raise异常" class="headerlink" title="抛出raise异常"></a>抛出raise异常</h3><pre><code>在开发中，除了 代码执行出错Python 解释器会 抛出 异常之外
还可以根据 应用程序 特有的业务需求 主动抛出异常

Python 中提供了一个Exception 异常类在开发时，如果满足 特定业务需求时，希望 抛出异常，可以:
a.创建一个 Exception 的 对象
b.使用 raise 关键字 抛出 异常对象
</code></pre><p>【案例】</p><pre><code class="python">def demo1():
    a = int(input(&quot;请输入一个整数&quot;))
    if a &lt; 10:
        ex = Exception(&quot;请输入大于10的数字&quot;)
        raise ex # 主动抛出异常
    return a

try:
    print(demo1())
except ValueError:
    print(&quot;请输入正确的整数&quot;)
except Exception as result:
    print(&quot;未知错误 %s&quot; % result)
</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><pre><code>每一个以扩展名py结尾的Python 源代码文件都是一个 模块
模块名 同样也是一个 标识符，需要符合标识符的命名规则
在模块中定义的 全局变量、函数、类都是提供给外界直接使用的 工具
模块 就好比是 工具包，要想使用这个工具包中的工具，就需要先 导入 这个模块
</code></pre><h3 id="模块的两种导入方式"><a href="#模块的两种导入方式" class="headerlink" title="模块的两种导入方式"></a>模块的两种导入方式</h3><h4 id="import导入"><a href="#import导入" class="headerlink" title="import导入"></a>import导入</h4><pre><code class="python">import 模块名1,模块名2
</code></pre><p>每个导入需要独占一行</p><pre><code class="python">import 模块1
import 模块2
</code></pre><p>通过 <code>模块名.</code> 使用 模块提供的工具–全局变量、函数、类</p><p>可以使用as指定模块的别名，别名要符合大驼峰命名法</p><pre><code class="python">import 模块名1 as 模块别名
</code></pre><h4 id="from…import…导入"><a href="#from…import…导入" class="headerlink" title="from…import…导入"></a>from…import…导入</h4><pre><code>import 模块名  是 一次性 把模块中 所有工具全部导入，并且通过 模块名/别名 访问
如果希望 从某一个模块 中，导入部分 工具，就可以使用 from...import 的方式

导入之后,不需要 通过 模块名. 来访问。可以直接使用 模块提供的工具 --全局变量、函数、类
</code></pre><blockquote><p>如果 两个模块，存在 同名的函数，那么 后导入模块的函数，会 覆盖掉先导入的函数</p><p>可以使用as关键字给其中一个函数起一个别名</p></blockquote><h4 id="模块的搜索顺序"><a href="#模块的搜索顺序" class="headerlink" title="模块的搜索顺序"></a>模块的搜索顺序</h4><p>搜索 当前目录 指定模块名的文件，如果有就直接导入<br>如果没有，再搜索 系统目录</p><pre><code>每一个模块都有一个内置属性__file__ 可以 查看模块 的 完整路径

__name__属性可以做到，测试模块的代码 只在测试情况下被运行，而在 被导入时不会被执行!
__name__记录着一个【字符串】
    如果是被其他文件导入的， __name__ 就是 模块名；
    如果是当前执行的程序__name__ 是 __main__
</code></pre><p>【案例】</p><pre><code class="python">def say_hello():
    print(&quot;Hello World&quot;)

if __name__ == &quot;__main__&quot;:
    say_hello()
</code></pre><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><pre><code>包 是一个 包含多个模块 的 特殊目录
目录下有一个 特殊的文件 __init__.py 
包名的 命名方式 和变量名一致， 小写字母 + _

使用 import 包名可以一次性导入 包 中 所有的模块
</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code>a.新建一个 hm_message 的包(就是一个文件夹)
b.在hm_message目录下，新建两个文件send_message.py和receive_message.py
c.在 send_message.py 文件中定义一个 send 函数
d.在 receive_message.py 文件中定义一个receive 函数
e.在 hm_message目录下新建一个 __init__.py 文件
f.在外部直接导入 hm_message 的包
</code></pre><p>【send_message.py】</p><pre><code class="python">def send():
    print(&quot;发送消息&quot;)
</code></pre><p>【receive_message.py】</p><pre><code class="python">def receive():
    print(&quot;接受消息&quot;)
</code></pre><p>【hm_message包下的init文件】</p><pre><code class="python">__init__.py 文件

from . import receive_message
from . import  send_message
</code></pre><p>【test_pack.py】</p><pre><code class="python">import hm_message

hm_message.send_message.send()
hm_message.receive_message.receive()
</code></pre><h3 id="pip安装第三方模块"><a href="#pip安装第三方模块" class="headerlink" title="pip安装第三方模块"></a>pip安装第三方模块</h3><pre><code>第三方模块 通常是指由 知名的第三方团队 开发的 并且被 程序员广泛使用 的 Python 包/模块。例如 pygame 就是一套非常成熟的 游戏开发模块

pip 是一个现代的，通用的Python 包管理工具，提供了对 Python 包的查找、下载、安装、卸载等功能
</code></pre><p>安装和卸载命令如下</p><pre><code># python2
pip install pygame
pip uninstall pygame

# python3
pip3 install pygame
pip3 unstall pygame
</code></pre><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><pre><code>在 计算机 中要操作文件的套路非常固定，一共包含三个步骤
a.打开文件
b.读、写文件
  读 将文件内容读入内存
  写 将内存内容写入文件
c.关闭文件
</code></pre><h3 id="操作文件的函数-x2F-方法"><a href="#操作文件的函数-x2F-方法" class="headerlink" title="操作文件的函数&#x2F;方法"></a>操作文件的函数&#x2F;方法</h3><pre><code>open方法：打开文件，并且返回文件操作对象
read方法：将文件内容读取到内存
write方法：将指定内容写入文件
close方法：关闭文件

open函数负责打开文件，并且返回文件对象
read/write/close三个方法都需要通过文件对象来调用
</code></pre><h4 id="read方法"><a href="#read方法" class="headerlink" title="read方法"></a>read方法</h4><pre><code>open函数的第一个参数是要打开的文件名(文件名区分大小写)
    如果文件 存在，返回 文件操作对象
    如果文件 不存在，会 抛出异常。
read 方法可以一次性 读入 并 返回 文件的 所有内容 
close方法负责 关闭文件

ps: 如果 忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问
注意:方法执行后，会把 文件指针 移动到 文件的【末尾】
</code></pre><p>【案例】</p><pre><code class="python"># 1.打开文件
file = open(&quot;README&quot;)

# 2.读取文件
text = file.read()
print(text)

# 3.关闭文件
file.close()
</code></pre><blockquote><p>提示：在开发中，通常会先编写 打开 和 关闭 的代码，再编写中间针对文件的 读&#x2F;写 操作!</p></blockquote><h4 id="文件指针-了解"><a href="#文件指针-了解" class="headerlink" title="文件指针(了解)"></a>文件指针(了解)</h4><pre><code>文件指针 标记 从哪个位置开始读取数据
第一次打开 文件时，通常 文件指针会指向文件的开始位置
当执行了 read 方法后，文件指针 会移动到 读取内容的末尾
    默认情况下会移动到 文件末尾
</code></pre><h4 id="打开文件的方式"><a href="#打开文件的方式" class="headerlink" title="打开文件的方式"></a>打开文件的方式</h4><p>open函数默认以 只读方式 打开文件，并且返回文件对象</p><p>语法：</p><pre><code class="python">f = open(&quot;文件名&quot;,访问方式)

访问方式
r: 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在抛出异常
w：以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件
a：以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入
r+：以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常
w+：以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件
a+：以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入

提示：频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以 只读、只写 的方式来操作文件
</code></pre><h4 id="按行读取文件内容"><a href="#按行读取文件内容" class="headerlink" title="按行读取文件内容"></a>按行读取文件内容</h4><pre><code>read 方法默认会把文件的 所有内容 一次性读取到内存
如果文件太大，对内存的占用会非常严重
</code></pre><p><strong>readline方法</strong></p><pre><code>readline 方法可以一次读取一行内容
方法执行后，会把 文件指针 移动到下一行，准备再次读取
</code></pre><p>【案例】</p><pre><code class="python"># 打开文件
file = open(&quot;README&quot;)
while True:
    # 读取一行内容
    line = file.readline()

    # 没有读到内容则终止循环
    if not line:
        break

    # 每读取一行的末尾以及有了一个 &#39;\n&#39;
    print(line, end=&quot;&quot;)
# 关闭文件
file.close()
</code></pre><h4 id="案例-复制文件"><a href="#案例-复制文件" class="headerlink" title="案例-复制文件"></a>案例-复制文件</h4><ul><li>小文件复制</li></ul><pre><code class="python"># 打开文件
file_read = open(&quot;README&quot;)
file_write = open(&quot;README[copy]&quot;, &quot;w&quot;)

txt = file_read.read()
file_write.write(txt)

# 关闭文件
file_write.close()
file_read.close()
</code></pre><ul><li>大文件复制</li></ul><pre><code class="python"># 打开文件
file_read = open(&quot;README&quot;)
file_write = open(&quot;README[copy-big]&quot;, &quot;w&quot;)

while True:
    line = file_read.readline()
    if not line:
        break
    file_write.write(line)

# 关闭文件
file_write.close()
file_read.close()
</code></pre><h3 id="文件-x2F-目录的常用管理操作"><a href="#文件-x2F-目录的常用管理操作" class="headerlink" title="文件&#x2F;目录的常用管理操作"></a>文件&#x2F;目录的常用管理操作</h3><pre><code>在 终端/文件浏览器中，导入os模块 可以执行常规的 文件/目录 管理操作
例如:创建、重命名、删除、改变路径、查看目录内容
</code></pre><p>文件操作</p><pre><code>rename: 重命名文件 例如： os.rename(源文件名,目标文件名)
remove：删除文件 例如：os.remove(文件名)
</code></pre><p>目录操作</p><pre><code>listdir：目录列表 例如：os.listdir(目录名)
mkdir：创建目录 例如： os.mkdir(目录名)
rmdir：删除目录 例如：os.rmdir(目录名)
getcwd：获取当前目录 例如：os.getcwd()
chdir：修改当前目录 例如： os.chdir(目标目录)
path.isdir：判断是否是文件 例如：os.path.isdir(文件路径)

提示:文件或者目录操作都支持 相对路径 和绝对路径
</code></pre><h2 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h2><p>将字符串 当成 有效的表达式 来求值 并 返回计算结果.</p><pre><code class="python">print(eval(&quot;1+1&quot;)) # 2
</code></pre><p>提示：不要滥用eval，不安全</p></div><div class="post-ending"><div class="end-txt">------ 本文结束，感谢您的阅读 ------</div><blockquote class="layui-elem-quote layui-quote-nm" style="padding:10px"><div><span class="title">本文作者: </span>贺刘芳</div><div><span class="title">本文链接: </span><a target="_blank" href="https://heliufang.github.io/posts/81efbd4e/">https://heliufang.github.io/posts/81efbd4e/</a></div><div><span class="title">版权声明: </span>本文采用知识共享署名-非商业性使用-禁止演绎 2.5 中国大陆许可协议进行许可。</div></blockquote><div id="vcomments"></div></div></div></div></div><ul id="toTopBtn" class="layui-fixbar" style="right:-70px" title="置顶"><div><a href="javascript:void(0)" class="icon iconfont icon-huojian"></a></div></ul><div class="qy-footer"><div class="font-Area"><p>访客数 <span style="color:red" id="busuanzi_value_site_uv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 人次 | 访问量 <span style="color:red" id="busuanzi_value_site_pv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 次 | 本站已运行 <span style="color:red" id="runDaysFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 天 | 本站文章字数合计 <span style="color:red">243.7k</span> | 最后更新于 <span style="color:red" id="lastUpdateFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span></p><p>由 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a> <span style="color:red" class="layui-icon layui-icon-find-fill layui-anim layui-anim-rotate layui-anim-loop"></span> 强力驱动 v6.1.0</p><p>Copyright © 2020 ~<span id="currentYear">2022</span> <span class="layui-icon layui-icon-heart-fill footer-heart"></span> HeLiuFang</p></div></div></body><script src="../../js/jquery.min.js"></script><script src="../../js/moment.min.js"></script><script src="../../layui/layui.js"></script><script src="../../lib/prism/prism.js"></script><script>$("#searchBtn").click(function(){$("#searchShade").show(),$("#searchLayer").addClass("layui-anim layui-anim-scaleSpring")}),$("#closeBtn").click(function(){$("#searchShade").hide()});var searchFunc=function(e,o,a){$.ajax({url:e,dataType:"json",success:function(e){var t=document.getElementById(o),n=document.getElementById(a);t.addEventListener("input",function(){var t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(e){var n=!0,o=e.title.trim().toLowerCase(),e=e.url;""!=o&&a.forEach(function(e,t){o.indexOf(e)<0?n=!1:o=o.replace(new RegExp(e,"g"),'<span style="color:red">'+e+"</span>")}),n&&(t=t+"<li><a href='"+e+"' class='search-result-title'>"+o+"</a></li>")}),t+="</ul>",n.innerHTML=t)})}})};function DynamicLine(){function e(e,t,n){return e.getAttribute(t)||n}function t(e){return document.getElementsByTagName(e)}function n(){s=a.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,r=a.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function c(){var n,o,a,i,l;m.clearRect(0,0,s,r),y.forEach(function(e,t){for(e.x+=e.xa,e.y+=e.ya,e.xa*=e.x>s||e.x<0?-1:1,e.ya*=e.y>r||e.y<0?-1:1,m.fillRect(e.x-.5,e.y-.5,1,1),o=t+1;o<d.length;o++)null!==(n=d[o]).x&&null!==n.y&&(a=e.x-n.x,i=e.y-n.y,(l=a*a+i*i)<n.max)&&(n===h&&l>=n.max/2&&(e.x-=.03*a,e.y-=.03*i),a=(n.max-l)/n.max,m.beginPath(),m.lineWidth=a/2,m.strokeStyle="rgba("+u.c+","+(.2+a)+")",m.moveTo(e.x,e.y),m.lineTo(n.x,n.y),m.stroke())}),w(c)}var s,r,d,o,a=document.createElement("canvas"),u=(i=(o=t("script")).length,o=o[i-1],{l:i,z:e(o,"zIndex",-1),o:e(o,"opacity",.5),c:e(o,"color","0,0,50"),n:e(o,"count",99)}),i="c_n"+u.l,m=a.getContext("2d"),w=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(e,1e3/45)},l=Math.random,h={x:null,y:null,max:2e4};a.id=i,a.style.cssText="position:fixed;top:0;left:0;z-index:"+u.z+";opacity:"+u.o,t("body")[0].appendChild(a),n(),window.onresize=n,window.onmousemove=function(e){e=e||window.event,h.x=e.clientX,h.y=e.clientY},window.onmouseout=function(){h.x=null,h.y=null};for(var y=[],x=0;x<u.n;x++){var f=l()*s,p=l()*r,$=2*l()-1,v=2*l()-1;y.push({x:f,y:p,xa:$,ya:v,max:6e3})}d=y.concat([h]),setTimeout(function(){c()},100)}searchFunc("/search.json","searchTxt","searchResult"),DynamicLine(),document.querySelector("#currentYear").innerText=(new Date).getFullYear();var days=moment().diff($("#runDays")[0].dataset.sinceDate,"days"),lastUpdate=($("#runDays").html(days),$("#runDaysFooter").html(days),moment($("#lastUpdate")[0].dataset.lastUpdate,"YYYY-MM-DD HH:mm:ss").locale("zh-CN").fromNow());$("#lastUpdate").html(lastUpdate),$("#lastUpdateFooter").html(lastUpdate),$("#toTopBtn").click(function(){var e=$(window).scrollTop(),t=parseInt(e/60),n=setInterval(function(){$(window).scrollTop($(window).scrollTop()-t),0===$(window).scrollTop()&&clearInterval(n)},1)}),$.event.add(window,"scroll",function(){$("#toTopBtn").css("transform",0<$(window).scrollTop()?"translateX(-85px)":"translateX(85px)"),$("#toTopBtn").css("transition","all 0.5s")}),$("#loadingBox").hide(),$("body").css("overflow","auto")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var element=null;layui.use(["element"],function(){element=layui.element}),$(function(){var e=$("#toc-area"),t=$(e).offset().top;$.event.add(window,"scroll",function(){var o=$(".markdown-body").height(),o=(($(window).scrollTop()+t)/o*100).toFixed(2);element.progress("demo",(o=0==(o=99<o?100:o)?0:o)+"%"),$("#progressTxt").text(o),console.log("percent",o),$(e).css("position",$(window).scrollTop()>t?"fixed":"static"),$(e).css("top",$(window).scrollTop()>t?"60px":""),$("#tocMain").scrollTop($("#tocMain .toc").height()*o*.01)}),$("pre code").each(function(){var o=$(this).attr("class");o="language-"+(null==o||""==o||null==o?"plaintext":o),$(this).attr("class",o)}),$("pre").prepend('<div class="copy-to-clipboard-button"></div>')})</script></html>