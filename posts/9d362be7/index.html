<!DOCTYPE html><html lang="zh-CN"><head><title>贺刘芳的搬砖日记</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="stylesheet" href="../../layui/css/layui.css"><link rel="stylesheet" href="../../css/common.css"><link rel="stylesheet" href="../../css/post.css"><link rel="stylesheet" href="../../lib/prism/prism.css"><link rel="shortcut icon" href="../../img/favicon.ico"><link rel="stylesheet" href="../../lib/iconfont/iconfont.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="贺刘芳的搬砖日记" type="application/atom+xml"></head><body style="overflow:hidden" data-prismjs-copy="复制" data-prismjs-copy-success="复制成功!"><div class="qy-nav"><ul class="layui-nav" lay-filter="" lay-bar="disabled" lay-unselect><li class="hide-xs layui-nav-item" id="searchBtn" style="float:right"><a class="searchBtn" href="javascript:void(0);"><i class="layui-icon layui-icon-search"></i> 搜索</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://github.com/heliufang"><i class="icon iconfont icon-github"></i> github</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://gitee.com/heliufang"><i class="icon iconfont icon-gitee"></i> gitee</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf"><i class="icon iconfont icon-cnblogs"></i> 博客园</a></li><li class="layui-nav-item"><a class="title" href="/" style="padding:0"><i class="layui-anim layui-anim-rotate layui-anim-loop layui-icon layui-icon-star-fill"></i> 贺刘芳的笔记本</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/about"><i class="layui-icon layui-icon-friends"></i> 关于</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/archives"><i class="layui-icon layui-icon-date"></i> 归档</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/tags"><i class="layui-icon layui-icon-note"></i> 标签</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/categories"><i class="layui-icon layui-icon-template-1"></i> 分类</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/"><i class="layui-icon layui-icon-home"></i> 首页</a></li><li class="layui-nav-item hide-sm hide-md hide-lg" style="float:right"><a href="javascript:;">菜单</a><dl class="layui-nav-child"><dd><a href="/">首页</a></dd><dd><a href="/archives">归档</a></dd><dd><a href="/tags">标签</a></dd><dd><a href="/categories">分类</a></dd><dd><a href="/about">关于</a></dd><dd><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github">github</a></dd><dd><a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee">gitee</a></dd><dd><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园">博客园</a></dd><dd><a href="javascript:void(0)" onclick='document.querySelector("#searchShade").style.display="block"'>搜索</a></dd></dl></li></ul><div id="loadingBox" class="loadingBox"><img src="/img/loading.gif"></div></div><div id="searchShade" class="searchShade"><div id="searchLayer"><div id="closeBtn" class="close"><i class="layui-icon layui-icon-close"></i></div><input id="searchTxt" type="text" placeholder="搜索文章(只支持文章标题关键字)" autofocus><div id="searchResult"></div></div></div><div class="layui-container center" id="top"><div class="layui-row layui-col-space20"><div class="layui-col-md3 hide-xs hide-sm"><div class="layui-card"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-speaker"></i> 公告</div><div class="layui-card-body"><div class="userinfo"><img src="/head.png"><div class="name">淡泊明志，宁静致远</div><div class="icons"><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github"><i class="icon iconfont icon-github"></i></a> <a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee"><i class="icon iconfont icon-gitee"></i></a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园"><i class="icon iconfont icon-cnblogs"></i></a></div><div class="other"><div class="item"><a class="title" style="color:#ff5722" href="/"><p class="num">40</p><div>文章</div></a></div><div class="item"><a style="color:#009688" href="/categories"><div class="num">7</div><div class="title">分类</div></a></div><div class="item"><a class="title" style="color:#01aaed" href="/tags"><div class="num">44</div><div>标签</div></a></div></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-website"></i> 网站资讯</div><div class="layui-card-body"><div class="webInfo-item"><div class="title">已运行时间</div><div class="content"><span id="runDays" data-since-date="2020-12-24"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span>天</div></div><div class="webInfo-item"><div class="title">本站文章字数合计</div><div class="content">200.8k</div></div><div class="webInfo-item"><div class="title">最后更新时间</div><div class="content" id="lastUpdate" data-last-update="2023-01-08 12:54:41"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-time"></i> 最新文章</div><div class="layui-card-body"><ul><li><a href="/posts/27fcdfc0/">1.react笔记</a></li><li><a href="/posts/304cd95d/">2.vue3.2新特性笔记</a></li><li><a href="/posts/f2f1536e/">3.node笔记</a></li><li><a href="/posts/73c9868e/">4.vue3笔记</a></li><li><a href="/posts/9d362be7/">5.TypeScript笔记</a></li></ul></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-template-1"></i> 文章分类</div><div class="layui-card-body left-a-color"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../categories/java/">java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/vue/">vue</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/web%E5%89%8D%E7%AB%AF/">web前端</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/">公众号和小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/">其它技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li></ul></div></div><div style="height:calc(100% - 60px - 60px);width:267px" id="toc-area" class="layui-card ahover"><div class="layui-card-header"><i class="layui-icon layui-icon-align-center"></i> 本文目录</div><div id="tocMain" class="layui-card-body" style="overflow:auto;height:calc(100% - 60px - 60px)"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-text">编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-text">编译选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-text">类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">自动类型判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#number"><span class="toc-text">number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boolean"><span class="toc-text">boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-text">string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any"><span class="toc-text">any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unknown"><span class="toc-text">unknown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void"><span class="toc-text">void</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never"><span class="toc-text">never</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object%EF%BC%88%E6%B2%A1%E5%95%A5%E7%94%A8%EF%BC%89"><span class="toc-text">object（没啥用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array"><span class="toc-text">array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tuple%EF%BC%88%E5%85%83%E7%A5%96%EF%BC%89"><span class="toc-text">tuple（元祖）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum-%E6%9E%9A%E4%B8%BE"><span class="toc-text">enum(枚举)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">类型断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#public"><span class="toc-text">public</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protected"><span class="toc-text">protected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#private"><span class="toc-text">private</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%AD%98%E5%8F%96%E5%99%A8"><span class="toc-text">(*)属性存取器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-text">静态属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li></ol></li></ol></div><div class="readprocess"><div><i class="layui-icon layui-icon-read"></i> 已阅读：<span id="progressTxt"></span>%</div><div class="layui-progress" lay-filter="demo"><div class="layui-progress-bar" lay-percent="10%"></div></div></div></div></div><div class="layui-col-md9 markdown-body" style="background:#fff;margin-top:10px"><div class="article-title"><h1>TypeScript笔记</h1><p><i class="layui-icon layui-icon-survey"></i>发表于:2022-07-09 | <i class="layui-icon layui-icon-app"></i>字数:3.6k</p></div><div id="article"><p>B站教学视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Xy4y1v7S2">尚硅谷TypeScript教程（李立超老师TS新课）</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>TypeScript是JavaScript的超集。</li><li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li><li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li><li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。</li><li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局ts的命令</p><pre><code>npm i -g typescript
</code></pre><p>装好之后输入下面指令即可看到版本号，表示安装成功</p><pre><code>tsc -v
</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>新建xxx.ts文件,ts文件里面随便写点js代码</p><ul><li>进入命令行</li><li>进入ts文件所在目录</li><li>执行初始化配置文件的命令： tsc –init</li><li>执行命令：tsc xxx.ts</li></ul><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>略。要用的时候再去查询</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><table><thead><tr><th align="center">类型</th><th align="center">例子</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">number</td><td align="center">1, -33, 2.5</td><td align="center">任意数字</td></tr><tr><td align="center">string</td><td align="center">‘hi’, “hi”, <code>hi</code></td><td align="center">任意字符串</td></tr><tr><td align="center">boolean</td><td align="center">true、false</td><td align="center">布尔值true或false</td></tr><tr><td align="center">字面量</td><td align="center">其本身</td><td align="center">限制变量的值就是该字面量的值</td></tr><tr><td align="center"><strong style="color:red">any</strong></td><td align="center">*</td><td align="center">任意类型</td></tr><tr><td align="center"><strong style="color:red">unknown</strong></td><td align="center">*</td><td align="center">类型安全的any</td></tr><tr><td align="center">void</td><td align="center">空值（undefined）</td><td align="center">没有值（或undefined）</td></tr><tr><td align="center"><strong style="color:red">never</strong></td><td align="center">没有值</td><td align="center">不能是任何值</td></tr><tr><td align="center">object</td><td align="center">{name:’孙悟空’}</td><td align="center">任意的JS对象</td></tr><tr><td align="center">array</td><td align="center">[1,2,3]</td><td align="center">任意JS数组</td></tr><tr><td align="center"><strong style="color:red">tuple（元祖）</strong></td><td align="center">[4,5]</td><td align="center">元素，TS新增类型，固定长度数组</td></tr><tr><td align="center"><strong style="color:red">enum</strong></td><td align="center">enum{A, B}</td><td align="center">枚举，TS中新增类型</td></tr></tbody></table><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><ul><li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p></li><li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p></li><li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p></li></ul><p>语法：</p><pre><code class="typescript">let 变量: 类型;

let 变量: 类型 = 值;

function fn(参数: 类型, 参数: 类型): 类型&#123;
    ...
&#125;
</code></pre><h3 id="自动类型判断"><a href="#自动类型判断" class="headerlink" title="自动类型判断"></a>自动类型判断</h3><ul><li>TS拥有自动的类型判断机制</li><li>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</li><li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li></ul><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><pre><code class="typescript">let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
let big: bigint = 100n; //es11
</code></pre><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><pre><code class="typescript">let isDone: boolean = false;
</code></pre><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><pre><code class="typescript">let color: string = &quot;blue&quot;;
color = &#39;red&#39;;

let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `my name is $&#123;fullName&#125;.I&#39;ll be $&#123;age + 1&#125; years old next month.`;
</code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p><pre><code class="typescript">let color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;
let num: 1 | 2 | 3 | 4 | 5;
</code></pre><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>任意类型(不安全),<strong style="color:red">会使ts的类型判断失效</strong></p><pre><code class="typescript">let d: any = 4;
d = &#39;hello&#39;;
d = true;

d.sayHello() //不会报错
</code></pre><h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p>任意类型(安全)</p><pre><code class="typescript">let notSure: unknown = 4;
notSure = &#39;hello&#39;;

//d.sayHello() //会报错
</code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>没有值（当时可以是undefined）</p><pre><code class="typescript">let unusable: void = undefined;
</code></pre><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>从不会出现的值，没有值，不能是任何值,永远不会有返回结果（返回“从不”的函数不能具有可访问的终结点）</p><pre><code class="typescript">let good: never;
// good = &#39;123&#39;; //error
// good = undefined; //error
// good = null; //error
 
function goodFun(): never &#123;
    // return &#39;123&#39;; //error
    // return;  //error
    // return undefined; //error
    // return null; //error
    // console.log(&#39;123&#39;); //error
    throw new Error(&#39;error&#39;); //只有这种不报错
&#125;
</code></pre><h3 id="object（没啥用）"><a href="#object（没啥用）" class="headerlink" title="object（没啥用）"></a>object（没啥用）</h3><pre><code class="typescript">let obj: object = &#123;&#125;;
</code></pre><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><pre><code class="typescript">let list: number[] = [1, 2, 3];
let list: Array&lt;number&gt; = [1, 2, 3]; //有点像java的泛型
</code></pre><h3 id="tuple（元祖）"><a href="#tuple（元祖）" class="headerlink" title="tuple（元祖）"></a>tuple（元祖）</h3><p>指定数组内部元素的类型和个数</p><pre><code class="typescript">let x: [string, number];
x = [&quot;hello&quot;, 10]; 
</code></pre><h3 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h3><pre><code class="typescript">// 不给默认值Red-0  Green-1 Blue-2
enum Color &#123;
  Red,
  Green,
  Blue,
&#125;
let c: Color = Color.Green;

// 给默认值Red-1  Green-2 Blue-3
enum Color &#123;
  Red = 1,
  Green,
  Blue,
&#125;
let c: Color = Color.Green;

// 给默认值Red-1  Green-2 Blue-4
enum Color &#123;
  Red = 1,
  Green = 2,
  Blue = 4,
&#125;
let c: Color = Color.Green;
</code></pre><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p><p>第一种： 使用as</p><pre><code class="typescript">let someValue: unknown = &quot;this is a string&quot;;
let strLength: number = (someValue as string).length;
</code></pre><p>第二种：类似java的强制类型转换</p><pre><code class="typescript">let someValue: unknown = &quot;this is a string&quot;;
let strLength: number = (&lt;string&gt;someValue).length;
</code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象是程序中一个非常重要的思想。简而言之就是程序之中所有的操作都需要通过对象来完成。</p><ul><li>举例来说：<ul><li>操作浏览器要使用window对象</li><li>操作网页要使用document对象</li><li>操作控制台要使用console对象</li></ul></li></ul><p>一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。</p><p>在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。</p><ul><li>定义类</li></ul><pre><code class="typescript">class 类名 &#123;
    属性名: 类型;
    
    constructor(参数: 类型)&#123;
        this.属性名 = 参数;
    &#125;

    方法名()&#123;
        ....
    &#125;
&#125;
</code></pre><ul><li>示例</li></ul><pre><code class="typescript">class Person&#123;
    name: string;
    age: number;

    constructor(name: string, age: number)&#123;
        this.name = name;
        this.age = age;
    &#125;

    sayHello()&#123;
        console.log(`大家好，我是$&#123;this.name&#125;`);
    &#125;
&#125;
</code></pre><ul><li>使用类</li></ul><pre><code class="typescript">const p = new Person(&#39;孙悟空&#39;, 18);
p.sayHello();
</code></pre><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p></li><li><p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</p></li><li><p>只读属性（readonly）：</p><ul><li>如果在声明属性时添加一个<strong style="color:red">readonly</strong>，则属性便成了<strong style="color:red">只读</strong>属性无法修改</li></ul></li><li><p>TS中属性具有三种修饰符：</p><ul><li>public（默认值），可以在类、子类和实例对象中修改</li><li>protected ，可以在类、子类中修改</li><li>private ，可以在类中修改</li></ul></li></ul><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><pre><code class="typescript">class Person&#123;
    public name: string; // 写或什么都不写,都是public
    public age: number;

    constructor(name: string, age: number)&#123;
        this.name = name; // 可以在类中修改
        this.age = age;
    &#125;

    sayHello()&#123;
        console.log(`大家好，我是$&#123;this.name&#125;`);
    &#125;
&#125;

class Employee extends Person&#123;
    constructor(name: string, age: number)&#123;
        super(name, age);
        this.name = name; //子类中可以修改
    &#125;
&#125;

const p = new Person(&#39;孙悟空&#39;, 18);
p.name = &#39;猪八戒&#39;;// 可以通过对象修改
</code></pre><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><pre><code class="typescript">class Person&#123;
    protected name: string;
    protected age: number;

    constructor(name: string, age: number)&#123;
        this.name = name; // 可以修改
        this.age = age;
    &#125;

    sayHello()&#123;
        console.log(`大家好，我是$&#123;this.name&#125;`);
    &#125;
&#125;

class Employee extends Person&#123;

    constructor(name: string, age: number)&#123;
        super(name, age);
        this.name = name; //子类中可以修改
    &#125;
&#125;

const p = new Person(&#39;孙悟空&#39;, 18);
p.name = &#39;猪八戒&#39;;// 不能修改
</code></pre><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><pre><code class="typescript">class Person&#123;
    private name: string;
    private age: number;

    constructor(name: string, age: number)&#123;
        this.name = name; // 可以修改
        this.age = age;
    &#125;

    sayHello()&#123;
        console.log(`大家好，我是$&#123;this.name&#125;`);
    &#125;
&#125;

class Employee extends Person&#123;

    constructor(name: string, age: number)&#123;
        super(name, age);
        this.name = name; //子类中不能修改
    &#125;
&#125;

const p = new Person(&#39;孙悟空&#39;, 18);
p.name = &#39;猪八戒&#39;;// 不能修改
</code></pre><h4 id="属性存取器"><a href="#属性存取器" class="headerlink" title="(*)属性存取器"></a>(*)属性存取器</h4><ul><li><p>对于一些不希望被任意修改的属性，可以将其设置为private</p></li><li><p>直接将其设置为private将导致无法再通过对象修改其中的属性</p></li><li><p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p></li><li><p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p></li></ul><pre><code class="typescript">class Person&#123;
    private _name: string;

    constructor(name: string)&#123;
        this._name = name;
    &#125;

    get name()&#123;
        return this._name;
    &#125;

    set name(name: string)&#123;
        this._name = name;
    &#125;

&#125;

const p1 = new Person(&#39;孙悟空&#39;);
console.log(p1.name); // 通过getter读取name属性
p1.name = &#39;猪八戒&#39;; // 通过setter修改name属性
</code></pre><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><ul><li><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p></li><li><p>静态属性（方法）使用static开头</p></li></ul><pre><code class="typescript">class Tools&#123;
    static PI = 3.1415926;
    
    static sum(num1: number, num2: number)&#123;
        return num1 + num2
    &#125;
&#125;

console.log(Tools.PI);
console.log(Tools.sum(123, 456));
</code></pre><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>在类中，使用this表示当前对象</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>继承是面向对象中的又一个特性</li><li>通过继承可以将其他类中的属性和方法引入到当前类中</li><li>通过继承可以在不修改类的情况下完成对类的扩展</li></ul><pre><code class="typescript">class Animal&#123;
    name: string;
    age: number;

    constructor(name: string, age: number)&#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;

class Dog extends Animal&#123;

    bark()&#123;
        console.log(`$&#123;this.name&#125;在汪汪叫！`);
    &#125;
&#125;

const dog = new Dog(&#39;旺财&#39;, 4);
dog.bark();
</code></pre><ul><li>重写:发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</li></ul><pre><code class="typescript">class Animal&#123;
    name: string;
    age: number;

    constructor(name: string, age: number)&#123;
        this.name = name;
        this.age = age;
    &#125;

    run()&#123;
        console.log(`父类中的run方法！`);
    &#125;
&#125;

class Dog extends Animal&#123;

    bark()&#123;
        console.log(`$&#123;this.name&#125;在汪汪叫！`);
    &#125;

    run()&#123;
        console.log(`子类中的run方法，会重写父类中的run方法！`);
    &#125;
&#125;

const dog = new Dog(&#39;旺财&#39;, 4);
dog.bark();
</code></pre><p>在子类中可以使用<strong style="color:red">super</strong>来完成对父类的引用</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</p><pre><code class="typescript">abstract class Animal&#123;
    abstract run(): void;
    bark()&#123;
        console.log(&#39;动物在叫~&#39;);
    &#125;
&#125;

class Dog extends Animals&#123;
    run()&#123;
        console.log(&#39;狗在跑~&#39;);
    &#125;
&#125;
</code></pre><p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。</p><ul><li>示例（<strong style="color:red">检查对象类型-开发中常用</strong>）：</li></ul><pre><code class="typescript">interface Person&#123;
    name: string;
    sayHello():void;
&#125;

function fn(per: Person)&#123;
    per.sayHello();
&#125;

fn(&#123;name:&#39;孙悟空&#39;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);
</code></pre><ul><li>示例（实现）</li></ul><pre><code class="typescript">interface Person&#123;
    name: string;
    sayHello():void;
&#125;

class Student implements Person&#123;
    constructor(public name: string) &#123;
    &#125;

    sayHello() &#123;
        console.log(&#39;大家好，我是&#39;+this.name);
    &#125;
&#125;
</code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。</p><ul><li>举个例子</li></ul><pre><code class="typescript">function test(arg: any): any&#123;
    return arg;
&#125;
</code></pre><p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</p><ul><li>使用泛型</li></ul><pre><code class="typescript">function test&lt;T&gt;(arg: T): T&#123;
    return arg;
&#125;
</code></pre><p>这里的<code>&lt;T&gt;</code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。那么如何使用上边的函数呢？</p><p>方式一（直接使用）</p><pre><code class="typescript">test(10)
</code></pre><p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p><p><strong style="color:red">方式二</strong>（指定类型—&gt;这种更好）</p><pre><code class="typescript">test&lt;number&gt;(10)
</code></pre><ul><li>同时指定多个泛型，泛型间使用逗号隔开</li></ul><pre><code class="typescript">function test&lt;T, K&gt;(a: T, b: K): K&#123;
    return b;
&#125;

test&lt;number, string&gt;(10, &quot;hello&quot;);
</code></pre><p>使用泛型时，完全可以将泛型当成是一个普通的类去使用</p><ul><li>类中同样可以使用泛型</li></ul><pre><code class="typescript">class MyClass&lt;T&gt;&#123;
    prop: T;

    constructor(prop: T)&#123;
        this.prop = prop;
    &#125;
&#125;
</code></pre><ul><li>除此之外，也可以对泛型的范围进行约束</li></ul><pre><code class="typescript">interface MyInter&#123;
    length: number;
&#125;

function test&lt;T extends MyInter&gt;(arg: T): number&#123;
    return arg.length;
&#125;
</code></pre><p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。</p></div><div class="post-ending"><div class="end-txt">------ 本文结束，感谢您的阅读 ------</div><blockquote class="layui-elem-quote layui-quote-nm" style="padding:10px"><div><span class="title">本文作者: </span>贺刘芳</div><div><span class="title">本文链接: </span><a target="_blank" href="https://heliufang.github.io/posts/9d362be7/">https://heliufang.github.io/posts/9d362be7/</a></div><div><span class="title">版权声明: </span>本文采用知识共享署名-非商业性使用-禁止演绎 2.5 中国大陆许可协议进行许可。</div></blockquote></div></div></div></div><ul id="toTopBtn" class="layui-fixbar" style="right:-70px" title="置顶"><div><a href="javascript:void(0)" class="icon iconfont icon-huojian"></a></div></ul><div class="qy-footer"><div class="font-Area"><p>Copyright © 2020 ~<span id="currentYear">2022</span> <span class="layui-icon layui-icon-heart-fill footer-heart"></span> HeLiuFang</p><p>由 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a> <span style="color:red" class="layui-icon layui-icon-find-fill layui-anim layui-anim-rotate layui-anim-loop"></span> 强力驱动</p><p>访客数 <span style="color:red" id="busuanzi_value_site_uv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 人次 | 访问量 <span style="color:red" id="busuanzi_value_site_pv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 次 | 本站已运行 <span style="color:red" id="runDaysFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 天 | 本站文章字数合计 <span style="color:red">200.8k</span> | 最后更新于 <span style="color:red" id="lastUpdateFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span></p></div></div></body><script src="../../js/jquery.min.js"></script><script src="../../js/moment.min.js"></script><script src="../../layui/layui.js"></script><script src="../../lib/prism/prism.js"></script><script>$("#searchBtn").click(function(){$("#searchShade").show(),$("#searchLayer").addClass("layui-anim layui-anim-scaleSpring")}),$("#closeBtn").click(function(){$("#searchShade").hide()});var searchFunc=function(e,s,t){$.ajax({url:e,dataType:"json",success:function(e){var a=document.getElementById(s),n=document.getElementById(t);a.addEventListener("input",function(){var a='<ul class="search-result-list">',t=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(e){var n=!0,s=e.title.trim().toLowerCase(),e=e.url;""!=s&&t.forEach(function(e,a){s.indexOf(e)<0?n=!1:s=s.replace(new RegExp(e,"g"),'<span style="color:red">'+e+"</span>")}),n&&(a=a+"<li><a href='"+e+"' class='search-result-title'>"+s+"</a></li>")}),a+="</ul>",n.innerHTML=a)})}})};searchFunc("/search.json","searchTxt","searchResult")</script><script src="../js/common.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var element=null;layui.use(["element"],function(){element=layui.element}),$(function(){var e=$("#toc-area"),t=$(e).offset().top;$.event.add(window,"scroll",function(){var o=$(".markdown-body").height(),o=(($(window).scrollTop()+t)/o*100).toFixed(2);element.progress("demo",(o=0==(o=99<o?100:o)?0:o)+"%"),$("#progressTxt").text(o),console.log("percent",o),$(e).css("position",$(window).scrollTop()>t?"fixed":"static"),$(e).css("top",$(window).scrollTop()>t?"60px":""),$("#tocMain").scrollTop($("#tocMain .toc").height()*o*.01)}),$("pre code").each(function(){var o=$(this).attr("class");o="language-"+(null==o||""==o||null==o?"plaintext":o),$(this).attr("class",o)}),$("pre").prepend('<div class="copy-to-clipboard-button"></div>')})</script></html>