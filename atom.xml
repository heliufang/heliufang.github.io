<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老C的搬砖日记</title>
  
  <subtitle>每天多学一点知识,就少写一行代码</subtitle>
  <link href="https://heliufang.github.io/atom.xml" rel="self"/>
  
  <link href="https://heliufang.github.io/"/>
  <updated>2024-09-17T14:34:32.990Z</updated>
  <id>https://heliufang.github.io/</id>
  
  <author>
    <name>老C</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python面向对象笔记</title>
    <link href="https://heliufang.github.io/posts/81efbd4e/"/>
    <id>https://heliufang.github.io/posts/81efbd4e/</id>
    <published>2024-09-17T14:32:33.000Z</published>
    <updated>2024-09-17T14:34:32.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h2><p>使用内置函数 dir传入标识符&#x2F;数据，可以查看对象内的 所有属性及方法</p><pre><code class="python">a = &quot;1234&quot;print(dir(a))  # [&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;.......]</code></pre><p>扩展</p><pre><code>__方法名__ 格式的方法是python提供的内置方法/属性__new__ 创建对象时自动调用__init__ 对象被初始化时自动调用__del__ 对象被从内存中销毁前自动调用__str__ 返回对象的描述信息</code></pre><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><pre><code class="python">class 类名:   def 方法1(self,参数列表):     pass  def 方法2(self,参数列表):     pass</code></pre><p>方法和之前定义的函数一样，区别是第一个参数必须是self</p><blockquote><p>注意：类名要符合驼峰命名</p></blockquote><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><pre><code>变量 = 类名()</code></pre><p>【例如】</p><pre><code class="python">class Cat:    def eat(self):        print(&#39;Eating&#39;)    def drink(self):        print(&#39;Drinking&#39;)# 创建对象a = Cat()a.eat()a.drink()</code></pre><h3 id="self参数"><a href="#self参数" class="headerlink" title="self参数"></a>self参数</h3><p>由 哪一个对象 调用方法，方法内的 self 就是 哪一个对象的引用，类似Java类中的this关键字.</p><pre><code>调用方法时，不需要传递 self参数在方法内部可以通过 self.访问对象的属性也可以通过 self.调用其他的对象方法</code></pre><p>【案例】</p><pre><code class="python">class Cat:    def eat(self):        print(&#39;%s Eating&#39; % self.name)    def drink(self):        print(&#39;%s Drinking&#39; % self.name)    def sleep(self):        print(&#39;Sleeping&#39;)        self.eat() # 通过self调用其它方法c = Cat()c.name = &#39;tom&#39;c.eat()c.drink()c.sleep()</code></pre><h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><ul><li>在日常开发中，不推荐在 类的外部 给对象增加属性</li><li>如果在运行时，没有找到属性，程序会报错。对象应该包含有哪些属性，应该 封装在类的内部</li></ul><pre><code>当使用 类名()创建对象时，会自动 执行以下操作:1.为对象在内存中 分配空间 --创建对象2.为对象的属性 设置初始值 --初始化方法( init )这个 初始化方法 就是__init__方法，__init__ 是对象的内置方法</code></pre><p>初始化方法是专门用来定义一个类 具有哪些属性的方法!</p><p>【案例】</p><pre><code class="python">class Cat:    def __init__(self, name, age):        self.name = name        self.age = age    def eat(self):        print(&#39;%s %s Eating&#39; % (self.name, self.age))    def drink(self):        print(&#39;%s Drinking&#39; % self.name)a = Cat(&#39;Jack&#39;, 22)a.eat()b = Cat(&#39;lucy&#39;, 18)b.drink()</code></pre><h3 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h3><pre><code>__del__ 方法 对象被从内存中销毁前，会被 自动 调用 (了解)__str__ 方法 返回对象的描述信息，print 函数输出使用 (类似Java的toString方法)</code></pre><p>【案例】</p><pre><code class="python">class Cat:    def __init__(self, name):        self.name = name    def __str__(self):        return &quot;我是猫咪【%s】&quot; % self.namea = Cat(&quot;汤姆&quot;) # a是一个全局变量print(a)</code></pre><blockquote><p>在定义属性时，如果 不知道设置什么初始值，可以设置为 None</p><p>在 封装的 方法内部，还可以让 自己的 使用其他类创建的对象属性 调用已经 封装好的方法</p></blockquote><h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>身份运算符用于 比较 两个对象的 内存地址 是否一致 –是否是对同一个对象的引用。</p><p>在Python 中针对None比较时，建议使用is判断</p><pre><code>is 是判断两个标识符是不是引用同一个对象 eg: x is y,类似 id(x)== id(y)is not 是判断两个标识符是不是引用不同对象 eg: x is not y, 类似 id(a) != id(b)</code></pre><ul><li>is和&#x3D;&#x3D;的区别</li></ul><p>is  用于判断 两个变量 引用对象是否为同一个</p><p>&#x3D;&#x3D; 用于判断 引用变量的值 是否相等</p><pre><code class="python">arr1 = [1, 2, 3]arr2 = [1, 2, 3]print(arr1 is arr2) # Falseprint(arr1 == arr2) # True</code></pre><h3 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到<br>私有属性 就是 对象 不希望公开的 属性<br>私有方法 就是 对象 不希望公开的 方法</p><h4 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h4><p>在 属性名或者方法名前 增加 两个下划线，定义的就是 私有 属性或方法</p><pre><code class="python">class Cat:    def __init__(self,name,age):        self.name = name        self.__age = age        self.__secret()    def print_age(self):        print(self.__age)    def __secret(self):        print(&quot;secret&quot;)a = Cat(&quot;tom&quot;,18)# a.__secret() # error# print(a.__age) # errora.print_age()</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象三大特性</p><pre><code>封装 根据 职贵 将 属性 和 方法 封装 到一个抽象的 类中继承 实现代码的重用，相同的代码不需要重复的编写多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度</code></pre><p>继承的概念:子类 拥有 父类 的所有 方法 和 属性</p><p><img src="/posts/81efbd4e/image-20240916104417068.png" alt="image-20240916104417068"></p><h4 id="继承的语法"><a href="#继承的语法" class="headerlink" title="继承的语法"></a>继承的语法</h4><pre><code class="python">class 类名(父类名):   pass</code></pre><ul><li><p>子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发</p></li><li><p>子类 中 根据 职责，封装 子类特有的 属性和方法</p></li></ul><p>子类 &#x3D; 派生类 ，父类 &#x3D; 基类</p><h4 id="继承的传递性"><a href="#继承的传递性" class="headerlink" title="继承的传递性"></a>继承的传递性</h4><p>C类从 B类继承，B类又从A类继承。那么C类就具有 B类和 A类的所有属性和方法</p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>子类 拥有 父类 的所有 方法 和 属性<br>子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发</p><p><strong>应用场景</strong></p><p>当 父类 的方法实现不能满足子类需求时，可以对方法进行 重写(override)</p><pre><code>重写父类方法有两种情况:1)覆盖父类的方法如果在开发中，父类的方法实现 和 子类的方法实现，完全不同就可以使用 覆盖 的方式，在子类中 重新编写 父类的方法实现具体的实现方式，就相当于在 子类中 定义了一个和【父类同名的方法】并且实现重写之后，在运行时，只会调用 子类中重写的方法，而不再会调用 父类封装的方法2)对父类方法进行扩展如果在开发中，子类的方法实现 中 包含 父类的方法实现。父类原本封装的方法实现 是 子类方法的一部分就可以使用 扩展 的方式1.在子类中重写父类的方法2.在需要的位置使用 super()父类方法 来调用父类方法的执行3.代码其他的位置针对子类的需求，编写 子类特有的代码实现</code></pre><h4 id="父类的私有属性和私有方法"><a href="#父类的私有属性和私有方法" class="headerlink" title="父类的私有属性和私有方法"></a>父类的私有属性和私有方法</h4><pre><code>a.子类对象 不能 在自己的方法内部，直接 访问 父类的 私有属性 或 私有方法b.子类对象 可以通过 父类 的 公有方法 间接 访问到 私有属性 或 私有方法私有属性、方法 是对象的隐私，不对外公开，外界以及 子类 都不能直接访问私有属性、方法 通常用于做一些内部的事情</code></pre><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><pre><code>子类 可以拥有 多个父类，并且具有 所有父类 的 属性 和 方法。例如:孩子 会继承自己 父亲 和 母亲 的 特性</code></pre><p>语法</p><pre><code class="python">class 子类名(父类名1,父类名2...)  pass</code></pre><p>注意：如果父类之间 存在 同名的属性或者方法，应该尽量避免 使用多继承</p><p><img src="/posts/81efbd4e/image-20240916143441100.png" alt="image-20240916143441100"></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre><code>面向对象三大特性a. 封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类中   定义类的准则b.继承 实现代码的重用，相同的代码不需要重复的编写   设计类的技巧   子类针对自己特有的需求，编写特定的代码c.多态 不同的 子类对象 调用相同的 父类方法，产生不同的执行结果  多态 可以 增加代码的灵活度  以 继承 和 重写父类方法 为前提  是调用方法的技巧，不会影响到类的内部设计</code></pre><p>术语</p><pre><code>a. 创建出来的 对象 叫做 类 的 实例b. 创建对象的 动作 叫做 实例化c. 对象的属性 叫做 实例属性d. 对象调用的方法 叫做 实例方法在程序执行时:1).对象各自拥有自己的 实例属性2).调用对象方法，可以通过  self. 访问自己的属性和调用自己的方法结论1）每一个对象 都有自己 独立的内存空间，保存各自不同的属性2）多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用传递到方法内部</code></pre><h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>类是一个特殊的对象</p><pre><code>在程序运行时，类 同样 会被加载到内存在Python 中，类是一个特殊的对象--类对象在程序运行时，类对象 在内存中 只有一份，使用 一个类 可以创建出 很多个对象实例除了封装 实例 的 属性 和 方法外，【类对象】 还可以拥有自己的 【属性】 和 【方法】通过 类名. 的方式可以访问类的属性或者调用类的方法</code></pre><p><img src="/posts/81efbd4e/image-20240916153445680.png" alt="image-20240916153445680"></p><p>【案例】</p><pre><code class="python">class Tool:    # 使用赋值语句，定义类属性，记录创建工具对象的总数    count = 0    def __init__(self, name):        self.name = name        Tool.count += 1tool1 = Tool(&quot;111&quot;)tool2 = Tool(&quot;222&quot;)tool3 = Tool(&quot;333&quot;)print(Tool.count)</code></pre><p><img src="/posts/81efbd4e/image-20240916154058358.png" alt="image-20240916154058358"></p><h3 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h3><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><pre><code>a.类属性 就是针对 类对象 定义的属性使用 赋值语句 在 class 关键字下方可以定义 类属性类属性 用于记录 与这个类相关 的特征b.类方法 就是针对 类对象 定义的方法在 类方法 内部可以直接访问 类属性 或者调用其他的 类方法</code></pre><p>语法</p><pre><code class="python">@classmethoddef 类方法名(cls):     passa.类方法需要用 修饰器 @classmethod 来标识，告诉解释器这是一个类方法b.类方法的 第一个参数 应该是 cls    由 哪一个类 调用的方法，方法内的 cls 就是 哪一个类的引用    这个参数和 实例方法 的第一个参数是self 类似    使用其他名称也可以，不过习惯使用clsc.通过 类名.调用 类方法，调用方法时，不需要传递cls 参数d.在方法内部 通过 cls.访问类的属性或通过 cls.调用其他的类方法</code></pre><p>【案例】</p><pre><code class="python">class Tool:    # 使用赋值语句，定义类属性，记录创建工具对象的总数    count = 0    @classmethod    def show_tool_count(cls):        print(&quot;总数 %s&quot; % cls.count)    def __init__(self, name):        self.name = name        Tool.count += 1tool1 = Tool(&quot;111&quot;)tool2 = Tool(&quot;222&quot;)tool3 = Tool(&quot;333&quot;)Tool.show_tool_count() # 总数 3</code></pre><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><pre><code>在开发时，如果需要在 类 中封装一个方法，这个方法:    既 不需要 访问 实例属性 或者调用 实例方法。    也 不需要 访问 类属性 或者调用 类方法那么就可以定义成一个静态方法</code></pre><p>语法</p><pre><code class="python">@staticmethoddef 静态方法名():     pass静态方法 需要用 修饰器 @staticmethod 来标识通过 类名. 调用静态方法</code></pre><p>【案例】</p><pre><code class="python">class Tool:    @staticmethod    def sum(a,b):        return a + bprint(Tool.sum(1,2))</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><pre><code>实例方法： 可以访问【实例属性】并且可以通过 类名. 访问【类属性】类方法： 只能访问【类属性】静态方法： 不能访问类属性和实例属性</code></pre><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="简单的捕获语法"><a href="#简单的捕获语法" class="headerlink" title="简单的捕获语法"></a>简单的捕获语法</h3><pre><code class="python">try:     尝试执行的代码except:     出现错误的处理</code></pre><p>【案例】</p><pre><code class="python">try:    num = int(input(&quot;Enter a number: &quot;))except:    print(&quot;请输入正确的数字&quot;)</code></pre><h3 id="错误类型捕捉"><a href="#错误类型捕捉" class="headerlink" title="错误类型捕捉"></a>错误类型捕捉</h3><p>在程序执行时，可能会遇到 不同类型的异常，并且需要 针对不同类型的异常，做出不同的响应，这个时候，就需要捕获错误类型了</p><p>语法</p><pre><code class="python">try:     #尝试执行的代码    pass except 错误类型1：     #针对错误类型1执行的代码    passexcept 错误类型2：     #针对错误类型2执行的代码    passexcept Exception as result:  # 针对未知错误执行的代码    print(&quot;未知错误 %s&quot; % result)</code></pre><h3 id="异常捕获完整语法"><a href="#异常捕获完整语法" class="headerlink" title="异常捕获完整语法"></a>异常捕获完整语法</h3><pre><code class="python">try:     #尝试执行的代码    pass except 错误类型1：     print(&quot;针对错误类型1执行的代码&quot;)except 错误类型2：     print(&quot;针对错误类型2执行的代码&quot;)except Exception as result:    print(&quot;未知错误 %s&quot; % result)else:     print(&quot;没有异常才会执行的代码&quot;)finally:     print(&quot;无论是否异常都会执行的代码&quot;)</code></pre><h3 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h3><pre><code>当 函数/方法 执行 出现异常，会 将异常传递 给 函数/方法 的 【调用一方】如果 传递到主程序，仍然 没有异常处理，程序才会被终止在开发中，可以在主函数中增加 异常捕获而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 异常捕获 中这样就不需要在代码中，增加大量的 异常捕获，能够保证代码的整洁</code></pre><p>【案例】</p><pre><code class="python">def demo1():    return int(input(&quot;请输入一个整数&quot;))def demo2():     return demo1()try:    print(demo2())except ValueError:     print(&quot;请输入正确的整数&quot;)except Exception as result:     print(&quot;未知错误 %s&quot; % result)</code></pre><h3 id="抛出raise异常"><a href="#抛出raise异常" class="headerlink" title="抛出raise异常"></a>抛出raise异常</h3><pre><code>在开发中，除了 代码执行出错Python 解释器会 抛出 异常之外还可以根据 应用程序 特有的业务需求 主动抛出异常Python 中提供了一个Exception 异常类在开发时，如果满足 特定业务需求时，希望 抛出异常，可以:a.创建一个 Exception 的 对象b.使用 raise 关键字 抛出 异常对象</code></pre><p>【案例】</p><pre><code class="python">def demo1():    a = int(input(&quot;请输入一个整数&quot;))    if a &lt; 10:        ex = Exception(&quot;请输入大于10的数字&quot;)        raise ex # 主动抛出异常    return atry:    print(demo1())except ValueError:    print(&quot;请输入正确的整数&quot;)except Exception as result:    print(&quot;未知错误 %s&quot; % result)</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><pre><code>每一个以扩展名py结尾的Python 源代码文件都是一个 模块模块名 同样也是一个 标识符，需要符合标识符的命名规则在模块中定义的 全局变量、函数、类都是提供给外界直接使用的 工具模块 就好比是 工具包，要想使用这个工具包中的工具，就需要先 导入 这个模块</code></pre><h3 id="模块的两种导入方式"><a href="#模块的两种导入方式" class="headerlink" title="模块的两种导入方式"></a>模块的两种导入方式</h3><h4 id="import导入"><a href="#import导入" class="headerlink" title="import导入"></a>import导入</h4><pre><code class="python">import 模块名1,模块名2</code></pre><p>每个导入需要独占一行</p><pre><code class="python">import 模块1import 模块2</code></pre><p>通过  <code>模块名.</code> 使用 模块提供的工具–全局变量、函数、类</p><p>可以使用as指定模块的别名，别名要符合大驼峰命名法</p><pre><code class="python">import 模块名1 as 模块别名</code></pre><h4 id="from…import…导入"><a href="#from…import…导入" class="headerlink" title="from…import…导入"></a>from…import…导入</h4><pre><code>import 模块名  是 一次性 把模块中 所有工具全部导入，并且通过 模块名/别名 访问如果希望 从某一个模块 中，导入部分 工具，就可以使用 from...import 的方式导入之后,不需要 通过 模块名. 来访问。可以直接使用 模块提供的工具 --全局变量、函数、类</code></pre><blockquote><p>如果 两个模块，存在 同名的函数，那么 后导入模块的函数，会 覆盖掉先导入的函数</p><p>可以使用as关键字给其中一个函数起一个别名</p></blockquote><h4 id="模块的搜索顺序"><a href="#模块的搜索顺序" class="headerlink" title="模块的搜索顺序"></a>模块的搜索顺序</h4><p>搜索 当前目录 指定模块名的文件，如果有就直接导入<br>如果没有，再搜索 系统目录</p><pre><code>每一个模块都有一个内置属性__file__ 可以 查看模块 的 完整路径__name__属性可以做到，测试模块的代码 只在测试情况下被运行，而在 被导入时不会被执行!__name__记录着一个【字符串】    如果是被其他文件导入的， __name__ 就是 模块名；    如果是当前执行的程序__name__ 是 __main__</code></pre><p>【案例】</p><pre><code class="python">def say_hello():    print(&quot;Hello World&quot;)if __name__ == &quot;__main__&quot;:    say_hello()</code></pre><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><pre><code>包 是一个 包含多个模块 的 特殊目录目录下有一个 特殊的文件 __init__.py 包名的 命名方式 和变量名一致， 小写字母 + _使用 import 包名可以一次性导入 包 中 所有的模块</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code>a.新建一个 hm_message 的包(就是一个文件夹)b.在hm_message目录下，新建两个文件send_message.py和receive_message.pyc.在 send_message.py 文件中定义一个 send 函数d.在 receive_message.py 文件中定义一个receive 函数e.在 hm_message目录下新建一个 __init__.py 文件f.在外部直接导入 hm_message 的包</code></pre><p>【send_message.py】</p><pre><code class="python">def send():    print(&quot;发送消息&quot;)</code></pre><p>【receive_message.py】</p><pre><code class="python">def receive():    print(&quot;接受消息&quot;)</code></pre><p>【hm_message包下的init文件】</p><pre><code class="python">__init__.py 文件from . import receive_messagefrom . import  send_message</code></pre><p>【test_pack.py】</p><pre><code class="python">import hm_messagehm_message.send_message.send()hm_message.receive_message.receive()</code></pre><h3 id="pip安装第三方模块"><a href="#pip安装第三方模块" class="headerlink" title="pip安装第三方模块"></a>pip安装第三方模块</h3><pre><code>第三方模块 通常是指由 知名的第三方团队 开发的 并且被 程序员广泛使用 的 Python 包/模块。例如 pygame 就是一套非常成熟的 游戏开发模块pip 是一个现代的，通用的Python 包管理工具，提供了对 Python 包的查找、下载、安装、卸载等功能</code></pre><p>安装和卸载命令如下</p><pre><code># python2pip install pygamepip uninstall pygame# python3pip3 install pygamepip3 unstall pygame</code></pre><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><pre><code>在 计算机 中要操作文件的套路非常固定，一共包含三个步骤a.打开文件b.读、写文件  读 将文件内容读入内存  写 将内存内容写入文件c.关闭文件</code></pre><h3 id="操作文件的函数-x2F-方法"><a href="#操作文件的函数-x2F-方法" class="headerlink" title="操作文件的函数&#x2F;方法"></a>操作文件的函数&#x2F;方法</h3><pre><code>open方法：打开文件，并且返回文件操作对象read方法：将文件内容读取到内存write方法：将指定内容写入文件close方法：关闭文件open函数负责打开文件，并且返回文件对象read/write/close三个方法都需要通过文件对象来调用</code></pre><h4 id="read方法"><a href="#read方法" class="headerlink" title="read方法"></a>read方法</h4><pre><code>open函数的第一个参数是要打开的文件名(文件名区分大小写)    如果文件 存在，返回 文件操作对象    如果文件 不存在，会 抛出异常。read 方法可以一次性 读入 并 返回 文件的 所有内容 close方法负责 关闭文件ps: 如果 忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问注意:方法执行后，会把 文件指针 移动到 文件的【末尾】</code></pre><p>【案例】</p><pre><code class="python"># 1.打开文件file = open(&quot;README&quot;)# 2.读取文件text = file.read()print(text)# 3.关闭文件file.close()</code></pre><blockquote><p>提示：在开发中，通常会先编写 打开 和 关闭 的代码，再编写中间针对文件的 读&#x2F;写 操作!</p></blockquote><h4 id="文件指针-了解"><a href="#文件指针-了解" class="headerlink" title="文件指针(了解)"></a>文件指针(了解)</h4><pre><code>文件指针 标记 从哪个位置开始读取数据第一次打开 文件时，通常 文件指针会指向文件的开始位置当执行了 read 方法后，文件指针 会移动到 读取内容的末尾    默认情况下会移动到 文件末尾</code></pre><h4 id="打开文件的方式"><a href="#打开文件的方式" class="headerlink" title="打开文件的方式"></a>打开文件的方式</h4><p>open函数默认以 只读方式 打开文件，并且返回文件对象</p><p>语法：</p><pre><code class="python">f = open(&quot;文件名&quot;,访问方式)访问方式r: 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在抛出异常w：以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件a：以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入r+：以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常w+：以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件a+：以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入提示：频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以 只读、只写 的方式来操作文件</code></pre><h4 id="按行读取文件内容"><a href="#按行读取文件内容" class="headerlink" title="按行读取文件内容"></a>按行读取文件内容</h4><pre><code>read 方法默认会把文件的 所有内容 一次性读取到内存如果文件太大，对内存的占用会非常严重</code></pre><p><strong>readline方法</strong></p><pre><code>readline 方法可以一次读取一行内容方法执行后，会把 文件指针 移动到下一行，准备再次读取</code></pre><p>【案例】</p><pre><code class="python"># 打开文件file = open(&quot;README&quot;)while True:    # 读取一行内容    line = file.readline()    # 没有读到内容则终止循环    if not line:        break    # 每读取一行的末尾以及有了一个 &#39;\n&#39;    print(line, end=&quot;&quot;)# 关闭文件file.close()</code></pre><h4 id="案例-复制文件"><a href="#案例-复制文件" class="headerlink" title="案例-复制文件"></a>案例-复制文件</h4><ul><li>小文件复制</li></ul><pre><code class="python"># 打开文件file_read = open(&quot;README&quot;)file_write = open(&quot;README[copy]&quot;, &quot;w&quot;)txt = file_read.read()file_write.write(txt)# 关闭文件file_write.close()file_read.close()</code></pre><ul><li>大文件复制</li></ul><pre><code class="python"># 打开文件file_read = open(&quot;README&quot;)file_write = open(&quot;README[copy-big]&quot;, &quot;w&quot;)while True:    line = file_read.readline()    if not line:        break    file_write.write(line)# 关闭文件file_write.close()file_read.close()</code></pre><h3 id="文件-x2F-目录的常用管理操作"><a href="#文件-x2F-目录的常用管理操作" class="headerlink" title="文件&#x2F;目录的常用管理操作"></a>文件&#x2F;目录的常用管理操作</h3><pre><code>在 终端/文件浏览器中，导入os模块 可以执行常规的 文件/目录 管理操作例如:创建、重命名、删除、改变路径、查看目录内容</code></pre><p>文件操作</p><pre><code>rename: 重命名文件 例如： os.rename(源文件名,目标文件名)remove：删除文件 例如：os.remove(文件名)</code></pre><p>目录操作</p><pre><code>listdir：目录列表 例如：os.listdir(目录名)mkdir：创建目录 例如： os.mkdir(目录名)rmdir：删除目录 例如：os.rmdir(目录名)getcwd：获取当前目录 例如：os.getcwd()chdir：修改当前目录 例如： os.chdir(目标目录)path.isdir：判断是否是文件 例如：os.path.isdir(文件路径)提示:文件或者目录操作都支持 相对路径 和绝对路径</code></pre><h2 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h2><p>将字符串 当成 有效的表达式 来求值 并 返回计算结果.</p><pre><code class="python">print(eval(&quot;1+1&quot;)) # 2</code></pre><p>提示：不要滥用eval，不安全</p>]]></content>
    
    
    <summary type="html">Python面向对象、封装、继承、多态、异常，文件操作等</summary>
    
    
    
    <category term="python" scheme="https://heliufang.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://heliufang.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础笔记</title>
    <link href="https://heliufang.github.io/posts/3d8035a5/"/>
    <id>https://heliufang.github.io/posts/3d8035a5/</id>
    <published>2024-09-17T14:31:28.000Z</published>
    <updated>2024-09-17T14:34:32.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>【qy_01_hello.py】</p><pre><code class="python">print(&quot;11234&quot;)print(&quot;你好&quot;)print(&quot;abc&quot;)</code></pre><p>命令行执行</p><pre><code class="shell">python qy_01_hello.py</code></pre><h2 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h2><ul><li><p>不能以数字开头</p></li><li><p>使用小写字母、数字、下划线</p></li></ul><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><h3 id="官方解释器"><a href="#官方解释器" class="headerlink" title="官方解释器"></a>官方解释器</h3><p>命令行输入 python 进入python解释器</p><pre><code class="shell">C:\Users\97301&gt;pythonPython 3.11.0rc2 (main, Sep 11 2022, 20:22:52) [MSC v.1933 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; print(&quot;hello 官方解释器&quot;)hello 官方解释器&gt;&gt;&gt; exitUse exit() or Ctrl-Z plus Return to exit&gt;&gt;&gt; exit()</code></pre><p>输入exit() 退出解释器</p><h3 id="ipython解释器"><a href="#ipython解释器" class="headerlink" title="ipython解释器"></a>ipython解释器</h3><p>相比官网的解释器增加了智能提示</p><p>安装</p><pre><code class="sh">pip install ipython</code></pre><p>使用</p><pre><code class="shell">C:\Users\97301&gt;ipythonPython 3.11.0rc2 (main, Sep 11 2022, 20:22:52) [MSC v.1933 64 bit (AMD64)]Type &#39;copyright&#39;, &#39;credits&#39; or &#39;license&#39; for more informationIPython 8.26.0 -- An enhanced Interactive Python. Type &#39;?&#39; for help.In [1]: print(&quot;hello&quot;)helloIn [2]: exit</code></pre><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>pycharm或者vscode</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释:   # 空格 注释内容</p><pre><code class="python"># 这是单行注释print(&quot;hello&quot;)print(&quot;hello world&quot;)  # 单行注释，前面要空两个格</code></pre><p>多行注释</p><pre><code class="python">&quot;&quot;&quot;多行注释，使用连续的三个引号阿斯顿发送到阿斯蒂芬&quot;&quot;&quot;print(&quot;hello&quot;)</code></pre><p>代码规范</p><p><a href="https://www.cnblogs.com/yugen9/articles/15735737.html">https://www.cnblogs.com/yugen9/articles/15735737.html</a></p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><pre><code>+ 加- 减* 乘，还可以用于字符串，计算结果/ 除// 取整除% 取余** 幂运算</code></pre><p>优先级</p><p>和数学中的运算符的优先级一致，在 Python 中进行数学计算时，同样也是:</p><ul><li>先乘除后加减</li><li>同级运算符是 从左至右 计算。</li><li>可以使用()调整计算的优先级</li></ul><pre><code>以下的算数优先级由高到最低顺序排列1. **2. * / % // 3. + -</code></pre><h2 id="程序执行原理"><a href="#程序执行原理" class="headerlink" title="程序执行原理"></a>程序执行原理</h2><p><img src="/posts/3d8035a5/image-20240726223137065.png" alt="image-20240726223137065"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>语法：变量名 &#x3D; 值</p><pre><code>在Python 中，定义变量时是不需要指定变量的类型, 在运行的时候，Python 解释器，会根据赋值语句等号右侧的数据为 自动推导出变量中保存数据的准确类型</code></pre><p>【案例】</p><pre><code class="python">price = 5.8num = 20money = price * numprint(money)</code></pre><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>数字类型</p><pre><code>str 字符串类型bool 布尔类型  True Falsefloat 小数类型int 整数类型</code></pre><p>非数字类型</p><pre><code>字符串列表元祖字典</code></pre><h3 id="type函数查看变量类型"><a href="#type函数查看变量类型" class="headerlink" title="type函数查看变量类型"></a>type函数查看变量类型</h3><pre><code class="shell">&gt;&gt;&gt; a = 12&gt;&gt;&gt; type(a)&lt;class &#39;int&#39;&gt;&gt;&gt;&gt; type(&quot;123&quot;)&lt;class &#39;str&#39;&gt;&gt;&gt;&gt; type(True)&lt;class &#39;bool&#39;&gt;</code></pre><h3 id="不同类型计算"><a href="#不同类型计算" class="headerlink" title="不同类型计算"></a>不同类型计算</h3><pre><code class="python"># python中True = 1 False = 0a = 1 + Trueb = 1 + Falseprint(a)  # 2print(b)  # 1# python中+号可以拼接字符串c = &quot;123&quot;d = &quot;456&quot;print(c+d)  # 123456</code></pre><h3 id="变量的输入"><a href="#变量的输入" class="headerlink" title="变量的输入"></a>变量的输入</h3><p>input函数: 等待用户输入，返回值为字符串</p><pre><code class="python">name = input(&quot;请输入姓名&quot;)print(name)</code></pre><p>类型转换函数</p><p>int(x) 将x转换为整数</p><p>float(x) 将x转换为浮点数 </p><pre><code class="python">price = float(input(&quot;请输入价格&quot;))weight = float(input(&quot;请输入重量&quot;))print(price * weight)</code></pre><h3 id="格式化变量"><a href="#格式化变量" class="headerlink" title="格式化变量"></a>格式化变量</h3><pre><code>%s 字符串%d 整数 %06d标识输出的整数显示位数，不足的地方使用0补全%f 浮点数，%.2f表示小数点后只显示2位%% 输出 %</code></pre><p>语法</p><pre><code>print(&quot;格式化字符串&quot; % 变量1)print(&quot;格式化字符串&quot; % (变量1，变量2...))</code></pre><p>【案例】</p><pre><code class="python">a = &quot;李华&quot;print(&quot;我叫 %s &quot; % a)b = 18print(&quot;今年%d岁&quot; % b)c = 4print(&quot;存款%.2f&quot; % c)d = 20print(&quot;年级排名%d%%&quot; % d)print(&quot;我叫 %s 今年%d岁&quot; % (a, b))</code></pre><h3 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h3><p>由字母、数字、下划线组成</p><p>不能以数字开头</p><p>不能以关键字重名</p><p>单词之间用下划线连接、每个单词都使用小写</p><p>&#x3D;号的左右各保留一个空格</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><pre><code class="python">import keywordprint(keyword.kwlist) #  打印所有的关键字&quot;&quot;&quot;[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;async&#39;, &#39;await&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]&quot;&quot;&quot;</code></pre><h2 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h2><pre><code class="python">if 条件:     条件成立要做的事</code></pre><p>注意: 代码的缩进为一个 tab 键，或者4个空格建议使用空格在 Python 开发中，Tab 和空格不要混用!</p><p>【案例】</p><pre><code class="python">age = 19if age &lt; 18:    print(&quot;未成年&quot;)</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><pre><code>== 等于!= 不等于&gt; 大于&lt; 小于&gt;= 大于等于&lt;= 小于等于</code></pre><h2 id="if-else-条件判断"><a href="#if-else-条件判断" class="headerlink" title="if else 条件判断"></a>if else 条件判断</h2><pre><code class="python">if 条件:     条件成立要做的事else:     条件不成立要做的事</code></pre><p>【案例】</p><pre><code class="python">age = 19if age &lt; 18:    print(&quot;未成年&quot;)else:    print(&quot;你是大人了&quot;)</code></pre><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>and  与</p><pre><code>条件1 and 条件2</code></pre><p>or 或</p><pre><code>条件1 or 条件2</code></pre><p>not 非</p><pre><code>not 条件</code></pre><h2 id="elif"><a href="#elif" class="headerlink" title="elif"></a>elif</h2><pre><code class="python">if 条件1:     条件1要做的事elif 条件2:    条件2要做的事elif 条件3:    条件3要做的事else:     条件都不满足要做的事</code></pre><p>【案例】</p><pre><code class="python">age = 80if age &lt; 5:    print(&quot;幼童&quot;)elif 5 &lt;= age &lt;= 18:    print(&quot;少年&quot;)elif 18 &lt; age &lt;= 65:    print(&quot;成人&quot;)else:    print(&quot;老人&quot;)</code></pre><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><pre><code class="python">import randomnum = random.randint(0,10) # 获取[0,10]的随机数 包含0和10</code></pre><h2 id="单行代码过长格式化"><a href="#单行代码过长格式化" class="headerlink" title="单行代码过长格式化"></a>单行代码过长格式化</h2><p>使用小括号包起来换行</p><pre><code class="python">if((player == 1 and computer == 2)   or (player == 2 and computer == 3)   or (player == 3 and computer == 1)):    print(&quot;欧耶，电脑弱爆了!&quot;)</code></pre><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre><code class="python"># 打印1-10的数字i = 1while i &lt;= 10:    print(i)    i += 1print(&quot;i:%d&quot; % i)  # 程序执行完毕i依然存在</code></pre><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><pre><code>= 等于+= 加等于-= 减等于*= 乘等于/= 除等于//= 取整除等于%= 取余等于**= 幂运算等于</code></pre><p>【案例】</p><pre><code class="python">a = 22b = 3# a /= b# a **= ba %= bprint(a)</code></pre><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>break 表示退出循环</p><p>continue 表示结束本次循序，继续下一次循环</p><p>二者只对<strong>当前</strong>所在循环有效</p><h2 id="print扩展"><a href="#print扩展" class="headerlink" title="print扩展"></a>print扩展</h2><pre><code>在默认情况下，print 函数输出内容之后，会自动在内容末尾增加换行如果不希望末尾增加换行，可以在print 函数输出内容的后面增加，end=&quot;&quot;其中&quot;&quot;中间可以指定 print 函数输出内容之后，继续希望显示的内容</code></pre><p>【案例】</p><pre><code class="python">print(&quot;*&quot;,end=&quot;&quot;)print(&quot;*&quot;,end=&quot;1234&quot;)</code></pre><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><pre><code>\t 制表符\n 换行\\ 反斜杠\&#39; 单引号\r 回车</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><pre><code class="python">def 函数名():    函数内部代码</code></pre><pre><code>函数名 命名规则和变量命名规则一致可以由 字母、下划线 和 数字 组成不能以数字开头不能与关键字重名函数必须先定义再使用！！</code></pre><p>【案例】</p><pre><code class="python"># 定义函数def say_hello():    print(&quot;hello&quot;)    say_hello()  # 调用函数</code></pre><p>ctrl+q函数文档注释</p><pre><code>在开发中，如果希望给函数添加注释，应该在 定义函数 的下方，使用 连续的三对引号在 连续的三对引号 之间编写对函数的说明文字在 函数调用 位置，光标放在函数名上 可以查看函数的说明信息注意:因为 函数体相对比较独立，函数定义的上方，应该和其他代码(包括注释)保留两个空行 !!!</code></pre><p>【案例】</p><pre><code class="python">def say_hello():    &quot;&quot;&quot;    打招呼函数    &quot;&quot;&quot;    print(&quot;hello&quot;)say_hello()</code></pre><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><pre><code>在函数名的后面的小括号内部填写 参数多个参数之间使用,分隔形参:定义 函数时，小括号中的参数，是用来接收参数用的，在函数内部 作为变量使用实参:调用 函数时，小括号中的参数，是用来把数据传递到 函数内部 用的</code></pre><p>【案例】</p><pre><code class="python">def sum_fn(num1, num2):    print(num1 + num2)sum_fn(1, 2)  # 3</code></pre><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>使用return关键字来返回结果</p><p>【案例】</p><pre><code class="python">def sum_fn(num1, num2):    return num1 + num2result = sum_fn(1, 2)print(result)  # 3</code></pre><h3 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h3><pre><code class="python">def sum_fn(num1, num2):    &quot;&quot;&quot;数字求和    :param num1: 数字1    :param num2: 数字2    :return: 求和结果    &quot;&quot;&quot;    return num1 + num2</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><pre><code>模块 就好比是 工具包，要想使用这个工具包中的工具，就需要 导入import 这个模块每一个以扩展名py结尾的Python 源代码文件都是一个 模块在模块中定义的 全局变量、函数 都是模块能够提供给外界直接使用的工具</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>【utils.py】</p><pre><code class="python">def add(a, b):    return a + bdef subtract(a, b):    return a - btitle = &quot;程序员青阳&quot;</code></pre><p>【test_utils.py】</p><pre><code class="python">import utilsprint(utils.add(1, 2))print(utils.subtract(4, 2))print(utils.title)</code></pre><h3 id="模块名也是一个标识符"><a href="#模块名也是一个标识符" class="headerlink" title="模块名也是一个标识符"></a>模块名也是一个标识符</h3><ul><li>标示符可以由 字母、下划线 和 数字 组成，不能以数字开头不能与关键字重名</li><li>注意:  如果在给Python 文件起名时，以数字开头是无法在Pycharm 中通过导入这个模块的</li></ul><h3 id="pyc文件-了解"><a href="#pyc文件-了解" class="headerlink" title="pyc文件(了解)"></a>pyc文件(了解)</h3><pre><code>C是compiled编译过 的意思操作步骤1. 浏览程序目录会发现一个pycache_的目录2.目录下会有一个hm_18_分隔线模块.cpython-35.pyc文件，(cpython-35 表示Python 解释器的版本3.这个 pyc 文件是由 Python 解释器将 模块的源码 转换为 字节码。(Python 这样保存 字节码 是作为一种启动 速度的优化字节码Python 在解释源程序时是分成两个步骤的1.首先处理源代码，编译 生成一个二进制 字节码2.再对 字节码 进行处理，才会生成 CPU 能够识别的 机器码有了模块的字节码文件之后，下一次运行程序时，如果在 上次保存字节码之后 没有修改过源代码Python 将会加载.pyc文件并跳过编译这个步骤当Python)重编译时，它会自动检查源文件和字节码文件的时间截如果你又修改了源代码,，下次程序运行时，字节码将自动重新创建</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><img src="/posts/3d8035a5/image-20240805214925236.png" alt="image-20240805214925236"></p><h3 id="循环遍历列表"><a href="#循环遍历列表" class="headerlink" title="循环遍历列表"></a>循环遍历列表</h3><pre><code class="python">name_list = [&quot;张三&quot;, &quot;李四&quot;,&quot;阿发&quot;,&quot;张三&quot;]for name in name_list:    print(name)</code></pre><h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><pre><code>Tuple(元组)与列表类似，元组 表示多个元素组成的序列，不同之处在于元组的元素不能修改。元组 在Python 开发中，有特定的应用场景,用于存储 一串 信息，数据 之间使用，分隔。元组用()定义元组的 索引从 8 开始，索引 就是数据在 元组 中的位置编号</code></pre><p>【案例】</p><pre><code class="python">info_tuple = (1,2,3)empty_tuple = ()one_tuple = (1,) # 元组中 只包含一个元素 时，需要 在元素后面添加逗号print(info_tuple)print(empty_tuple)print(one_tuple)</code></pre><p>元祖的常用操作和列表类似，可以参考列表的图练习</p><h3 id="循环遍历元祖"><a href="#循环遍历元祖" class="headerlink" title="循环遍历元祖"></a>循环遍历元祖</h3><p>和列表一样</p><pre><code class="python">info_tuple = (1,2,3,1)for i in info_tuple:    print(i)</code></pre><p>在 Python中，可以使用for循环遍历所有非数字型类型的变量:列表、元组、字典 以及 字符串<br>提示: 在实际开发中，除非 能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>尽管可以使用 for in 遍历 元组但是在开发中，更多的应用场景是:函数的 参数 和 返回值，一个函数可以接收 任意多个参数，或者 一次返回多个数据格式化字符串后面的()本质上就是一个元组让列表不可以被修改，以保护数据安全</code></pre><h3 id="元祖和列表之间的转换"><a href="#元祖和列表之间的转换" class="headerlink" title="元祖和列表之间的转换"></a>元祖和列表之间的转换</h3><p>list(元祖)  将元祖转列表</p><p>tuple(列表) 将列表转元祖</p><pre><code class="python">nameList = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;]print(tuple(nameList))tupleList = (&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;)print(list(tupleList))</code></pre><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>dictionary(字典)是除列表以外Python 之中 最灵活 的数据类型字典同样可以用来 存储多个数据,通常用于存储 描述一个 物体 的相关信息</p><pre><code>列表 是 有序 的对象集合字典 是 无序 的对象集合</code></pre><p>字典用 {} 定义<br>字典使用 键值对 存储数据，键值对之间使用,分隔<br>键 key 是索引<br>值 value 是数据<br>键 和 值 之间使用:分隔<br>键必须是唯一的<br>值 可以取任何数据类型，但 键 只能使用 字符串、数字或 元组</p><pre><code class="python">student = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;print(student)</code></pre><p>相关api</p><pre><code>len(字典) 获取字典的 键值对数量字典.keys() 所有 key 列表字典.values() 所有 value 列表字典.items() 所有(key,value)元组列表字典[key] 可以从字典中取值，key 不存在会报错字典.get(key) 可以从字典中取值，key 不存在不会报错del 字典[key] 删除指定键值对，key 不存在会报错字典.pop(key) 删除指定键值对，key 不存在会报错字典.popitem() 随机删除一个键值对字典.clear() 清空字典字典[key] = value 如果 key 存在，修改数据如果 key 不存，新建键值对字典.setdefault(key, value) 如果 key 存在，不会修改数据如果 key 不存在，新建键值对字典.update(字典2) 将字典 2 的数据合并到字典</code></pre><p>【案例】</p><pre><code class="python">student = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;other = &#123;&quot;hobby&quot;: [&quot;吃饭&quot;,&quot;睡觉&quot;], &quot;phone&quot;: &quot;12341234&quot;&#125;print(student)print(len(student))print(student.keys())print(student.values())print(student.items())print(student[&quot;name&quot;])print(student.get(&quot;name&quot;))# del student[&quot;name&quot;]# student.pop(&quot;name&quot;)# student.popitem()# student.clear()# student[&quot;address&quot;] = &quot;北京&quot;student.update(other)print(student)</code></pre><h3 id="循环遍历-了解"><a href="#循环遍历-了解" class="headerlink" title="循环遍历(了解)"></a>循环遍历(了解)</h3><p>遍历 就是 依次 从 字典 中获取所有键值对</p><pre><code class="python">student = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;for key in student:    print(student[key])</code></pre><p>尽管可以使用 for in 遍历 字典<br>但是在开发中，更多的应用场景是:</p><pre><code>使用 多个键值对,存储 描述一个 物体 的相关信息 --描述更复杂的数据信息将 多个字典 放在 一个列表 中，再进行遍历，在循环体内部针对每一个字典进行 相同的处理</code></pre><h2 id="字符串API"><a href="#字符串API" class="headerlink" title="字符串API"></a>字符串API</h2><p>字符串 就是 一串字符，是编程语言中表示文本的数据类型在 Python 中可以使用 一对双引号”或者 一对单引号’定义一个字符串.</p><p>虽然可以使用&quot;或者&#39;做字符串的转义，但在实际开发中:如果字符串内部需要使用”，可以使用’定义字符串,如果字符串内部需要使用’，可以使用”定义字符串</p><p>可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0开始也可以使用 for循环遍历 字符串中每一个字符<br>大多数编程语言都是用”来定义字符串</p><pre><code>len(字符串) 获取字符串的长度字符串.count(字符) 字符在字符串中出现的次数字符串[索引] 取出指定索引的字符字符串.index(字符串) 获取字符第一次出现的下标</code></pre><p>判断类型</p><pre><code>string.isspace() 如果 string 中只包含空格，则返回 Truestring.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 Truestring.isalpha() 如果string至少有一个字符并且所有字符都是字母则返回Truestring.isdecimal() 如果string只包含数字则返回True，全角数字 string.isdigit() 如果string只包含数字则返回True，全角数字 string.isnumeric() 如果string只包含数字则返回True 全角数字，汉字数字string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 Truestring.islower() 如果string中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写 则返回Truestring.isupper() 如果string中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写 则返回True</code></pre><p>查找和替换</p><pre><code>string.startswith(str) 检查字符串是否是以 str 开头，是则返回 Truestring.endswith(str) 检查字符串是否是以 str 结尾，是则返回 Truestring.find(str, start=0.end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返-1string.rfnd(str, start=0,end=len(string)) 类似于 find 函数，不过是从右边开始查找string.index(str,start=0,end=len(string)) 跟 find 方法类似，只不过如果 str 不在 string 会报错string.rindex(str,start=0,end-len(string)) 类似于 index方法，不过是从右边开始string.replace(old str,new_str,num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次</code></pre><p>大小写转换</p><pre><code>string.capitalize() 把字符串的第一个字符大写string.title() 把字符串的每个单词首字母大写string.lower() 转换 string 中所有大写字符为小写string.upper() 转换 string 中所有大写字符为大写string.swapcase() 翻转 string 中的大小写</code></pre><p>文本对齐</p><pre><code>string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串</code></pre><p>去除空白字符串</p><pre><code>string.lstrip() 截掉 string 左边(开始)的空白字符string.rstrip() 截掉 string 右边(末尾)的空白字符string.strip() 截掉 string 左右两边的空白字符</code></pre><p>拆分和连接</p><pre><code>string.partition(str) 把字符串 string 分成一个3元素的元组(str前面,str,str后面)string.rpartition(str) 类似于 partition()函数，不过是从右边开始查找string.split(str=&quot;&quot;,num) 以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+1个子字符串，str 默认包含 \r,t,\n&#39;和空格string.splitlines() 按照行(\r,\n,\r\n)分隔，返回一个包含各行作为元素的列表string.join(seq) 以 string 作为分隔符，将 seq中所有的元素(的字符串表示)合并为一个新的字符串</code></pre><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p><img src="/posts/3d8035a5/image-20240811120915037.png" alt="image-20240811120915037"></p><p>切片练习题</p><pre><code>1.截取从2~5 位置 的字符串2.截取从 2-末尾 的字符串3.截取从 开始 ~5 位置 的字符串4.截取完整的字符串5.从开始位置，每隔一个字符截取字符串6.从索引 1开始，每隔一个取一个截取7.从2~末尾-1的字符串8.截取字符串末尾两个字符9.字符串的逆序(面试题)</code></pre><h2 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h2><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><pre><code>len(item) 计算容器中元素个数del(item) 删除变量max(item) 返回容器中元素最大值min(item) 返回容器中元素最小值cmp(item1,item2) 比较两个值，-1小于/0 相等/1 大于</code></pre><p>注意： 字符串 比较符合以下规则:”0”&lt;”A”&lt;”a”</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p><img src="/posts/3d8035a5/image-20240811140823322.png" alt="image-20240811140823322"></p><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><p><img src="/posts/3d8035a5/image-20240811140901513.png" alt="image-20240811140901513"></p><h3 id="完整的for方法"><a href="#完整的for方法" class="headerlink" title="完整的for方法"></a>完整的for方法</h3><p><img src="/posts/3d8035a5/image-20240811141131364.png" alt="image-20240811141131364"></p><h2 id="变量的进阶"><a href="#变量的进阶" class="headerlink" title="变量的进阶"></a>变量的进阶</h2><h3 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h3><p>变量 和 数据 都是保存在 内存 中的<br>在 Python 中函数的 参数传递 以及 返回值 都是靠 引用 传递的</p><pre><code>变量 和 数据 是分开存储的数据 保存在内存中的一个位置变量 中保存着数据在内存中的地址变量 中 记录数据的地址，就叫做 引用使用 id()函数可以查看变量中保存数据所在的 内存地址注意:如果变量已经被定义，当给一个变量赋值的时候，本质上是修改了数据的引用变量 不再 对之前的数据引用变量 改为 对新赋值的数据引用</code></pre><h3 id="函数的参数和返回值"><a href="#函数的参数和返回值" class="headerlink" title="函数的参数和返回值"></a>函数的参数和返回值</h3><p><img src="/posts/3d8035a5/image-20240811141916395.png" alt="image-20240811141916395"></p><h3 id="可变和不可变类型"><a href="#可变和不可变类型" class="headerlink" title="可变和不可变类型"></a>可变和不可变类型</h3><p><img src="/posts/3d8035a5/image-20240811142139631.png" alt="image-20240811142139631"></p><p>注意：字典的key只能使用不可变类型</p><p><img src="/posts/3d8035a5/image-20240811142258744.png" alt="image-20240811142258744"></p><p>哈希</p><p><img src="/posts/3d8035a5/image-20240811142345124.png" alt="image-20240811142345124"></p><h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><p>局部变量 是在 函数内部 定义的变量，只能在函数内部使用<br>全局变量 是在 函数外部定义 的变量(没有定义在某一个函数内)，所有函数 内部 都可以使用这个变量</p><blockquote><p>提示:在其他的开发语言中，大多不推荐使用全局变量–可变范围太大，导致程序不<br>好维护!</p></blockquote><pre><code>局部变量 是在 函数内部 定义的变量，只能在函数内部使用函数执行结束后，函数内部的局部变量，会被系统回收不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响</code></pre><p>注意:函数执行时，需要处理变量时 会:</p><ol><li>首先 查找 函数内部 是否存在 指定名称 的局部变量，如果有，直接使用</li><li>如果没有，查找 函数外部 是否存在 指定名称 的全局变量，如果有，直接使用</li><li>如果还没有，程序报错!</li></ol><ul><li>函数不能直接修改全局变量的值，要修改的话需要加上global关键字</li><li>全角变量的命名建议以 g_开头或者 gl_前缀,具体以开发团队要求为准</li></ul><pre><code class="python">num = 1def test1():    global num    num = 2    print(num) # 2def test2():    num = 3    print(num) # 3test1()test2()print(num) # 2</code></pre><h2 id="函数的参数和返回值-1"><a href="#函数的参数和返回值-1" class="headerlink" title="函数的参数和返回值"></a>函数的参数和返回值</h2><p>在程序开发中，希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理</p><pre><code>返回值 是函数 完成工作后，最后 给调用者的一个结果在函数中使用return 关键字可以返回结果调用函数一方可以 使用变量 来 接收 函数的返回结果</code></pre><p>【案例】</p><pre><code class="python">def add(a,b):    sum = a+b    return a,b,sum # 返回一个元祖 ()可以省略# 如果函数返回的类型是元组，同时希望单独的处理元组中的元素可以使用多个变量，一次接收函数的返回结果# 注意:使用多个变量接收结果时，变量的个数应该和元组中元素的个数保持一a,b,sum = add(1,2)print(a)print(b)print(sum)</code></pre><p>【利用元祖交换两个变量】</p><pre><code class="python">c = 1d = 2c,d = d,cprint(c)print(d)</code></pre><h2 id="不可变和可变参数"><a href="#不可变和可变参数" class="headerlink" title="不可变和可变参数"></a>不可变和可变参数</h2><p>问题1:在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量?       –不会!<br>无论传递的参数是 可变 还是 不可变，只要 针对参数 使用 赋值语句，会在 函数内部 修改 局部变量的引用，不会影响到 外部变量的引用</p><pre><code class="python">g_name = &quot;tom&quot;g_num_list = [5,6,7,8,9]def demo(name,num_list):    name = &quot;jerry&quot;    num_list = [1,2,3,4,5]    print(name) # &quot;jerry&quot;    print(num_list) # [1,2,3,4,5]demo(g_name,g_num_list)print(g_name) # &quot;tom&quot;print(g_num_list) # [5,6,7,8,9]</code></pre><p>问题2:如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据</p><pre><code class="python">g_num_list = [5,6,7,8,9]def test(num_list):    num_list.extend([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])    print(num_list) # [5, 6, 7, 8, 9, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]test(g_num_list)print(g_num_list) # [5, 6, 7, 8, 9, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><blockquote><p>在 python 中，列表调用+&#x3D;本质上是在执行列表的extend 方法，不会修改变量的引用</p></blockquote><h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><pre><code>定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用 </code></pre><p>对列表排序的方法</p><pre><code class="python">g_num_list = [5,6,7,8,9]g_num_list.sort() # 缺省参数升序g_num_list.sort(reverse=True) # 有参数则降序print(g_num_list)</code></pre><p>指定函数的缺省参数</p><pre><code class="python">def print_info(name,gender = True):    gender_txt = &quot;女生&quot;    if gender:        gender_txt = &quot;男生&quot;    print(&quot;姓名 %s,性别 %s&quot; % (name,gender_txt))     print_info(&quot;张三&quot;) # 姓名 张三,性别 男生print_info(&quot;李四&quot;,False) # 姓名 李四,性别 女生</code></pre><p><img src="/posts/3d8035a5/wps2.jpg" alt="img"></p><h2 id="多值参数-了解"><a href="#多值参数-了解" class="headerlink" title="多值参数(了解)"></a>多值参数(了解)</h2><p><img src="/posts/3d8035a5/wps3.jpg" alt="img"></p><p><img src="/posts/3d8035a5/wps5.jpg" alt="img"></p><p><img src="/posts/3d8035a5/wps4.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">Python基础、流程控制，变量、函数等</summary>
    
    
    
    <category term="python" scheme="https://heliufang.github.io/categories/python/"/>
    
    
    <category term="python" scheme="https://heliufang.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于nodejs的http-server搭建静态资源服务</title>
    <link href="https://heliufang.github.io/posts/8898569d/"/>
    <id>https://heliufang.github.io/posts/8898569d/</id>
    <published>2024-09-16T01:48:28.000Z</published>
    <updated>2024-09-16T01:15:14.067Z</updated>
    
    <content type="html"><![CDATA[<p>快速搭建一个基于node.js的静态资源服务器，无需安装nginx</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装</p><pre><code class="sh">npm install -g http-server</code></pre><p>先进入某个文件夹，将这个文件夹的路径作为静态资源只需要执行下面的命令</p><pre><code class="shell">http-server -p 81 --cors</code></pre><p>-p 指定端口</p><p>–cors 允许跨域</p><p>这样就搭建好了静态资源服务器了，非常的方便</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000044652558">http-server：Node.js下的轻量级静态服务器利器</a></p>]]></content>
    
    
    <summary type="html">基于nodejs的http-server快速搭建静态资源服务，功能类似nginx</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="http-server" scheme="https://heliufang.github.io/tags/http-server/"/>
    
  </entry>
  
  <entry>
    <title>springboot整合websocket</title>
    <link href="https://heliufang.github.io/posts/9183fda2/"/>
    <id>https://heliufang.github.io/posts/9183fda2/</id>
    <published>2024-08-18T07:38:28.000Z</published>
    <updated>2024-08-22T14:25:38.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="springboot整合websocket"><a href="#springboot整合websocket" class="headerlink" title="springboot整合websocket"></a>springboot整合websocket</h2><ul><li>pom.xml</li></ul><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>SpringbootApplication.java</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringbootApplication.class, args);    &#125;&#125;</code></pre><ul><li>Constant.java</li></ul><pre><code class="java">import java.util.HashMap;import java.util.Map;import javax.websocket.Session;public class Constant &#123;    public static Map&lt;Integer,Session&gt; sessionMap = new HashMap();&#125;</code></pre><ul><li>Message.java</li></ul><pre><code class="java">public class Message &#123;    private Integer sendUserId; //发送人id    private String sendName; //发送人姓名    private Integer receiveUserId; //接受人id    private String receiveName; //接收人姓名    private String content; //发送的的内容    private String time = &quot;2024-8-19 11:40:59&quot;; //发送时间        //get and set&#125;</code></pre><ul><li>WebsocketConfig.java</li></ul><pre><code class="java">import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.server.standard.ServerEndpointExporter;@Configuration@EnableWebSocketpublic class WebsocketConfig &#123;    @Bean    public ServerEndpointExporter serverEndpoint() &#123;        return new ServerEndpointExporter();    &#125; &#125;</code></pre><ul><li>WsServerEndpoint.java</li></ul><pre><code class="java">import org.springframework.stereotype.Component;import com.alibaba.fastjson.JSON;import javax.websocket.OnClose;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.ServerEndpoint;import java.io.IOException;import java.util.HashMap;import java.util.Map;@ServerEndpoint(&quot;/myWs&quot;)@Componentpublic class WsServerEndpoint &#123;        /**     * 查询字符串转map     * @param queryString     * @return     */    public static Map&lt;String, String&gt; queryStringToMap (String queryString) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        if (queryString == null || queryString.isEmpty()) &#123;            return map;        &#125;        String[] pairs = queryString.split(&quot;&amp;&quot;);        for (String pair : pairs) &#123;            String[] keyValue = pair.split(&quot;=&quot;);            if (keyValue.length == 2) &#123;                String key = keyValue[0];                String value = keyValue[1];                map.put(key, value);            &#125;        &#125;        return map;    &#125;    /**     * 连接成功     * @param session     */    @OnOpen    public void onOpen(Session session) &#123;        Map&lt;String, String&gt; queryStringToMap = queryStringToMap(session.getQueryString());        System.out.println(queryStringToMap);        Integer currentUserId = Integer.parseInt(queryStringToMap.get(&quot;sendUserId&quot;).toString());        Constant.sessionMap.put(currentUserId, session);        System.out.println(&quot;连接成功&quot;+queryStringToMap+Constant.sessionMap.keySet().size());        try &#123;            session.getBasicRemote().sendText(queryStringToMap.get(&quot;sendName&quot;)+&quot;上线了&quot;);        &#125; catch (IOException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;    &#125;    /**     * 连接关闭     * @param session     */    @OnClose    public void onClose(Session session) &#123;        System.out.println(&quot;连接关闭&quot;);    &#125;    /**     * 接收到客户端发送的消息，转发到客户端     * @param text     */    @OnMessage    public void onMsg(String text) throws IOException &#123;        Message message = JSON.parseObject(text, Message.class);        System.out.println(&quot;onMsg:&quot;+message);        System.out.print(&quot;sessionMap:&quot;+Constant.sessionMap);        String sendMsg = &quot;&quot;+message.getTime()+&quot;   &quot;+message.getSendName()+&quot;：&quot;+message.getContent()+&quot;  &quot;;        Constant.sessionMap.get(message.getSendUserId()).getBasicRemote().sendText(sendMsg); //发送人        Constant.sessionMap.get(message.getReceiveUserId()).getBasicRemote().sendText(sendMsg); //接收人//        return msg;    &#125;&#125;</code></pre><ul><li>websoket.html</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;WebSocket Chat&lt;/title&gt;    &lt;style&gt;        #chat &#123;            border: 1px solid #ccc;            height: 300px;            overflow-y: scroll;        &#125;        #messageInput &#123;            width: calc(100% - 50px);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;chat&quot;&gt;&lt;/div&gt;    &lt;input type=&quot;text&quot; id=&quot;messageInput&quot; placeholder=&quot;Type a message&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;sendUserIdInput&quot; placeholder=&quot;你的id&quot;&gt;&lt;/input&gt;    &lt;input type=&quot;text&quot; id=&quot;sendNameInput&quot; placeholder=&quot;你的姓名&quot;&gt;&lt;/input&gt;    &lt;input type=&quot;text&quot; id=&quot;receiveUserIdInput&quot; placeholder=&quot;对方id&quot;&gt;&lt;/input&gt;    &lt;input type=&quot;text&quot; id=&quot;receiveNameInput&quot; placeholder=&quot;对方姓名&quot;&gt;&lt;/input&gt;    &lt;button onclick=&quot;linkMessage()&quot;&gt;连接到WebSocket服务器&lt;/button&gt;    &lt;button onclick=&quot;sendMessage()&quot;&gt;发送&lt;/button&gt;    &lt;script&gt;        const chat = document.getElementById(&#39;chat&#39;);        const messageInput = document.getElementById(&#39;messageInput&#39;);        const sendUserIdInput = document.getElementById(&#39;sendUserIdInput&#39;);        const sendNameInput = document.getElementById(&#39;sendNameInput&#39;);        const receiveUserIdInput = document.getElementById(&#39;receiveUserIdInput&#39;);        const receiveNameInput = document.getElementById(&#39;receiveNameInput&#39;);        let ws = null        // 连接到WebSocket服务器        function linkMessage() &#123;            const sendUserId = sendUserIdInput.value;            const sendName = encodeURIComponent(sendNameInput.value);            console.log(&#39;sendUserId&#39;, sendUserId,&#39;sendName&#39;, sendName)            ws = new WebSocket(`ws://localhost:8700/myWs?sendUserId=$&#123;sendUserId&#125;&amp;sendName=$&#123;sendName&#125;`);            // 接收WebSocket服务器的消息            ws.onmessage = (event) =&gt; &#123;                console.log(&#39;event.data&#39;, event.data)                const message = document.createElement(&#39;div&#39;);                message.textContent = decodeURIComponent(event.data);                chat.appendChild(message);                chat.scrollTop = chat.scrollHeight; // 自动滚动到底部            &#125;;        &#125;        // 发送消息到WebSocket服务器        function sendMessage() &#123;            const message = messageInput.value;            const params = &#123;                sendUserId: sendUserIdInput.value,                sendName: sendNameInput.value,                content: message,                receiveUserId: receiveUserIdInput.value,                receiveName: receiveNameInput.value,                time: new Date().toLocaleString()            &#125;            if (message) &#123;                ws.send(JSON.stringify(params));                messageInput.value = &#39;&#39;; // 发送消息后清空输入框            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="websocket在线测试"><a href="#websocket在线测试" class="headerlink" title="websocket在线测试"></a>websocket在线测试</h2><p> <a href="http://coolaf.com/zh/tool/chattest">http://coolaf.com/zh/tool/chattest</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/cfd77316546a">java实现websocket的五种方式</a></p>]]></content>
    
    
    <summary type="html">springboot整合websocket</summary>
    
    
    
    <category term="java" scheme="https://heliufang.github.io/categories/java/"/>
    
    
    <category term="websocket" scheme="https://heliufang.github.io/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>jquery封装echart插件</title>
    <link href="https://heliufang.github.io/posts/134dc9cc/"/>
    <id>https://heliufang.github.io/posts/134dc9cc/</id>
    <published>2024-08-17T11:48:28.000Z</published>
    <updated>2024-09-16T01:16:33.939Z</updated>
    
    <content type="html"><![CDATA[<p>使用的jquery3版本</p><h2 id="封装echart-plugins-js"><a href="#封装echart-plugins-js" class="headerlink" title="封装echart-plugins.js"></a>封装echart-plugins.js</h2><pre><code class="js">(function ($) &#123;  $.fn.echart = function (options) &#123;    var $this = this;    var chart = echarts.init($this[0]);    function renderChart() &#123;      chart.setOption(options);    &#125;    function updateOptions(newOptions) &#123;      options = $.extend(&#123;&#125;, options, newOptions);      renderChart();    &#125;    function resize() &#123;      chart.resize();    &#125;    renderChart();    // 返回一个对象，包含更新选项和调整大小的方法    return &#123;      updateOptions: updateOptions,      resize: resize,    &#125;;  &#125;;&#125;)(jQuery);</code></pre><h2 id="使用封装好的echart插件"><a href="#使用封装好的echart插件" class="headerlink" title="使用封装好的echart插件"></a>使用封装好的echart插件</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;./echartplugins.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;chartContainer&quot; style=&quot;width: 600px; height: 400px;&quot;&gt;&lt;/div&gt;    &lt;script&gt;        // 示例用法        $(document).ready(function () &#123;            var options = &#123;                title: &#123;                    text: &#39;示例图表&#39;                &#125;,                tooltip: &#123;&#125;,                xAxis: &#123;                    data: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]                &#125;,                yAxis: &#123;&#125;,                series: [&#123;                    name: &#39;销量&#39;,                    type: &#39;bar&#39;,                    data: [5, 20, 36, 10, 10]                &#125;]            &#125;;            var chart = $(&#39;#chartContainer&#39;).echart(options);            // 示例：更新图表选项            setTimeout(function () &#123;                chart.updateOptions(&#123;                    series: [&#123;                        name: &#39;销量&#39;,                        type: &#39;bar&#39;,                        data: [15, 25, 30, 20, 5]                    &#125;]                &#125;);            &#125;, 3000);        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">jquery封装echart插件</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="echart" scheme="https://heliufang.github.io/tags/echart/"/>
    
  </entry>
  
  <entry>
    <title>nuxt2笔记整理</title>
    <link href="https://heliufang.github.io/posts/8088d2b5/"/>
    <id>https://heliufang.github.io/posts/8088d2b5/</id>
    <published>2023-12-12T09:44:28.000Z</published>
    <updated>2024-01-12T13:46:14.036Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://v2.nuxt.com/docs/get-started/installation">Nuxt2官网</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>nuxt是基于vue语法来实现SSR(服务器渲染)的框架，解决单页应用不利于SEO的问题</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>由于国内网络问题经常下载失败，推荐采用沙盒下载环境项目模板</p><p><a href="https://stackblitz.com/github/nuxt/starter/tree/v2-stackblitz?file=README.md">https://stackblitz.com/github/nuxt/starter/tree/v2-stackblitz?file=README.md</a></p><p><img src="/posts/8088d2b5/1702344800164.png" alt="1702344800164"></p><p>新建一个nuxt2-study文件夹，将下载后的文件解压到这个文件夹中</p><p><img src="/posts/8088d2b5/1702345551102.png" alt="1702345551102"></p><p>然后安装依赖</p><pre><code class="shell">npm i</code></pre><p>启动</p><pre><code class="shell">npm run dev</code></pre><p>访问：localhost:3000</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>每个页面组件都是一个Vue组件 ，pages目录中的每个文件都是一个页面。</p><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>假设文件结构如下</p><pre><code>pages/--| user/-----| index.vue-----| one.vue--| index.vue</code></pre><p>那么生成的路由如下</p><pre><code class="js">router: &#123;  routes: [    &#123;      name: &#39;index&#39;,      path: &#39;/&#39;,      component: &#39;pages/index.vue&#39;    &#125;,    &#123;      name: &#39;user&#39;,      path: &#39;/user&#39;,      component: &#39;pages/user/index.vue&#39;    &#125;,    &#123;      name: &#39;user-one&#39;,      path: &#39;/user/one&#39;,      component: &#39;pages/user/one.vue&#39;    &#125;  ]&#125;</code></pre><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>假设文件结构如下</p><pre><code>pages/--| _slug/-----| comments.vue-----| index.vue--| users/-----| _id.vue--| index.vue</code></pre><p>那么生成的路由如下</p><pre><code class="js">router: &#123;  routes: [    &#123;      name: &#39;index&#39;,      path: &#39;/&#39;,      component: &#39;pages/index.vue&#39;    &#125;,    &#123;      name: &#39;users-id&#39;,      path: &#39;/users/:id?&#39;,      component: &#39;pages/users/_id.vue&#39;    &#125;,    &#123;      name: &#39;slug&#39;,      path: &#39;/:slug&#39;,      component: &#39;pages/_slug/index.vue&#39;    &#125;,    &#123;      name: &#39;slug-comments&#39;,      path: &#39;/:slug/comments&#39;,      component: &#39;pages/_slug/comments.vue&#39;    &#125;  ]&#125;</code></pre><p>动态路由参数的获取和<code>vue-router</code>一致：<code>this.$route.params.xxx</code></p><h3 id="NuxtLink组件"><a href="#NuxtLink组件" class="headerlink" title="NuxtLink组件"></a>NuxtLink组件</h3><p>和router-link类似，用于跳转页面。 对于指向站点内页面的所有链接，请使用&lt; NuxtLink &gt;。如果有其他网站的链接，应该使用&lt; a &gt;标签</p><pre><code class="html">&lt;NuxtLink to=&quot;/book/10001&quot;&gt;查看详情&lt;/NuxtLink&gt;</code></pre><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>功能类似vue中的router-view组件，一个项目可以有多个布局。默认使用的布局是 layouts&#x2F;default.vue </p><ul><li>定义新布局  layouts&#x2F;myLayout.vue</li></ul><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;自定义页面头部&lt;/h1&gt;        &lt;!-- Nuxt功能类似router-view组件 --&gt;        &lt;Nuxt /&gt;        &lt;h1&gt;自定义页面底部&lt;/h1&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>组件中使用布局</li></ul><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;NuxtLink to=&quot;/book/10001&quot;&gt;查看详情&lt;/NuxtLink&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;Nuxt2StudyIndex&#39;,    layout: &#39;myLayout&#39;,//使用自定义的布局    //...&#125;;&lt;/script&gt;</code></pre><h2 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h2><p>当404和500的时候显示一个错误页面</p><p>layouts&#x2F;error.vue</p><pre><code class="html">&lt;template&gt;    &lt;!-- 自定义错误页面 --&gt;    &lt;div class=&quot;error-container&quot;&gt;        &lt;div class=&quot;info&quot;&gt;            &lt;div class=&quot;code&quot;&gt;&#123;&#123; error.statusCode &#125;&#125;&lt;/div&gt;            &lt;div v-if=&quot;error.statusCode == 404&quot; class=&quot;desc&quot;&gt;抱歉！页面走丢了&lt;/div&gt;            &lt;div v-else class=&quot;desc&quot;&gt;抱歉！服务器繁忙&lt;/div&gt;            &lt;el-button @click=&quot;$router.replace(&#39;/home&#39;)&quot;&gt;返回首页&lt;/el-button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;  &lt;script&gt;export default &#123;    props: [&#39;error&#39;]&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.error-container &#123;    background-color: #55aafe;    height: 100vh;    display: flex;    .info &#123;        margin: auto;        color: #fff;        text-align: center;        .code &#123;            font-size: 200px;            font-weight: bold;        &#125;        .desc&#123;            font-size: 30px;            margin: 20px 0;        &#125;    &#125;&#125;&lt;/style&gt;</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期如下: 重点掌握asyncData() 和 mouted()</p><p><img src="/posts/8088d2b5/lifecycle.png" alt="lifecycle"></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>在请求到达之前做一些处理、比如重定向、鉴权等操作</p><h3 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h3><p>新建 middleware&#x2F;middleware.js</p><pre><code class="js">export default function (&#123;app,redirect,route &#125;) &#123;    console.log(&#39;这个会在服务器的控制台打印&#39;)    //默认跳转到 home    if(&quot;/&quot; == route.fullPath || &quot;/zh&quot; == route.fullPath)&#123;        redirect(&#39;/home&#39;)    &#125;&#125;</code></pre><p>nuxt.config.js 配置中间件</p><pre><code class="js">export default &#123;    router: &#123;        middleware: &quot;middleware&quot;, //middleware对应middleware.js的文件名    &#125;    //...&#125;</code></pre><h3 id="命名中间件"><a href="#命名中间件" class="headerlink" title="命名中间件"></a>命名中间件</h3><p>新建middleware&#x2F;auth.js</p><pre><code class="js">//鉴权中间件export default function (&#123; app,store, redirect, route &#125;) &#123;  console.log(&quot;auth middleware&quot;, store.getters.token, &quot;auth url&quot;, route.path);  //白名单  let whiteList = [    &quot;/sign-in&quot;,     &#39;/register&#39;,    &#39;/home&#39;  ];  //let whiteListZh = whiteList.map(m =&gt; app.localePath(m))  //whiteList = [...whiteList,...whiteListZh] //生成中英  if (process.client &amp;&amp; !store.getters.token) &#123;//客户端渲染的页面 没有token    if (!(whiteList.includes(route.path) || whiteList.some(s =&gt; route.path.startsWith(s)))) &#123;//不在白名单       return redirect(&quot;/sign-in&quot;);//跳转登录      //return redirect(app.localePath(&quot;/sign-in&quot;));//跳转登录    &#125;  &#125;&#125;</code></pre><p>在页面组件或者布局组件中</p><pre><code class="html">&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;MyLayout&#39;,  middleware: [&#39;auth&#39;] //当前组件将要受到auth中间件控制&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</code></pre><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><h3 id="asyncData"><a href="#asyncData" class="headerlink" title="asyncData"></a>asyncData</h3><p>asyncData只能用于页面级组件，asyncData不能访问组件实例(this)。它接收上下文作为其参数。Nuxt会自动将返回的对象与组件数据进行浅层合并。 </p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for=&quot;car in carList&quot;&gt;&#123;&#123; car.id + '-' + car.name &#125;&#125;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;Nuxt2StudyIndex&#39;,    data() &#123;        return &#123;            carList: []        &#125;;    &#125;,    //服务端渲染：服务器请求并渲染数据 这个钩子内部不能使用this    async asyncData(ctx) &#123;         //query 等价于 this.$route.query  params 等价于 this.$route.params        console.log(&#39;ctx&#39;, ctx.query,ctx.params)        //模拟发送请求        let carList = await new Promise((resolve, reject) =&gt; &#123;            setTimeout(() =&gt; &#123;                resolve([                    &#123; id: 1, name: &#39;宝马&#39; &#125;,                    &#123; id: 2, name: &#39;奔驰&#39; &#125;,                    &#123; id: 3, name: &#39;五菱&#39; &#125;,                ])            &#125;, 1000);        &#125;)        return &#123; carList &#125; //这个数据将自动合并到组件data()    &#125;&#125;;&lt;/script&gt;</code></pre><h3 id="mouted"><a href="#mouted" class="headerlink" title="mouted"></a>mouted</h3><p>用于客户端渲染,和vue中的一致</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for=&quot;car in carList&quot;&gt;&#123;&#123; car.id + '-' + car.name &#125;&#125;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;Nuxt2StudyIndex&#39;,    data() &#123;        return &#123;            carList: []        &#125;;    &#125;,    //客户端渲染    mounted() &#123;        let cartList = [            &#123;id: 1,name: &#39;宝马&#39;&#125;,            &#123;id: 2,name: &#39;奔驰&#39;&#125;,            &#123;id: 3,name: &#39;五菱&#39;&#125;,        ]         this.carList = cartList    &#125;&#125;;&lt;/script&gt;</code></pre><h2 id="集成sass"><a href="#集成sass" class="headerlink" title="集成sass"></a>集成sass</h2><p>安装</p><pre><code class="shell">npm i sass@1.32.13npm i sass-loader@10.1.1</code></pre><p>页面使用</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;h1&gt;hello nuxt2&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.container&#123;  h1&#123;    color: red;  &#125;&#125;&lt;/style&gt;</code></pre><h2 id="集成elementui"><a href="#集成elementui" class="headerlink" title="集成elementui"></a>集成elementui</h2><p>安装</p><pre><code class="shell">npm i element-ui -S</code></pre><p>新建plugins&#x2F;elementui.js</p><pre><code class="js">import Vue from &#39;vue&#39;;import ElementUI from &#39;element-ui&#39;;Vue.use(ElementUI);</code></pre><p>nuxt.config.js引入elementui.js插件和样式</p><pre><code class="js">export default &#123;    css: [        &quot;element-ui/lib/theme-chalk/index.css&quot;,        &#39;element-ui/lib/theme-chalk/display.css&#39;      ],    plugins: [        &quot;~/plugins/elementui.js&quot;,    ],    //...&#125;</code></pre><p>页面使用</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;el-button type=&quot;primary&quot;&gt;test&lt;/el-button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装</p><pre><code class="shell">npm i @nuxtjs/i18n@7.3.1</code></pre><p>项目根目录新建lang&#x2F;zh.js</p><pre><code class="js">export default &#123;    name: &#39;姓名&#39;,    age: &#39;年龄&#39;&#125;</code></pre><p>项目根目录新建lang&#x2F;en.js</p><pre><code class="js">export default &#123;    name: &#39;name&#39;,    age: &#39;age&#39;&#125;</code></pre><p>项目根目录新建i18n.js</p><pre><code class="js">import en from &quot;./lang/en.js&quot;;import zh from &quot;./lang/zh.js&quot;;import Vue from &quot;vue&quot;;import VueI18n from &quot;vue-i18n&quot;;Vue.use(VueI18n);const i18n = &#123;  locales: [&quot;en&quot;, &quot;zh&quot;], //有多少地区的语言就添加多少种  defaultLocale: &quot;en&quot;, //默认的地区语言  vueI18n: &#123;    fallbackLocale: &quot;en&quot;, //回退策略，指定的locale中没有找到对应资源的情况下使用的locale    messages: &#123;      //要渲染的信息，有多少语言就添加多少种      en,      zh,    &#125;  &#125;,&#125;</code></pre><p>nuxt.config.js</p><pre><code class="js">import i18n from &quot;./i18n.js&quot;; //导入上面的i18n配置文件export default &#123;    //模块  modules: [[&quot;@nuxtjs/i18n&quot;, i18n]],    //...&#125;</code></pre><p>页面中使用</p><p>this.$t(‘key’)  获取当前语言下对应的value值</p><p>this.localePath(url)  根据语言处理路径</p><p>this.$i18n.locale 获取当前语言</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;el-tag type=&quot;primary&quot;&gt;&#123;&#123; $t('name') &#125;&#125;&lt;/el-tag&gt;    &lt;el-tag type=&quot;success&quot;&gt;&#123;&#123; $t('age') &#125;&#125;&lt;/el-tag&gt;    &lt;nuxt-link :to=&quot;url&quot;&gt;本地化路径&lt;/nuxt-link&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Nuxt2StudyIndex&#39;,  data() &#123;    return &#123;      url: &#39;&#39;    &#125;;  &#125;,  mounted() &#123;    //localePath方法可根据语言处理路径 英文：/book/1001 中文：/zh/book/1001    this.url = this.localePath(&#39;/book/1001&#39;)  &#125;&#125;;&lt;/script&gt;</code></pre><p>访问</p><pre><code>英文：http://localhost:3000/中文：http://localhost:3000/zh</code></pre><h3 id="语言切换组件"><a href="#语言切换组件" class="headerlink" title="语言切换组件"></a>语言切换组件</h3><p>components&#x2F;Language.vue</p><pre><code class="html">&lt;template&gt;    &lt;a :href=&quot;webUrl&quot;&gt;        &lt;img :src=&quot;require(&#39;@/assets/images/zh.svg&#39;)&quot; v-if=&quot;$i18n.locale == &#39;en&#39;&quot; @click.prevent=&quot;changeLang(&#39;zh&#39;)&quot;            style=&quot;cursor: pointer&quot; /&gt;        &lt;img :src=&quot;require(&#39;@/assets/images/en.svg&#39;)&quot; v-if=&quot;$i18n.locale == &#39;zh&#39;&quot; @click.prevent=&quot;changeLang(&#39;en&#39;)&quot;            style=&quot;cursor: pointer&quot; /&gt;    &lt;/a&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;Language&#39;,    data() &#123;        return &#123;        &#125;    &#125;,    computed: &#123;        webUrl() &#123;            return this.$i18n.locale == &#39;en&#39; ? &quot;/zh&quot; + this.$route.fullPath : this.$route.fullPath        &#125;    &#125;,    methods: &#123;        // 切换语言        changeLang(lang) &#123;            let url = this.$route.fullPath            url = url.includes(&#39;/zh&#39;) ? url.replace(&#39;/zh&#39;, &#39;&#39;) : &#39;/zh&#39; + url            url = url.replace(&#39;null&#39;, &#39;&#39;)            // location.href = url            this.$router.replace(url)        &#125;    &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;a:hover&#123;    background: #f2f4f7;&#125;a&#123;    padding: 8px!important;&#125;img &#123;    vertical-align: middle;&#125;&lt;/style&gt;</code></pre><h3 id="element-ui-国际化"><a href="#element-ui-国际化" class="headerlink" title="element ui 国际化"></a>element ui 国际化</h3><p>layouts&#x2F;default.vue</p><pre><code class="html">&lt;template&gt;  &lt;!-- 默认布局组件 --&gt;  &lt;div&gt;    &lt;!-- 渲染内容 --&gt;    &lt;Nuxt /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import en from &#39;element-ui/lib/locale/lang/en&#39;import zh from &#39;element-ui/lib/locale/lang/zh-CN&#39;import locale from &#39;element-ui/lib/locale&#39;export default &#123;  name: &#39;Default&#39;,  mounted() &#123;    //elementui国际化    let lang = this.$i18n.locale == &#39;en&#39;? en :zh    locale.use(lang)  &#125;&#125;;&lt;/script&gt;</code></pre><h2 id="SEO的处理"><a href="#SEO的处理" class="headerlink" title="SEO的处理"></a>SEO的处理</h2><h3 id="全局处理"><a href="#全局处理" class="headerlink" title="全局处理"></a>全局处理</h3><p>在nuxt.config.js 中可以给所有页面配置</p><pre><code class="js">export default &#123;  //全局SEO设置  head: &#123;    title: &quot;Tranalysis system&quot;,    htmlAttrs: &#123;      lang: &quot;en&quot;,    &#125;,    meta: [      &#123; charset: &quot;utf-8&quot; &#125;,      &#123; name: &quot;viewport&quot;, content: &quot;width=device-width, initial-scale=1&quot; &#125;,      &#123; hid: &quot;description&quot;, name: &quot;description&quot;, content: &quot;Tranalysis system&quot; &#125;,    ],    link: [&#123; rel: &quot;icon&quot;, type: &quot;image/x-icon&quot;, href: &quot;/favicon.ico&quot; &#125;],  &#125;,&#125;</code></pre><h3 id="单个页面或者布局组件中配置"><a href="#单个页面或者布局组件中配置" class="headerlink" title="单个页面或者布局组件中配置"></a>单个页面或者布局组件中配置</h3><p>这种方式更好，可以支持国际化</p><pre><code class="html">&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    head() &#123;        let title = &#39;标题111&#39;        let description = &#39;描述2222&#39;        return &#123;          title,//网页标题          meta: [            &#123;              hid: &#39;keywords&#39;,              name: &#39;keywords&#39;, //网页关键字              content: title            &#125;,            &#123;              hid: &#39;description&#39;,              name: &#39;description&#39;,//网页描述              content: description            &#125;,          ]        &#125;    &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</code></pre><h2 id="vuex的使用"><a href="#vuex的使用" class="headerlink" title="vuex的使用"></a>vuex的使用</h2><p>和原来的用法一致，nuxt中已经内置vuex，所以不需要安装vuex，只需要安装vuex持久化插件即可</p><p>安装vuex持久化插件</p><pre><code class="shell">npm i vuex-persistedstate@4.1.0</code></pre><p>新建 plugins&#x2F;vuex-persistedstate.js</p><pre><code class="js">import createPersistedState from &#39;vuex-persistedstate&#39;//vuex持久化export default (&#123; store &#125;) =&gt; &#123;    createPersistedState(&#123;        storage: localStorage    &#125;)(store)&#125;</code></pre><p>nuxt.config.js</p><pre><code class="js">export default &#123;  plugins: [    //...    &#123; src: &#39;~/plugins/vuex-persistedstate.js&#39;, ssr: false &#125; //引入vuex-persistedstate插件  ],&#125;</code></pre><p>store&#x2F;modules&#x2F;user.js</p><pre><code class="js">const user = &#123;    state: &#123;        count: 0    &#125;,    mutations: &#123;        SET_COUNT: (state, data) =&gt; &#123;          state.count = data        &#125;,    &#125;,    actions: &#123;&#125;&#125;export default user;</code></pre><p>store&#x2F;getters.js</p><pre><code class="js">const getters = &#123;    count: state =&gt; state.user.count&#125;export default getters</code></pre><p>store&#x2F;index.js</p><pre><code class="js">import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;import user from &quot;./modules/user&quot;;import getters from &quot;./getters&quot;;Vue.use(Vuex);//主要这里要用箭头函数的形式导出，否则会报错export default () =&gt; new Vuex.Store(&#123;  getters,  modules: &#123;    user  &#125;,&#125;);</code></pre><p>组件中使用vuex</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;el-button @click=&quot;add&quot; type=&quot;primary&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/el-button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapGetters,mapMutations&#125; from &#39;vuex&#39;export default &#123;    name: &#39;Nuxt2StudyIndex&#39;,    computed:&#123;        ...mapGetters([&#39;count&#39;])    &#125;,    methods: &#123;        ...mapMutations([&#39;SET_COUNT&#39;]),        add()&#123;            this.SET_COUNT(this.count+1)        &#125;    &#125;,&#125;&lt;/script&gt;</code></pre><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>安装</p><pre><code class="shell">npm i cross-env@7.0.3 -D</code></pre><p>项目根目录新建env.js</p><pre><code class="js">export default &#123;    //开发环境    dev:&#123;      NODE_ENV: &#39;dev&#39;,      PROJECT_TITLE: &#39;NUXT-DEV&#39;,      ENV_API:&#39;http://dev.com/api&#39;,//API地址    &#125;,    //测试环境    stage:&#123;      NODE_ENV: &#39;test&#39;,      PROJECT_TITLE: &#39;NUXT-TEST&#39;,      ENV_API:&#39;http://test.com/api&#39;,//API地址    &#125;,    //正式环境    prod:&#123;      NODE_ENV: &#39;prod&#39;,      PROJECT_TITLE: &#39;NUXT-PRODUCTION&#39;,      ENV_API:&#39;http://prod.com/api&#39;,//API地址    &#125;&#125;</code></pre><p>nuxt.config.js</p><pre><code class="js">import env from &quot;./env.js&quot;; //导入上面的环境变量export default &#123;    env: env[process.env.NODE_ENV] //配置环境变量    //...&#125;</code></pre><p>package.json 配置</p><pre><code class="js">&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;cross-env NODE_ENV=dev nuxt dev&quot;,    &quot;build:stage&quot;: &quot;cross-env NODE_ENV=stage nuxt build&quot;,    &quot;start:stage&quot;: &quot;cross-env NODE_ENV=stage nuxt start&quot;,    &quot;build:prod&quot;: &quot;cross-env NODE_ENV=prod nuxt build&quot;,    &quot;start:prod&quot;: &quot;cross-env NODE_ENV=prod nuxt start&quot;,    &quot;generate:prod&quot;: &quot;cross-env NODE_ENV=prod nuxt generate&quot;,    &quot;generate:stage&quot;: &quot;cross-env NODE_ENV=stage nuxt generate&quot;  &#125;,&#125;</code></pre><p>页面中使用</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &#123;&#123; title &#125;&#125;-&#123;&#123; baseAPI &#125;&#125;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;Nuxt2StudyIndex&#39;,    data() &#123;        return &#123;            title: process.env.PROJECT_TITLE,            baseAPI: process.env.ENV_API        &#125;    &#125;&#125;</code></pre><h2 id="集成axios"><a href="#集成axios" class="headerlink" title="集成axios"></a>集成axios</h2><p>安装</p><pre><code class="shell">npm i @nuxtjs/axios@5.13.6</code></pre><p>plugins&#x2F;axios.js  参考下面按需修改即可</p><pre><code class="js">import &#123; Message &#125; from &quot;element-ui&quot;;import &#123; getToken &#125; from &quot;@/utils/auth&quot;;//get请求参数处理function tansParams(params) &#123;  let result = &quot;&quot;;  for (const propName of Object.keys(params)) &#123;    const value = params[propName];    var part = encodeURIComponent(propName) + &quot;=&quot;;    if (value !== null &amp;&amp; value !== &quot;&quot; &amp;&amp; typeof value !== &quot;undefined&quot;) &#123;      if (typeof value === &quot;object&quot;) &#123;        for (const key of Object.keys(value)) &#123;          if (            value[key] !== null &amp;&amp;            value[key] !== &quot;&quot; &amp;&amp;            typeof value[key] !== &quot;undefined&quot;          ) &#123;            let params = propName + &quot;[&quot; + key + &quot;]&quot;;            var subPart = encodeURIComponent(params) + &quot;=&quot;;            result += subPart + encodeURIComponent(value[key]) + &quot;&amp;&quot;;          &#125;        &#125;      &#125; else &#123;        result += part + encodeURIComponent(value) + &quot;&amp;&quot;;      &#125;    &#125;  &#125;  return result;&#125;export default function (&#123; $axios, redirect, app, store, $router, $route &#125;) &#123;  //如果需要国际化可以：app.i18n.t(&quot;key&quot;)  //请求拦截  $axios.interceptors.request.use(    (config) =&gt; &#123;      const isToken = (config.headers || &#123;&#125;).isToken === false;      if (getToken() &amp;&amp; !isToken) &#123;        config.headers[&quot;Authorization&quot;] = &quot;Bearer &quot; + getToken(); // 让每个请求携带自定义token 请根据实际情况自行修改      &#125;      // get请求映射params参数      if (config.method === &quot;get&quot; &amp;&amp; config.params) &#123;        let url = config.url + &quot;?&quot; + tansParams(config.params);        url = url.slice(0, -1);        config.params = &#123;&#125;;        config.url = url;      &#125;      return config;    &#125;,    (error) =&gt; &#123;      console.log(&quot;axios request error&quot;, error);      return Promise.reject(error);    &#125;  );  //响应拦截  $axios.interceptors.response.use(    (response) =&gt; &#123;      const code = response.data.code || 200;      console.log(&quot;code&quot;, code, &quot;axios response:&quot; + response);      const res = response.data;      //文件下载      if (&quot;business/product/downloadProductData&quot; == response.config.url) &#123;        return res;      &#125;      if (code === 401) &#123;        //登录过期        // if(app.i18n.t(res.msg)) Message(&#123;type: &#39;error&#39;, message: app.i18n.t(res.msg)&#125;)        // store.dispatch(&quot;LogOut&quot;).then(() =&gt; &#123;        //   app.router.push(app.localePath(&quot;/&quot;));        // &#125;);        Message(&#123; type: &quot;error&quot;, message: &quot;登录已过期，请重新登录！&quot; &#125;);        app.router.push(app.localePath(&quot;/&quot;));      &#125; else if (code === 200) &#123;        //普通请求        return res;      &#125; else if (code === 500) &#123;        Message(&#123; type: &quot;error&quot;, message: app.i18n.t(res?.msg) &#125;);        return Promise.reject(new Error(res?.msg || &quot;Error&quot;));      &#125; else &#123;        return res;      &#125;    &#125;,    (error) =&gt; &#123;      console.log(&quot;err&quot; + error);      let &#123; message &#125; = error;      Message(&#123; message, type: &quot;error&quot;, duration: 5 * 1000 &#125;);      return Promise.reject(error);    &#125;  );&#125;</code></pre><p>plugins&#x2F;api.js</p><pre><code class="js">import login from &#39;@/api/login&#39;import menu from &#39;@/api/menu&#39;export default function(&#123; $axios &#125;,inject) &#123;    inject(&#39;loginAPI&#39;,login($axios)) //组件中使用this.$loginAPI.xxx方法名调用    inject(&#39;menuAPI&#39;,menu($axios)) //组件中使用this.$menuAPI.xxx方法名调用&#125;</code></pre><p>api&#x2F;menu.js</p><pre><code class="js">export default function menu(request) &#123;  /**   * 获取菜单   */  const getRouters = (lang,menuSuit=1) =&gt; &#123;    return request(&#123;      url: `/system/menu/getRouters/$&#123;lang&#125;/$&#123;menuSuit&#125;`,      method: &quot;get&quot;,    &#125;);  &#125;;  return &#123;    getRouters,  &#125;;&#125;</code></pre><p>api&#x2F;login.js</p><pre><code class="js">export default function login(request) &#123;    // 注册方法      function register(data) &#123;        return request(&#123;          url: &quot;/auth/register&quot;,          headers: &#123;            isToken: false, //无需携带token          &#125;,          method: &quot;post&quot;,          data: data,        &#125;);      &#125;        // 获取用户详细信息      function getInfo() &#123;        return request(&#123;          url: &quot;/system/user/getInfo&quot;,          method: &quot;get&quot;,        &#125;);      &#125;    return &#123;        register,        getInfo      &#125;;&#125;</code></pre><p>nuxt.config.js 中配置</p><pre><code class="js">export default &#123;    //第一步：配置axios请求前缀    axios: &#123;        // proxyHeaders: false        baseURL: env[process.env.NODE_ENV].ENV_API         //...    &#125;    //第二步：增加axios相关的两个配置    plugins: [        &quot;~/plugins/axios.js&quot;,        &quot;~/plugins/api.js&quot;,         //...    ],    //第三步：模块中增加axios    modules: [&quot;@nuxtjs/axios&quot;, [&quot;@nuxtjs/i18n&quot;, i18n]],    //...&#125;</code></pre><p>页面中使用</p><pre><code class="js">export default &#123;    methods: &#123;        async test()&#123;          //调用方法：plugins/api.js中的 inject(&#39;loginAPI&#39;,login($axios)) 第一个参数前面+$调用          const res = await this.$loginAPI.register(&#123;username: &#39;tom&#39;,password: 123456&#125;)          //await this.$loginAPI.getInfo()          //this.$menuAPI.getRouters()        &#125;    &#125;&#125;</code></pre><h2 id="配置组件自动导入"><a href="#配置组件自动导入" class="headerlink" title="配置组件自动导入"></a>配置组件自动导入</h2><p>nuxt.config.js</p><pre><code class="js">export default &#123;    components: true    //...&#125;</code></pre><h2 id="配置ip和端口"><a href="#配置ip和端口" class="headerlink" title="配置ip和端口"></a>配置ip和端口</h2><p>nuxt.config.js</p><pre><code class="js">export default &#123;    server: &#123;        port: 81, // default: 3000        host: &quot;0.0.0.0&quot;, // default: localhost    &#125;    //...&#125;</code></pre><h2 id="配置src目录"><a href="#配置src目录" class="headerlink" title="配置src目录"></a>配置src目录</h2><p>默认不使用src目录，如果需要配置像下面这样</p><pre><code class="bash">---| node_modules/---| nuxt.config.js---| package.json---| src/------| assets/------| components/------| layouts/------| middleware/------| pages/------| plugins/------| static/------| store/</code></pre><p>则需要在nuxt.config.js中配置</p><pre><code class="js">export default &#123;    srcDir: &quot;./src&quot;    //...&#125;</code></pre><h2 id="svg组件封装"><a href="#svg组件封装" class="headerlink" title="svg组件封装"></a>svg组件封装</h2><p>封装svg组件，方便后续svg图片的使用</p><p>首先安装</p><pre><code class="shell">npm i svg-sprite-loader@6.0.11 -D</code></pre><p>在nuxt.config.js中配置</p><pre><code class="js">const path = require(&#39;path&#39;); //导入path模块export default &#123;    build: &#123;        vendor: [&quot;element-ui&quot;],        extend(config, ctx) &#123;          // ...          const svgRule = config.module.rules.find((rule) =&gt;            rule.test.test(&quot;.svg&quot;)          );          //这里将svg图片拷贝到 》 根目录/static/svg文件夹中          svgRule.exclude = [path.resolve(__dirname, &quot;./static/svg&quot;)];          config.module.rules.push(&#123;            test: /\.svg$/,            include: [path.resolve(__dirname, &quot;./static/svg&quot;)],            loader: &quot;svg-sprite-loader&quot;,            options: &#123;              symbolId: &quot;icon-[name]&quot;,            &#125;,          &#125;);        &#125;,    &#125;,    //...&#125;</code></pre><p>新建 components&#x2F;SvgIcon.vue 组件</p><pre><code class="html">&lt;!-- nuxt中使用svg https://blog.csdn.net/qq_26373925/article/details/108405038 --&gt;&lt;template&gt;    &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;        &lt;use :xlink:href=&quot;iconName&quot; /&gt;    &lt;/svg&gt;&lt;/template&gt;  &lt;script&gt;export default &#123;    name: &#39;SvgIcon&#39;,    props: &#123;        iconClass: &#123;            type: String,            required: true        &#125;,        className: &#123;            type: String,            default: &#39;&#39;        &#125;    &#125;,    computed: &#123;        iconName() &#123;            console.log(&#39;iconClass&#39;, this.iconClass)            return `#icon-$&#123;this.iconClass&#125;`        &#125;,        svgClass() &#123;            return this.className ? &#39;svg-icon &#39; + this.className : &#39;svg-icon&#39;        &#125;    &#125;&#125;&lt;/script&gt;  &lt;style scoped&gt;.svg-icon &#123;    width: 1em;    height: 1em;    font-size: 1.2em;    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;&#125;&lt;/style&gt;</code></pre><p>页面中使用</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;!--dashboard 对应 static/svg/dashboard.svg--&gt;        &lt;svg-icon icon-class=&quot;dashboard&quot; /&gt; &lt;span slot=&quot;title&quot;&gt;首页&lt;/span&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h2 id="静态资源引入"><a href="#静态资源引入" class="headerlink" title="静态资源引入"></a>静态资源引入</h2><p>static目录和assets目录，都是用来存储静态文件的</p><pre><code>assets中的资源会被webpack处理，打包后会在dist中合并成一个文件；static中的资源不会被webpack处理，打包后直接复制到dist（默认是dist/static）下推荐assets中存放自己的资源（css、images、utils等），static中放第三方资源（pdf.js、iconfont等）动态绑定中，assets的图片会加载失败，因为webpack使用commonJS规范，需要使用require引入图片（可以通过import的方式引入）</code></pre><p>assets 需要 require引入</p><pre><code class="html">&lt;!--assets/images/zh.svg--&gt;&lt;img :src=&quot;require(&#39;@/assets/images/zh.svg&#39;)&quot; /&gt;</code></pre><p>static直接映射到服务器根目录，可以通过项目根URL访问</p><pre><code class="html">&lt;!--static/images/pay/ali.png--&gt;&lt;img src=&quot;/images/pay/ali.png&quot; width=&quot;40&quot;&gt;</code></pre><h2 id="集成tailwindcss"><a href="#集成tailwindcss" class="headerlink" title="集成tailwindcss"></a>集成tailwindcss</h2><p>安装</p><pre><code class="shell">npm i @nuxtjs/tailwindcss@6.10.1</code></pre><p>项目根目录 创建 tailwind.config.js</p><pre><code class="js">/** @type &#123;import(&#39;tailwindcss&#39;).Config&#125; */module.exports = &#123;  content: [],  theme: &#123;    extend: &#123;&#125;,  &#125;,  plugins: [],&#125;</code></pre><p>项目根目录 创建 assets&#x2F;css&#x2F;tailwind.css</p><pre><code class="css">@tailwind base;@tailwind components;@tailwind utilities;</code></pre><p>在nuxt.config.js中配置</p><pre><code class="js">export default &#123;    buildModules: [&#39;@nuxtjs/tailwindcss&#39;],    tailwindcss: &#123;        cssPath: &#39;~/assets/css/tailwind.css&#39;,        configPath: &#39;tailwind.config.js&#39;,        exposeConfig: false,        config: &#123;&#125;    &#125;,    //...&#125;</code></pre><h2 id="nuxt2项目模板"><a href="#nuxt2项目模板" class="headerlink" title="nuxt2项目模板"></a>nuxt2项目模板</h2><p>自建nuxt2项目模板 <a href="https://gitee.com/heliufang/nuxt2-template">nuxt2-template</a></p>]]></content>
    
    
    <summary type="html">nuxt2基础、以及整合elementui、tailwindcss、axios、i18n国际化等等</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="nuxt" scheme="https://heliufang.github.io/tags/nuxt/"/>
    
  </entry>
  
  <entry>
    <title>js格式化时间间隔</title>
    <link href="https://heliufang.github.io/posts/31559881/"/>
    <id>https://heliufang.github.io/posts/31559881/</id>
    <published>2023-12-11T08:50:28.000Z</published>
    <updated>2024-01-12T13:46:14.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>js计算时间间隔要求如下：</p><pre><code>小于1分钟：刚刚        60小于1小时：几分钟前    60*60小于1天：几小时前      60*60*24小于1周：几天前        60*60*24*7小于1月：几周前        60*60*24*30小于1年：几个月前      60*60*24*365大于1年：几年前        60*60*24*365</code></pre><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>formatTimeFromNowZh-中文方法<br>formatTimeFromNowEn-英文方法</p><pre><code class="js">//1.中文方法function formatTimeFromNowZh(time) &#123;  // if ((&quot;&quot; + time).length === 10) &#123;  //   time = parseInt(time) * 1000;  // &#125; else &#123;  //   time = +time;  // &#125;  const d = new Date(time);  const now = Date.now();  const diff = (now - d) / 1000;  // console.log(&#39;formatTimeFromNowZh time&#39;, time,&#39;diff&#39;,diff)  if(diff &lt; 0)&#123;//未来时间    return time  &#125;  if (diff &lt; 60) &#123;    return &quot;刚刚&quot;;  &#125; else if (diff &lt; 3600) &#123;    return Math.floor(diff / 60) + &quot;分钟前&quot;;  &#125; else if (diff &lt; 3600 * 24) &#123;    return Math.floor(diff / 3600) + &quot;小时前&quot;;  &#125; else if (diff &lt; 3600 * 24 * 7) &#123;    return Math.floor(diff / (3600 * 24))+&quot;天前&quot;;  &#125;else if (diff &lt; 3600 * 24 * 30) &#123;    return Math.floor(diff / (3600 * 24 * 7))+&quot;周前&quot;;  &#125;else if (diff &lt; 3600 * 24 * 365) &#123;    let m = Math.floor(diff / (3600 * 24 * 30))    m = m==12?11:m    return m+&quot;月前&quot;;  &#125;else if (diff &gt;= 3600 * 24 * 365) &#123;    return Math.floor(diff / (3600 * 24 * 365))+&quot;年前&quot;;  &#125;else&#123;    return time  &#125;&#125;//2.英文方法function formatTimeFromNowEn(time) &#123;  // if ((&quot;&quot; + time).length === 10) &#123;  //   time = parseInt(time) * 1000;  // &#125; else &#123;  //   time = +time;  // &#125;  const d = new Date(time);  const now = Date.now();  const diff = (now - d) / 1000;  if(diff &lt; 0)&#123;//未来时间    return time  &#125;  if (diff &lt; 60) &#123;    return &quot;Just now&quot;;  &#125; else if (diff &lt; 3600) &#123;    let suffix = Math.floor(diff / 60) &gt; 1?&quot;minutes ago&quot;:&quot;minute ago&quot;    return Math.floor(diff / 60) +&quot; &quot;+suffix;  &#125; else if (diff &lt; 3600 * 24) &#123;    let suffix = Math.floor(diff / 3600) &gt; 1?&quot;hours ago&quot;:&quot;hour ago&quot;    return Math.floor(diff / 3600)+&quot; &quot; + suffix;  &#125; else if (diff &lt; 3600 * 24 * 7) &#123;    let suffix = Math.floor(diff / (3600 * 24)) &gt; 1?&quot;days ago&quot;:&quot;day ago&quot;    return Math.floor(diff / (3600 * 24))+&quot; &quot;+suffix;  &#125;else if (diff &lt; 3600 * 24 * 30) &#123;    let suffix =Math.floor(diff / (3600 * 24 * 7)) &gt; 1?&quot;weeks ago&quot;:&quot;week ago&quot;    return Math.floor(diff / (3600 * 24 * 7))+&quot; &quot;+suffix;  &#125;else if (diff &lt; 3600 * 24 * 365) &#123;    let m = Math.floor(diff / (3600 * 24 * 30))    m = m==12?11:m    let suffix = m &gt; 1?&quot;months ago&quot;:&quot;month ago&quot;    return m+&quot; &quot;+suffix;  &#125;else if (diff &gt;= 3600 * 24 * 365) &#123;    let suffix = Math.floor(diff / (3600 * 24 * 30)) &gt; 1?&quot;years ago&quot;:&quot;year ago&quot;    return Math.floor(diff / (3600 * 24 * 365))+&quot; &quot;+suffix;  &#125;else&#123;    return time  &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">js格式化时间间隔，格式（刚刚 几分钟前 几小时前 几天前  几周前 几个月前 几年前）</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://heliufang.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue和react封装echart组件</title>
    <link href="https://heliufang.github.io/posts/b1adc31a/"/>
    <id>https://heliufang.github.io/posts/b1adc31a/</id>
    <published>2023-12-11T08:34:28.000Z</published>
    <updated>2024-01-12T13:46:14.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue封装echart"><a href="#Vue封装echart" class="headerlink" title="Vue封装echart"></a>Vue封装echart</h2><p>安装ResizeListener</p><pre><code>npm i element-resize-detector@1.2.4</code></pre><p>VueEchart组件</p><pre><code class="html">&lt;template&gt;    &lt;div :class=&quot;className&quot;&gt;&lt;/div&gt;&lt;/template&gt;    &lt;script&gt;  import &#123; merge &#125; from &quot;lodash&quot;;  import * as echarts from &quot;echarts&quot;;  import ResizeListener from &quot;element-resize-detector&quot;;    export default &#123;    name: &quot;NuxtEchart&quot;,    props: &#123;      options: &#123;        type: Object,        default: () =&gt; (&#123;&#125;),      &#125;,      className: &#123;        type: String,        default: &#39;def&#39;      &#125;,    &#125;,    data() &#123;      return &#123;        chart: null,      &#125;;    &#125;,    watch: &#123;      options: &#123;        deep: true,        handler() &#123;          this.updateChartView();        &#125;,      &#125;,    &#125;,    mounted() &#123;      this.chart = echarts.init(this.$el);      this.updateChartView();      window.addEventListener(&quot;resize&quot;, this.handleWindowResize);      this.addChartResizeListener();      // 监听 &#39;click&#39; 事件        this.chart.on(&#39;click&#39;, (params) =&gt; &#123;            this.$emit(&#39;click&#39;,params)      &#125;);    &#125;,    beforeDestroy() &#123;      window.removeEventListener(&quot;resize&quot;, this.handleWindowResize);    &#125;,    methods: &#123;      myChart()&#123;        return this.chart      &#125;,      mergeOption() &#123;        return merge(          &#123;            //backgroundColor: &quot;#ffffff&quot;,            // textStyle:&#123;            //   color:&#39;#A5D7FA&#39;,            //   fontSize:15            // &#125;          &#125;,          this.options        );      &#125;,        //对chart元素尺寸进行监听，当发生变化时同步更新echart视图      addChartResizeListener() &#123;        const instance = ResizeListener(&#123;          strategy: &quot;scroll&quot;,          callOnAdd: true,        &#125;);          instance.listenTo(this.$el, () =&gt; &#123;          if (!this.chart) return;          this.chart.resize();        &#125;);      &#125;,        //更新echart视图      updateChartView() &#123;        if (!this.chart) return;        this.chart.setOption(this.mergeOption(), true);      &#125;,        // 当窗口缩放时，echart动态调整自身大小      handleWindowResize() &#123;        if (!this.chart) return;        this.chart.resize();      &#125;,    &#125;,  &#125;;  &lt;/script&gt;  &lt;style  scoped&gt;  .def &#123;    width: 100%;    height: 100%;  &#125;  &lt;/style&gt;  </code></pre><h2 id="React封装echart"><a href="#React封装echart" class="headerlink" title="React封装echart"></a>React封装echart</h2><p>ReactEchart组件</p><pre><code class="jsx">import React, &#123; useEffect,useRef &#125; from &quot;react&quot;;import * as echarts from &quot;echarts&quot;;//自定义echart组件export default function ReactEcharts(&#123; option,width,height &#125;) &#123;  const echartRef = useRef()  useEffect(() =&gt; &#123;    setTimeout(() =&gt; &#123;        initChart();    &#125;);  &#125;, [option]);  /*生成图表，做了判断，如果不去判断dom有没有生成，每次更新图表都要生成一个dom节点*/  const initChart = () =&gt; &#123;    // 基于准备好的dom，初始化echarts实例    let myChart = echarts.getInstanceByDom(echartRef.current);    if (myChart === undefined) &#123;      myChart = echarts.init(echartRef.current);    &#125;    // 绘制图表，option设置图表格式及源数据    myChart.setOption(option);    //响应式    window.addEventListener(&#39;resize&#39;, function () &#123;      myChart.resize();    &#125;);  &#125;;  return (    &lt;div ref=&#123;echartRef&#125; style=&#123;&#123; height: height?height:400,width:width?width:'100%' &#125;&#125;&gt;&lt;/div&gt;  );&#125;</code></pre>]]></content>
    
    
    <summary type="html">整理项目中vue和react两种框架下echart组件的封装</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="echart" scheme="https://heliufang.github.io/tags/echart/"/>
    
  </entry>
  
  <entry>
    <title>Nextjs入门笔记</title>
    <link href="https://heliufang.github.io/posts/b4b4770b/"/>
    <id>https://heliufang.github.io/posts/b4b4770b/</id>
    <published>2023-12-11T08:20:28.000Z</published>
    <updated>2024-01-12T13:46:14.026Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nextjs.org/docs/getting-started/installation">Nextjs英文官网</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>nextjs是基于react语法来实现SSR(服务器渲染)的框架，解决单页应用不利于SEO的问题</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>环境说明</p><ul><li>node v18</li><li>next v14</li></ul><p>执行下面的命令</p><pre><code class="shell">npx create-next-app@latest</code></pre><p>然后依次选择</p><pre><code>H:\study\next-study&gt;npx create-next-app@latestNeed to install the following packages:  create-next-app@latestOk to proceed? (y) ynpm WARN EBADENGINE Unsupported engine &#123;npm WARN EBADENGINE   package: &#39;create-next-app@14.0.3&#39;,npm WARN EBADENGINE   required: &#123; node: &#39;&gt;=18.17.0&#39; &#125;,npm WARN EBADENGINE   current: &#123; node: &#39;v16.15.0&#39;, npm: &#39;8.5.5&#39; &#125;npm WARN EBADENGINE &#125;√ What is your project named? ... my-app√ Would you like to use TypeScript? ... No / Yes #使用ts√ Would you like to use ESLint? ... No / Yes  #使用eslint校验√ Would you like to use Tailwind CSS? ... No / Yes #使用Tailwind CSS样式库√ Would you like to use `src/` directory? ... No / Yes #使用src目录√ Would you like to use App Router? (recommended) ... No / Yes #使用app路由√ Would you like to customize the default import alias (@/*)? ... No / Yes  #使用@相对路径√ What import alias would you like configured? ... @/*</code></pre><p>启动</p><pre><code class="shell">npm run dev</code></pre><p>访问：<a href="http://localhost:3000/">http://localhost:3000/</a></p><h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><pre><code>- public 静态资源目录- src   - app 页面目录（重点）    - favicon.ico 网站favicon.ico图标    - globals.css 全局css文件    - layout.tsx 根布局组件（重点）    - page.tsx 默认页面（重点）- next.config.js 核心配置文件- postcss.config.js postcss配置文件- tailwind.config.ts tailwindcss配置文件- tsconfig.json ts配置文件</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h3><p>Next.js使用基于文件系统的路由器，其中文件夹用于定义路由。 文件夹中的page.jsx&#x2F;page.tsx&#x2F;page.js文件代表的就是页面。</p><p>【案例：定义路由】</p><p>创建a页面：src&#x2F;app&#x2F;a&#x2F;page.tsx   访问a页面：<a href="http://localhost:3000/a">http://localhost:3000/a</a></p><pre><code class="jsx">import React from &#39;react&#39;const page = () =&gt; &#123;  return (    &lt;div&gt;a页面&lt;/div&gt;  )&#125;export default page</code></pre><p>创建b页面：src&#x2F;app&#x2F;a&#x2F;b&#x2F;page.tsx  访问b页面：<a href="http://localhost:3000/a/b">http://localhost:3000/a/b</a></p><pre><code class="jsx">import React from &#39;react&#39;const page = () =&gt; &#123;  return (    &lt;div&gt;b页面&lt;/div&gt;  )&#125;export default page</code></pre><p>可以看到创建了两个嵌套的文件夹,文件夹可以无限嵌套。</p><p>页面使用page.tsx导出一个react组件，其中<a href="http://localhost:3000/">http://localhost:3000</a> 访问的就是src&#x2F;app&#x2F;page.tsx</p><h3 id="layout布局"><a href="#layout布局" class="headerlink" title="layout布局"></a>layout布局</h3><p>布局是在多个页面之间共享的用户界面。在导航中，布局保留状态，保持交互，并且不重新呈现。布局也可以嵌套。 </p><p>【案例：定义布局】</p><p>创建根布局：src&#x2F;app&#x2F;layout.tsx  </p><blockquote><p>1.根布局是所有页面共享的布局,并且是必须的</p><p>2.只有根布局可以包含&lt; html &gt;和&lt; body &gt;标记。</p></blockquote><pre><code class="jsx">import type &#123; Metadata &#125; from &#39;next&#39;import &#39;./globals.css&#39;export const metadata: Metadata = &#123; //定义网站的seo  title: &#39;Create Next App&#39;,  description: &#39;Generated by create next app&#39;,&#125;export default function RootLayout(&#123;children&#125;: &#123;children: React.ReactNode&#125;) &#123;  return (    &lt;html lang=&quot;en&quot;&gt;      &lt;body className=&quot;bg-slate-400&quot;&gt;根布局：&#123;children&#125;&lt;/body&gt;    &lt;/html&gt;  )&#125;</code></pre><p>创建a页面的布局：src&#x2F;app&#x2F;a&#x2F;layout.tsx</p><pre><code class="jsx">import React from &#39;react&#39;const layout = (&#123;children&#125;:&#123;children:React.ReactNode&#125;) =&gt; &#123;  return (    &lt;div&gt;layoutA:&#123;children&#125;&lt;/div&gt;  )&#125;export default layout</code></pre><p>访问<a href="http://localhost:3000/a">http://localhost:3000/a</a>   </p><p><img src="/posts/b4b4770b/1701851198502.png" alt="1701851198502"></p><h3 id="Link导航组件"><a href="#Link导航组件" class="headerlink" title="Link导航组件"></a>Link导航组件</h3><p>Link组件可以使用页面跳转c</p><p>创建c页面：src&#x2F;app&#x2F;c&#x2F;page.tsx </p><pre><code class="jsx">import React from &#39;react&#39;import Link from &#39;next/link&#39;const page = () =&gt; &#123;  return (    &lt;div&gt;      c组件&lt;br /&gt;      &lt;Link className=&#39;text-blue-600&#39; href=&quot;/a&quot;&gt;去a组件&lt;/Link&gt;      &lt;/div&gt;  )&#125;export default page</code></pre><h3 id="usePathname"><a href="#usePathname" class="headerlink" title="usePathname"></a>usePathname</h3><p>这个hook可以获取路由地址</p><p>创建d页面：src&#x2F;app&#x2F;d&#x2F;page.tsx </p><pre><code class="jsx">&#39;use client&#39; //表示这个是一个客户端组件import React from &#39;react&#39;import &#123; usePathname &#125; from &#39;next/navigation&#39;const page = () =&gt; &#123;    const pathname = usePathname()    return (        &lt;div&gt;pathname: &#123;pathname&#125;&lt;/div&gt;    )&#125;export default page</code></pre><h3 id="useRouter"><a href="#useRouter" class="headerlink" title="useRouter"></a>useRouter</h3><p>这个hook可以实现编程式导航</p><p>创建e页面：src&#x2F;app&#x2F;d&#x2F;page.tsx </p><pre><code class="jsx">&#39;use client&#39;import React from &#39;react&#39;import &#123; useRouter &#125; from &#39;next/navigation&#39;const page = () =&gt; &#123;  const router = useRouter()  return (    &lt;div&gt;编程式导航：&lt;br /&gt;        &lt;button onClick=&#123;() =&gt; router.push(&#39;/d&#39;)&#125;&gt;跳转到d页面&lt;/button&gt;    &lt;/div&gt;  )&#125;export default page</code></pre><h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><p>路由组的命名除了对组织而言没有特殊意义。它们不影响URL路径。 </p><p>如下用括号进行分组，不会影响URL路径。</p><p><img src="/posts/b4b4770b/1701852815965.png" alt="1701852815965"></p><pre><code>http://localhost:3000/bookhttp://localhost:3000/userhttp://localhost:3000/adminhttp://localhost:3000/shop</code></pre><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>一般用于一些详情页面，比如商品详情、新闻详情等</p><p>创建product页面：src&#x2F;app&#x2F;product&#x2F;[id]&#x2F;page.tsx </p><pre><code class="jsx">import React from &#39;react&#39;const page = (&#123;params&#125;: &#123;params: &#123;id: number&#125;&#125;) =&gt; &#123;  return (    &lt;div&gt;product: &#123;params.id&#125;&lt;/div&gt;  )&#125;export default page</code></pre><p>访问：<a href="http://localhost:3000/product/123">http://localhost:3000/product/123</a></p><h3 id="loading组件"><a href="#loading组件" class="headerlink" title="loading组件"></a>loading组件</h3><p>用户展示loading效果</p><p>新增loading.tsx组件</p><pre><code class="jsx">import React from &#39;react&#39;import &#39;./style.css&#39;const loading = () =&gt; &#123;  return (    &lt;div className=&#39;text-red-500&#39;&gt;loading...&lt;/div&gt;  )&#125;export default loading</code></pre><p>新增layout.tsx布局</p><pre><code class="jsx">import &#123; Suspense &#125; from &#39;react&#39;import Loading from &#39;./loading&#39;export default function Layout(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123;    return (    &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;        &lt;div&gt;layoutE:&#123;children&#125;&lt;/div&gt;    &lt;/Suspense&gt;    )&#125;</code></pre><p>新增page.tsx布局</p><pre><code class="jsx">&#39;use client&#39;import React from &#39;react&#39;const page = async () =&gt; &#123;  const router = useRouter()  //模拟服务器请求数据渲染  await new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(&#39;服务器渲染ok&#39;)    &#125;, 2000);  &#125;)  return (    &lt;div&gt;我来了&lt;/div&gt;  )&#125;export default page</code></pre><p>参考：<a href="https://www.cnblogs.com/azoux/p/17289923.html">Next.js 13 如何使用loading.js</a></p><h3 id="error组件"><a href="#error组件" class="headerlink" title="error组件"></a>error组件</h3><p>创建一个和page.tsx同级的error.tsx</p><pre><code class="jsx">&#39;use client&#39; // Error components must be Client Components import &#123; useEffect &#125; from &#39;react&#39; export default function Error(&#123; error,reset&#125;: &#123;error: Error &amp; &#123; digest?: string &#125;,reset: () =&gt; void&#125;) &#123;      useEffect(() =&gt; &#123;    console.error(error)  &#125;, [error])   return (    &lt;div&gt;      &lt;h2&gt;Something went wrong!&lt;/h2&gt;      &lt;button        onClick=&#123;() =&gt; reset()&#125;      &gt;        Try again      &lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>page.tsx中抛出错误</p><pre><code class="jsx">&#39;use client&#39;import React from &#39;react&#39;const page = async () =&gt; &#123;  const router = useRouter()  //模拟服务器请求数据渲染  await new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      reject(&#39;服务器渲染error&#39;)    &#125;, 2000);  &#125;)  return (    &lt;div&gt;我来了&lt;/div&gt;  )&#125;export default page</code></pre><h3 id="404组件"><a href="#404组件" class="headerlink" title="404组件"></a>404组件</h3><p>app&#x2F;not-found.tsx ,当页面找不到的时候就会展示这个组件。(<strong>名字固定</strong>)</p><pre><code class="jsx">export default function NotFound() &#123;  return (    &lt;div&gt;      &lt;h2&gt;Not Found&lt;/h2&gt;      &lt;p&gt;Could not find requested resource&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><p>特殊情况：当有动态路由时，那么上面的not-found组件无效，需要使用[…not_found]</p><p>app&#x2F;[lang]&#x2F;[…not_found]&#x2F;page.tsx    </p><pre><code class="jsx">export default function NotFound(props) &#123;    return (    &lt;div&gt;      &lt;h2&gt;Not Found&lt;/h2&gt;      &lt;p&gt;Could not find requested resource&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><p>参考：<a href="https://stackoverflow.com/questions/75302340/not-found-page-does-not-work-in-next-js-13">https://stackoverflow.com/questions/75302340/not-found-page-does-not-work-in-next-js-13</a></p><h3 id="并行路由"><a href="#并行路由" class="headerlink" title="并行路由"></a>并行路由</h3><p>并行路由允许在同一布局中同时或有条件地呈现一个或多个页面。对于应用程序的高度动态部分，并行路由可用于实现复杂的路由模式。 </p><blockquote><p>1.并行路由是使用命名文件夹创建的。文件夹名是用 <strong>@文件名</strong> 约定定义的，并作为<code>props</code>传递给<strong>同一级别</strong>的布局。 </p><p>2.并行路由文件夹中也支持error.tsx和loading.tsx</p></blockquote><p>创建src&#x2F;app&#x2F;@analytics&#x2F;page.tsx页面</p><pre><code class="jsx">import React from &#39;react&#39;const page = () =&gt; &#123;  return (    &lt;&gt;analytics page&lt;/&gt;  )&#125;export default page</code></pre><p>创建src&#x2F;app&#x2F;@team&#x2F;page.tsx页面</p><pre><code class="jsx">import React from &#39;react&#39;const page = () =&gt; &#123;  return (    &lt;&gt;team page&lt;/&gt;  )&#125;export default page</code></pre><p>修改src&#x2F;app&#x2F;layout.tsx</p><pre><code class="jsx">import type &#123; Metadata &#125; from &#39;next&#39;import &#39;./globals.css&#39;import React from &#39;react&#39;export const metadata: Metadata = &#123;  title: &#39;Create Next App&#39;,  description: &#39;Generated by create next app&#39;,&#125;// export default function RootLayout(&#123;children&#125;: &#123;children: React.ReactNode&#125;) &#123;export default function RootLayout(props: &#123;  children: React.ReactNode,  team: React.ReactNode, //接受并行路由  analytics: React.ReactNode,//接受并行路由&#125;) &#123;  return (    &lt;html lang=&quot;en&quot;&gt;      &lt;body className=&quot;bg-slate-400&quot;&gt;        根布局：&#123;props.children&#125;        &lt;div className=&#39;text-blue-500&#39;&gt;team: &#123;props.team&#125;&lt;/div&gt;        &lt;div className=&#39;text-green-400&#39;&gt;analytics: &#123;props.analytics&#125;&lt;/div&gt;        &lt;/body&gt;    &lt;/html&gt;  )&#125;</code></pre><p>此时访问<a href="http://localhost:3000/%E5%8F%AF%E4%BB%A5%E5%B9%B6%E8%A1%8C%E8%B7%AF%E7%94%B1%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%80%8C%E8%AE%BF%E9%97%AE%E5%85%B6%E5%AE%83%E7%BA%A7%E5%88%AB%E6%AF%94%E5%A6%82http://localhost:3000/a%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B9%B6%E8%A1%8C%E8%B7%AF%E7%94%B1%E6%97%A0%E6%B3%95%E5%B1%95%E7%A4%BA%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%B9%B6%E8%A1%8C%E8%B7%AF%E7%94%B1%E4%BD%9C%E4%B8%BA%60props%60%E5%8F%AA%E4%BC%A0%E9%80%92%E7%BB%99**%E5%90%8C%E4%B8%80%E7%BA%A7%E5%88%AB**%E7%9A%84%E5%B8%83%E5%B1%80">http://localhost:3000/可以并行路由可以正常展示，而访问其它级别比如http://localhost:3000/a，那么并行路由无法展示，因为并行路由作为`props`只传递给**同一级别**的布局</a></p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件允许在请求完成之前运行代码。然后，根据传入的请求，可以通过重写、重定向、修改请求或响应头或直接响应来修改响应。 （类似拦截器）</p><blockquote><p>新建文件middleware.ts(或js,文件名固定)来定义中间件。与pages或app处于同一级别，或者在src内部。 </p></blockquote><p>比如下面定义的一个用于国际化的中间件</p><pre><code class="jsx">import &#123; NextResponse &#125; from &#39;next/server&#39; let locales = [&#39;en&#39;, &#39;zh&#39;] // Get the preferred locale, similar to above or using a libraryfunction getLocale(request) &#123;  //设置默认语言    return &#39;zh&#39;&#125; export function middleware(request) &#123;  const pathname = request.nextUrl.pathname  //判断不是/en 或者/zh开头  const pathnameIsMissingLocale = locales.every(    (locale) =&gt; !pathname.startsWith(`/$&#123;locale&#125;/`) &amp;&amp; pathname !== `/$&#123;locale&#125;`  )   // 如果不是/en 或者/zh开头 那么重定向到/zh或者/en  if (pathnameIsMissingLocale) &#123;    const locale = getLocale(request)    return NextResponse.redirect(      new URL(`/$&#123;locale&#125;/$&#123;pathname&#125;`, request.url)    )  &#125;&#125;//不需要拦截的路径export const config = &#123;  matcher: [    // Skip all internal paths (_next)    //&#39;/((?!_next).*)&#39;,    // Optional: only run on root (/) URL    // &#39;/&#39;    &#39;/((?!api|_next/static|_next/image|favicon.ico|resources).*)&#39;  ],&#125;</code></pre><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件有客户端组件(由浏览器渲染的组件)、服务端组件(由服务器渲染的组件)、内置组件</p><p>客户端组件和服务端组件需要自己编写，默认是服务端组件，内置组件由next提供。</p><h3 id="服务端组件"><a href="#服务端组件" class="headerlink" title="服务端组件"></a>服务端组件</h3><p>默认就是服务器组件，按照react组件的写法即可</p><h3 id="客户端组件"><a href="#客户端组件" class="headerlink" title="客户端组件"></a>客户端组件</h3><p>需要在组件的第一行加上<code>use client</code></p><h3 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h3><h4 id="Image组件"><a href="#Image组件" class="headerlink" title="Image组件"></a>Image组件</h4><p>用法和img标签类似，只不过做了性能优化</p><pre><code class="jsx">import Image from &#39;next/image&#39; export default function Page() &#123;  return (    &lt;Image      src=&quot;/profile.png&quot;      width=&#123;500&#125;      height=&#123;500&#125;      alt=&quot;Picture of the author&quot;    /&gt;  )&#125;</code></pre><p>Image组件可配置的属性如下：</p><table><thead><tr><th>Prop</th><th>Example</th><th>Type</th><th>Status</th></tr></thead><tbody><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#src"><code>src</code></a></td><td><code>src=&quot;/profile.png&quot;</code></td><td>String</td><td>Required</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#width"><code>width</code></a></td><td><code>width=&#123;500&#125;</code></td><td>Integer (px)</td><td>Required</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#height"><code>height</code></a></td><td><code>height=&#123;500&#125;</code></td><td>Integer (px)</td><td>Required</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#alt"><code>alt</code></a></td><td><code>alt=&quot;Picture of the author&quot;</code></td><td>String</td><td>Required</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#loader"><code>loader</code></a></td><td><code>loader=&#123;imageLoader&#125;</code></td><td>Function</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#fill"><code>fill</code></a></td><td><code>fill=&#123;true&#125;</code></td><td>Boolean</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#sizes"><code>sizes</code></a></td><td><code>sizes=&quot;(max-width: 768px) 100vw, 33vw&quot;</code></td><td>String</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#quality"><code>quality</code></a></td><td><code>quality=&#123;80&#125;</code></td><td>Integer (1-100)</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#priority"><code>priority</code></a></td><td><code>priority=&#123;true&#125;</code></td><td>Boolean</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#placeholder"><code>placeholder</code></a></td><td><code>placeholder=&quot;blur&quot;</code></td><td>String</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#style"><code>style</code></a></td><td><code>style=&#123;&#123;objectFit: "contain"&#125;&#125;</code></td><td>Object</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#onloadingcomplete"><code>onLoadingComplete</code></a></td><td><code>onLoadingComplete=&#123;img =&gt; done())&#125;</code></td><td>Function</td><td>Deprecated</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#onload"><code>onLoad</code></a></td><td><code>onLoad=&#123;event =&gt; done())&#125;</code></td><td>Function</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#onerror"><code>onError</code></a></td><td><code>onError(event =&gt; fail()&#125;</code></td><td>Function</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#loading"><code>loading</code></a></td><td><code>loading=&quot;lazy&quot;</code></td><td>String</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#blurdataurl"><code>blurDataURL</code></a></td><td><code>blurDataURL=&quot;data:image/jpeg...&quot;</code></td><td>String</td><td>-</td></tr></tbody></table><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>服务器渲染：在服务器上请求数据并渲染好组件</p><pre><code class="jsx">import React from &#39;react&#39;interface IUser &#123;    name: string,    age: number&#125;//1.请求数据的方法const getData = async () =&gt; &#123;    //模拟后端请求，这里也可以换成第三方的请求库，比如axios    const res: IUser = await new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve(&#123; name: &#39;tom&#39;, age: 18 &#125;)        &#125;, 1000);    &#125;)    console.log(&#39;getData res&#39;, res)    return res&#125;//2.使用async关键字标记组件export default async function page() &#123;    //3.请求数据并渲染组件    const data = await getData()    return (        &lt;div&gt;            &lt;div&gt;name: &#123;data.name&#125;&lt;/div&gt;            &lt;div&gt;age: &#123;data.age&#125;&lt;/div&gt;        &lt;/div&gt;    )&#125;</code></pre><p>客户端渲染：和react的写法一直，在useEffect中发送请求，渲染数组即可</p><h2 id="Metadata配置"><a href="#Metadata配置" class="headerlink" title="Metadata配置"></a>Metadata配置</h2><p>静态配置：直接写死</p><pre><code class="jsx">import type &#123; Metadata &#125; from &#39;next&#39; export const metadata: Metadata = &#123;  title: &#39;...&#39;,  description: &#39;...&#39;,&#125; export default function Page() &#123;&#125;</code></pre><p>动态配置：获取数据之后在配置</p><p> app&#x2F;[lang]&#x2F;news&#x2F;[id]&#x2F;page.tsx </p><pre><code class="jsx">import &#123;getData&#125; from &#39;@/api/news&#39;export async function generateMetadata(&#123; params &#125;) &#123;  const &#123; lang, id &#125; = params;  const res = await getData(id); //获取数据  let title = lang == &quot;zh&quot; ? &#39;中文标题&#39; : &#39;英文标题&#39;;  let description = lang == &quot;zh&quot; ? &#39;中文描述&#39; : &#39;英文描述&#39;;  return &#123;    title,    description,    keywords: title  &#125;;&#125;export default function Page() &#123;&#125;</code></pre><h2 id="相对路径的配置"><a href="#相对路径的配置" class="headerlink" title="@相对路径的配置"></a>@相对路径的配置</h2><p>tsconfig.json文件中paths对象中配置</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;paths&quot;: &#123;      &quot;@/api/*&quot;: [&quot;api/*&quot;],      &quot;@/components/*&quot;: [&quot;components/*&quot;],      &quot;@/lang/*&quot;: [&quot;lang/*&quot;],      &quot;@/lib/*&quot;: [&quot;lib/*&quot;],      &quot;@/styles/*&quot;: [&quot;styles/*&quot;],      &quot;@/utils/*&quot;: [&quot;utils/*&quot;]    &#125;  &#125;&#125;</code></pre><h2 id="sass的安装和使用"><a href="#sass的安装和使用" class="headerlink" title="sass的安装和使用"></a>sass的安装和使用</h2><p>安装</p><pre><code class="shell">npm install --save-dev sass</code></pre><p>style.scss</p><pre><code class="css">.g-container&#123;    background-color: deeppink;&#125;</code></pre><p>page.tsx</p><pre><code class="jsx">import React from &#39;react&#39;import &#39;./style.scss&#39;const page = () =&gt; &#123;  return (    &lt;div className=&#39;g-container&#39;&gt;page&lt;/div&gt;  )&#125;export default page</code></pre><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>第一步：安装cross-env</p><pre><code class="shell">npm install --save-dev cross-env</code></pre><p>第二步：新建三个环境文件</p><p>.env.development</p><pre><code>NODE_ENV = developmentNEXT_PUBLIC_API = https://dev.api.com</code></pre><p>.env.test</p><pre><code>NODE_ENV = testNEXT_PUBLIC_API = https://test.api.com</code></pre><p>.env.production</p><pre><code>NODE_ENV = productionNEXT_PUBLIC_API = https://production.api.com</code></pre><p>第三步：修改package.json文件中的script</p><pre><code class="json">&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;cross-env NODE_ENV=development next dev -p 3000&quot;,    &quot;build:stage&quot;: &quot;cross-env NODE_ENV=test next build&quot;,    &quot;build:prod&quot;: &quot;cross-env NODE_ENV=production next build &quot;,    &quot;start:stage&quot;: &quot;cross-env NODE_ENV=test next start -p 3000&quot;,    &quot;start:prod&quot;: &quot;cross-env NODE_ENV=production next start -p 3000&quot;  &#125;</code></pre><p>第四步：页面组件中使用</p><pre><code class="jsx">import React from &#39;react&#39;import &#39;./style.scss&#39;const page = () =&gt; &#123;  const api = process.env.NEXT_PUBLIC_API  return (    &lt;div className=&#39;g-container&#39;&gt;BASE——API: &#123;api&#125;&lt;/div&gt;  )&#125;export default page</code></pre><p>参考：<a href="https://www.yii666.com/blog/422369.html">NextJS 创建项目和环境变量配置</a></p><h2 id="全局状态管理"><a href="#全局状态管理" class="headerlink" title="全局状态管理"></a>全局状态管理</h2><p>在Next.js中，跨不同组件管理状态可能是一项具有挑战性的任务。因此，像ContextApi这样的全局状态管理工具可以帮助简化该过程。核心技术点：react的createContext和useContext<br>参考：<a href="http://news.sangniao.com/p/2516936941">用ContextApi在Next.js中进行全局状态管理</a></p><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>利用动态路由和路由中间件来实现</p><pre><code>中文：localhost:3000/zh/a英文：localhost:3000/en/a</code></pre><p>第一步：在src&#x2F;app目录中新建一个[lang]文件夹，以后所有的页面都放到[lang]文件夹中</p><p>第二步：新建两个国际化文件</p><p>src&#x2F;lang&#x2F;zh.json</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;姓名&quot;,    &quot;age&quot;: &quot;年龄&quot;&#125;</code></pre><p>src&#x2F;lang&#x2F;en.json</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;name&quot;,    &quot;age&quot;: &quot;age&quot;&#125;</code></pre><p>第三步：编写一个国际化方法</p><p>src&#x2F;utils&#x2F;locale.js</p><pre><code class="js">const en = require(&quot;@/lang/en.json&quot;);const zh = require(&quot;@/lang/zh.json&quot;);export const getDictionaryByStr = (locale) =&gt; &#123;  return (key) =&gt; getDeepDict(key, locale === &quot;zh&quot; ? zh : en);&#125;;function getDeepDict(str, value) &#123;  let keys = str?.split(&quot;.&quot;);  for (let key of keys) &#123;    if (value) &#123;      value = value[key];    &#125;  &#125;  return value;&#125;</code></pre><p>第四步：组件中使用</p><p>src&#x2F;[lang]&#x2F;a&#x2F;page.tsx</p><pre><code class="tsx">import React from &#39;react&#39;import &#123;getDictionaryByStr&#125; from &#39;@/utils/locale&#39;const page = (props: &#123;params:&#123;lang:string&#125;&#125;) =&gt; &#123;  const $t = getDictionaryByStr(props.params.lang)  return (    &lt;div&gt;        lang:&#123;props.params.lang&#125;        &lt;div&gt;name: &#123;$t(&#39;name&#39;)&#125;&lt;/div&gt;        &lt;div&gt;age: &#123;$t(&#39;age&#39;)&#125;&lt;/div&gt;    &lt;/div&gt;  )&#125;export default page</code></pre>]]></content>
    
    
    <summary type="html">nextjs是基于react语法来实现SSR(服务器渲染)的框架，能够解决单页应用不利于SEO的问题</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Nextjs" scheme="https://heliufang.github.io/tags/Nextjs/"/>
    
  </entry>
  
  <entry>
    <title>vue中window.open父子窗口通信</title>
    <link href="https://heliufang.github.io/posts/a35b4e10/"/>
    <id>https://heliufang.github.io/posts/a35b4e10/</id>
    <published>2023-11-16T01:57:28.000Z</published>
    <updated>2024-01-05T13:02:35.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js中window相关属性和方法"><a href="#js中window相关属性和方法" class="headerlink" title="js中window相关属性和方法"></a>js中window相关属性和方法</h2><p> window.opener  实际上是通过window.open()打开的窗体的父窗体 </p><p> window.close()    关闭window.open()打开的窗口 </p><h2 id="vue中window窗口通信"><a href="#vue中window窗口通信" class="headerlink" title="vue中window窗口通信"></a>vue中window窗口通信</h2><p>父窗口为a页面，子窗口为b页面</p><p>操作流程图如下：</p><p><img src="/posts/a35b4e10/1700099008976.png" alt="1700099008976"></p><ul><li>a页面</li></ul><pre><code class="html">&lt;template&gt;    &lt;div&gt;        a页面,我是父窗口        &lt;el-button type=&quot;primary&quot; @click=&quot;go&quot;&gt;打开子页面&lt;/el-button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;A&#39;,    data() &#123;        return &#123;                    &#125;;    &#125;,    mounted() &#123;        //给父窗口绑定一个数据        window.myData = &#123;name: &#39;jerry&#39;,age: 6&#125;        //给父窗口绑定一个方法        window.getChildData = (data) =&gt; &#123;            console.log(&#39;接受子窗口数据：&#39;, data)        &#125;    &#125;,    methods: &#123;        go()&#123;            window.open(&#39;http://localhost:81/zh/b&#39;, &quot;payWindow&quot;, &quot;toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=400, height=400&quot;);        &#125;    &#125;,&#125;;&lt;/script&gt;</code></pre><ul><li>b页面</li></ul><pre><code class="html">&lt;template&gt;    &lt;div&gt;        a页面,我是子窗口        &lt;el-button type=&quot;success&quot; @click=&quot;closeWin&quot;&gt;关闭窗口&lt;/el-button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;B&#39;,    data() &#123;        return &#123;                    &#125;;    &#125;,    mounted() &#123;        //获取父窗口的中数据        console.log(&#39;获取父窗口的中数据：&#39;, window.opener.myData)    &#125;,    methods: &#123;        closeWin()&#123;            //向父窗口发送数据            window.opener.getChildData(&#123;name: &#39;linda&#39;,age: 8&#125;) //window.opener代表父窗口对象             //关闭当前窗口            setTimeout(() =&gt; &#123;                window.close()            &#125;, 2000);                    &#125;    &#125;,&#125;;&lt;/script&gt;</code></pre><h2 id="设置子窗口居中"><a href="#设置子窗口居中" class="headerlink" title="设置子窗口居中"></a>设置子窗口居中</h2><ul><li>父窗口</li></ul><pre><code class="js">let win = window.open(&#39;http://localhost:81/zh/b?name=tom&amp;age=18&#39;, &quot;payWindow&quot;, `toolbar=yes, location=no, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=$&#123;width&#125;, height=$&#123;height&#125;`);//设置窗口居中let left = (screen.availWidth - width) / 2let top = (screen.availHeight - height) / 2win.moveTo(left, top);</code></pre><h2 id="子窗口获取父窗口路径参数"><a href="#子窗口获取父窗口路径参数" class="headerlink" title="子窗口获取父窗口路径参数"></a>子窗口获取父窗口路径参数</h2><ul><li>父窗口</li></ul><pre><code class="js">window.open(&#39;http://localhost:81/zh/b?name=tom&amp;age=18&#39;, &quot;payWindow&quot;, &quot;toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=400, height=400&quot;);</code></pre><ul><li>子窗口</li></ul><pre><code class="js">//接收路径参数const p = new URLSearchParams(window.location.search)console.log(&#39;b页面close&#39;,p.get(&#39;name&#39;),p.get(&#39;age&#39;))</code></pre><h2 id="相关文章参考"><a href="#相关文章参考" class="headerlink" title="相关文章参考"></a>相关文章参考</h2><p><a href="http://www.yuyanba.com/default.aspx/did204034">vue跨窗口通信之新窗口调用父窗口方法实例</a></p><p><a href="https://pythonjishu.com/hyxdrfpmyafkqte/">JavaScript window.open打开页面居中显示的示例代码</a></p><p><a href="https://wenku.csdn.net/answer/2d9d24e747a2482e80a617ee3756f5fc">window.open()获取get路径参数</a></p>]]></content>
    
    
    <summary type="html">vue中window.open父子窗口通信</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>java项目跨域问题解决</title>
    <link href="https://heliufang.github.io/posts/55a96b31/"/>
    <id>https://heliufang.github.io/posts/55a96b31/</id>
    <published>2023-10-25T03:10:28.000Z</published>
    <updated>2024-01-05T13:02:35.222Z</updated>
    
    <content type="html"><![CDATA[<p>后端一般用cors解决跨域问题,需要配置下面的内容</p><pre><code>1.允许任何域名使用,正式环境应该指定跨域访问的域名或ip2.允许任何头3.允许任何方法（post、get等）</code></pre><h2 id="ssm-x2F-jsp项目"><a href="#ssm-x2F-jsp项目" class="headerlink" title="ssm&#x2F;jsp项目"></a>ssm&#x2F;jsp项目</h2><p>通过编写一个过滤器【CorsFilter.java】以及配置【web.xml】来实现</p><pre><code class="java">public class CorsFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST, GET, OPTIONS, DELETE&quot;);        //推荐允许任何头,否则可能跨域无法解决！！！        response.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot;*&quot;)        filterChain.doFilter(servletRequest, servletResponse);    &#125;&#125;</code></pre><p>配置web.xml</p><pre><code class="xml">  &lt;filter&gt;    &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.sale4gr.filter.CorsFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;</code></pre><h2 id="springboot项目"><a href="#springboot项目" class="headerlink" title="springboot项目"></a>springboot项目</h2><p>通过编写一个配置类【CorsConfig.java】来实现</p><pre><code class="java">import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Bean;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsConfig &#123;    /**            跨域问题的cors全局解决方案     */    private CorsConfiguration buildConfig() &#123;        CorsConfiguration corsConfiguration = new CorsConfiguration();        corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 1允许任何域名使用,正式环境应该指定跨域访问的域名或ip        corsConfiguration.addAllowedHeader(&quot;*&quot;); // 2允许任何头        corsConfiguration.addAllowedMethod(&quot;*&quot;); // 3允许任何方法（post、get等）        return corsConfiguration;    &#125;    @Bean    public CorsFilter corsFilter() &#123;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); // 4        return new CorsFilter(source);    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">ssm/servlet项目以及springboot项目跨域问题解决</summary>
    
    
    
    <category term="java" scheme="https://heliufang.github.io/categories/java/"/>
    
    
    <category term="跨域" scheme="https://heliufang.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>pm2的安装和常用命令</title>
    <link href="https://heliufang.github.io/posts/fb35de03/"/>
    <id>https://heliufang.github.io/posts/fb35de03/</id>
    <published>2023-09-04T01:48:28.000Z</published>
    <updated>2024-01-05T13:02:35.272Z</updated>
    
    <content type="html"><![CDATA[<p>在项目部署的时候，当linux终端关闭之后项目也停止了，所以需要pm2来解决这个问题</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装pm2工具</p><pre><code class="shell">npm install pm2 -g</code></pre><h2 id="配置软连接"><a href="#配置软连接" class="headerlink" title="配置软连接"></a>配置软连接</h2><p>windows环境默认已配好，linux环境需要配置。参考下面的文章配置</p><p><a href="https://www.cnblogs.com/mmzuo-798/p/11126773.html">linux下安装pm2,pm2: command not found</a></p><h2 id="基本命令-掌握"><a href="#基本命令-掌握" class="headerlink" title="基本命令(掌握)"></a>基本命令(掌握)</h2><p>用<code>npm</code>启动项目</p><pre><code class="shell">npm run start:prod #这种方式启动项目，当终端关闭之后项目也停止了，所以需要pm2来解决这个问题</code></pre><p>用<code>pm2</code>启动项目</p><pre><code class="shell">pm2 --name=&#39;tranalysis&#39; start npm -- run start:prod #这种方式启动项目，当终端关闭项目会在后台运行</code></pre><p>–name 参数内容可任意，只是方便后面查看</p><h3 id="pm2-list"><a href="#pm2-list" class="headerlink" title="pm2 list"></a>pm2 list</h3><p>查询正在运行的进程</p><pre><code class="shell">pm2 list</code></pre><p><img src="/posts/fb35de03/1697509989881.png" alt="1697509989881"></p><h3 id="pm2-stop"><a href="#pm2-stop" class="headerlink" title="pm2 stop"></a>pm2 stop</h3><p>停止正在运行的进程</p><pre><code class="shell">pm2 stop 0  #通过id停止pm2 stop tranalysis #通过name停止</code></pre><h3 id="pm2-start"><a href="#pm2-start" class="headerlink" title="pm2 start"></a>pm2 start</h3><p>启动正在运行的进程</p><pre><code class="shell">pm2 start 0  #通过id停止pm2 start tranalysis #通过name停止</code></pre><h3 id="pm2-delete"><a href="#pm2-delete" class="headerlink" title="pm2 delete"></a>pm2 delete</h3><pre><code class="shell">pm2 delete 0  #通过id删除pm2 delete tranalysis #通过name删除</code></pre>]]></content>
    
    
    <summary type="html">pm2的安装、配置、常用命令</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="pm2" scheme="https://heliufang.github.io/tags/pm2/"/>
    
  </entry>
  
  <entry>
    <title>前端网站分享功能的实现</title>
    <link href="https://heliufang.github.io/posts/e79a8d86/"/>
    <id>https://heliufang.github.io/posts/e79a8d86/</id>
    <published>2023-07-27T01:48:28.000Z</published>
    <updated>2024-01-05T13:02:35.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端网站分享功能的实现"><a href="#前端网站分享功能的实现" class="headerlink" title="前端网站分享功能的实现"></a>前端网站分享功能的实现</h2><p>分享功能，主要通过链接的形式实现,在新标签页打开链接填入分享的url和标题即可。<code>shareUrl</code>为分享的网址，<code>shareTitle</code>为分享的标题</p><p>分享到Twitter</p><pre><code>https://twitter.com/intent/tweet?url=shareUrl&amp;text=shareTitle</code></pre><p>分享到facebook</p><pre><code>http://www.facebook.com/sharer.php?u=shareUrl</code></pre><p>分享到微博</p><pre><code>https://service.weibo.com/share/share.php?url=shareUrl&amp;title=shareTitle</code></pre><p>分享到qq</p><pre><code>https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=shareUrl&amp;title=shareTitle</code></pre><p>分享到微信：通过生成二维码，用户扫码再分享</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/47223273/answer/3065991702?utm_id=0">分享到facebook、twitter、google、youtube、instagram的分享代码？</a></p>]]></content>
    
    
    <summary type="html">前端网站分享功能的实现思路，主要通过链接的形式</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="分享" scheme="https://heliufang.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>git提交代码注释规范</title>
    <link href="https://heliufang.github.io/posts/7d8cfe28/"/>
    <id>https://heliufang.github.io/posts/7d8cfe28/</id>
    <published>2023-06-25T13:20:28.000Z</published>
    <updated>2024-01-05T13:02:35.192Z</updated>
    
    <content type="html"><![CDATA[<p> 提交代码注释规范 </p><ul><li>feat: 新增feature</li><li>fix: 修复bug</li><li>perf: 优化相关，比如提升性能、体验</li><li>refactor: 代码重构、没有加新功能或者修复bug</li><li>test: 测试用例，包括单元测试、继承测试等</li><li>docs: 仅仅修改了文档，比如README、CHANGELOG、CONTRIBUTE等等</li><li>style: 仅仅修改了空格、格式所以进、变量名等等，不改变代码逻辑</li><li>chore: 改变构建流程、或者依赖库、工具等</li><li>revert: 回滚到上一个版本</li><li>merge: 代码合并同步</li></ul><p>小例子如下</p><p><img src="/posts/7d8cfe28/1696729267355.png" alt="1696729267355"></p><p>参考：<a href="https://www.cnblogs.com/Lcsxx/p/17040818.html">提交代码注释规范</a></p>]]></content>
    
    
    <summary type="html">git提交代码注释规范，提高代码提交的可读性</summary>
    
    
    
    <category term="git" scheme="https://heliufang.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://heliufang.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>angular笔记</title>
    <link href="https://heliufang.github.io/posts/2ea11abc/"/>
    <id>https://heliufang.github.io/posts/2ea11abc/</id>
    <published>2023-03-15T09:20:28.000Z</published>
    <updated>2024-01-12T13:46:14.026Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://angular.cn/docs">angluar中文文档</a></p><p>简书上写的很好的angular教程 — <a href="https://www.jianshu.com/p/018c0bedcdf2">学习angular可以看看，看完会掌握大部分！！！</a></p><h2 id="angular-cli-安装"><a href="#angular-cli-安装" class="headerlink" title="angular cli 安装"></a>angular cli 安装</h2><p>执行下面的命令</p><pre><code class="shell">npm install -g @angular/cli</code></pre><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>执行下面的命令, <code>angular-study</code>可以任意,表示的是项目名称</p><pre><code class="shell">ng new angular-study</code></pre><p>输入n，再输入n。(不共享数据,先不安装路由模块)</p><p>css编写这里选择less</p><pre><code class="shell">? Would you like to share pseudonymous usage data about this project with the Angular Teamat Google under Google&#39;s Privacy Policy at https://policies.google.com/privacy. For moredetails and how to change this setting, see https://angular.io/analytics. NoGlobal setting: disabledLocal setting: No local workspace configuration file.Effective status: disabled? Would you like to add Angular routing? No? Which stylesheet format would you like to use? Less   [ http://lesscss.org ]</code></pre><p>启动项目</p><pre><code class="shell">ng serve </code></pre><p>访问项目</p><pre><code>http://localhost:4200/</code></pre><h2 id="项目结构说明"><a href="#项目结构说明" class="headerlink" title="项目结构说明"></a>项目结构说明</h2><pre><code>src - app 根组件   - app.component.html  html模板   - app.component.less  css样式   - app.component.ts    ts写数据处理逻辑   - app.module.ts  app模块文件 - assets 静态资源目录 - index.html 主页 - main.ts 项目的入口文件 - styles.less 全局样式文件 - .editorconfig 环境配置(开发/测试/上线) - .gitignore git忽略文件 - angular.json  angular cli的配置相关 - tsconfig  ts编译器相关配置</code></pre><p>更多介绍可参考官网：<a href="https://angular.cn/guide/file-structure">工作区和项目文件结构</a></p><h3 id="app-component-ts"><a href="#app-component-ts" class="headerlink" title="app.component.ts"></a>app.component.ts</h3><p>主要用来定义根组件</p><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-root&#39;, //组件的唯一标识，当前是根组件  templateUrl: &#39;./app.component.html&#39;, //当前组件的html模板文件  styleUrls: [&#39;./app.component.less&#39;] //当前组件的样式文件&#125;)export class AppComponent &#123;  title = &#39;angular-study&#39;; //定义一个双向绑定的数据&#125;</code></pre><h3 id="app-module-ts"><a href="#app-module-ts" class="headerlink" title="app.module.ts"></a>app.module.ts</h3><p>Angular 应用是模块化的，它拥有自己的模块化系统，称作 NgModule。 一个 NgModule 就是一个容器，用于存放一些内聚的代码块，这些代码块专注于某个应用领域、某个工作流或一组紧密相关的功能。 它可以包含一些组件、服务提供商或其它代码文件，其作用域由包含它们的 NgModule 定义。 它还可以导入一些由其它模块中导出的功能，并导出一些指定的功能供其它 NgModule 使用。</p><pre><code class="js">/*这个文件是Angular 根模块，告诉Angular如何组装应用*///Angular核心模块import &#123; NgModule &#125; from &#39;@angular/core&#39;;//BrowserModule，浏览器解析的模块import &#123; BrowserModule &#125; from &#39;@angular/platform-browser&#39;;//根组件import &#123; AppComponent &#125; from &#39;./app.component&#39;;//NgModule装饰器, @NgModule接受一个元数据对象，告诉 Angular 如何编译和启动应用@NgModule(&#123;  declarations: [//配置当前项目运行的的组件    AppComponent  ],  imports: [//配置当前模块运行依赖的其他模块    BrowserModule  ],  providers: [],//项目所需要的服务  //指定应用的主视图（称为根组件） 通过引导根AppModule来启动应用  ，这里一般写的是根组件  bootstrap: [AppComponent] &#125;)export class AppModule &#123; &#125;</code></pre><h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><ul><li>在src&#x2F;view下面创建一个Hello组件(先创建view文件夹并且切换到这个文件夹)</li></ul><pre><code class="shell">D:\webcode\angular-study\src\view&gt; ng g component Hello --skip-import</code></pre><ul><li>修改src&#x2F;app&#x2F;app.module.ts</li></ul><pre><code class="js">import &#123; NgModule &#125; from &#39;@angular/core&#39;;import &#123; BrowserModule &#125; from &#39;@angular/platform-browser&#39;;//导入Hello组件import &#123; HelloComponent &#125; from &#39;../view/hello/hello.component&#39;;import &#123; AppComponent &#125; from &#39;./app.component&#39;;@NgModule(&#123;  declarations: [     AppComponent,    HelloComponent //注册Hello组件  ],  imports: [    BrowserModule  ],  providers: [],  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;</code></pre><ul><li>将src&#x2F;app&#x2F;app.component.html内容清空,并引入hello组件</li></ul><pre><code class="html">&lt;app-hello&gt;&lt;/app-hello&gt;</code></pre><p>然后就可以看到hello组件的内容展示了</p><h2 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h2><p>只需要定义类中的属性即可</p><pre><code class="js">export class HelloComponent &#123;  title = &#39;hello angular&#39; //定义双向绑定的数据变量&#125;</code></pre><h2 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h2><h3 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h3><pre><code class="html">&lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;</code></pre><h3 id="绑定html"><a href="#绑定html" class="headerlink" title="绑定html"></a>绑定html</h3><ul><li>定义数据</li></ul><pre><code class="js">export class HelloComponent &#123;  htmlStr = &#39;&lt;h2&gt;hello angular&lt;/h2&gt;&#39;&#125;</code></pre><ul><li>绑定</li></ul><pre><code class="html">&lt;div [innerHTML]=&quot;htmlStr&quot;&gt;&lt;/div&gt;</code></pre><h3 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h3><pre><code class="html">&lt;div [title]=&quot;title&quot; [id]=&quot;id&quot;&gt;绑定属性&lt;/div&gt;</code></pre><h3 id="数据循环-ngFor"><a href="#数据循环-ngFor" class="headerlink" title="数据循环 *ngFor"></a>数据循环 *ngFor</h3><ul><li>定义数据</li></ul><pre><code class="js">export class HelloComponent &#123;  userlist = [&#123;    username: &#39;张三&#39;,    age: 20  &#125;, &#123;    username: &#39;李四&#39;,    age: 21  &#125;,  &#123;    username: &#39;王五&#39;,    age: 40  &#125;]&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;ul&gt;    &lt;li *ngFor=&quot;let user of userlist&quot;&gt;&#123;&#123;user.username + '-' + user.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 带下标/绑定key --&gt;&lt;ul&gt;    &lt;li *ngFor=&quot;let user of userlist;let i = index&quot;&gt;&#123;&#123;i+":"+user.username + '-' + user.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="条件判断-ngIf"><a href="#条件判断-ngIf" class="headerlink" title="条件判断 *ngIf"></a>条件判断 *ngIf</h3><pre><code class="html">&lt;div *ngIf=&quot;gender == &#39;male&#39;&quot;&gt;男的&lt;/div&gt;&lt;div *ngIf=&quot;gender == &#39;famale&#39;&quot;&gt;女的&lt;/div&gt;</code></pre><h3 id="ngSwitch"><a href="#ngSwitch" class="headerlink" title="*ngSwitch"></a>*ngSwitch</h3><ul><li>定义数据</li></ul><pre><code class="js">export class HelloComponent &#123;  status = 2&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;ul [ngSwitch]=&quot;status&quot;&gt;    &lt;li *ngSwitchCase=&quot;1&quot;&gt;未开始&lt;/li&gt;    &lt;li *ngSwitchCase=&quot;2&quot;&gt;进行中&lt;/li&gt;    &lt;li *ngSwitchCase=&quot;3&quot;&gt;已完成&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="绑定click事件"><a href="#绑定click事件" class="headerlink" title="绑定click事件"></a>绑定click事件</h3><ul><li>定义方法</li></ul><pre><code class="js">export class HelloComponent &#123;  age = 18  setAge()&#123;    this.age = this.age + 1  &#125;  getAge()&#123;    return this.age  &#125;&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;h2&gt;当前age：&#123;&#123;getAge()&#125;&#125;&lt;/h2&gt;&lt;button (click)=&quot;setAge()&quot;&gt;age+1&lt;/button&gt;</code></pre><h3 id="input事件"><a href="#input事件" class="headerlink" title="input事件"></a>input事件</h3><ul><li>定义</li></ul><pre><code class="js">export class HelloComponent &#123;  msg = &#39;&#39;  keyUpFn(event:any)&#123;    // console.log(event.target.value)    this.msg = event.target.value  &#125;&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; (keyup)=&quot;keyUpFn($event)&quot;&gt;&lt;div&gt;输入的值为：&#123;&#123;msg&#125;&#125;&lt;/div&gt;</code></pre><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><ul><li>定义</li></ul><pre><code class="js">export class HelloComponent &#123;  text = &#39;&#39;&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;input type=&quot;text&quot; name=&quot;&quot; [(ngModel)]=&quot;text&quot;&gt;&lt;div&gt;双向绑定：&#123;&#123;text&#125;&#125;&lt;/div&gt;</code></pre><h3 id="ngStyle"><a href="#ngStyle" class="headerlink" title="[ngStyle]"></a>[ngStyle]</h3><ul><li>定义</li></ul><pre><code class="js">export class HelloComponent &#123;  textRed = &#39;red&#39;&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;div [style]=&quot;&#123;&#39;color&#39;:&#39;blue&#39;&#125;&quot;&gt;蓝色字体&lt;/div&gt;&lt;div [style]=&quot;&#123;&#39;color&#39;:textRed&#125;&quot;&gt;红色字体-变量&lt;/div&gt;</code></pre><h3 id="ngClass"><a href="#ngClass" class="headerlink" title="[ngClass]"></a>[ngClass]</h3><ul><li>定义样式</li></ul><pre><code class="css">.blueText&#123;    color: blue;&#125;.redText&#123;    color: red;&#125;</code></pre><ul><li>定义数据</li></ul><pre><code class="js">export class HelloComponent &#123;  isRed = true&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;div [ngClass]=&quot;&#123;blueText: true&#125;&quot;&gt;蓝色字体&lt;/div&gt;&lt;div [ngClass]=&quot;&#123;redText: isRed&#125;&quot;&gt;红色字体-变量&lt;/div&gt;</code></pre><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>类似vue中的过滤器</p><p><a href="https://angular.cn/guide/pipes">官方文档：Angular - 用管道转换数据</a></p><ul><li>定义</li></ul><pre><code class="js">export class HelloComponent &#123;  today = new Date()&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;div&gt;&#123;&#123;today |  date:'yyyy-MM-dd HH:mm:ss'&#125;&#125;&lt;/div&gt;</code></pre><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>服务是一个广义的概念，它包括应用所需的任何值、函数或特性。狭义的服务是一个明确定义了用途的类。它应该做一些具体的事，并做好。<br>Angular 把组件和服务区分开，以提高模块性和复用性。 通过把组件中和视图有关的功能与其他类型的处理分离开，你可以让组件类更加精简、高效。</p><blockquote><p>一个服务可以为多个组件使用</p></blockquote><blockquote><p>个人理解：类似Java中一个工具类</p></blockquote><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><pre><code class="shell">ng g service services/storage</code></pre><h3 id="编写服务"><a href="#编写服务" class="headerlink" title="编写服务"></a>编写服务</h3><p>src&#x2F;services&#x2F;storage.service.ts</p><pre><code class="js">import &#123; Injectable &#125; from &#39;@angular/core&#39;;@Injectable(&#123;  providedIn: &#39;root&#39;&#125;)export class StorageService &#123;  constructor() &#123; &#125;  private tlist = [    &#123; name: &#39;tom&#39;, age: 18&#125;,    &#123; name: &#39;jerry&#39;, age: 16&#125;  ]  getTlist()&#123;    return this.tlist;  &#125;  setTlist(tlist: [])&#123;    this.tlist = tlist  &#125;&#125;</code></pre><h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>src&#x2F;app&#x2F;app.module.ts</p><pre><code class="js">import &#123; NgModule &#125; from &#39;@angular/core&#39;;import &#123; BrowserModule &#125; from &#39;@angular/platform-browser&#39;;import &#123; HelloComponent &#125; from &#39;../view/hello/hello.component&#39;;import &#123; AppComponent &#125; from &#39;./app.component&#39;;import &#123; FormsModule &#125; from &#39;@angular/forms&#39;;  //导入自己写的服务import &#123;StorageService&#125; from &#39;../services/storage.service&#39;;@NgModule(&#123;  declarations: [     AppComponent,HelloComponent  ],  imports: [    BrowserModule,    FormsModule  ],  providers: [StorageService],//注册服务  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;</code></pre><h3 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h3><p>src&#x2F;view&#x2F;hello&#x2F;hello.component.ts</p><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;//导入服务import &#123;StorageService&#125; from &#39;../../services/storage.service&#39;@Component(&#123;  selector: &#39;app-hello&#39;,  templateUrl: &#39;./hello.component.html&#39;,  styleUrls: [&#39;./hello.component.less&#39;]&#125;)export class HelloComponent &#123;    //注入服务给构造函数参数  constructor(private storage : StorageService) &#123;    console.log(&#39;tlist&#39;, storage.getTlist()) //使用服务  &#125;&#125;</code></pre><h2 id="dom"><a href="#dom" class="headerlink" title="dom"></a>dom</h2><p>ngAfterViewInit() ： angular 中操作dom要在这个生命周期钩子函数中。有原生的获取和ViewChild注入方式来获取</p><ul><li>页面</li></ul><pre><code class="html">&lt;!-- 原生dom --&gt;&lt;div id=&quot;dom1&quot;&gt;dom1111&lt;/div&gt;&lt;!-- ViewChild方式获取dom --&gt;&lt;div #dom2&gt;dom2222&lt;/div&gt;</code></pre><ul><li>ts</li></ul><pre><code class="js">import &#123; Component,ViewChild &#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-hello&#39;,  templateUrl: &#39;./hello.component.html&#39;,  styleUrls: [&#39;./hello.component.less&#39;]&#125;)export class HelloComponent &#123;   //注入dom2  @ViewChild(&#39;dom2&#39;) dom2:any   //页面 初始化之后，可以在这个钩子中操作dom  ngAfterViewInit() &#123;    //1.原生方式操作dom    let dom1:any = document.getElementById(&#39;dom1&#39;)    dom1.style.color = &#39;red&#39;    //2.ViewChild注入的方式，获取dom通过nativeElement属性    this.dom2.nativeElement.style.color = &#39;green&#39;  &#125;&#125;</code></pre><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父组件给子组件传数据"><a href="#父组件给子组件传数据" class="headerlink" title="父组件给子组件传数据"></a>父组件给子组件传数据</h3><ul><li>父组件将变量传给子组件—&gt;通过<code>标签属性</code>的方式传递</li></ul><pre><code class="html">&lt;!-- 给子组件传递数据 --&gt;&lt;app-child [msg]=&quot;msg&quot;&gt;&lt;/app-child&gt;</code></pre><ul><li>子组件接收数据—&gt;通过<code>Input</code>注入</li></ul><pre><code class="js">import &#123; Component,Input &#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-child&#39;,  templateUrl: &#39;./child.component.html&#39;,  styleUrls: [&#39;./child.component.less&#39;]&#125;)export class ChildComponent &#123;  //接受父组件传过来的数据,通过Input注入fatherMsg变量  @Input(&#39;msg&#39;) fatherMsg: string = &#39;&#39;  ngOnInit()&#123;    console.log(&#39;fatherMsg&#39;, this.fatherMsg)  &#125;&#125;</code></pre><h3 id="子组件给父组件传数据"><a href="#子组件给父组件传数据" class="headerlink" title="子组件给父组件传数据"></a>子组件给父组件传数据</h3><ul><li>子组件html</li></ul><pre><code class="html">&lt;button (click)=&quot;sendMsgToFather()&quot;&gt;给父组件传数据&lt;/button&gt;</code></pre><ul><li>子组件ts</li></ul><pre><code class="js">import &#123; Component,Output,EventEmitter &#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-child&#39;,  templateUrl: &#39;./child.component.html&#39;,  styleUrls: [&#39;./child.component.less&#39;]&#125;)export class ChildComponent &#123;  //通过这个对象来触发父组件的方法(如果父组件有多个方法要传递，那么需要创建多个outer)  @Output() private outer = new EventEmitter&lt;string&gt;();  //点击后向父组件传数据  sendMsgToFather()&#123;    //通过emit触发父组件方法给父组件传递数据    this.outer.emit(&#39;我是 child 组件&#39;)  &#125;&#125;</code></pre><ul><li>父组件html</li></ul><pre><code class="html">&lt;app-child (outer)=&quot;reciveChild($event)&quot;&gt;&lt;/app-child&gt;</code></pre><ul><li>父组件ts</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-father&#39;,  templateUrl: &#39;./father.component.html&#39;,  styleUrls: [&#39;./father.component.less&#39;]&#125;)export class FatherComponent &#123;  childMsg = &#39;&#39;  //接收子组件发送来的数据  reciveChild(childMsg:string)&#123;    console.log(&#39;childMsg&#39;, childMsg)    this.childMsg = childMsg  &#125;&#125;</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>1、<strong>ngOnChanges()</strong><br>当 Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的 SimpleChanges 对象当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在 ngOnInit() 之前。<br>2、<strong>ngOnInit()</strong><br>在 Angular 第一次显示数据绑定和设置指令&#x2F;组件的输入属性之后，初始化指令&#x2F;组件。<br>在第一轮 ngOnChanges() 完成之后调用，只调用一次。<br>使用 ngOnInit() 有两个原因：</p><pre><code> &lt;1&gt;在构造函数之后马上执行复杂的初始化逻辑 &lt;2&gt;在 Angular 设置完输入属性之后，对该组件进行准备。 有经验的开发者会认同组件的构建应该很便宜和安全。</code></pre><p>3、<strong>ngDoCheck()</strong><br>检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。在每个 Angular 变更检测周期中调用，ngOnChanges() 和 ngOnInit() 之后<br>4、<strong>ngAfterContentInit()</strong><br>当把内容投影进组件之后调用。第一次 ngDoCheck() 之后调用，只调用一次。<br>5、<strong>ngAfterContentChecked()</strong><br>每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit() 和每次 ngDoCheck() 之后调用。<br>6、<strong>ngAfterViewInit()</strong><br>初始化完组件视图及其子视图之后调用。第 一次 ngAfterContentChecked() 之后调用，只调用一次。<br>7、<strong>ngAfterViewChecked()</strong><br>每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit()和每次 ngAfterContentChecked() 之后调用<br>8、<strong>ngOnDestroy()</strong><br>当 Angular 每次销毁指令&#x2F;组件之前调用并清扫。在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在 Angular 销毁指令&#x2F;组件之前调用</p><pre><code class="js">import &#123; Component,Input&#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-lifecycle&#39;,  templateUrl: &#39;./lifecycle.component.html&#39;,  styleUrls: [&#39;./lifecycle.component.scss&#39;]&#125;)export class LifecycleComponent&#123;    @Input(&#39;title&#39;) title:string;    public msg:string=&#39;生命周期演示&#39;;    public userinfo:string=&#39;&#39;;    public oldUserinfo:string=&#39;&#39;;    constructor() &#123;       console.log(&#39;00构造函数执行了---除了使用简单的值对局部变量进行初始化之外，什么都不应该做&#39;)    &#125;    ngOnChanges() &#123;      console.log(&#39;01ngOnChages执行了---当被绑定的输入属性的值发生变化时调用(父子组件传值的时候会触发)&#39;);     &#125;    ngOnInit() &#123;        console.log(&#39;02ngOnInit执行了--- 请求数据一般放在这个里面&#39;);         &#125;    ngDoCheck() &#123;        //写一些自定义的操作        console.log(&#39;03ngDoCheck执行了---检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应&#39;);        if(this.userinfo!==this.oldUserinfo)&#123;            console.log(`你从$&#123;this.oldUserinfo&#125;改成$&#123;this.userinfo&#125;`);            this.oldUserinfo = this.userinfo;        &#125;else&#123;                        console.log(&quot;数据没有变化&quot;);                  &#125;    &#125;    ngAfterContentInit() &#123;        console.log(&#39;04ngAfterContentInit执行了---当把内容投影进组件之后调用&#39;);    &#125;    ngAfterContentChecked() &#123;        console.log(&#39;05ngAfterContentChecked执行了---每次完成被投影组件内容的变更检测之后调用&#39;);    &#125;    ngAfterViewInit(): void &#123;             console.log(&#39;06 ngAfterViewInit执行了----初始化完组件视图及其子视图之后调用（dom操作放在这个里面）&#39;);    &#125;    ngAfterViewChecked() &#123;        console.log(&#39;07ngAfterViewChecked执行了----每次做完组件视图和子视图的变更检测之后调用&#39;);    &#125;    ngOnDestroy() &#123;        console.log(&#39;08ngOnDestroy执行了····&#39;);    &#125;    //自定义方法    changeMsg()&#123;      this.msg=&quot;数据改变了&quot;;    &#125;&#125;</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>创建一个带路由的项目  angular-routing-study 为项目名称</p><pre><code class="shell">ng new angular-routing-study --routing --defaults</code></pre><p>创建四个组件</p><pre><code>ng g component home --skip-importng g component news --skip-importng g component newsdetails --skip-importng g component pagenotfind --skip-import</code></pre><h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><ul><li>app-routing.module.ts</li></ul><pre><code class="js">import &#123; NgModule &#125; from &#39;@angular/core&#39;;import &#123; RouterModule, Routes &#125; from &#39;@angular/router&#39;;//导入自定义的组件import &#123; HomeComponent &#125; from &#39;../views/home/home.component&#39; import &#123; NewsComponent &#125; from &#39;../views/news/news.component&#39; import &#123; PagenotfindComponent &#125; from &#39;../views/pagenotfind/pagenotfind.component&#39; //配置路由const routes: Routes = [  &#123;path: &#39;home&#39; , component: HomeComponent&#125;,  &#123;path: &#39;news&#39; , component: NewsComponent&#125;,  &#123;path: &#39;&#39; , redirectTo: &#39;/home&#39;,pathMatch: &#39;full&#39;&#125;, //&#39;&#39;表示默认重定向到home页面  &#123;path: &#39;**&#39;,component: PagenotfindComponent&#125; //通配符匹配,404]@NgModule(&#123;  imports: [RouterModule.forRoot(routes)],  exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125;</code></pre><ul><li>app.component.html</li></ul><pre><code class="html">&lt;!-- 路由跳转链接-routerLink属性  routerLinkActive设置路由激活后的按钮链接样式 --&gt;&lt;a class=&quot;menu-btn&quot; routerLink=&quot;/home&quot; routerLinkActive=&quot;active&quot;&gt;首页&lt;/a&gt;&lt;a class=&quot;menu-btn&quot; routerLink=&quot;/news&quot; routerLinkActive=&quot;active&quot;&gt;新闻&lt;/a&gt;&lt;!-- 路由匹配后展示的区域-router-outlet标签 --&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></pre><ul><li>app.component.css</li></ul><pre><code class="css">.active&#123;    color: deeppink;&#125;.menu-btn&#123;    width: 200px;    height: 60px;    padding: 10px;    margin-left: 6px;&#125;</code></pre><p>然后点击页面上的<code>首页</code>和<code>新闻</code>按钮就可以在<code>router-outlet</code>的区域进行的切换了</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>和vue中的类似,也就是传递和接收params参数</p><ul><li>app-routing.module.ts  在Routes数组中新增一条路由规则</li></ul><pre><code class="js">const routes: Routes = [    //新增下面这条路由规则  :id表示传递的参数名为id,也可以是其它的  &#123;path: &#39;newDetails/:id&#39; , component: NewsdetailsComponent&#125;]</code></pre><ul><li>app.component.html 新增一个跳转的按钮</li></ul><pre><code class="html">&lt;a class=&quot;menu-btn&quot; routerLink=&quot;/newDetails/1&quot;&gt;新闻详情1，传递的参数为1&lt;/a&gt;&lt;a class=&quot;menu-btn&quot; [routerLink]=&quot;[&#39;/newDetails&#39;,2]&quot; &gt;新闻详情2，传递的参数为2&lt;/a&gt;</code></pre><ul><li>newsdetails.component.ts</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;//1.导入ActivatedRouteimport &#123; ActivatedRoute &#125; from &#39;@angular/router&#39;;@Component(&#123;  selector: &#39;app-newsdetails&#39;,  templateUrl: &#39;./newsdetails.component.html&#39;,  styleUrls: [&#39;./newsdetails.component.css&#39;]&#125;)export class NewsdetailsComponent &#123;  newsId = &#39;&#39;  //2.将ActivatedRoute注入给route  constructor(private route:ActivatedRoute)&#123; &#125;  ngOnInit()&#123;     console.log(this.route.params);     //3.获取params参数,并赋值给newsId    this.route.params.subscribe((data:any) =&gt; this.newsId = data.id)  &#125;&#125;</code></pre><ul><li>newsdetails.component.html  新闻详情页就可以接收到传递过来的params参数了</li></ul><pre><code class="html">&lt;p&gt;newsdetails works!,接受到参数新闻id：&#123;&#123;newsId&#125;&#125;&lt;/p&gt;</code></pre><h3 id="问号传参跳转"><a href="#问号传参跳转" class="headerlink" title="问号传参跳转"></a>问号传参跳转</h3><p>也就是在链接后面用问号的形式传递参数,跳转页面</p><ul><li>app.component.html修改新闻按钮，这样点击按钮就会以问号传参的形式跳转到新闻页面</li></ul><pre><code class="html">&lt;a class=&quot;menu-btn&quot; href=&quot;/news?name=tom&amp;age=18&quot;&gt;新闻(？传参)&lt;/a&gt;</code></pre><ul><li>news.component.ts  - 接收参数</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;import &#123; ActivatedRoute &#125; from &#39;@angular/router&#39;;@Component(&#123;  selector: &#39;app-news&#39;,  templateUrl: &#39;./news.component.html&#39;,  styleUrls: [&#39;./news.component.css&#39;]&#125;)export class NewsComponent &#123;  name = &#39;&#39;  age = &#39;&#39;  constructor(private router:ActivatedRoute)&#123;    //通过 this.router.queryParams 获取问号传递过来的参数    this.router.queryParams.subscribe(params =&gt; &#123;      console.log(&#39;?参数&#39;, params)      this.age = params[&#39;age&#39;]      this.name = params[&#39;name&#39;]    &#125;);  &#125;&#125;</code></pre><ul><li>news.component.html - 展示接收到的参数</li></ul><pre><code class="html">&lt;p&gt;news works! 接受到的queryParams参数:&#123;&#123;name+'-'+age&#125;&#125;&lt;/p&gt;</code></pre><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>其实就是通过js的形式跳转页面</p><h4 id="问号传参的编程式导航"><a href="#问号传参的编程式导航" class="headerlink" title="问号传参的编程式导航"></a>问号传参的编程式导航</h4><ul><li>app.component.html 新增一个新闻详情按钮</li></ul><pre><code class="html">&lt;button class=&quot;menu-btn&quot; (click)=&quot;goNews()&quot;&gt;新闻(？传参)&lt;/button&gt;</code></pre><ul><li>app.component.ts   通过js事件的形式跳转路由</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;//1.导入Router,NavigationExtrasimport &#123; Router,NavigationExtras &#125; from &#39;@angular/router&#39;;@Component(&#123;  selector: &#39;app-root&#39;,  templateUrl: &#39;./app.component.html&#39;,  styleUrls: [&#39;./app.component.css&#39;]&#125;)export class AppComponent &#123;  title = &#39;angular-routing-study&#39;;  //2.注入Router到router  constructor(private router:Router)&#123;&#125;  goNews()&#123;    //3.定义需要传递的问号参数    let navigationExtras:NavigationExtras = &#123;      queryParams: &#123; name: &#39;jerry&#39;,age: 19 &#125;    &#125;    //4.调用navigate跳转页面并传递参数    this.router.navigate([&#39;/news&#39;],navigationExtras)  &#125;&#125;</code></pre><ul><li>获取参数的方式和前面a标签跳转的方式一致</li></ul><h4 id="动态路由的编程式导航"><a href="#动态路由的编程式导航" class="headerlink" title="动态路由的编程式导航"></a>动态路由的编程式导航</h4><ul><li>app.component.html 新增一个新闻详情按钮</li></ul><pre><code class="html">&lt;button class=&quot;menu-btn&quot; (click)=&quot;goNewsDetails()&quot;&gt;新闻详情1&lt;/button&gt;</code></pre><ul><li>app.component.ts 通过js事件的形式跳转路由</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;//1.导入Routerimport &#123; Router &#125; from &#39;@angular/router&#39;;@Component(&#123;  selector: &#39;app-root&#39;,  templateUrl: &#39;./app.component.html&#39;,  styleUrls: [&#39;./app.component.css&#39;]&#125;)export class AppComponent &#123;  title = &#39;angular-routing-study&#39;;  //2.注入Router到router  constructor(private router:Router)&#123;&#125;  goNewsDetails()&#123;    //3.调用navigate方法携带参数跳转    this.router.navigate([&#39;/newDetails&#39;,1])  &#125;&#125;</code></pre><ul><li>获取参数的方式和前面a标签跳转的方式一致</li></ul><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>假设newsdetails是news的子页面</p><ul><li>app-routing.module.ts 修改news为嵌套路由</li></ul><pre><code class="js">const routes: Routes = [  &#123;       path: &#39;news&#39;,       component: NewsComponent,       //添加一个children节点,并配置      children: [          &#123; path: &#39;newDetails/:id&#39;, component: NewsdetailsComponent &#125;      ]   &#125;]</code></pre><ul><li>news.component.html 页面修改为如下</li></ul><pre><code class="html">&lt;p&gt;news works!&lt;/p&gt;&lt;ul&gt;    &lt;li&gt;&lt;a routerLink=&quot;/news/newDetails/1&quot;&gt;新闻1&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a routerLink=&quot;/news/newDetails/2&quot;&gt;新闻2&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a routerLink=&quot;/news/newDetails/3&quot;&gt;新闻3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 新闻详情展示的区域 --&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></pre><ul><li>newsdetails.component.ts 接收传递过来的路由参数</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;import &#123; ActivatedRoute &#125; from &#39;@angular/router&#39;;@Component(&#123;  selector: &#39;app-newsdetails&#39;,  templateUrl: &#39;./newsdetails.component.html&#39;,  styleUrls: [&#39;./newsdetails.component.css&#39;]&#125;)export class NewsdetailsComponent &#123;  newsId = &#39;&#39;  constructor(private route:ActivatedRoute)&#123;&#125;  ngOnInit()&#123;     //获取传递来的新闻id并赋值给newsId    this.route.params.subscribe((data:any) =&gt; this.newsId = data.id)  &#125;&#125;</code></pre><ul><li>newsdetails.component.html  渲染传递来的参数</li></ul><pre><code class="html">&lt;p&gt;newsdetails works!,接受到参数新闻id：&#123;&#123;newsId&#125;&#125;&lt;/p&gt;</code></pre><ul><li>新增一个news.module.ts 文件</li></ul><pre><code class="js">import &#123; NgModule &#125; from &#39;@angular/core&#39;;import &#123; RouterModule &#125; from &#39;@angular/router&#39;import &#123; NewsComponent &#125; from &#39;./news.component&#39;;@NgModule(&#123;  declarations: [      //一定要声明这个，否则父组件中使用&lt;router-outlet&gt;标签将报错 ！！！      //https://stackoverflow.com/questions/44517737/router-outlet-is-not-a-known-element    NewsComponent   ],  imports: [   RouterModule  ],  exports: [RouterModule],&#125;)export class NewsModule &#123; &#125;</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是组织应用和使用外部库扩展应用的最佳途径。</p><h3 id="angular内置模块"><a href="#angular内置模块" class="headerlink" title="angular内置模块"></a>angular内置模块</h3><p>Angular 自己的库都是 NgModule，比如 <code>FormsModule</code>、<code>HttpClientModule</code> 和 <code>RouterModule</code>。很多第三方库也是 NgModule，比如 <a href="https://material.angular.cn/">Material Design</a>、 <a href="http://ionicframework.com/">Ionic</a> 和 <a href="https://github.com/angular/angularfire2">AngularFire2</a>。</p><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>当项目非常庞大的时候把所有的组件都挂载到根模块里面不是特别合适。所以这个时候就可以自定义模块来组织的项目。并且通过 Angular 自定义模块可以实现路由的懒加载。</p><ul><li>在组件中创建模块</li></ul><pre><code class="shell">D:\webcode\angular-routing-study\src\views&gt;ng g module home    # home组件的模块D:\webcode\angular-routing-study\src\views&gt;ng g module newsdetails # newsdetails组件的模块D:\webcode\angular-routing-study\src\views&gt;ng g module pagenotfind # pagenotfind组件的模块</code></pre><ul><li>修改app-routing.module.ts中路由的配置如下</li></ul><pre><code class="js">const routes: Routes = [  //主要通过loadChildren回调函数的形式导入模块,实现懒加载  &#123; path: &#39;**&#39;, loadChildren: () =&gt; import(&#39;../views/pagenotfind/pagenotfind.module&#39;).then(m =&gt; m.PagenotfindModule) &#125; //通配符匹配,404]</code></pre>]]></content>
    
    
    <summary type="html">angular和angularjs是完全不同的两个框架！！！</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="angular" scheme="https://heliufang.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>原生js实现页面滚动到指定dom节点</title>
    <link href="https://heliufang.github.io/posts/97aee00c/"/>
    <id>https://heliufang.github.io/posts/97aee00c/</id>
    <published>2023-03-07T01:48:28.000Z</published>
    <updated>2024-01-05T13:02:35.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原生js实现页面滚动到指定dom节点"><a href="#原生js实现页面滚动到指定dom节点" class="headerlink" title="原生js实现页面滚动到指定dom节点"></a>原生js实现页面滚动到指定dom节点</h2><p>【案例】</p><pre><code class="html">&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;滚动到指定的div案例&lt;/title&gt;    &lt;style&gt;        .box &#123;            height: 1000px;            background-color: #bfa;            border: 1px solid #000;        &#125;        .myBox &#123;            margin-top: 500px;            height: 200px;            background-color: deepskyblue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;button id=&quot;gun&quot;&gt;滚&lt;/button&gt;        &lt;div class=&quot;myBox&quot;&gt;目标元素&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        function heightToTop(ele) &#123;            //ele为指定跳转到该位置的DOM节点            let bridge = ele;            let root = document.body;            let height = 0;            //关键点1：这里使用do while 累加偏移的高度            do &#123;                height += bridge.offsetTop;                bridge = bridge.offsetParent;            &#125; while (bridge !== root)            return height;        &#125;        //按钮点击时        let gunBtn = document.querySelector(&quot;#gun&quot;)        let targetEle = document.querySelector(&quot;.myBox&quot;)        gunBtn.addEventListener(&#39;click&#39;, function () &#123;            //关键点2：使用window的滚动方法            window.scrollTo(&#123;                top: heightToTop(targetEle),                behavior: &#39;smooth&#39;            &#125;)            // window.scrollTo(&#123;            //     top: 0,            //     behavior: &#39;smooth&#39;            // &#125;)        &#125;)            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/m0_46833693/article/details/123186078">JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解（含示例图）</a></p>]]></content>
    
    
    <summary type="html">原生js实现点击按钮，滚动到指定dom节点</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://heliufang.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>angularjs笔记</title>
    <link href="https://heliufang.github.io/posts/b3a0e706/"/>
    <id>https://heliufang.github.io/posts/b3a0e706/</id>
    <published>2023-02-20T10:05:31.000Z</published>
    <updated>2023-02-20T14:34:10.783Z</updated>
    
    <content type="html"><![CDATA[<p>B站教学视频：<a href="https://www.bilibili.com/video/BV1ts411E7qg">尚硅谷AngularJS实战教程(angular.js框架精讲)</a></p><p><a href="https://www.angularjs.net.cn/">AngularJS中文文档</a></p><p><a href="https://www.runoob.com/angularjs/angularjs-intro.html">菜鸟教程Angularjs文档(这个教程写的不错,可作为视频教程的补充)</a></p><p>涉及到的资料在这里,搬运来的链接，大家自取<br>链接: <a href="https://pan.baidu.com/s/180125RF0kI2wzpOMLrzC4A">https://pan.baidu.com/s/180125RF0kI2wzpOMLrzC4A</a> 提取码: pgt4 </p><h2 id="angular简介"><a href="#angular简介" class="headerlink" title="angular简介"></a>angular简介</h2><p>Google开源的 前端JS 结构化 框架</p><p>动态展示页面数据, 并与用户进行交互</p><p>AngularJS特性(优点)</p><ul><li>双向数据绑定</li><li>声明式依赖注入</li><li>解耦应用逻辑, 数据模型和视图</li><li>完善的页面指令</li><li>定制表单验证</li><li>Ajax封装</li></ul><h2 id="入门demo"><a href="#入门demo" class="headerlink" title="入门demo"></a>入门demo</h2><p>语法详解</p><pre><code>ng-app(指令) : 告诉angular核心它管理当前标签所包含的整个区域,并且会自动创建$rootScope根作用域对象ng-model : 将当前输入框的值与谁关联(属性名:属性值), 并作为当前作用域对象($rootScope)的属性&#123;&#123;&#125;&#125; (表达式) : 显示数据,从作用域对象的指定属性名上取  1、表达式：通常有一个返回值，可以放在任何需要值得地方，比如函数调用的参数，一个变量名，一个运算，  2、语句：通常表示一个完整的执行单位，一段完整的js可执行的代码，有的语句也可以用表达式来执行，叫做表达式语句。  3、区别：语句用封号结尾，有些语句我们没有加封号，比如console.log虽然我们没有加封号，但也是语句，因为js引擎会自动解析并且加上封号。  js引擎在解析的时候会自动的加上封号  4、特例：if语句，就不用加封号  可也是完整的语句。</code></pre><p>入门案例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;!-- 设置ng-app接管的区域 --&gt;&lt;body ng-app&gt;    &lt;!-- ng-model实现双向绑定 --&gt;    &lt;input type=&quot;text&quot; ng-model=&quot;username&quot;&gt;    &lt;div&gt;你输入的用户名为：&#123;&#123;username&#125;&#125;&lt;/div&gt;    &lt;script src=&quot;../js/angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>画图理解入门demo</p><p><img src="/posts/b3a0e706/image-20230220181855274.png" alt="image-20230220181855274"></p><p>安装 <code>ng-inspector.crx</code> - chrome扩展程序,如果crx文件装不上可以先改成zip文件,再来加载即可</p><p><a href="https://www.cnplugins.com/zhuanti/newinstall.html">https://www.cnplugins.com/zhuanti/newinstall.html</a></p><h2 id="四个重要概念"><a href="#四个重要概念" class="headerlink" title="四个重要概念"></a>四个重要概念</h2><ol><li><p>数据绑定: 数据从一个地方A转移(传递)到另一个地方B, 而且这个操作由框架来完成</p></li><li><p>双向数据绑定: 数据可以从View(视图层)流向Model（模型）, 也可以从Model流向View</p><pre><code>视图(View): 也就是我们的页面(主要是Andular指令和表达式)模型(Model) : 作用域对象(当前为$rootScope), 它可以包含一些属性或方法当改变View中的数据, Model对象的对应属性也会随之改变:  ng-model指令  数据从View==&gt;Model当Model域对象的属性发生改变时, 页面对应数据随之更新:  &#123;&#123;&#125;&#125;表达式  数据从Model==&gt;Viewng-model是双向数据绑定, 而&#123;&#123;&#125;&#125;是单向数据绑定</code></pre></li><li><p>ng-init  用来初始化当前作用域变量。(不常用)</p></li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body ng-app ng-init=&quot;name=&#39;tom&#39;&quot;&gt;    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;    &lt;div&gt;您输入的用户名为：&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;    &lt;div&gt;您输入的用户名为：&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;script src=&quot;../js/angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>画图说明双向绑定</p></blockquote><p><img src="/posts/b3a0e706/image-20230220183832537.png" alt="image-20230220183832537"></p><ol start="4"><li>依赖注入</li></ol><pre><code>依赖对象：完成某个特定的功能需要某个对象才能实现，这个对象就是依赖对象。依赖注入：依赖的对象以形参的形式被注入进来使用，这种方式就是依赖注入。angular的 ‘$scope’对象就是依赖对象，并且是依赖注入的形式进行使用。！！！形参必须是特定的名称, 否则Angular无法注入抛异常回调函数的event的就是依赖对象回调函数有形参就是依赖注入</code></pre><p>案例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body ng-app&gt;&lt;div ng-controller=&quot;MyController&quot;&gt;  &lt;input type=&quot;text&quot; placeholder=&quot;姓&quot; ng-model=&quot;firstName&quot;&gt;  &lt;input type=&quot;text&quot; placeholder=&quot;名&quot; ng-model=&quot;lastName&quot;&gt;  &lt;p&gt;输入的姓名为: &#123;&#123;firstName+'-'+lastName&#125;&#125;&lt;/p&gt;  &lt;p&gt;输入的姓名2为: &#123;&#123;getName()&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;  &#123;&#123;firstName&#125;&#125; &lt;!--不能显示--&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/angular-1.2.29/angular.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;  //这种定义controller的方式了解即可,一般不会用这种方式定义controller  //必须是$scope, $scope就是依赖对象, 被angular动态注入的  function MyController ($scope) &#123;    $scope.firstName = &#39;KB&#39;;    $scope.lastName = &#39;Brent&#39;;    //给域对象指定方法    $scope.getName = function() &#123;      return $scope.firstName + &quot;  &quot; + $scope.lastName;    &#125;;    console.log($scope.age);    //声明式和命令式的区别    //1.命令式：命令程序执行的时候每一步都是按照自己的指令，更注重执行的过程    //2.声明式：更注重执行的结果。    //命令式    var arr = [1,2,3,4,5];    var newArr = [];    for(var i=0;i&lt;arr.length;i++)&#123;      var num = arr[i]*2;      newArr.push(num);    &#125;    console.log(newArr);    //声明式    var newArr2 = arr.map(function (item) &#123;      return item*2;    &#125;);    console.log(newArr2);    //命令式更注重的执行的过程    //声明式更注重的执行的结果    //声明式是对命令式的局部包装    //解答题与填空题的区别  &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    document.getElementById(&#39;btn&#39;).onclick = function(event) &#123;        alert(event.clientX);    &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="三个重要对象"><a href="#三个重要对象" class="headerlink" title="三个重要对象"></a>三个重要对象</h2><ol><li>作用域对象 :<br> 一个js实例对象, ng-app指令默认会创建一个根作用域对象(<code>$rootScope</code>)<br> 它的属性和方法与页面中的指令或表达式是关联的</li><li>控制器:<br> 用来控制AngularJS应用数据的 实例对象<br> <code>ng-controller</code> : 指定控制器构造函数, Angular会自动<code>new此函数创建控制器对象</code><br> 同时Angular还有创建一个<code>新的域对象$scope</code>, 它是<code>$rootScope的子对象</code><br> 在控制器函数中声明<code>$scope形参</code>, Angular会自动将$scope传入</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body ng-app&gt;    &lt;div ng-controller=&quot;MyController&quot;&gt;        姓：&lt;input type=&quot;text&quot; ng-model=&quot;firstname&quot;&gt;        名：&lt;input type=&quot;text&quot; ng-model=&quot;lastname&quot;&gt;        &lt;div&gt;输入的姓名为：&#123;&#123;firstname+"-"+lastname&#125;&#125;&lt;/div&gt;        &lt;div&gt;输入的姓名为(func)：&#123;&#123;firstname+"-"+lastname&#125;&#125;&lt;/div&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;!--不能显示--&gt;        &lt;!-- &#123;&#123;name&#125;&#125; --&gt;    &lt;/div&gt;    &lt;script src=&quot;../js/angular-1.2.29/angular.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        function MyController($scope)&#123;            //定义属性            $scope.firstname = &#39;&#39;            $scope.lastname = &#39;&#39;            //定义方法            $scope.getName = function()&#123;                return $scope.firstname+&#39;-&#39;+$scope.lastname            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="3"><li>模块</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body ng-app=&quot;MyApp&quot;&gt;    &lt;div ng-controller=&quot;myctrl1&quot;&gt;        &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;        &lt;div&gt;当前输入的用户名为：&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;/div&gt;    &lt;div ng-controller=&quot;myctrl2&quot;&gt;        &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;        &lt;div&gt;当前输入的用户名为：&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;/div&gt;    &lt;script src=&quot;../js/angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        //得到modul对象        // var module = angular.module(&#39;MyApp&#39;,[])        // //通过module注册controller,多个controller之间互相不影响        // module.controller(&#39;myctrl1&#39;,function($scope)&#123;        //     $scope.name = &#39;&#39;        // &#125;)        // module.controller(&#39;myctrl2&#39;,function($scope)&#123;        //     $scope.name = &#39;&#39;        // &#125;)        //改进写法 使用链式调用  【记住这种就好】        //解决问题1：形参只能写固定的变量名$scope;        //解决问题2：一旦文件压缩，将不能使用，会报错。        angular.module(&#39;MyApp&#39;,[])        .controller(&#39;myctrl1&#39;,[&#39;$scope&#39;,function(a)&#123;            a.name = &#39;myctrl1&#39;        &#125;])        .controller(&#39;myctrl2&#39;,[&#39;$scope&#39;,function(b)&#123;            b.name = &#39;myctrl2&#39;        &#125;])     &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="二个页面语法"><a href="#二个页面语法" class="headerlink" title="二个页面语法"></a>二个页面语法</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ol><li>使用Angular表达式:<br>语法: <br>作用: 显示表达式的结果数据<br>注意: 表达式中引用的变量必须是<strong style="color:red">当前域对象</strong>有的属性(包括其原型属性)</li><li>操作的数据<br>基本类型数据: number&#x2F;string&#x2F;boolean<br>undefined, Infinity, NaN, null解析为空串: “”, 不显示任何效果<br>对象的属性或方法<br>数组</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body ng-app&gt;&lt;p&gt;&#123;&#123;1&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;'尚硅谷'&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;undefined&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;'atguigu'+3&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;4+3&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;true&#125;&#125;&lt;/p&gt;&lt;p ng-init=&quot;a=3;b=4&quot;&gt;&#123;&#123;a+b&#125;&#125;&lt;/p&gt;&lt;p ng-init=&quot;p=&#123;name:&#39;Tom&#39;,age:12&#125;;arr=[true, 3, &#39;atguigu&#39;]&quot;&gt;&#123;&#123;p.name&#125;&#125;---&#123;&#123;p.age&#125;&#125;----&#123;&#123;arr[2]&#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;script type=&#39;text/javascript&#39; src=&quot;../../js/angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="Angular指令"><a href="#Angular指令" class="headerlink" title="Angular指令"></a>Angular指令</h4><pre><code>Angular为HTML页面扩展的: 自定义标签属性或标签与Angular的作用域对象(scope)交互,扩展页面的动态表现力</code></pre><h4 id="常用指令-一"><a href="#常用指令-一" class="headerlink" title="常用指令(一)"></a>常用指令(一)</h4><pre><code>ng-app: 指定模块名，angular管理的区域ng-model： 双向绑定，输入相关标签ng-init： 初始化数据ng-click： 调用作用域对象的方法（点击时）ng-controller: 指定控制器构造函数名，内部会自动创建一个新的子作用域（外部的）ng-bind： 解决使用&#123;&#123;&#125;&#125;显示数据闪屏（在很短时间内显示&#123;&#123;&#125;&#125;）ng-repeat： 遍历数组显示数据， 数组有几个元素就会产生几个新的作用域($index,$first, $last, $middle, $odd, $even)ng-show: 布尔类型， 如果为true才显示ng-hide: 布尔类型， 如果为true就隐藏</code></pre><p>【常用指令(一).html】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; &gt;&lt;div ng-controller=&quot;MyCtrl&quot; ng-init=&quot;age=12&quot;&gt;    &lt;div&gt;        &lt;h2&gt;价格计算器(自动)&lt;/h2&gt;        数量：&lt;input type=&quot;number&quot; ng-model=&quot;count1&quot;&gt;        价格：&lt;input type=&quot;number&quot; ng-model=&quot;price1&quot;&gt;        &lt;p&gt;总计：&#123;&#123;count1 * price1&#125;&#125;&lt;/p&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;h2&gt;价格计算器(手动)&lt;/h2&gt;        数量：&lt;input type=&quot;number&quot; ng-model=&quot;count2&quot;&gt;        价格：&lt;input type=&quot;number&quot; ng-model=&quot;price2&quot;&gt;        &lt;button ng-click=&quot;getTotalPrice()&quot;&gt;计算&lt;/button&gt;        &lt;p&gt;总计：&#123;&#123;totalPrice&#125;&#125;&lt;/p&gt;    &lt;/div&gt;    &lt;!--    * ng-repeat： 遍历数组显示数据， 数组有几个元素就会产生几个新的作用域        * $index, $first, $last, $middle, $odd, $even    --&gt;    &lt;h3&gt;人员信息列表&lt;/h3&gt;    &lt;ul&gt;        &lt;li ng-repeat=&quot;person in persons&quot;&gt;偶数行：&#123;&#123;$even&#125;&#125;,奇数行&#123;&#123;$odd&#125;&#125;,中间的：&#123;&#123;$middle&#125;&#125;,最后一个：&#123;&#123;$last&#125;&#125;,第一个：&#123;&#123;$first&#125;&#125;,第&#123;&#123;$index + 1&#125;&#125;个，&#123;&#123;person.name&#125;&#125;----&#123;&#123;person.age&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;!--    * ng-bind： 解决使用&#123;&#123;&#125;&#125;显示数据闪屏（在很短时间内显示&#123;&#123;&#125;&#125;）    --&gt;    &lt;!--当使用ng-bind的时候表达式不在生效--&gt;    &lt;p ng-bind=&quot;count2&quot;&gt;&#123;&#123;'asdfdsfds'&#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123;count2&#125;&#125;&lt;/p&gt;    &lt;!--      * ng-show: 布尔类型， 如果为true才显示      * ng-hide: 布尔类型， 如果为true就隐藏    --&gt;    &lt;!--&lt;button ng-click=&quot;switch()&quot;&gt;切换&lt;/button&gt;--&gt;    &lt;!--&lt;p ng-show=&quot;isLike&quot;&gt;我爱范冰冰&lt;/p&gt;--&gt;    &lt;!--&lt;p ng-hide=&quot;isLike&quot;&gt;范冰冰爱我&lt;/p&gt;--&gt;    &lt;button ng-click=&quot;switch()&quot;&gt;切换&lt;/button&gt;    &lt;p ng-show=&quot;isLike&quot;&gt;我喜欢贾静雯&lt;/p&gt;    &lt;p ng-hide=&quot;isLike&quot;&gt;贾静雯喜欢我&lt;/p&gt;&lt;/div&gt;&lt;script type=&#39;text/javascript&#39; src=&#39;../../js/angular-1.5.5/angular.js&#39;&gt;&lt;/script&gt;&lt;script type=&#39;text/javascript&#39;&gt;    //创建模块对象    angular.module(&#39;myApp&#39;, [])            .controller(&#39;MyCtrl&#39;, [&#39;$scope&#39;, function ($scope) &#123;                $scope.count1 = 1;                $scope.price1 = 20;                $scope.count2 = 1;                $scope.price2 = 10;                $scope.totalPrice = $scope.count1 * $scope.price1;                $scope.getTotalPrice = function () &#123;                    $scope.totalPrice =  this.count2 * this.count2;                &#125;;                $scope.persons = [                    &#123;name : &#39;kobe&#39;, age : 39&#125;,                    &#123;name : &#39;anverson&#39;, age : 41&#125;,                    &#123;name : &#39;weide&#39;, age : 38&#125;,                    &#123;name : &#39;tim&#39;, age : 40&#125;,                    &#123;name : &#39;curry&#39;, age : 29&#125;                ];                $scope.isLike = true;                $scope.switch = function () &#123;                    $scope.isLike = !$scope.isLike;                &#125;            &#125;])&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="常用指令-二"><a href="#常用指令-二" class="headerlink" title="常用指令(二)"></a>常用指令(二)</h4><pre><code> ng-class: 动态引用定义的样式  &#123;aClass:true, bClass:false&#125; ng-style: 动态引用通过js指定的样式对象   &#123;color:&#39;red&#39;,background:&#39;blue&#39;&#125; ng-click: 点击监听, 值为函数调用, 可以传$event ng-mouseenter: 鼠标移入监听, 值为函数调用, 可以传$event ng-mouseleave: 鼠标移出监听, 值为函数调用, 可以传$event</code></pre><p>【常用指令(二).html】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;style&gt;  .evenB &#123;    background-color: grey;  &#125;  .oddB &#123;    background-color: green;  &#125;&lt;/style&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;MyController&quot;&gt;&lt;div style=&quot;width: 100px;height: 100px;background-color: red&quot;     ng-mouseover=&quot;over()&quot; ng-mouseleave=&quot;leave()&quot; ng-style=&quot;myStyle&quot;&gt;&lt;/div&gt;&lt;div&gt;  &lt;ul&gt;      &lt;li ng-repeat=&quot;p in persons&quot; ng-class=&quot;&#123;evenB:$even, oddB:$odd&#125;&quot;&gt;        &#123;&#123;p.name&#125;&#125;---&#123;&#123;p.age&#125;&#125;      &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&#39;text/javascript&#39; src=&quot;../../js/angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;  angular.module(&#39;myApp&#39;, [])      .controller(&#39;MyController&#39;, function ($scope) &#123;        $scope.over = function () &#123;          $scope.myStyle = &#123;            background: &#39;blue&#39;          &#125;;        &#125;;        $scope.leave = function () &#123;          $scope.myStyle = &#123;            background: &#39;green&#39;          &#125;;        &#125;;        $scope.persons = [          &#123;name: &#39;Tom&#39;, age: 12&#125;,          &#123;name: &#39;Tom2&#39;, age: 13&#125;,          &#123;name: &#39;Tom3&#39;, age: 14&#125;,          &#123;name: &#39;Tom4&#39;, age: 15&#125;,          &#123;name: &#39;Tom5&#39;, age: 16&#125;        ];      &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">Angularjs1.x简单入门笔记整理</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="angular" scheme="https://heliufang.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>js的防抖和节流</title>
    <link href="https://heliufang.github.io/posts/3c6138e1/"/>
    <id>https://heliufang.github.io/posts/3c6138e1/</id>
    <published>2023-02-12T02:09:09.000Z</published>
    <updated>2023-02-12T03:34:48.079Z</updated>
    
    <content type="html"><![CDATA[<p>B站视频教程: <a href="https://www.bilibili.com/video/BV1tG411J7dc">JS_防抖_节流</a></p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h3 id="搜索框带来的问题"><a href="#搜索框带来的问题" class="headerlink" title="搜索框带来的问题"></a>搜索框带来的问题</h3><p>需求：根据输入框内容来请求数据</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id=&quot;searchTxt&quot; type=&quot;search&quot; placeholder=&quot;请输入关键字检索&quot;&gt;    &lt;script&gt;        document.querySelector(&quot;#searchTxt&quot;).oninput = function()&#123;            console.log(&#39;发送请求，当前输入框值：&#39;,this.value)        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>上面的代码会带来一个问题：用户每输入一个关键字都会触发</p><p><img src="/posts/3c6138e1/image-20230212103615638.png" alt="image-20230212103615638"></p><p>现在是要求是用户停下来不输入的时候再<strong style="color:red">触发一次</strong>，这个时候就需要用到防抖函数了</p><h3 id="实现的思路"><a href="#实现的思路" class="headerlink" title="实现的思路"></a>实现的思路</h3><ol><li>事件函数执行,先<strong style="color:red">创建个定时器</strong></li><li>把<strong style="color:red">逻辑代码</strong>放到<strong style="color:red">定时器</strong>中</li><li>当函数再次触发，<strong style="color:red">清除定时器</strong></li><li>创建一个<strong style="color:red">新定时器</strong>即可</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id=&quot;searchTxt&quot; type=&quot;search&quot; placeholder=&quot;请输入关键字检索&quot;&gt;    &lt;script&gt;        let t = null        document.querySelector(&quot;#searchTxt&quot;).oninput = function()&#123;            clearTimeout(t) //有定时器则清除            t = setTimeout(() =&gt; &#123;                console.log(&#39;发送请求，当前输入框值：&#39;,this.value)            &#125;, 1000);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/posts/3c6138e1/image-20230212104119184.png" alt="image-20230212104119184"></p><h3 id="封装防抖函数"><a href="#封装防抖函数" class="headerlink" title="封装防抖函数"></a>封装防抖函数</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id=&quot;searchTxt&quot; type=&quot;search&quot; placeholder=&quot;请输入关键字检索&quot;&gt;    &lt;script&gt;        document.querySelector(&quot;#searchTxt&quot;).oninput = debounce(function()&#123;            console.log(&#39;发送请求，当前输入框值：&#39;,this.value)        &#125;)        //封装一个公共的防抖函数        function debounce(fn)&#123;//将函数逻辑放入fn中            let t = null //此处利用闭包保存定时器            return function()&#123;                clearTimeout(t) //有定时器则清除                t = setTimeout(() =&gt; &#123;                    //箭头函数指向外面函数的this,而外面函数由input触发                    fn.call(this) //利用call改变fn的this,否则fn的this为undefined                &#125;, 1000);            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="滚动条加载带来的问题"><a href="#滚动条加载带来的问题" class="headerlink" title="滚动条加载带来的问题"></a>滚动条加载带来的问题</h3><p>需求：页面滚动时,加载数据列表</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box&#123;            height: 1000px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        document.onscroll = function()&#123;            console.log(&#39;发送ajax,请求下一页数据&#39;)        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>上面的代码会带来一个问题：用户轻轻下拉滚动条,onscroll中的逻辑会触发很多次</p><p><img src="/posts/3c6138e1/image-20230212111058652.png" alt="image-20230212111058652"></p><p>现在是要求是<strong style="color:red">降低触发事件的频率</strong>,这个时候就需要用到节流函数了。</p><h3 id="实现的思路-1"><a href="#实现的思路-1" class="headerlink" title="实现的思路"></a>实现的思路</h3><ol><li>事件函数执行,先判断是否有定时器，有则直接<strong style="color:red">return</strong></li><li>把逻辑代码放到<strong style="color:red">定时器</strong>中</li><li>定时器执行后，<strong style="color:red">置空</strong>定时器变量</li></ol><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box&#123;            height: 1000px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;    &lt;script&gt;        let t = null        document.onscroll = function()&#123;            if(null != t) return //关键点1：有定时器则return            t = setTimeout(() =&gt; &#123;//关键点2：逻辑代码放到定时器中                console.log(&#39;发送ajax,请求下一页数据&#39;)                t = null  //关键点3：定时器执行完毕,置空定时器变量            &#125;, 500);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="封装节流函数"><a href="#封装节流函数" class="headerlink" title="封装节流函数"></a>封装节流函数</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box&#123;            height: 1000px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;    &lt;script&gt;                document.onscroll = throttle(function () &#123;            console.log(&#39;发送ajax,请求下一页数据&#39;,this)        &#125;)        //封装一个节流函数        function throttle(fn) &#123;            return function()&#123;                //这里用的是fn.t变量的形式来保存定时器变量                if(null != fn.t) return                 fn.t = setTimeout(() =&gt; &#123;                    fn.call(this)                    fn.t = null                &#125;, 500);            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">防抖和节流技术总结</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="防抖" scheme="https://heliufang.github.io/tags/%E9%98%B2%E6%8A%96/"/>
    
    <category term="节流" scheme="https://heliufang.github.io/tags/%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>pinia笔记</title>
    <link href="https://heliufang.github.io/posts/1e33e6ff/"/>
    <id>https://heliufang.github.io/posts/1e33e6ff/</id>
    <published>2023-02-10T06:57:38.000Z</published>
    <updated>2023-02-10T09:06:48.971Z</updated>
    
    <content type="html"><![CDATA[<p>B站教学视频: <a href="https://www.bilibili.com/video/BV11Y411b7nb">抛弃 Vuex，使用 Pinia</a></p><p><a href="https://pinia.vuejs.org/zh/index.html">pinia官方中文文档</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Pinia <a href="https://github.com/vuejs/pinia/commit/06aeef54e2cad66696063c62829dac74e15fd19e">最初是在 2019 年 11 月左右重新设计使用</a> <a href="https://github.com/vuejs/composition-api">Composition API</a> 。</p><p>Pinia 是 Vue 的存储库，它允许您跨组件&#x2F;页面共享状态。类似vuex</p><blockquote><p>Vuex 3.x 是 Vuex 的 Vue 2 而 Vuex 4.x 是 Vue 3</p></blockquote><p>Pinia API 与 Vuex ≤4 有很大不同，即：</p><ul><li><em>mutations</em> 不再存在</li><li>无需创建自定义复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能利用 TS 类型推断。</li><li>不再需要注入、导入函数、调用函数、享受自动完成功能！</li><li>无需动态添加 Store，默认情况下它们都是动态的</li><li>不再有 <em>modules</em> 的嵌套结构</li><li>没有 <em>命名空间模块</em></li></ul><h2 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h2><ul><li>新建一个新的vite项目</li></ul><pre><code class="shell">yarn create vite</code></pre><p>按提示选择vue、typscript</p><ul><li>安装依赖</li></ul><pre><code class="shell">yarn</code></pre><ul><li>安装pinia</li></ul><pre><code class="shell">yarn add pinia</code></pre><h2 id="pinia基本使用"><a href="#pinia基本使用" class="headerlink" title="pinia基本使用"></a>pinia基本使用</h2><ul><li><code>src/main.ts</code>中创建pinia实例并且挂在vue实例上</li></ul><pre><code class="js">import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#123; createPinia &#125; from &#39;pinia&#39;//创建pinia实例const pinia = createPinia()const app = createApp(App)//挂载pinia实例app.use(pinia)app.mount(&#39;#app&#39;)</code></pre><ul><li><code>src/store/index.ts</code> 主要是定义容器</li></ul><pre><code class="js">import &#123; defineStore &#125; from &#39;pinia&#39;//定义容器export const useMainStore = defineStore(&#39;main&#39;,&#123;    /**   * 类似与组件的data， 用来存储全局状态   * 1.必须是函数：这样是为了在服务端渲染的时候避免交叉请求导致的数据状态污染（客户端其实无所谓）   * 2.必须是箭头函数：为了更好的ts类型推导   * 返回值：一个函数，调用该函数即可得到容器实例   */    state: () =&gt; (&#123;        count: 666,        name: &#39;tom&#39;,        arr: [1,2,3]    &#125;),    /**   * 类似于组件的computed，用来封装计算属性，有【缓存】功能   */    getters: &#123;    &#125;,    /**   * 完全类比于Vue2组件中的methods（可以直接用this)，用来【封装业务逻辑】，修改state   */    actions: &#123;    &#125;&#125;)</code></pre><ul><li><code>src/components/HelloWorld.vue</code></li></ul><pre><code class="html">&lt;template&gt;  &#123;&#123; mainStore.count &#125;&#125;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;//导入上面定义的storeimport &#123; useMainStore &#125; from &#39;../store&#39;//获取容器中的stateconst mainStore = useMainStore()//从store中取值console.log(mainStore.count)&lt;/script&gt;</code></pre><ul><li><code>src/App.vue</code>删除不必要的内容，保留HelloWorld组件</li></ul><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;HelloWorld /&gt;&lt;/template&gt;</code></pre><h2 id="解构访问pinia数据"><a href="#解构访问pinia数据" class="headerlink" title="解构访问pinia数据"></a>解构访问pinia数据</h2><p>不能直接使用解构,这样会丢失响应式,因为pinia在底层将state用reactive做了处理</p><p><code>src/components/HelloWorld.vue</code></p><pre><code class="html">&lt;template&gt;  &#123;&#123; count &#125;&#125;-&#123;&#123; name &#125;&#125;-&#123;&#123; arr &#125;&#125;  &lt;div&gt;&lt;button @click=&quot;addOne&quot;&gt;count+1&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useMainStore &#125; from &#39;../store&#39;import &#123; storeToRefs &#125; from &#39;pinia&#39; //获取容器中的stateconst mainStore = useMainStore()//修改容器中的stateconst addOne = () =&gt; &#123;  mainStore.count += 1&#125;//不能直接使用解构,这样会丢失响应式,因为pinia在底层将state用reactive做了处理// const &#123;count,name&#125; = mainStore//若想使用解构,则需要用storeToRefs将结构出的数据做ref响应式代理const &#123;count,name&#125; = storeToRefs(mainStore)&lt;/script&gt;</code></pre><h2 id="状态更新和Actions"><a href="#状态更新和Actions" class="headerlink" title="状态更新和Actions"></a>状态更新和Actions</h2><p>状态更新的四种方式</p><ul><li><code>src/components/HelloWorld.vue</code></li></ul><pre><code class="html">&lt;template&gt;  &#123;&#123; count &#125;&#125;-&#123;&#123; name &#125;&#125;-&#123;&#123; arr &#125;&#125;  &lt;div&gt;&lt;button @click=&quot;addOne&quot;&gt;count+1&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useMainStore &#125; from &#39;../store&#39;import &#123; storeToRefs &#125; from &#39;pinia&#39; //获取容器中的stateconst mainStore = useMainStore()//修改容器中的stateconst addOne = () =&gt; &#123;  //方式一：直接修改  //mainStore.count += 1  //方式二：使用 $patch(对象) 批量修改，建议使用，底层做了性能优化  // mainStore.$patch(&#123;  //   count: mainStore.count + 1,  //   name: &#39;jerry&#39;,  //   arr: [...mainStore.arr,4]  // &#125;)  //方式三：使用 $patch(回调函数)  【推荐】  //回调函数中的state参数，就是Store定义时里面的state!  // mainStore.$patch(state =&gt; &#123;  //   state.count ++  //   state.name = &#39;lucy&#39;  //   state.arr.push(5)  // &#125;)  // 方式四：逻辑较为复杂时，应封装到Store的actions中，并对外暴露接口  mainStore.addN(10)&#125;const &#123;count,name,arr&#125; = storeToRefs(mainStore)&lt;/script&gt;</code></pre><ul><li><code>src/store/index.ts</code></li></ul><pre><code class="js">import &#123; defineStore &#125; from &#39;pinia&#39;//定义容器export const useMainStore = defineStore(&#39;main&#39;,&#123;    state: () =&gt; (&#123;        count: 666,        name: &#39;tom&#39;,        arr: [1, 2, 3]    &#125;),    getters: &#123;    &#125;,    //注意：不能使用箭头函数定义actions！因为箭头函数绑定了外部this    actions: &#123;        addN(num: number)&#123;            //单个修改---&gt;直接使用this,类似vue2            // this.count += num            // this.name = &#39;linda&#39;            // this.arr.push(6)             //批量修改---&gt;建议使用patch做优化             this.$patch(state =&gt; &#123;                state.count += num                state.name = &#39;jack&#39;                state.arr.push(8)             &#125;)        &#125;    &#125;&#125;)</code></pre><h2 id="Getters的使用"><a href="#Getters的使用" class="headerlink" title="Getters的使用"></a>Getters的使用</h2><p>和计算属性类似,带有缓存功能</p><ul><li><code>src/components/HelloWorld.vue</code></li></ul><pre><code class="html">&lt;template&gt;  &#123;&#123; count &#125;&#125;-&#123;&#123; name &#125;&#125;-&#123;&#123; arr &#125;&#125;-&#123;&#123; count10 &#125;&#125;-&#123;&#123; count20 &#125;&#125;  &lt;div&gt;&lt;button @click=&quot;addOne&quot;&gt;count+1&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useMainStore &#125; from &#39;../store&#39;import &#123; storeToRefs &#125; from &#39;pinia&#39; //获取容器中的stateconst mainStore = useMainStore()//修改容器中的stateconst addOne = () =&gt; &#123;  mainStore.addN(10)&#125;const &#123;count,name,arr,count10,count20&#125; = storeToRefs(mainStore)&lt;/script&gt;</code></pre><ul><li><code>src/store/index.ts</code></li></ul><pre><code class="js">import &#123; defineStore &#125; from &#39;pinia&#39;//定义容器export const useMainStore = defineStore(&#39;main&#39;,&#123;    state: () =&gt; (&#123;        count: 666,        name: &#39;tom&#39;,        arr: [1, 2, 3]    &#125;),    //类似于组件的computed，用来封装计算属性，有【缓存】功能    getters: &#123;        //不带state参数：此时就不能对返回值类型做自动推导了，必须手动指定        count10(): number&#123;            console.log(&#39;count10&#39;)            return this.count + 10        &#125;,        //带state参数：对返回值类型做自动推导 【推荐这种】        count20(state)&#123;             return state.count + 20        &#125;    &#125;,    //注意：不能使用箭头函数定义actions！因为箭头函数绑定了外部this    actions: &#123;        addN(num: number)&#123;             this.$patch(state =&gt; &#123;                state.count += num                state.name = &#39;jack&#39;                state.arr.push(8)             &#125;)        &#125;    &#125;&#125;)</code></pre><h2 id="pinia和vue-devtools"><a href="#pinia和vue-devtools" class="headerlink" title="pinia和vue devtools"></a>pinia和vue devtools</h2><p>第一种查看方式</p><p><img src="/posts/1e33e6ff/image-20230210165300143.png" alt="image-20230210165300143"></p><p>第二种查看方式： 组件内部</p><p><img src="/posts/1e33e6ff/image-20230210165337467.png" alt="image-20230210165337467"></p>]]></content>
    
    
    <summary type="html">vue状态管理-pinia笔记整理</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
    <category term="pinia" scheme="https://heliufang.github.io/tags/pinia/"/>
    
  </entry>
  
  <entry>
    <title>react笔记</title>
    <link href="https://heliufang.github.io/posts/27fcdfc0/"/>
    <id>https://heliufang.github.io/posts/27fcdfc0/</id>
    <published>2022-12-30T09:15:28.000Z</published>
    <updated>2023-01-08T03:53:03.045Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1wy4y1D7JT">尚硅谷React教程（2022加更，B站超火react教程）</a></p><h2 id="react入门"><a href="#react入门" class="headerlink" title="react入门"></a>react入门</h2><p>React：用于构建用户界面的 JavaScript 库。由 <code>Facebook</code> 开发且开源。</p><p>原生 JavaScript 的痛点：</p><ul><li>操作 DOM 繁琐、效率低</li><li>使用 JavaScript 直接操作 DOM，浏览器进行大量重绘重排</li><li>原生 JavaScript 没有组件化编码方案，代码复用率低</li></ul><p>React 的特点：</p><ul><li>采用组件化模式、声明式编码，提高开发效率和组件复用率</li><li>在 <code>React Native</code> 中可用 React 语法进行移动端开发</li><li>使用虚拟 DOM 和 Diffing 算法，减少与真实 DOM 的交互</li></ul><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><ul><li><code>react.development.js</code> ：React 核心库</li><li><code>react-dom.development.js</code> ：提供 DOM 操作的 React 扩展库</li><li><code>babel.min.js</code> ：解析 JSX 语法，转换为 JS 代码</li></ul><pre><code class="html">&lt;!-- 引入react核心库 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入babel，用于将jsx转为js --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 准备容器 --&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;!-- 此处一定要写babel，表示写的不是 JS，而是 JSX，并且靠 babel 翻译 --&gt;&lt;script type=&quot;text/babel&quot;&gt;        // 创建虚拟dom        let VDOM = &lt;div&gt;Hello React&lt;/div&gt;        // 渲染        ReactDOM.render(VDOM,document.getElementById(&#39;app&#39;))&lt;/script&gt;</code></pre><h3 id="创建虚拟DOM的两种方式"><a href="#创建虚拟DOM的两种方式" class="headerlink" title="创建虚拟DOM的两种方式"></a>创建虚拟DOM的两种方式</h3><p>两种方式是：js和jsx</p><ul><li>使用 JS 创建虚拟 DOM 比 JSX 繁琐</li><li>JSX 可以让程序员更加简单地创建虚拟 DOM，相当于语法糖</li><li>最终 babel 会把 JSX 语法转换为 JS</li></ul><blockquote><p>开发中一般使用jsx的方式，也就是入门案例中使用的方式，会jsx就行</p></blockquote><p>第一种：使用js创建</p><pre><code class="jsx">//1.使用 React 提供的 API 创建虚拟DOMconst VDOM = React.createElement(&#39;h1&#39;, &#123; id: &#39;title&#39; &#125;, React.createElement(&#39;span&#39;, &#123;&#125;, &#39;Hello,React&#39;))//2.渲染虚拟DOM到页面ReactDOM.render(VDOM, document.getElementById(&#39;app&#39;))</code></pre><p>第二种：使用jsx创建(<strong style="color:red">掌握</strong>)  例子见入门案例</p><h3 id="虚拟DOM和真实DOM"><a href="#虚拟DOM和真实DOM" class="headerlink" title="虚拟DOM和真实DOM"></a>虚拟DOM和真实DOM</h3><p>关于虚拟 DOM：</p><ol><li>本质是 Object 类型的对象（一般对象）</li><li>虚拟 DOM 比较<strong style="color:red">“轻”</strong>，真实 DOM 比较<strong style="color:red">“重”</strong>，因为虚拟 DOM 是 React 内部在用，无需真实 DOM 上那么多的属性。</li><li>虚拟 DOM 最终会被 React 转化为真实 DOM，呈现在页面上。</li></ol><pre><code class="jsx">//如果VDOM如果有多行，可以用()包起来const VDOM = (    &lt;h1 id=&quot;title&quot;&gt;    &lt;span&gt;Hello,React&lt;/span&gt;    &lt;/h1&gt;)ReactDOM.render(VDOM, document.getElementById(&#39;app&#39;))const TDOM = document.getElementById(&#39;demo&#39;)console.log(&#39;虚拟DOM&#39;, VDOM)console.log(&#39;真实DOM&#39;, TDOM)</code></pre><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><ul><li>全称：JavaScript XML</li><li>React 定义的类似于 XML 的 JS 扩展语法；本质是 <code>React.createElement()</code> 方法的语法糖</li><li>作用：简化创建虚拟 DOM</li></ul><h4 id="JSX的语法规则"><a href="#JSX的语法规则" class="headerlink" title="JSX的语法规则"></a>JSX的语法规则</h4><ul><li>定义虚拟 DOM 时，不要写引号</li><li>标签中混入 JS 表达式需要使用 <code>&#123;&#125;</code></li><li>指定类名不用 <code>class</code>，使用 <code>className</code></li><li>内联样式，使用 <code>style=&#123; &#123; key: value &#125; &#125;</code> 的形式</li><li>只能有一个根标签</li><li>标签必须闭合，单标签结尾必须添加 <code>/</code>：<code>&lt;input type=&quot;text&quot; /&gt;</code></li><li>标签首字母小写，则把标签转换为 HTML 对应的标签，若没有，则报错</li><li>标签首字母大写，则渲染对应组件，若没有定义组件，则报错</li></ul><pre><code class="jsx">let title = &#39;HeLLOjSx&#39;let VDOM = (    &lt;div title=&#123;title.toUpperCase()&#125;&gt;    &lt;div className=&quot;info&quot;&gt;info&lt;/div&gt;&lt;div style=&#123;&#123;fontSize: '26px',color: 'red'&#125;&#125;&gt;style内联样式&lt;/div&gt;&lt;/div&gt;)ReactDOM.render(VDOM,document.getElementById(&quot;app&quot;))</code></pre><h4 id="js语句和表达式的区别"><a href="#js语句和表达式的区别" class="headerlink" title="js语句和表达式的区别"></a>js语句和表达式的区别</h4><ul><li>表达式：一个表达式会产生一个<code>值</code>，可以放在任何一个需要值的地方</li></ul><pre><code class="js">aa + bdemo(1)arr.map()function test() &#123;&#125;</code></pre><ul><li>语句(代码)：</li></ul><pre><code class="js">if()&#123;&#125;for()&#123;&#125;switch()&#123;case:xxxx&#125;</code></pre><pre><code class="jsx">let arr = [&#39;vue&#39;,&#39;react&#39;,&#39;angular&#39;]let VDOM = (    &lt;ul&gt;    &#123;        arr.map( v =&gt; &lt;li&gt;&#123;v&#125;&lt;/li&gt; )    &#125;      &lt;/ul&gt;)ReactDOM.render(VDOM,document.getElementById(&quot;app&quot;))</code></pre><h2 id="react面向组件编程"><a href="#react面向组件编程" class="headerlink" title="react面向组件编程"></a>react面向组件编程</h2><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>要点：</p><ul><li>组件名称<strong style="color:red">首字母必须大写</strong>，否则会解析成普通标签导致报错，详见 JSX 语法规则</li><li>函数需返回一个虚拟 DOM</li><li>渲染组件时需要使用标签形式，同时标签必须闭合</li></ul><p>渲染组件的过程：</p><ul><li>React 解析标签，寻找对应组件</li><li>发现组件是函数式组件，则调用函数，将返回的虚拟 DOM 转换为真实 DOM ，并渲染到页面中</li></ul><pre><code class="jsx">//1.创建函数式组件  function MyComponent() &#123;    console.log(this)//undefined    return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;  &#125;  //2.渲染组件到页面  ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&#39;app&#39;))</code></pre><blockquote><p>注意： 上面函数组件内部this 是 undefined，因为 babel 编译后开启了严格模式</p></blockquote><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>要点：</p><ul><li>使用class关键字来定义组件</li><li>使用extends来继承React.Component类</li><li>类中使用render方法来返回虚拟DOM</li></ul><p>组件渲染过程：</p><ul><li>React 解析组件标签，寻找组件</li><li>发现是类式组件，则 <code>new</code> 该类的实例对象，通过实例调用原型上的 <code>render</code> 方法</li><li>将 <code>render</code> 返回的虚拟 DOM 转为真实 DOM ，渲染到页面上·</li></ul><pre><code class="jsx">// 创建类式组件  class MyComponent extends React.Component &#123;    render() &#123;      console.log(&#39;render中的this：&#39;, this)      return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;/h2&gt;    &#125;  &#125;  ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&#39;app&#39;))</code></pre><h3 id="组件实例的三大属性"><a href="#组件实例的三大属性" class="headerlink" title="组件实例的三大属性"></a>组件实例的三大属性</h3><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p><code>state</code> 是组件实例对象最重要的属性，值为对象。又称为状态机，通过更新组件的 <code>state</code> 来更新对应的页面显示。</p><p>要点：</p><ul><li>初始化 <code>state</code></li><li>React 中事件绑定</li><li><code>this</code> 指向问题</li><li><code>setState</code> 修改 <code>state</code> 状态</li><li><code>constructor</code> 、<code>render</code> 、自定义方法的调用次数</li></ul><pre><code class="jsx">class Sum extends React.Component&#123;    constructor(props)&#123;// 调用一次        super(props)        //初始化state        this.state = &#123;count: 0&#125;        //解决this为undefined问题,将原型上面的add方法改变this之后，挂在实例上        this.add = this.add.bind(this)         console.log(this)    &#125;    add()&#123;//这样写是挂在原型上        console.log(&quot;add&quot;,this)        //更新state的值        this.setState(&#123;            count: this.state.count + 1        &#125;)    &#125;    render()&#123;//调用 1+N次        return (            // 注意绑定事件的方式:a)驼峰 b)带上&#123;&#125;  onClick=&#123;this.add&#125;                &lt;div&gt;                    sum的值：&#123; this.state.count &#125;&lt;br/&gt;                    &lt;button onClick=&#123;this.add&#125;&gt;+1&lt;/button&gt;                                    &lt;/div&gt;           )    &#125;&#125;ReactDOM.render(&lt;Sum /&gt;,document.getElementById(&quot;app&quot;))</code></pre><p>简化版(<strong style="color:red">推荐</strong>)</p><pre><code class="jsx">class Sum extends React.Component&#123;    // = 表示直接挂在组件实例身上    state = &#123;count: 0&#125;    //采用箭头函数 + 赋值语句形式 this指向外面组件的this    add = () =&gt; &#123;         console.log(&quot;add&quot;,this) //this为组件实例        //更新state的值        this.setState(&#123;count: this.state.count + 1&#125;)    &#125;    render()&#123;//调用 1+N次        return (            &lt;div&gt;                sum的值：&#123; this.state.count &#125;&lt;br/&gt;                &lt;button onClick=&#123;this.add&#125;&gt;+1&lt;/button&gt;                            &lt;/div&gt;            )    &#125;&#125;ReactDOM.render(&lt;Sum /&gt;,document.getElementById(&quot;app&quot;))</code></pre><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>每个组件对象都有 <code>props</code> 属性，组件标签的属性都保存在 <code>props</code> 中。<code>props</code> 是<code>只读</code>的，不能修改。</p><h5 id="props的基本使用"><a href="#props的基本使用" class="headerlink" title="props的基本使用"></a>props的基本使用</h5><p>通过标签属性传值,会包装在组件的props属性上面。</p><pre><code class="jsx">class Person extends React.Component &#123;    render()&#123;        console.log(this.props)//&#123;name: &#39;青阳&#39;, age: 18, gender: &#39;男&#39;&#125;        const &#123;name , age, gender&#125; = this.props        return (            &lt;div&gt;                &lt;div&gt;name: &#123;name&#125;&lt;/div&gt;                &lt;div&gt;age:  &#123;age&#125;&lt;/div&gt;                &lt;div&gt;gender: &#123;gender&#125;&lt;/div&gt;            &lt;/div&gt;        )    &#125;&#125;// 类似于标签属性传值 注意：数值要用&#123;&#125;ReactDOM.render(&lt;Person name=&quot;青阳&quot; age=&#123;18&#125; gender=&quot;男&quot;/&gt;,document.getElementById(&#39;app&#39;))</code></pre><h5 id="批量传递props"><a href="#批量传递props" class="headerlink" title="批量传递props"></a>批量传递props</h5><pre><code class="jsx">class Person extends React.Component &#123;    render()&#123;        console.log(this.props)        const &#123;name , age, gender&#125; = this.props        return (            &lt;div&gt;                &lt;div&gt;name: &#123;name&#125;&lt;/div&gt;                &lt;div&gt;age:  &#123;age&#125;&lt;/div&gt;                &lt;div&gt;gender: &#123;gender&#125;&lt;/div&gt;            &lt;/div&gt;        )    &#125;&#125;const p = &#123;name: &#39;青阳&#39;,age: 19,gender: &#39;男&#39;&#125;//通过...批量传递propsReactDOM.render(&lt;Person &#123;...p&#125; /&gt;,document.getElementById(&#39;app&#39;))</code></pre><h5 id="props的类型限制"><a href="#props的类型限制" class="headerlink" title="props的类型限制"></a>props的类型限制</h5><p>在 <code>React 15.5</code> 以前，<code>React</code> 身上有一个 <code>PropTypes</code> 属性可直接使用，即 <code>name: React.PropTypes.string.isRequired</code> ，没有把 <code>PropTypes</code> 单独封装为一个模块。</p><p>从 <code>React 15.5</code> 开始，把 <code>PropTypes</code> 单独封装为一个模块，需要额外导入使用。</p><blockquote><p>了解即可,用的时候再看,老项目可能使用这种，最新一般使用ts来做类型校验.</p></blockquote><pre><code class="jsx">&lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;  class Person extends React.Component &#123;    render() &#123;      const &#123; name, age, sex &#125; = this.props      return (        &lt;ul&gt;          &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;          &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;          &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt;        &lt;/ul&gt;      )    &#125;  &#125;  // 类型和必要性限制  Person.propTypes = &#123;    name: PropTypes.string.isRequired,    sex: PropTypes.string,    age: PropTypes.number,    // 限制 speak 为函数    speak: PropTypes.func,  &#125;  // 指定默认值  Person.defaultProps = &#123;    sex: &#39;male&#39;,    age: 19,  &#125;  ReactDOM.render(&lt;Person name=&quot;Vue&quot; sex=&quot;male&quot; age=&#123;11&#125; speak=&#123;speak&#125; /&gt;, document.getElementById(&#39;test&#39;))  function speak() &#123;    console.log(&#39;speaking...&#39;)  &#125;&lt;/script&gt;</code></pre><p><code>Person.propTypes</code> 和 <code>Person.defaultProps</code> 可以看作在类身上添加属性，利用 <code>static</code> 关键词就能在类内部进行声明。因此所谓简写只是从类外部移到类内部。</p><pre><code class="jsx">&lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;  class Person extends React.Component &#123;    static propTypes = &#123;      name: PropTypes.string.isRequired,      sex: PropTypes.string,      age: PropTypes.number,      // 限制 speak 为函数      speak: PropTypes.func,    &#125;    static defaultProps = &#123;      sex: &#39;male&#39;,      age: 19,    &#125;    render() &#123;      const &#123; name, age, sex &#125; = this.props      return (        &lt;ul&gt;          &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;          &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;          &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt;        &lt;/ul&gt;      )    &#125;  &#125;  ReactDOM.render(&lt;Person name=&quot;Vue&quot; sex=&quot;male&quot; age=&#123;11&#125; speak=&#123;speak&#125; /&gt;, document.getElementById(&#39;test&#39;))  function speak() &#123;    console.log(&#39;speaking...&#39;)  &#125;&lt;/script&gt;</code></pre><h5 id="函数组件使用props"><a href="#函数组件使用props" class="headerlink" title="函数组件使用props"></a>函数组件使用props</h5><p>由于函数可以传递参数，因此函数式组件可以使用 <code>props</code> 。</p><pre><code class="jsx">function Person(props)&#123;    const &#123;name,age,gender&#125; = props    return &lt;div&gt;个人信息 name：&#123;name&#125; , age：&#123;age&#125; , gender：&#123;gender&#125;&lt;/div&gt;&#125;Person.propTypes = &#123;    age: PropTypes.number.required&#125;Person.defaultProps = &#123;    age: 10&#125;const p = &#123;name: &#39;tom&#39;,gender: &#39;男&#39;&#125;ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="类组件的构造器和props"><a href="#类组件的构造器和props" class="headerlink" title="类组件的构造器和props"></a>类组件的构造器和props</h5><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#constructor">官网文档说明</a>  构造函数一般用在两种情况：</p><ul><li>通过给 <code>this.state</code> 赋值对象来初始化内部 <code>state</code></li><li>为事件处理函数绑定实例</li></ul><pre><code class="jsx">constructor(props) &#123;  super(props)  // 初始化 state  this.state = &#123; isHot: true, wind: &#39;微风&#39; &#125;  // 解决 this 指向问题  this.changeWeather = this.changeWeather.bind(this)&#125;</code></pre><blockquote><p>因此构造器一般都不需要写。如果要在构造器内使用 <code>this.props</code> 才声明构造器，并且需要在最开始调用 <code>super(props)</code></p></blockquote><h4 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h4><p>Refs 提供了一种方式，允许我们<strong style="color:red">访问 DOM 节点</strong>或在 render 方法中创建的 React 元素。</p><h5 id="字符串形式的ref"><a href="#字符串形式的ref" class="headerlink" title="字符串形式的ref"></a>字符串形式的ref</h5><p>这种形式已过时，效率不高，<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs">官方</a> 不建议使用。</p><pre><code class="jsx">class Demo extends React.Component&#123;    showInput = () =&gt; &#123;        //2.使用ref        const &#123; myRef &#125; = this.refs        console.log(myRef) //input标签dom        console.log(myRef.value) //input标签的值    &#125;    render()&#123;        return (           &lt;div&gt;            &#123;/*1.定义ref*/&#125;            &lt;input type=&quot;text&quot; ref=&quot;myRef&quot; /&gt;            &lt;button type=&quot;button&quot; onClick=&#123;this.showInput&#125;&gt;点击显示输入框内容&lt;/button&gt;        &lt;/div&gt;        )    &#125;&#125;  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="回调形式的ref"><a href="#回调形式的ref" class="headerlink" title="回调形式的ref"></a>回调形式的ref</h5><pre><code class="jsx">class Demo extends React.Component&#123;    showInput = () =&gt; &#123;        console.log(this.myInput.value);    &#125;    render()&#123;        return (            &lt;div&gt;              &#123;/*                  通过回调将input标签的dom 挂在实例的 myInput属性上                  由于是箭头函数，因此 `this` 是 `render` 函数里的 `this` ，即组件实例              */&#125;              &lt;input type=&quot;text&quot; ref=&#123;input =&gt; this.myInput = input&#125; /&gt;              &lt;button type=&quot;button&quot; onClick=&#123;this.showInput&#125;&gt;点击显示输入框内容&lt;/button&gt;            &lt;/div&gt;       )    &#125;&#125;  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="createRef形式的ref"><a href="#createRef形式的ref" class="headerlink" title="createRef形式的ref"></a>createRef形式的ref</h5><p>该方式通过调用 <code>React.createRef</code> 返回一个容器用于存储节点，且一个容器只能存储一个节点。</p><pre><code class="jsx">class Demo extends React.Component&#123;    //1.创建ref对象    myRef = React.createRef()    showInput = () =&gt; &#123;        //3.使用ref对象        console.log(this.myRef.current) //input dom对象        console.log(this.myRef.current.value);    &#125;    render()&#123;        return (            &lt;div&gt;                &#123;/* 2.绑定ref对象 */&#125;                &lt;input type=&quot;text&quot; ref=&#123;this.myRef&#125; /&gt;                &lt;button type=&quot;button&quot; onClick=&#123;this.showInput&#125;&gt;点击显示输入框内容&lt;/button&gt;            &lt;/div&gt;            )        &#125;&#125;  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul><li>React 使用自定义事件，而非原生 DOM 事件，即 <code>onClick、onBlur</code> ：为了更好的兼容性</li><li>React 的事件通过事件委托方式进行处理：为了高效</li><li>通过 <code>event.target</code> 可获取触发事件的 DOM 元素：勿过度使用 <code>ref</code></li></ul><p>当触发事件的元素和需要操作的元素为同一个时，可以不使用 <code>ref</code> ：</p><pre><code class="jsx">class Demo extends React.Component &#123;  showData2 = (event) =&gt; &#123;    alert(event.target.value)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;input onBlur=&#123;this.showData2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot; /&gt;        &amp;nbsp;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>包含表单的组件分类：</p><ul><li>非受控组件：现用现取。即需要使用时，再获取节点得到数据</li><li>受控组件：类似于<code> Vue 双向绑定</code>的从视图层绑定到数据层</li></ul><p>尽量使用受控组件，因为非受控组件需要使用大量的 <code>ref</code> 。</p><h4 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h4><p>主要是通过ref来实现</p><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = (e) =&gt; &#123;        e.preventDefault();        const &#123;username,password&#125; = this        console.log(username.value,&quot;,&quot;,password.value);    &#125;    render()&#123;        return (            &lt;div&gt;                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;                账号：&lt;input type=&quot;text&quot; ref=&#123;c =&gt; this.username = c&#125;/&gt;&lt;br/&gt;                    密码：&lt;input type=&quot;password&quot; ref=&#123;c =&gt; this.password = c&#125;/&gt;&lt;br/&gt;                        &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;                &lt;/form&gt;            &lt;/div&gt;            )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><h5 id="受控组件基础"><a href="#受控组件基础" class="headerlink" title="受控组件基础"></a>受控组件基础</h5><p>通过表单的onChange事件，当内容变化时，将数据更新到state中</p><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = e =&gt; &#123;        e.preventDefault();//阻止默认提交        const &#123;username,password&#125; = this.state        console.log(username,&quot;,&quot;,password);    &#125;    setUsername = e =&gt; &#123;        this.setState(&#123;username: e.target.value&#125;)    &#125;    setPassword = e =&gt; &#123;        this.setState(&#123;password: e.target.value&#125;)    &#125;    render()&#123;            return (                &lt;div&gt;                    &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;                    账号：&lt;input type=&quot;text&quot; onChange=&#123;this.setUsername&#125;/&gt;&lt;br/&gt;                        密码：&lt;input type=&quot;password&quot; onChange=&#123;this.setPassword&#125;/&gt;&lt;br/&gt;                            &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;                    &lt;/form&gt;                &lt;/div&gt;            )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><p>对上述受控组件的代码进行优化，希望把 <code>saveUsername</code> 和 <code>savePassword</code> 合并为一个函数。有如下两种方案。</p><ul><li>高阶函数：参数为函数或者返回一个函数的函数，如 <code>Promise、setTimeout、Array.map()</code></li><li>函数柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</li></ul><h5 id="受控组件柯里化"><a href="#受控组件柯里化" class="headerlink" title="受控组件柯里化"></a>受控组件柯里化</h5><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = (e) =&gt; &#123;        e.preventDefault();        const &#123;username,password&#125; = this.state        console.log(username,&quot;,&quot;,password);    &#125;    setFormData = name =&gt; &#123;        return e =&gt; &#123;//函数调用返回一个函数,多次接受参数统一处理            this.setState(&#123;[name]: e.target.value&#125;)        &#125;    &#125;    render()&#123;        return (            &lt;div&gt;            &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;            账号：&lt;input type=&quot;text&quot; onChange=&#123;this.setFormData(&#39;username&#39;)&#125;/&gt;&lt;br/&gt;            密码：&lt;input type=&quot;password&quot; onChange=&#123;this.setFormData(&#39;password&#39;)&#125;/&gt;&lt;br/&gt;            &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;            &lt;/form&gt;            &lt;/div&gt;            )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="受控组件不用柯里化"><a href="#受控组件不用柯里化" class="headerlink" title="受控组件不用柯里化"></a>受控组件不用柯里化</h5><p>和柯里化差不多,只不过是在onChange里面定义一个箭头函数来接受参数</p><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = (e) =&gt; &#123;        e.preventDefault();        const &#123;username,password&#125; = this.state        console.log(username,&quot;,&quot;,password);    &#125;    setFormData = (e,name) =&gt; &#123;        this.setState(&#123;[name]: e.target.value&#125;)    &#125;    render()&#123;        return (         &lt;div&gt;            &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;         账号：&lt;input type=&quot;text&quot; onChange=&#123;e =&gt; this.setFormData(e,&#39;username&#39;) &#125;/&gt;             密码：&lt;input type=&quot;password&quot; onChange=&#123;e =&gt; this.setFormData(e,&#39;password&#39;) &#125;/&gt;              &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;            &lt;/form&gt;        &lt;/div&gt;        )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="生命周期-旧版"><a href="#生命周期-旧版" class="headerlink" title="生命周期-旧版"></a>生命周期-旧版</h4><p><strong>初始化阶段</strong>：<code>ReactDOM.render()</code> 触发的初次渲染</p><ul><li><code>constructor</code></li><li><code>componentWillMount</code></li><li><code>render</code></li><li><code>componentDidMount</code></li></ul><p><strong>更新阶段</strong></p><ol><li>父组件重新 <code>render</code> 触发的更新</li></ol><ul><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code> ：控制组件是否更新的阀门，返回值为布尔值，默认为 <code>true</code> 。若返回 <code>false</code> ，则后续流程不会进行。</li><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul><ol><li>组件内部调用 <code>this.setState()</code> 修改状态</li></ol><ul><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul><ol><li>组件内部调用 <code>this.forceUpdate()</code> 强制更新</li></ol><ul><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul><p><strong>卸载阶段</strong>：<code>ReactDOM.unmountComponentAtNode()</code> 触发</p><ul><li><code>componentWillUnmount</code></li></ul><p><img src="/posts/27fcdfc0/react-lifecyle-old.5c4592bd.png" alt="React Lifecycle"></p><h4 id="生命周期-新版"><a href="#生命周期-新版" class="headerlink" title="生命周期-新版"></a>生命周期-新版</h4><p><a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html">更改内容</a>：</p><ul><li>废弃三个钩子：<code>componentWillMount</code> 、<code>componentWillReceiveProps</code> 、 <code>componentWillUpdate</code> 。在新版本中这三个钩子需要加 <code>UNSAFE_</code> 前缀才能使用，后续可能会废弃。</li><li>新增两个钩子（实际场景用得很少）：<code>getDerivedStateFromProps</code> 、<code>getSnapshotBeforeUpdate</code></li></ul><p><img src="/posts/27fcdfc0/react-lifecycle-new.7009279b.png" alt="React LIfecycle New"></p><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops">static getDerivedStateFromProps(props, state)</a>：</p><ul><li>需使用 <code>static</code> 修饰</li><li>需返回一个对象更新 <code>state</code> 或返回 <code>null</code></li><li>适用于如下情况：<code>state</code> 的值任何时候都取决于 <code>props</code></li></ul><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate">getSnapshotBeforeUpdate(prevProps, prevState)</a>：</p><ul><li>在组件更新之前获取快照</li><li>得组件能在发生更改之前从 DOM 中捕获一些信息（如滚动位置）</li><li>返回值将作为参数传递给 <code>componentDidUpdate()</code></li></ul><pre><code class="jsx">static getDerivedStateFromProps(props,state)&#123;  console.log(&#39;getDerivedStateFromProps&#39;,props,state);  return null&#125;getSnapshotBeforeUpdate()&#123;  console.log(&#39;getSnapshotBeforeUpdate&#39;);  return &#39;atguigu&#39;&#125;componentDidUpdate(preProps,preState,snapshotValue)&#123;  console.log(&#39;componentDidUpdate&#39;,preProps,preState,snapshotValue);&#125;</code></pre><pre><code class="jsx">// getSnapshotBeforeUpdate 案例class NewsList extends React.Component &#123;  state = &#123; newsArr: [] &#125;  componentDidMount() &#123;    setInterval(() =&gt; &#123;      //获取原状态      const &#123; newsArr &#125; = this.state      //模拟一条新闻      const news = &#39;新闻&#39; + (newsArr.length + 1)      //更新状态      this.setState(&#123; newsArr: [news, ...newsArr] &#125;)    &#125;, 1000)  &#125;  getSnapshotBeforeUpdate() &#123;    return this.refs.list.scrollHeight  &#125;  componentDidUpdate(preProps, preState, height) &#123;    this.refs.list.scrollTop += this.refs.list.scrollHeight - height  &#125;  render() &#123;    return (      &lt;div className=&quot;list&quot; ref=&quot;list&quot;&gt;        &#123;this.state.newsArr.map((n, index) =&gt; &#123;          return (            &lt;div key=&#123;index&#125; className=&quot;news&quot;&gt;              &#123;n&#125;            &lt;/div&gt;          )        &#125;)&#125;      &lt;/div&gt;    )  &#125;&#125;ReactDOM.render(&lt;NewsList /&gt;, document.getElementById(&#39;test&#39;))</code></pre><h4 id="最重要的三个钩子"><a href="#最重要的三个钩子" class="headerlink" title="最重要的三个钩子"></a>最重要的三个钩子</h4><ul><li><code>render</code> ：初始化渲染和更新渲染</li><li><code>componentDidMount</code> ：进行初始化，如开启定时器、发送网络请求、订阅消息</li><li><code>componentWillUnmount</code> ：进行收尾，如关闭定时器、取消订阅消息</li></ul><h3 id="虚拟DOM和diff算法"><a href="#虚拟DOM和diff算法" class="headerlink" title="虚拟DOM和diff算法"></a>虚拟DOM和diff算法</h3><p><img src="/posts/27fcdfc0/Diff.ae9f4adc.png" alt="Diff"></p><p><strong><code>key</code> 的作用：</strong></p><p><code>key</code> 是虚拟 DOM 对象的标识，可提高页面更新渲染的效率。</p><p>当状态中的数据发生变化时，React 会根据新数据生成新的虚拟 DOM ，接着对新旧虚拟 DOM 进行 Diff 比较，规则如下：</p><ul><li>旧虚拟 DOM 找到和新虚拟 DOM 相同的 key：<ul><li>若内容没变，直接复用真实 DOM</li><li>若内容改变，则生成新的真实 DOM ，替换页面中之前的真实 DOM</li></ul></li><li>旧虚拟 DOM 未找到和新虚拟 DOM 相同的 key：根据数据创建新的真实 DOM ，渲染到页面</li></ul><p><strong>使用 <code>index</code> 作为 <code>key</code> 可能引发的问题：</strong></p><ul><li>若对数据进行逆序添加、逆序删除等破坏顺序的操作，会进行没有必要的真实 DOM 更新。界面效果没问题，但效率低下。</li><li>如果结构中包含输入类的 DOM（如 input 输入框） ，则会产生错误的 DOM 更新。</li><li>若不存在对数据逆序添加、逆序删除等破坏顺序的操作，则没有问题。</li></ul><pre><code class="jsx">// 使用 index 作为 key 引发的问题class Person extends React.Component &#123;  state = &#123;    persons: [      &#123; id: 1, name: &#39;小张&#39;, age: 18 &#125;,      &#123; id: 2, name: &#39;小李&#39;, age: 19 &#125;,    ],  &#125;  add = () =&gt; &#123;    const &#123; persons &#125; = this.state    const p = &#123; id: persons.length + 1, name: &#39;小王&#39;, age: 20 &#125;    this.setState(&#123; persons: [p, ...persons] &#125;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h2&gt;展示人员信息&lt;/h2&gt;        &lt;button onClick=&#123;this.add&#125;&gt;添加小王&lt;/button&gt;        &lt;h3&gt;使用index作为key&lt;/h3&gt;        &lt;ul&gt;          &#123;this.state.persons.map((personObj, index) =&gt; &#123;            return (              &lt;li key=&#123;index&#125;&gt;                &#123;personObj.name&#125;---&#123;personObj.age&#125;                &lt;input type=&quot;text&quot; /&gt;              &lt;/li&gt;            )          &#125;)&#125;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h2 id="react脚手架"><a href="#react脚手架" class="headerlink" title="react脚手架"></a>react脚手架</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ul><li>全局安装 React 脚手架：<code>npm i -g create-react-app</code></li><li>创建项目：<code>create-react-app 项目名称</code></li><li>进入文件夹：<code>cd 项目名称</code></li><li>启动项目：<code>npm start</code></li></ul><p>上述方式已经过时，改用下方命令。详见<a href="https://create-react-app.dev/docs/getting-started">官方说明</a>。</p><pre><code class="shell">npx create-react-app my-appcd my-appnpm start</code></pre><h3 id="项目结构说明"><a href="#项目结构说明" class="headerlink" title="项目结构说明"></a>项目结构说明</h3><p><code>public</code> ：静态资源文件</p><ul><li><code>manifest.json</code> ：应用加壳（把网页变成安卓&#x2F;IOS 软件）的配置文件</li><li><code>robots.txt</code> ：爬虫协议文件</li></ul><p><code>src</code> ：源码文件</p><ul><li><code>App.test.js</code> ：用于给 <code>App</code> 组件做测试，一般不用</li><li><strong style="color:red">index.js</strong> ：入口文件</li><li><code>reportWebVitals.js</code> ：页面性能分析文件，需要 <code>web-vitals</code> 库支持</li><li><code>setupTests.js</code> ：组件单元测试文件，需要 <code>jest-dom</code> 库支持</li></ul><p><img src="/posts/27fcdfc0/React-cli.5baa9e94.png" alt="React-cli structure"></p><p><code>index.html</code> 代码分析：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;!-- %PUBLIC_URL% 代表 public 文件夹的路径 --&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;!-- 开启理想视口，用于做移动端网页的适配 --&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;    &lt;!-- 用于配置浏览器页签+地址栏的颜色(仅支持安卓手机浏览器) --&gt;    &lt;meta name=&quot;theme-color&quot; content=&quot;red&quot; /&gt;    &lt;!-- 网站描述 --&gt;    &lt;meta name=&quot;description&quot; content=&quot;Web site created using create-react-app&quot; /&gt;    &lt;!-- 用于指定网页添加到手机主屏幕后的图标 --&gt;    &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;    &lt;!-- 应用加壳时的配置文件 --&gt;    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;    &lt;title&gt;React App&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 若浏览器不支持 js 则展示标签中的内容 --&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>删除项目中不必要的文件，并且使用jsx文件来定义组件</p><p><img src="/posts/27fcdfc0/image-20220911172638523.png" alt="image-20220911172638523"></p><h3 id="TodoList-案例总结"><a href="#TodoList-案例总结" class="headerlink" title="TodoList 案例总结"></a>TodoList 案例总结</h3><ol><li>拆分组件、实现静态组件，注意：<code>className</code> 、<code>style</code> 的写法</li><li>动态初始化列表，如何确定将数据放在哪个组件的 <code>state</code> 中？</li></ol><ul><li>某个组件使用：放在其自身的 <code>state</code> 中</li><li>某些组件使用：放在他们共同的父组件 <code>state</code> 中，即<strong>状态提升</strong></li></ul><ol><li>关于父子之间通信：</li></ol><ul><li>父传子：直接通过 <code>props</code> 传递</li><li>子传父：父组件通过 <code>props</code> 给子组件传递一个函数，子组件调用该函数</li></ul><pre><code class="jsx">// 父组件class Father extends Component &#123;  state: &#123;    todos: [&#123; id: &#39;001&#39;, name: &#39;吃饭&#39;, done: true &#125;],    flag: true,  &#125;  addTodo = (todo) =&gt; &#123;    const &#123; todos &#125; = this.state    const newTodos = [todo, ...todos]    this.setState(&#123; todos: newTodos &#125;)  &#125;  render() &#123;    return &lt;List todos=&#123;this.state.todos&#125; addTodo=&#123;this.addTodo&#125; /&gt;  &#125;&#125;// 子组件class Son extends Component &#123;  // 由于 addTodo 是箭头函数，this 指向父组件实例对象，因此子组件调用它相当于父组件实例在调用  handleClick = () =&gt; &#123;    this.props.addTodo(&#123; id: &#39;002&#39;, name: &#39;敲代码&#39;, done: false &#125;)  &#125;  render() &#123;    return &lt;button onClick=&#123;this.handleClick&#125;&gt;添加&lt;/button&gt;  &#125;&#125;</code></pre><ol><li>注意 <code>defaultChecked</code> 和 <code>checked</code> 的区别，类似的还有：<code>defaultValue</code> 和 <code>value</code></li><li>状态在哪里，操作状态的方法就在哪里</li></ol><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>方法一：</p><p>在 <code>package.json</code> 文件中进行配置：</p><pre><code class="json">&quot;proxy&quot;: &quot;http://localhost:5000&quot;</code></pre><ul><li>优点：配置简单，前端请求资源可不加前缀</li><li>缺点：不能配置多个代理</li><li>工作方式：当请求了 3000 端口号（本机）不存在的资源时，就会把请求转发给 5000 端口号服务器</li></ul><p>方法二：</p><p>在 <code>src</code> 目录下创建代理配置文件 <code>setupProxy.js</code> ，进行配置：</p><pre><code class="jsx">const proxy = require(&#39;http-proxy-middleware&#39;)module.exports = function (app) &#123;  app.use(    //api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)    proxy(&#39;/api1&#39;, &#123;      //配置转发目标地址(能返回数据的服务器地址)      target: &#39;http://localhost:5000&#39;,      //控制服务器接收到的请求头中host字段的值      /*      changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000      changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000      changeOrigin默认值为false，但一般将changeOrigin改为true      */      changeOrigin: true,      //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)      pathRewrite: &#123; &#39;^/api1&#39;: &#39;&#39; &#125;,    &#125;),    proxy(&#39;/api2&#39;, &#123;      target: &#39;http://localhost:5001&#39;,      changeOrigin: true,      pathRewrite: &#123; &#39;^/api2&#39;: &#39;&#39; &#125;,    &#125;)  )&#125;</code></pre><h2 id="消息订阅发布机制"><a href="#消息订阅发布机制" class="headerlink" title="消息订阅发布机制"></a>消息订阅发布机制</h2><p>即 React 中兄弟组件或任意组件之间的通信方式。（类似vue的bus）</p><ul><li>先订阅，再发布（隔空对话）</li><li>适用于任意组件间通信</li><li>要在 <code>componentWillUnmount</code> 钩子中取消订阅</li></ul><p>使用的工具库：<a href="https://www.npmjs.com/package/pubsub-js">PubSubJS</a> </p><pre><code>npm i pubsub-js --save</code></pre><p>基础用法：</p><pre><code class="jsx">import PubSub from &#39;pubsub-js&#39;// 发布消息PubSub.publish(&#39;topic&#39;, &#39;hello react&#39;)// 订阅消息 token是一个标识，类似setTimeout会有个返回值作为标识let token = PubSub.subscribe(&#39;topic&#39;, (msg, data) =&gt; &#123;  console.log(msg, data)&#125;)// 取消订阅PubSub.unsubscribe(token)</code></pre><h2 id="解构赋值再认识"><a href="#解构赋值再认识" class="headerlink" title="解构赋值再认识"></a>解构赋值再认识</h2><p>熟悉一下连续解构赋值、连续解构赋值+重命名</p><pre><code class="js">let obj = &#123; a: &#123; b: 1 &#125; &#125;//传统解构赋值const &#123; a &#125; = obj//连续解构赋值const &#123;  a: &#123; b &#125;,&#125; = obj//连续解构赋值 + 重命名const &#123;  a: &#123; b: value &#125;,&#125; = obj</code></pre><h2 id="nanoid生成唯一标识"><a href="#nanoid生成唯一标识" class="headerlink" title="nanoid生成唯一标识"></a>nanoid生成唯一标识</h2><p><a href="https://gitee.com/mirrors/nanoid">https://gitee.com/mirrors/nanoid</a></p><p>生成唯一标识的一个库</p><pre><code class="shell">npm install --save nanoid</code></pre><p>使用</p><pre><code class="js">import &#123;nanoid&#125; from &#39;nanoid&#39;console.log(nanoid())</code></pre><h2 id="react-router5"><a href="#react-router5" class="headerlink" title="react-router5"></a>react-router5</h2><h3 id="路由的理解"><a href="#路由的理解" class="headerlink" title="路由的理解"></a>路由的理解</h3><p>何为路由？</p><ul><li>一个路由是一个映射关系</li><li><code>key</code> 为路径，<code>value</code> 可能是 <code>function</code> 或 <strong style="color:red">组件</strong></li></ul><p>后端路由：</p><ul><li><code>value</code> 是 <code>function</code> ，用于处理客户端的请求</li><li>注册路由：<code>router.get(path, function(req, res))</code></li><li>工作过程：Node 接收到请求，根据路径匹配路由，调用对应函数处理请求，返回响应数据</li></ul><p>前端路由：</p><ul><li><code>value</code> 是组件</li><li>注册路由：<code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code></li><li>工作过程：浏览器路径变为 <code>/test</code> ，展示 <code>Test</code> 组件</li></ul><h3 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h3><p>安装 <code>react-router-dom</code> </p><pre><code class="shell">// 安装 5.X 版本路由npm install react-router-dom@5.2.0 -S</code></pre><p>最新默认是安装的6.x版本，这里以 <code>5.x</code> 版本为例展示基本使用,后面再写6.x版本的使用</p><p>导航区使用 <code>&lt;Link&gt;</code>，展示区使用 <code>&lt;Route&gt;</code>。</p><h4 id="Link组件"><a href="#Link组件" class="headerlink" title="Link组件"></a>Link组件</h4><blockquote><p>定义链接，用来替换a标签</p></blockquote><ul><li><p>to属性：定义点击之后切换的路径</p></li><li><p>className属性： 定义类名</p></li><li><p>标签体：定义显示的名称</p></li></ul><p>【例如】</p><pre><code class="html">&lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;about&lt;/Link&gt;</code></pre><h4 id="Route组件"><a href="#Route组件" class="headerlink" title="Route组件"></a>Route组件</h4><blockquote><p>路由组件匹配成功之后的展示区</p></blockquote><ul><li>path属性：匹配的路径</li><li>component属性：匹配成功后展示的组件</li></ul><p>【例如】</p><pre><code class="html">&lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;</code></pre><h4 id="路由入门案例"><a href="#路由入门案例" class="headerlink" title="路由入门案例"></a>路由入门案例</h4><ul><li>复制boostrap.css到public&#x2F;css下,并且在index.html中引入</li></ul><p><img src="/posts/27fcdfc0/image-20220911224233636.png" alt="image-20220911224233636"></p><ul><li><code>&lt;App&gt;</code> 的最外侧包裹 <code>&lt;BrowserRouter&gt;</code> 或 <code>&lt;HashRouter&gt;</code> ：</li></ul><pre><code class="jsx">// index.jsimport React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;import App from &#39;./App&#39;ReactDOM.render(  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;,  document.getElementById(&#39;root&#39;))</code></pre><ul><li>App.jsx</li></ul><pre><code class="jsx">// App.jsximport React, &#123; Component &#125; from &#39;react&#39;import &#123; Link, Route &#125; from &#39;react-router-dom&#39;import Home from &#39;./components/Home&#39;import About from &#39;./components/About&#39;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;div className=&quot;list-group&quot;&gt;          &lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;            About          &lt;/Link&gt;          &lt;Link className=&quot;list-group-item&quot; to=&quot;/home&quot;&gt;            Home          &lt;/Link&gt;        &lt;/div&gt;        &lt;div className=&quot;panel-body&quot;&gt;          &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;          &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;        &lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="路由组件和一般组件"><a href="#路由组件和一般组件" class="headerlink" title="路由组件和一般组件"></a>路由组件和一般组件</h3><p>存放位置不同</p><ul><li>一般组件：<code>components</code></li><li>路由组件：<code>pages</code></li></ul><p><strong style="color:red">写法不同</strong></p><ul><li>一般组件：<code>&lt;Demo/&gt;</code></li><li>路由组件：<code>&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt;</code></li></ul><p><strong style="color:red">接收到的 props不同</strong></p><ul><li>一般组件：标签属性传递</li><li>路由组件：接收到三个固定的属性(history、location、match)</li></ul><pre><code class="js">history:  go: ƒ go(n)  goBack: ƒ goBack()  goForward: ƒ goForward()  push: ƒ push(path, state)  replace: ƒ replace(path, state)location:  pathname: &quot;/home/message/detail/2/hello&quot;  search: &quot;&quot;  state: undefinedmatch:  params: &#123;&#125;  path: &quot;/home/message/detail/:id/:title&quot;  url: &quot;/home/message/detail/2/hello&quot;</code></pre><h3 id="NavLink组件"><a href="#NavLink组件" class="headerlink" title="NavLink组件"></a>NavLink组件</h3><p><code>NavLink</code> 可以实现路由链接的高亮，通过 <code>activeClassName</code> 指定样式名，默认追加类名为 <code>active</code> 。</p><pre><code class="html">&lt;NavLink activeClassName=&quot;navLinkActive&quot; to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;&lt;NavLink activeClassName=&quot;navLinkActive&quot; to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;</code></pre><p>封装 <code>NavLink</code> 组件：由于 <code>NavLink</code> 组件中重复的代码太多，因此进行二次封装。</p><p><strong style="color:red">※ 细节点</strong>：组件标签的内容会传递到 <code>this.props.children</code> 属性中，反过来通过指定标签的 <code>children</code> 属性可以修改组件标签内容</p><pre><code class="jsx">// MyNavLink 组件import React, &#123; Component &#125; from &#39;react&#39;import &#123; NavLink &#125; from &#39;react-router-dom&#39;export default class MyNavLink extends Component &#123;  render() &#123;    // this.props.children 可以取到标签内容，如 About, Home    // 反过来通过指定标签的 children 属性可以修改标签内容   return &lt;NavLink activeClassName=&quot;active&quot; className=&quot;list-group-item&quot; &#123;...this.props&#125;/&gt;  &#125;&#125;</code></pre><pre><code class="html">&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;</code></pre><h3 id="Switch-的使用"><a href="#Switch-的使用" class="headerlink" title="Switch 的使用"></a>Switch 的使用</h3><p><code>Switch</code> 可以提高路由匹配效率，如果匹配成功，则不再继续匹配后面的路由，即单一匹配。</p><pre><code class="html">&lt;!-- 只会展示 Home 组件 --&gt;&lt;Switch&gt;  &lt;Route path=&quot;/about&quot; component=&quot;&#123;About&#125;&quot; /&gt;  &lt;Route path=&quot;/home&quot; component=&quot;&#123;Home&#125;&quot; /&gt;  &lt;Route path=&quot;/home&quot; component=&quot;&#123;Test&#125;&quot; /&gt;&lt;/Switch&gt;</code></pre><h3 id="多级路径刷新样式丢失"><a href="#多级路径刷新样式丢失" class="headerlink" title="多级路径刷新样式丢失"></a>多级路径刷新样式丢失</h3><ul><li><code>public/index.html</code> 中 引入样式时不写 <code>./</code> 写 <code>/</code> （常用）</li><li><code>public/index.html</code> 中 引入样式时不写 <code>./</code> 写 <code>%PUBLIC_URL%</code> （常用）</li><li>使用 <code>HashRouter</code></li></ul><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;%PUBLIC_URL%/css/bootstrap.css&quot; /&gt;</code></pre><h3 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a>路由的严格匹配与模糊匹配</h3><ul><li>默认使用模糊匹配（<code>Route</code>组件的<code>path</code>必须包含<code>Link</code>组件要匹配的路径，且顺序一致）</li><li>开启严格匹配：<code>&lt;Route exact path=&quot;/about&quot; component=&#123;About&#125;/&gt;</code></li><li>严格匹配需要再开，开启可能会导致无法继续匹配二级路由</li></ul><h3 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect (重定向)"></a>Redirect (重定向)</h3><p>一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到 Redirect 指定的路由</p><pre><code class="html">&lt;Switch&gt;  &lt;Route path=&quot;/about&quot; component=&quot;&#123;About&#125;&quot; /&gt;  &lt;Route path=&quot;/home&quot; component=&quot;&#123;Home&#125;&quot; /&gt;  &lt;Redirect to=&quot;/about&quot; /&gt;&lt;/Switch&gt;</code></pre><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul><li>注册子路由需写上父路由的 <code>path</code></li><li>路由的匹配是<strong style="color:red">按照注册路由的顺序进行</strong>的</li></ul><p>父组件</p><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;&lt;Switch&gt;  &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;  &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;  &lt;Redirect to=&quot;/about&quot; /&gt;&lt;/Switch&gt;</code></pre><p>子组件</p><pre><code class="html">&lt;ul className=&quot;nav nav-tabs&quot;&gt;  &lt;li&gt;    &lt;MyNavLink to=&quot;/home/news&quot;&gt;News&lt;/MyNavLink&gt;  &lt;/li&gt;  &lt;li&gt;    &lt;MyNavLink to=&quot;/home/message&quot;&gt;Message&lt;/MyNavLink&gt;  &lt;/li&gt;&lt;/ul&gt;&lt;Switch&gt;  &lt;Route path=&quot;/home/news&quot; component=&#123;News&#125; /&gt;  &lt;Route path=&quot;/home/message&quot; component=&#123;Message&#125; /&gt;  &lt;Redirect to=&quot;/home/news&quot; /&gt;&lt;/Switch&gt;</code></pre><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><p>三种方式：<code>params, search, state</code> 参数</p><p>三种方式对比：</p><ul><li><code>state</code> 方式当前页面刷新可保留参数，但在新页面打开不能保留。前两种方式由于参数保存在 URL 地址上，因此都能保留参数。</li><li><code>params</code> 和 <code>search</code> 参数都会变成字符串</li></ul><pre><code class="html">&lt;!--1.params方式传参 --&gt;&lt;Link to=&#39;/home/message/detail/tom/21&#39;&gt;params&lt;/Link&gt;&lt;Link to=&#123;`/home/message/detail/$&#123;item.name&#125;/$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;&lt;!--2.search方式传参 --&gt;&lt;Link to=&#39;/home/message/detail/?name=tom&amp;age=21&#39;&gt;search&lt;/Link&gt;&lt;Link to=&#123;`/home/message/detail/?id=$&#123;item.name&#125;&amp;title=$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;&lt;!--3.state方式传参 --&gt;&lt;Link to=&#123;&#123;pathname:'/home/message/detail',state: &#123;name: 'tom', age: 21&#125;&#125;&#125;&gt;state&lt;/Link&gt;&lt;!-- params 注册路由 --&gt;&lt;Route path=&#39;/home/message/detail/:name/:age&#39; component=&#123;Detail&#125; /&gt;&lt;!-- search 和 state 按正常注册即可 --&gt;&lt;Route path=&#39;/home/message/detail&#39; component=&#123;Detail&#125; /&gt;</code></pre><p>接收参数</p><pre><code class="js">//1.params方式接受参数const &#123; name, age &#125; = this.props.match.params//2.search方式接受参数import qs from &#39;querystring&#39;const &#123; search &#125; = this.props.locationconst &#123; name, age &#125; = qs.parse(search.slice(1))//3.state方式接受参数const &#123; name, age &#125; = this.props.location.state</code></pre><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>编程式导航是使用路由组件 <code>this.props.history</code> 提供的 API 进行路由跳转：</p><pre><code class="js">this.props.history.push(path, state)this.props.history.replace(path, state)this.props.history.goForward()this.props.history.goBack()this.props.history.go(n)</code></pre><p>三种传参方式的编程式导航</p><pre><code class="js">// 编程式导航传参this.props.history.push(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)this.props.history.push(`/home/message/detail?id=$&#123;id&#125;&amp;title=$&#123;title&#125;`)this.props.history.push(`/home/message/detail`, &#123; id: id, title: title &#125;)</code></pre><h3 id="withRouter-的使用"><a href="#withRouter-的使用" class="headerlink" title="withRouter 的使用"></a>withRouter 的使用</h3><p><code>withRouter</code> 的作用：加工一般组件，让其拥有路由组件的 API ，如 <code>this.props.history.push</code> 等。</p><pre><code class="jsx">import React, &#123;Component&#125; from &#39;react&#39;import &#123;withRouter&#125; from &#39;react-router-dom&#39;class Header extends Component &#123;  ...&#125;export default withRouter(Header) //导出前用withRouter加工一下</code></pre><h3 id="BrowserRouter-和-HashRouter"><a href="#BrowserRouter-和-HashRouter" class="headerlink" title="BrowserRouter 和 HashRouter"></a>BrowserRouter 和 HashRouter</h3><p>底层原理不一样：</p><ul><li><code>BrowserRouter</code> 使用的是 H5 的 history API，不兼容 IE9 及以下版本。</li><li><code>HashRouter</code> 使用的是 URL 的哈希值。</li></ul><p>路径表现形式不一样</p><ul><li><code>BrowserRouter</code> 的路径中没有 <code>#</code> ，如：<code>localhost:3000/demo/test</code></li><li><code>HashRouter</code> 的路径包含#，如：<code>localhost:3000/#/demo/test</code></li></ul><p>刷新后对路由 <code>state</code> 参数的影响</p><ul><li><code>BrowserRouter</code> 没有影响，因为 <code>state</code> 保存在 <code>history</code> 对象中。</li><li><code>HashRouter</code> 刷新后会导致路由 <code>state</code> 参数的丢失！</li></ul><p>备注：<code>HashRouter</code> 可以用于解决一些路径错误相关的<a href="https://brucecai55520.gitee.io/bruceblog/notes/react/react-router5.html#%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%A7%E8%B7%AF%E5%BE%84%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98">问题</a>。</p><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><p><a href="https://redux.js.org/">官网</a></p><p><a href="https://www.redux.org.cn/">中文文档</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Redux 为何物，类似vue中的vuex</p><ul><li>Redux 是用于做 <strong>状态管理</strong> 的 JS 库</li><li>可用于 React、Angular、Vue 等项目中，常用于 React</li><li>集中式管理 React 应用多个组件共享的状态</li></ul><p>何时用 Redux</p><ul><li>某个组件的状态，需要让其他组件拿到（状态共享）</li><li>一个组件需要改变另一个组件的状态（通信）</li><li>使用原则：不到万不得已不要轻易动用</li></ul><p>Redux 工作流程</p><p><img src="/posts/27fcdfc0/redux.4afb4200.png" alt="redux 工作流程图"></p><ul><li>组件想操作 Redux 中的状态：把动作类型和数据告诉 <code>Action Creators</code></li><li><code>Action Creators</code> 创建 <code>action</code> ：同步 <code>action</code> 是一个普通对象，异步 <code>action</code> 是一个函数</li><li><code>Store</code> 调用 <code>dispatch()</code> 分发 <code>action</code> 给 <code>Reducers</code> 执行</li><li><code>Reducers</code> 接收 <code>previousState</code> 、<code>action</code> 两个参数，对状态进行加工后返回新状态</li><li><code>Store</code> 调用 <code>getState()</code> 把状态传给组件</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><ul><li><p>表示动作的对象，包含 2 个属性</p></li><li><p><code>type</code> ：标识属性，值为字符串，唯一，必须属性</p></li><li><p><code>data</code> ：数据属性，类型任意，可选属性。</p></li></ul><p>例如：<code>&#123;type: &#39;increment&#39;, data: 2&#125;</code></p><h4 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h4><ul><li>用于初始化状态、加工状态</li><li>根据旧状态和 <code>action</code> 产生新状态</li><li>是<strong>纯函数</strong></li></ul><blockquote><p>纯函数：输入同样的实参，必定得到同样的输出</p><ul><li>不能改写参数数据</li><li>不产生副作用，如网络请求、输入输出设备（网络请求不稳定）</li><li>不能调用 <code>Date.now()</code> 、<code>Math.random()</code> 等不纯方法</li></ul></blockquote><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><ul><li>Redux 核心对象，内部维护着 <code>state</code> 和 <code>reducer</code></li><li>核心 API<ul><li><code>store.getState()</code> ：获取状态</li><li><code>store.dispatch(action)</code> ：分发任务，触发 <code>reducer</code> 调用，产生新状态</li><li><code>store.subscribe(func)</code> ：注册监听函数，当状态改变自动调用</li></ul></li></ul><h3 id="求和案例"><a href="#求和案例" class="headerlink" title="求和案例"></a>求和案例</h3><ul><li>安装redux</li></ul><pre><code class="shell">npm i redux@4.0.5</code></pre><ul><li>App.jsx</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import Count from &#39;./components/Count&#39;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;Count /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><ul><li>index.js</li></ul><pre><code class="js">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import App from &#39;./App&#39;import store from &#39;./redux/store&#39;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))// 状态改变重新渲染 App 组件store.subscribe(() =&gt; &#123;  ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))&#125;)//react18的写法如下const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))root.render(&lt;App /&gt;)store.subscribe(()=&gt;&#123;    root.render(&lt;App /&gt;)&#125;)</code></pre><ul><li>redux&#x2F;constant.js 定义常量</li></ul><pre><code class="js">// 保存常量值export const INCREMENT = &#39;increment&#39;export const DECREMENT = &#39;decrement&#39;</code></pre><ul><li>redux&#x2F;count_reducer.js</li></ul><pre><code class="js">import &#123; INCREMENT, DECREMENT &#125; from &#39;./constant&#39;//初始化状态const initState = 0export default function countReducer(preState = initState, action) &#123;  const &#123; type, data &#125; = action  switch (type) &#123;    case INCREMENT:      return preState + data    case DECREMENT:      return preState - data    default:      return preState  &#125;&#125;</code></pre><ul><li>redux&#x2F;store.js</li></ul><pre><code class="js">import &#123; createStore &#125; from &#39;redux&#39;//引入为 Count 组件服务的 reducerimport countReducer from &#39;./count_reducer&#39;export default createStore(countReducer)</code></pre><ul><li>count_action.js</li></ul><pre><code class="js">import &#123;INCREMENT,DECREMENT&#125; from &#39;./constant&#39;export const createIncrementAction = data =&gt; (&#123;type: INCREMENT,data&#125;)export const createdecrementAction = data =&gt; (&#123;type: DECREMENT,data&#125;)</code></pre><ul><li>components&#x2F;Count&#x2F;index.jsx</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import store from &#39;../../redux/store&#39;import &#123; createIncrementAction, createDecrementAction &#125; from &#39;../../redux/count_action&#39;export default class Count extends Component &#123;  // 可在组件单独监听 Redux 状态变化  // componentDidMount() &#123;  //     store.subscribe(() =&gt; &#123;  //         this.setState(&#123;&#125;)  //     &#125;)  // &#125;  increment = () =&gt; &#123;    const &#123; value &#125; = this.selectNumber    // 将 value 转为数值    // 手动写 Action 对象    store.dispatch(&#123; type: &#39;increment&#39;, data: value * 1 &#125;)    // 专门创建 Action 对象    store.dispatch(createIncrementAction(value * 1))  &#125;  decrement = () =&gt; &#123;    const &#123; value &#125; = this.selectNumber    store.dispatch(createDecrementAction(value * 1))  &#125;  incrementAsync = () =&gt; &#123;    const &#123; value &#125; = this.selectNumber    setTimeout(() =&gt; &#123;      store.dispatch(createIncrementAction(value * 1))    &#125;, 500)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;当前求和为：&#123;store.getState()&#125;&lt;/h1&gt;        &lt;select ref=&#123;(c) =&gt; (this.selectNumber = c)&#125;&gt;          &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;          &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;          &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;        &lt;/select&gt;        &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;        &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;        &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p><strong style="color:red">编写步骤总结：</strong></p><p>1.创建constant.js定义常量</p><p>2.创建count_reducer.js</p><p>3.根据count_reducer创建store</p><p>4.创建action</p><p>5.在组件中使用 store.dispatch(action)更新数据 ，store.getState()获取数据</p><p><strong style="color:red">注意：</strong></p><ul><li>redux 只负责管理状态，状态改变驱动页面展示要自己写</li><li>可以在 <code>index.js</code> 中统一监听状态变化，也可以在组件中单独监听。注意不能直接 <code>this.render()</code> 调用 <code>render</code> 函数，要通过 <code>this.setState(&#123;&#125;)</code> 间接调用</li><li><code>reducer</code> 由 <code>store</code> 自动触发首次调用，传递的 <code>preState</code> 为 <code>undefined</code> ，<code>action</code> 为 <code>&#123;type: &#39;@@REDUX/ININT_a.5.v.9&#39;&#125;</code> 类似的数据格式，只有 <code>type</code></li></ul><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><blockquote><p>1.延迟的动作不想交给组件，而是 <code>action</code><br>2.当操作状态所需数据要靠异步任务返回时，可用异步 <code>action</code><br>3.创建 <code>action</code> 的函数<strong style="color:red">返回一个函数</strong>，该函数中写异步任务<br>4.异步任务完成后，分发一个同步 <code>action</code> 操作状态<br>5.异步 <code>action</code> 不是必要的，完全可以在组件中等待异步任务结果返回在分发同步 <code>action</code></p></blockquote><p>安装中间件</p><pre><code class="shell">npm i redux-thunk@2.3.0</code></pre><p>对上面的求和案例进行修改</p><ul><li>store.js</li></ul><pre><code class="js">import &#123; createStore, applyMiddleware &#125; from &#39;redux&#39;import countReducer from &#39;./count_reducer&#39;import thunk from &#39;redux-thunk&#39; //引入中间件//创建store的时候，使用中间件export default createStore(countReducer, applyMiddleware(thunk))</code></pre><ul><li>count_action.js</li></ul><pre><code class="js">import &#123; INCREMENT, DECREMENT &#125; from &#39;./constant.js&#39;export const createIncrementAction = (data) =&gt; (&#123; type: INCREMENT, data &#125;)export const createDecrementAction = (data) =&gt; (&#123; type: DECREMENT, data &#125;)// 异步 action 返回一个函数export const createIncrementAsyncAction = (data, time) =&gt; &#123;  return (dispatch) =&gt; &#123;    setTimeout(() =&gt; &#123;      dispatch(createIncrementAction(data))    &#125;, time)  &#125;&#125;</code></pre><ul><li>Count.jsx</li></ul><pre><code class="js">incrementAsync = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  store.dispatch(createIncrementAsyncAction(value * 1))&#125;</code></pre><p>整个过程简单理解：<code>store</code> 在分发 <code>action</code> 时，发现返回一个函数，那它知道这是个异步 <code>action</code> 。因此 <code>store</code> 帮忙执行这个函数(ps：使用<strong style="color:red">redux-thunk</strong>才会执行，否则报错)，同时给这个函数传递 <code>dispatch</code> 方法，等待异步任务完成取到数据后，直接调用 <code>dispatch</code> 方法分发同步 <code>action</code> 。</p><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>React-Redux 是一个插件库，用于简化 React 中使用 Redux 。</p><p><img src="/posts/27fcdfc0/image-20221228140202071.png" alt="image-20221228140202071"></p><p>React-Redux 将组件分为两类：</p><ul><li>UI 组件<ul><li>只负责 UI 呈现，不带有业务逻辑</li><li>通过 <code>props</code> 接收数据</li><li>不能使用 Redux 的 API</li><li>保存在 <code>components</code> 文件夹下</li></ul></li><li>容器组件<ul><li>负责管理数据和业务逻辑，和 Redux 通信，将结果交给 UI 组件</li><li>可使用 Redux 的 API</li><li>保存在 <code>containers</code> 文件夹下</li></ul></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>要点：</p><ul><li>装包：<code>npm i react-redux</code></li></ul><ul><li><code>connect()()</code> ：创建容器组件</li><li><code>mapStateToProps(state)</code> ：映射状态为 UI 组件标签属性，即传递状态</li><li><code>mapDispatchToProps(dispatch)</code> ：传递操作状态的方法</li><li>容器组件中的 <code>store</code> 是靠 <code>props</code> 传进去，而不是在容器组件中直接引入</li></ul><p>【react-redux使用案例】</p><blockquote><p>Count 容器组件</p></blockquote><pre><code class="jsx">// containers/Count/index.jsx// Count 容器组件import CountUI from &#39;../../components/Count&#39;import &#123; connect &#125; from &#39;react-redux&#39;import &#123; createIncrementAction, createDecrementAction, createIncrementAsyncAction &#125; from &#39;../../redux/count_action&#39;function mapStateToProps(state) &#123;  return &#123;    count: state,  &#125;&#125;function mapDispatchToProps(dispatch) &#123;  return &#123;    add: (number) =&gt; dispatch(createIncrementAction(number)),    sub: (number) =&gt; dispatch(createDecrementAction(number)),    addAsync: (number) =&gt; dispatch(createIncrementAsyncAction(number, time)),  &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(CountUI)</code></pre><blockquote><p>App.jsx</p></blockquote><pre><code class="jsx">// App.jsximport React, &#123; Component &#125; from &#39;react&#39;import Count from &#39;./containers/Count&#39;import store from &#39;./redux/store.js&#39;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;Count store=&#123;store&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><blockquote><p>Count UI 组件</p></blockquote><pre><code class="jsx">// components/Count/index.jsx// Count UI 组件increment = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  this.props.add(value * 1)&#125;decrement = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  this.props.sub(value * 1)&#125;incrementAsync = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  this.props.addAsync(value * 1, 500)&#125;</code></pre><h3 id="优化写法"><a href="#优化写法" class="headerlink" title="优化写法"></a>优化写法</h3><p><code>mapDispatchToProps</code> 可以写成对象形式，React-Redux 底层会帮助自动分发。</p><pre><code class="jsx">// 函数写法export default connect(  state =&gt; (&#123;count:state&#125;),  dispatch =&gt; (&#123;    add: number =&gt; dispatch(createIncrementAction(number)),    sub: number =&gt; dispatch(createDecrementAction(number)),    addAsync: (number,time) =&gt; dispatch(createIncrementAsyncAction(number,time)),  &#125;))(CountUI)// 对象写法export default connect(  state =&gt; (&#123; count: state &#125;),  &#123;    add: createIncrementAction,    sub: createDecrementAction,    addAsync: createIncrementAsyncAction,  &#125;)(CountUI)</code></pre><p>React-Redux 容器组件可以自动监测 Redux 状态变化，因此 <code>index.js</code> 不需要手动监听：</p><pre><code class="jsx">//不用写下面这些代码了store.subscribe(() =&gt; &#123;  ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))&#125;)</code></pre><p><code>Provider</code> 组件的使用：让所有组件都能获得状态数据，不必一个一个传递</p><pre><code class="jsx">// index.jsimport React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import App from &#39;./App&#39;import &#123; Provider &#125; from &#39;react-redux&#39;import store from &#39;./redux/store&#39;ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&#39;root&#39;))</code></pre><p>整合容器组件和 UI 组件为一个文件：</p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import &#123;createIncrementAction,createDecrementAction&#125; from &#39;../../redux/count_action&#39;import &#123;connect&#125; from &#39;react-redux&#39;// 定义 UI 组件class Count extends Component &#123;  ...&#125;// 创建容器组件export default connect(  state =&gt; (&#123;count: state&#125;),  &#123;    add: createIncrementAction,    sub: createDecrementAction  &#125;)(Count)</code></pre><h3 id="多组件数据共享"><a href="#多组件数据共享" class="headerlink" title="多组件数据共享"></a>多组件数据共享</h3><p>首先规范化文件结构，容器组件和 UI 组件合为一体后放在 <code>containers</code> 文件夹。<code>redux</code> 文件夹新建 <code>actions</code> 和 <code>reducers</code> 文件夹分别用于存放每个组件对应的 <code>action</code> 和 <code>reducer</code> 。</p><p>新建 <code>Person</code> 组件对应的 <code>action</code> 和 <code>reducer</code> ：</p><pre><code class="jsx">// redux/actions/person.jsimport &#123; ADD_PERSON &#125; from &#39;../constant.js&#39;export const createAddPersonAction = (personObj) =&gt; (&#123; type: ADD_PERSON, data: personObj &#125;)</code></pre><pre><code class="js">// redux/reducers/person.jsimport &#123; ADD_PERSON &#125; from &#39;../constant.js&#39;const initState = [&#123; id: &#39;lsfd&#39;, name: &#39;china&#39;, age: &#39;9999&#39; &#125;]export default function personReducer(preState = initState, action) &#123;  const &#123; type, data &#125; = action  switch (type) &#123;    case ADD_PERSON:      return [data, ...preState]    default:      return preState  &#125;&#125;</code></pre><p>关键步骤：在 <code>store.js</code> 中使用 <code>combineReducers()</code> 整合多个 <code>reducer</code> 来创建 <code>store</code> 对象。</p><p>这样 Redux 中就以对象的形式存储着每个组件的数据。类似于这样：</p><pre><code class="json">&#123;  total: 0,  personList: []&#125;</code></pre><pre><code class="js">// redux/store.jsimport &#123; createStore, applyMiddleware, combineReducers &#125; from &#39;redux&#39;import countReducer from &#39;./reducers/count&#39;import personReducer from &#39;./reducers/person&#39;import thunk from &#39;redux-thunk&#39;const Reducers = combineReducers(&#123; //关键代码！！！  total: countReducer,  personList: personReducer,&#125;)export default createStore(Reducers, applyMiddleware(thunk))</code></pre><p><code>Person</code> 组件中获取 Redux 保存的状态，包括其他组件的数据。</p><pre><code class="js">import React, &#123; Component &#125; from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;import &#123; createAddPersonAction &#125; from &#39;../../redux/actions/person&#39;import &#123; nanoid &#125; from &#39;nanoid&#39;class Person extends Component &#123;  addPerson = () =&gt; &#123;    const name = this.nameInput.value    const age = this.ageInput.value    const personObj = &#123; id: nanoid(), name, age &#125;    this.props.addPerson(personObj)    this.nameInput.value = &#39;&#39;    this.ageInput.value = &#39;&#39;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h2&gt;在Person组件拿到Count组件的数据：&#123;this.props.count&#125;&lt;/h2&gt;        &lt;input type=&quot;text&quot; ref=&#123;(c) =&gt; (this.nameInput = c)&#125; placeholder=&quot;Please input name&quot; /&gt;        &lt;input type=&quot;text&quot; ref=&#123;(c) =&gt; (this.ageInput = c)&#125; placeholder=&quot;Please input age&quot; /&gt;        &lt;button onClick=&#123;this.addPerson&#125;&gt;添加&lt;/button&gt;        &lt;ul&gt;          &#123;this.props.personList.map((item) =&gt; &#123;            return (              &lt;li key=&#123;item.id&#125;&gt;                &#123;item.name&#125; -- &#123;item.age&#125;              &lt;/li&gt;            )          &#125;)&#125;        &lt;/ul&gt;      &lt;/div&gt;    )  &#125;&#125;export default connect(  // state 是 Redux 保存的状态对象  // 容器组件从 Redux 中取出需要的状态，并传递给 UI 组件  state =&gt; (&#123;personList: state.personList, count: state.total&#125;),  &#123;    addPerson: createAddPersonAction  &#125;)(Person)</code></pre><p>一个细节，在 <code>personReducer</code> 中，是按如下方式修改状态的，而没有使用 <code>unshift</code> 方法。在第二种方式，React 会认为状态没有变化从而不会重新渲染页面，因为 <code>preState</code> 保存的是数组地址值，返回的地址和之前的地址是一样的，尽管数组内容发生了改变。而第一种方式返回一个新的数组的地址值，和之前不一样，因此会重新渲染页面。</p><pre><code class="js">// 方式一switch (type) &#123;  case ADD_PERSON:    return [data, ...preState]  default:    return preState&#125;// 方式二switch (type) &#123;  case ADD_PERSON:    preState.unshift(data)    return preState  default:    return preState&#125;</code></pre><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>概念：输入同样的参数，返回同样的输出。</p><p>约束：</p><ul><li>不能修改参数数据</li><li>不产生任何副作用，如网络请求、输入和输出设备</li><li>不能调用 <code>Date.now()</code> 或 <code>Math.random()</code> 等不纯的方法</li></ul><p><code>reducer</code> 的函数必须是纯函数。</p><h3 id="redux开发工具"><a href="#redux开发工具" class="headerlink" title="redux开发工具"></a>redux开发工具</h3><ul><li><p>Chrome 安装 Redux DevTools 开发者工具</p></li><li><p>项目下载依赖包 <code>npm i redux-devtools-extension --save-dev</code>，</p></li><li><p>最后在 <code>store.js</code> 进行配置：</p></li></ul><pre><code class="js">import &#123; composeWithDevTools &#125; from &#39;redux-devtools-extension&#39;...export default createStore(Reducers, composeWithDevTools(applyMiddleware(thunk)))// 不需要异步中间件export default createStore(Reducers, composeWithDevTools())</code></pre><h2 id="react扩展"><a href="#react扩展" class="headerlink" title="react扩展"></a>react扩展</h2><h3 id="setState-更新状态的两种写法"><a href="#setState-更新状态的两种写法" class="headerlink" title="setState 更新状态的两种写法"></a>setState 更新状态的两种写法</h3><p>对象式：<code>setState(stateChange, [callback])</code></p><ul><li><code>stateChange</code> 为状态改变对象(该对象可以体现出状态的更改)</li><li><code>callback</code> 是可选的回调函数, 它在状态更新完毕、界面也更新后才被调用</li></ul><p>函数式：<code>setState(updater, [callback])</code></p><ul><li>updater 为返回 stateChange 对象的函数。</li><li>updater 可以接收到 state 和 props。</li></ul><p>说明：</p><ul><li>React 状态更新是异步的。下述代码打印的 <code>count</code> 值是上一次的值，而非更新后的。可在第二个参数回调中获取更新后的状态。</li></ul><pre><code class="js">add = () =&gt; &#123;  this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count)&#125;add = () =&gt; &#123;  this.setState(&#123; count: this.state.count + 1 &#125;, () =&gt; &#123;    console.log(this.state.count)  &#125;)&#125;</code></pre><ul><li><code>callback</code> 回调在 <code>componentDidMount</code> 钩子之后执行</li><li>对象式写法可以看做函数式写法的语法糖</li></ul><pre><code class="js">add = () =&gt; &#123;  this.setState((state, props) =&gt; &#123;    return &#123; count: state.count + props.step &#125;  &#125;)&#125;</code></pre><h3 id="路由组件懒加载-lazyLoad"><a href="#路由组件懒加载-lazyLoad" class="headerlink" title="路由组件懒加载 lazyLoad"></a>路由组件懒加载 lazyLoad</h3><pre><code class="jsx">import React, &#123; Component, lazy, Suspense &#125; from &#39;react&#39;import Loading from &#39;./Loading&#39;// 通过 lazy 函数配合 import() 函数动态加载路由组件// 路由组件代码会被分开打包const Home = lazy(() =&gt; import(&#39;./Home&#39;)) const About = lazy(() =&gt; import(&#39;./About&#39;))export default Demo extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Demo 组件&lt;/h1&gt;        &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;        &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;        // 通过 &lt;Suspense&gt; 指定在加载得到路由打包文件前显示一个自定义 Loading 界面        &lt;Suspense fallback=&#123;Loading&#125;&gt;          &lt;Switch&gt;            &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;&gt;            &lt;Route path=&quot;/about&quot; component=&#123;About&#125;&gt;          &lt;/Switch&gt;        &lt;/Suspense&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h3><blockquote><p>Hook 是 React 16.8.0 增加的新特性，让我们能在函数式组件中使用 <code>state</code> 和其他特性</p></blockquote><h4 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h4><ul><li><code>State Hook</code> 让函数式组件也可拥有 <code>state</code> 状态。</li><li>语法：<code>const [Xxx, setXxx] = React.useState(initValue)</code></li><li><code>useState()</code> 参数：状态初始化值；返回值：包含 2 个元素的数组，分别为状态值和状态更新函数</li><li><code>setXxx()</code> 的 2 种用法：</li></ul><pre><code>setXxx(newValue)setXxx(value =&gt; newValue)</code></pre><p>注意！<strong style="color:orange">新状态值会覆盖原状态值！</strong>因此<strong style="color:red">若有多个状态，只能多次调用 React.useState ，不能使用对象！</strong></p><pre><code class="jsx">import React from &#39;react&#39;export default function StateHook() &#123;    const [count, setCount] = React.useState(0);    const add = () =&gt; setCount(count + 1);    const sub = () =&gt; setCount((count) =&gt; count - 1)    return (        &lt;div&gt;            &lt;h2&gt;状态值：&#123;count&#125;&lt;/h2&gt;            &lt;button onClick=&#123;add&#125;&gt;+1&lt;/button&gt;            &lt;button onClick=&#123;sub&#125;&gt;-1&lt;/button&gt;        &lt;/div&gt;    )&#125;</code></pre><h4 id="Ref-Hook"><a href="#Ref-Hook" class="headerlink" title="Ref Hook"></a>Ref Hook</h4><ul><li><code>Ref Hook</code> 可以在函数式组件存储或查找组件内的标签或其他数据</li><li>语法：<code>const refContainer = React.useRef()</code></li><li>保存标签对象的容器，和 <code>React.createRef()</code> 类似，也是专人专用</li></ul><pre><code class="jsx">import React from &#39;react&#39;export default function RefHook() &#123;  const myref = React.useRef()  const submit = () =&gt; console.log(&#39;myref.current.value&#39;, myref.current.value)  return (    &lt;div&gt;        &lt;input type=&quot;text&quot;  ref=&#123;myref&#125;/&gt;        &lt;button onClick=&#123;submit&#125;&gt;submit&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h4><ul><li><code>Effect Hook</code> 让我们能在函数式组件中执行副作用操作（就是模拟生命周期钩子）</li><li>副作用操作：发送 Ajax 请求、定时器、手动更改真实 DOM</li><li><code>Effect Hook</code> 可以模拟三个钩子：<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code></li><li><code>React.useEffect</code> 第一个参数 <code>return</code> 的函数相当于 <code>componentWillUnmount</code> ，若有多个会按顺序执行</li></ul><pre><code class="js">// 语法React.useEffect(() =&gt; &#123;  ...  return () =&gt; &#123;    // 组件卸载前执行，即 componentWillUnmount 钩子    ...  &#125;&#125;, [stateValue])// 模拟 componentDidMount// 第二个参数数组为空，表示不监听任何状态的更新// 因此只有页面首次渲染会执行输出React.useEffect(() =&gt; &#123;  console.log(&#39;DidMount&#39;)  return () =&gt; &#123;    console.log(&#39;WillUnmount 1&#39;)  &#125;&#125;, [])// 模拟全部状态 componentDidUpdate// 若第二个参数不写，表示监听所有状态的更新React.useEffect(() =&gt; &#123;  console.log(&#39;All DidUpdate&#39;)  return () =&gt; &#123;    console.log(&#39;WillUnmount 2&#39;)  &#125;&#125;)// 模拟部分状态 componentDidUpdate// 第二个参数数组写上状态，表示只监听这些状态的更新React.useEffect(() =&gt; &#123;  console.log(&#39;Part DidUpdate&#39;)  return () =&gt; &#123;    console.log(&#39;WillUnmount 3&#39;)  &#125;&#125;, [count, name])// 若调用 ReactDOM.unmountComponentAtNode(document.getElementById(&#39;root&#39;))// 会输出 WillUnmount 1、2、3</code></pre><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><ul><li><code>Fragment</code> 标签本身不会被渲染成一个真实 DOM 标签，有点像 Vue 的 <code>template</code>。</li><li>用空标签也有相同效果，但是空标签不能传递任何属性，<code>Fragment</code> 标签可以传递 <code>key</code> 属性，遍历时候可用。</li></ul><pre><code class="jsx">import React, &#123; Component, Fragment &#125; from &#39;react&#39;export default class Demo extends Component &#123;  render() &#123;    return (      &lt;Fragment key=&#123;1&#125;&gt;        &lt;input type=&quot;text&quot; /&gt;        &lt;input type=&quot;text&quot; /&gt;      &lt;/Fragment&gt;    )    // 或    return (      &lt;&gt;        &lt;input type=&quot;text&quot; /&gt;        &lt;input type=&quot;text&quot; /&gt;      &lt;/&gt;    )  &#125;&#125;</code></pre><h3 id="Context-了解"><a href="#Context-了解" class="headerlink" title="Context (了解)"></a>Context (了解)</h3><p>Context 是一种组件间通信方式，常用于祖父组件与子孙组件。实际开发一般不用，一般用 React-Redux</p><p>用法说明：</p><pre><code class="jsx">1) 创建Context容器对象：const XxxContext = React.createContext()2) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：&lt;XxxContext.Provider value=&#123;数据&#125;&gt;  子组件&lt;/XxxContext.Provider&gt;3) 后代组件读取数据：// 第一种方式：仅适用于类组件// 声明接收contextstatic contextType = xxxContext// 读取context中的value数据this.context//第二种方式: 可用于函数组件与类组件&lt;XxxContext.Consumer&gt;  &#123;    // value就是context中的value数据    value =&gt; (      ...    )  &#125;&lt;/XxxContext.Consumer&gt;</code></pre><p>举个例子：</p><pre><code class="js">// context.jsimport React from &#39;react&#39;export const MyContext = React.createContext()export const &#123; Provider, Consumer &#125; = MyContext</code></pre><pre><code class="jsx">// A.jsximport React, &#123; Component &#125; from &#39;react&#39;import B from &#39;./B.jsx&#39;import &#123; Provider &#125; from &#39;./context.js&#39;export default class A extends Component &#123;  state = &#123; username: &#39;tom&#39;, age: 18 &#125;  render() &#123;    const &#123; username, age &#125; = this.state    return (      &lt;div&gt;        &lt;h3&gt;A组件&lt;/h3&gt;        &lt;h4&gt;用户名是:&#123;username&#125;&lt;/h4&gt;        &lt;Provider value=&#123;&#123; username, age &#125;&#125;&gt;          &lt;B /&gt;        &lt;/Provider&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><pre><code class="jsx">// B.jsximport React, &#123; Component &#125; from &#39;react&#39;import C from &#39;./C.jsx&#39;export default class B extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;B组件&lt;/h3&gt;        &lt;C /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><pre><code class="jsx">// C.jsximport React, &#123; Component &#125; from &#39;react&#39;import &#123; MyContext &#125; from &#39;./context.js&#39;export default class C extends Component &#123;  static contextType = MyContext  render() &#123;    const &#123; username, age &#125; = this.context    return (      &lt;div&gt;        &lt;h3&gt;C组件&lt;/h3&gt;        &lt;h4&gt;          从A组件接收到的用户名:&#123;username&#125;,年龄:&#123;age&#125;        &lt;/h4&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><pre><code class="jsx">// C.jsx 为函数式组件import &#123; Consumer &#125; from &#39;./context.js&#39;export default function C() &#123;  return (    &lt;div&gt;      &lt;h3&gt;我是C组件&lt;/h3&gt;      &lt;h4&gt;        从A组件接收到的用户名:        &lt;Consumer&gt;&#123;(value) =&gt; `$&#123;value.username&#125;,年龄是$&#123;value.age&#125;`&#125;&lt;/Consumer&gt;      &lt;/h4&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="组件渲染优化"><a href="#组件渲染优化" class="headerlink" title="组件渲染优化"></a>组件渲染优化</h3><p>问题：</p><ul><li>只要调用 <code>setState()</code> ，即使没有修改状态，组件也会重新 <code>render()</code></li><li>只要父组件重新渲染，即使子组件没有使用父组件的状态，也会重新 <code>render()</code></li></ul><p>原因：</p><ul><li><code>shouldComponentUpdate()</code> 钩子默认总是返回 <code>true</code></li></ul><p>改进：</p><ul><li>只有组件的 <code>state</code> 或 <code>props</code> 的数据发生改变时才重新渲染</li></ul><p>方式：</p><ol><li>手动重写 <code>shouldComponentUpdate(nextProps, nextState)</code> 的逻辑，只有数据发生改变才返回 <code>true</code></li><li>使用 <code>PureComponent</code> ，它重写了 <code>shouldComponentUpdate()</code> ， 只有 <code>state</code> 或 <code>props</code> 数据有变化才返回 <code>true</code></li></ol><blockquote><p>TIP</p><ul><li>它只是进行 <code>state</code> 和 <code>props</code> 数据的浅比较, 如果只是数据对象内部数据变了, 返回 <code>false</code>。即对于引用数据类型，比较的是地址引用</li><li>不要直接修改 <code>state</code> 数据, 而是要产生新数据</li></ul></blockquote><pre><code class="js">import React, &#123; PureComponent &#125; from &#39;react&#39;class Demo extends PureComponent &#123;  ...  addStu = () =&gt; &#123;    // 不会渲染    const &#123; stus &#125; = this.state    stus.unshift(&#39;小刘&#39;)    this.setState(&#123; stus &#125;)    // 重新渲染    const &#123; stus &#125; = this.state    this.setState(&#123; stus: [&#39;小刘&#39;, ...stus] &#125;)  &#125;  ...&#125;</code></pre><h3 id="render-props-插槽"><a href="#render-props-插槽" class="headerlink" title="render props (插槽)"></a>render props (插槽)</h3><blockquote><p>类似于 Vue 中的插槽技术</p></blockquote><p>如何向组件内部动态传入带内容的结构（即标签或组件）？</p><ul><li>Vue：插槽技术</li><li>React：<ul><li>使用 <code>children props</code>：通过组件标签体传入结构</li><li>使用 <code>render props</code>：通过组件标签属性传入结构，可携带数据</li></ul></li></ul><p><code>children props</code> 方式：</p><ul><li>组件标签体内容会存储到 <code>this.props.children</code> 中</li><li>缺点：A 组件无法向 B 组件传递数据</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;export default class Parent extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;Parent组件&lt;/h3&gt;        &lt;A&gt;          &lt;B /&gt;        &lt;/A&gt;      &lt;/div&gt;    )  &#125;&#125;class A extends Component &#123;  state = &#123; name: &#39;tom&#39; &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;A组件&lt;/h3&gt;        &#123;this.props.children&#125;      &lt;/div&gt;    )  &#125;&#125;class B extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;B组件&lt;/h3&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p><code>render props</code> 方式：</p><ul><li><code>&lt;A render=&#123;(name) =&gt; &lt;B name=&#123;name&#125; /&gt;&#125; /&gt;</code></li><li><code>&#123;this.props.render(name)&#125;</code></li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;export default class Parent extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;Parent组件&lt;/h3&gt;        &lt;A render=&#123;(name) =&gt; &lt;B name=&#123;name&#125; /&gt;&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;class A extends Component &#123;  state = &#123; name: &#39;tom&#39; &#125;  render() &#123;    const &#123; name &#125; = this.state    return (      &lt;div&gt;        &lt;h3&gt;A组件&lt;/h3&gt;        &#123;this.props.render(name)&#125;      &lt;/div&gt;    )  &#125;&#125;class B extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;B组件,&#123;this.props.name&#125;&lt;/h3&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><blockquote><p>TIP</p><p>错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面。</p><p>注意：只在生产环境（项目上线）起效</p></blockquote><p>特点：</p><ul><li>只能捕获<strong>后代组件生命周期</strong>产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</li><li>简单理解就是只能捕获后代组件生命周期钩子里面代码的错误</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import Child from &#39;./Child&#39;export default class Parent extends Component &#123;  state = &#123;    //用于标识子组件是否产生错误    hasError: &#39;&#39;,  &#125;  // 当子组件出现错误，会触发调用，并携带错误信息  static getDerivedStateFromError(error) &#123;    // render 之前触发    // 返回新的 state    return &#123; hasError: error &#125;  &#125;  // 子组件产生错误时调用该钩子  componentDidCatch(error, info) &#123;    console.log(error, info)    console.log(&#39;此处统计错误，反馈给服务器&#39;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h2&gt;Parent组件&lt;/h2&gt;        &#123;this.state.hasError ? &lt;h2&gt;网络不稳定，稍后再试&lt;/h2&gt; : &lt;Child /&gt;&#125;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="组件通信方式总结"><a href="#组件通信方式总结" class="headerlink" title="组件通信方式总结"></a>组件通信方式总结</h3><ul><li><code>props</code></li><li>消息订阅发布：<code>pubs-sub</code></li><li>集中管理：Redux、dva 等</li><li>Context</li></ul><p>推荐搭配：</p><ul><li>父子组件：<code>props</code></li><li>兄弟组件：消息订阅-发布、集中式管理</li><li>祖孙组件(跨级组件)：消息订阅-发布、集中式管理、<code>conText</code>(开发用的少，封装插件用的多即 React-Redux)</li></ul><h2 id="react-router6"><a href="#react-router6" class="headerlink" title="react-router6"></a>react-router6</h2><p><a href="https://reactrouter.com/">官方文档</a></p><p>React Router 发布了三个不同的包：</p><ul><li><code>react-router</code>：路由核心库，提供许多组件、钩子</li><li><code>react-router-dom</code>：包括了 <code>react-router</code> 所有内容，同时添加了用于 DOM 的组件，如 <code>&lt;BrowserRouter&gt;</code></li><li><code>react-router-native</code>：包括了 <code>react-router</code> 所有内容，同时添加了用于 ReactNative 的 API，如 <code>&lt;NativeRouter&gt;</code></li></ul><p>与 React Router 5.x 版本的区别：</p><ul><li>内置组件的变化：移除 <code>&lt;Switch/&gt;</code>，新增 <code>&lt;Routes/&gt;</code>……</li><li>语法变化：<code>component=&#123;About&#125;</code> 变成 <code>element=&#123;&lt;About/&gt;&#125;</code>……</li><li>新增 hook：<code>useParams</code>、<code>useNavigate</code>、<code>useMatch</code>……</li><li>官方明确表示推荐使用函数式组件</li></ul><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装 6 版本的 React Router。</p><pre><code class="shell">npm install react-router-dom</code></pre><p><code>index.js</code> 文件引入 <code>&lt;BrowserRouter&gt;</code>。</p><pre><code class="jsx">// 从 react-dom/client 引入 ReactDOMimport ReactDOM from &#39;react-dom/client&#39;import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;import App from &#39;./App&#39;// React 18 的语法发生改变了ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;)</code></pre><p><code>App.js</code> 设置路由链接和注册路由。<code>&lt;Route caseSensitive&gt;</code> 属性用于指定匹配时是否区分大小写（默认为 false）</p><pre><code class="jsx">import &#123; NavLink, Routes, Route &#125; from &#39;react-router-dom&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;// React 18 默认使用函数式组件了export default function App() &#123;  return (    &lt;div&gt;      &lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &lt;Routes&gt;        &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;        &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h3><p><code>&lt;BrowserRouter&gt;</code> 用于包裹整个应用。</p><pre><code class="jsx">import ReactDOM from &#39;react-dom/client&#39;import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;import App from &#39;./App&#39;ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;)</code></pre><h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><p>作用与 <code>&lt;BrowserRouter&gt;</code> 一样，但 <code>&lt;HashRouter&gt;</code> 修改的是地址栏的 hash 值。</p><p>6.x 版本中 <code>&lt;HashRouter&gt;</code>、<code>&lt;BrowserRouter&gt;</code> 的用法与 5.x 相同。</p><h3 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h3><p>6 版本中移出了 <code>&lt;Switch&gt;</code>，引入了新的替代者：<code>&lt;Routes&gt;</code>。</p><p><code>&lt;Routes&gt;</code> 和 <code>&lt;Route&gt;</code> 要配合使用，且必须要用 <code>&lt;Routes&gt;</code> 包裹 <code>&lt;Route&gt;</code>。</p><h3 id="Navigate-重定向"><a href="#Navigate-重定向" class="headerlink" title="Navigate-重定向"></a>Navigate-重定向</h3><p>只要 <code>&lt;Navigate&gt;</code> 组件被渲染，就会修改路径，切换视图。可用于<code>路由重定向</code>。</p><p><code>replace</code> 属性用于控制跳转模式（push 或 replace，默认是 push）。</p><pre><code class="jsx">import &#123; NavLink, Routes, Route, Navigate &#125; from &#39;react-router-dom&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;export default function App() &#123;  return (    &lt;div&gt;      &lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &lt;Routes&gt;        &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;        &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;        &lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&quot;/about&quot; /&gt;&#125;&gt;&lt;/Route&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><pre><code class="jsx">import React, &#123; useState &#125; from &#39;react&#39;import &#123; Navigate &#125; from &#39;react-router-dom&#39;export default function Home() &#123;  const [sum, setSum] = useState(1)  return (    &lt;div&gt;      &lt;h1&gt;Home&lt;/h1&gt;      &#123;/* 根据sum的值决定是否切换视图 */&#125;      &#123;sum === 1 ? &lt;h4&gt;sum的值为&#123;sum&#125;&lt;/h4&gt; : &lt;Navigate to=&quot;/about&quot; replace=&#123;true&#125; /&gt;&#125;      &lt;button onClick=&#123;() =&gt; setSum(2)&#125;&gt;将sum变为 2&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="useRoutes-路由表"><a href="#useRoutes-路由表" class="headerlink" title="useRoutes() 路由表"></a>useRoutes() 路由表</h3><p>路由规则可以单独抽出一个模块。</p><pre><code class="jsx">// 路由表// routes/index.jsimport &#123; Navigate &#125; from &#39;react-router-dom&#39;import About from &#39;../components/About&#39;import Home from &#39;../components/Home&#39;const routes = [    &#123;        path: &#39;/about&#39;,        element: &lt;About /&gt;    &#125;,    &#123;        path: &#39;/home&#39;,        element: &lt;Home /&gt;    &#125;,    &#123;        path: &#39;/&#39;,        element: &lt;Navigate to=&quot;/home&quot; /&gt;    &#125;]export default routes</code></pre><pre><code class="jsx">// 引入路由表// App.jsimport &#123; NavLink, useRoutes &#125; from &#39;react-router-dom&#39;import routes from &#39;./routes&#39;export default function App() &#123;  // 生成路由规则  const element = useRoutes(routes)  return (    &lt;div&gt;      &lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &#123;element&#125;    &lt;/div&gt;  )&#125;</code></pre><h3 id="Outlet-嵌套路由"><a href="#Outlet-嵌套路由" class="headerlink" title="Outlet 嵌套路由"></a>Outlet 嵌套路由</h3><ul><li>嵌套路由中，需要使用 <code>&lt;Outlet&gt;</code> 设置子路由的路由出口，即在何处渲染子路由。</li><li>设置二级路由链接时，可以是 <code>to=&quot;news&quot;</code>、<code>to=&quot;./news&quot;</code>，但不能是 <code>to=&quot;/news&quot;</code>。</li></ul><p>不使用路由表的嵌套路由：</p><pre><code class="jsx">// App.jsexport default function App() &#123;  return (    &lt;div&gt;      &lt;NavLink to=&quot;about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &lt;Routes&gt;        &lt;Route path=&quot;about&quot; element=&#123;&lt;About /&gt;&#125; /&gt;        &lt;Route path=&quot;home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;          &lt;Route path=&quot;news&quot; element=&#123;&lt;News /&gt;&#125; /&gt;          &lt;Route path=&quot;message&quot; element=&#123;&lt;Message /&gt;&#125; /&gt;        &lt;/Route&gt;        &lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&quot;about&quot; /&gt;&#125; /&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><p>使用路由表的嵌套路由：</p><pre><code class="jsx">// 路由表const routes = [  &#123;    path: &#39;/about&#39;,    element: &lt;About /&gt;,  &#125;,  &#123;    path: &#39;/home&#39;,    element: &lt;Home /&gt;,    // 定义二级路由，注意不要加 /    children: [      &#123;        path: &#39;news&#39;,        element: &lt;News /&gt;,      &#125;,      &#123;        path: &#39;message&#39;,        element: &lt;Message /&gt;,      &#125;,    ],  &#125;,  &#123;    path: &#39;/&#39;,    element: &lt;Navigate to=&quot;/about&quot; /&gt;,  &#125;,]</code></pre><pre><code class="jsx">// Home 子组件import React, &#123; Fragment &#125; from &#39;react&#39;import &#123; NavLink, Outlet &#125; from &#39;react-router-dom&#39;export default function Hello() &#123;  return (    &lt;Fragment&gt;      &lt;h2&gt;I am Hello!&lt;/h2&gt;      &#123;/* 子路由链接 */&#125;      &lt;NavLink to=&quot;news&quot;&gt;News&lt;/NavLink&gt;      &lt;NavLink to=&quot;message&quot;&gt;Message&lt;/NavLink&gt;      &lt;hr /&gt;      &#123;/* 子路由出口 */&#125;      &lt;Outlet&gt;&lt;/Outlet&gt;    &lt;/Fragment&gt;  )&#125;</code></pre><h3 id="NavLink-路由高亮"><a href="#NavLink-路由高亮" class="headerlink" title="NavLink 路由高亮"></a>NavLink 路由高亮</h3><p>实现导航的 “高亮” 效果，6 版本不能直接指定高亮类名，需要通过函数返回。该函数传入一个对象，类似于 <code>&#123;isActive: true&#125;</code> 标识路由是否被激活。</p><p>默认情况下，当 <code>Home</code> 的子组件匹配成功，<code>Home</code> 的导航也会高亮，<code>end</code> 属性可移除该效果。</p><pre><code class="jsx">// NavLink 默认类名是 active，下面是指定自定义类名//自定义样式&lt;NavLink    to=&quot;login&quot;    className=&#123;(&#123; isActive &#125;) =&gt; &#123;        console.log(&#39;home&#39;, isActive)        return isActive ? &#39;base MyClass&#39; : &#39;base&#39;    &#125;&#125;&gt;about&lt;/NavLink&gt;// 默认情况下，当 Home 的子组件匹配成功，Home 的导航也会高亮// 当 NavLink 上添加了 end 属性后，若 Home 的子组件匹配成功，则 Home 的导航没有高亮效果。&lt;NavLink to=&quot;home&quot; end &gt;home&lt;/NavLink&gt;</code></pre><h3 id="路由传参-1"><a href="#路由传参-1" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="传递-params参数"><a href="#传递-params参数" class="headerlink" title="传递 params参数"></a>传递 params参数</h4><p>注册路由时声明 <code>params</code> 参数，和 React Router 5 一样。</p><pre><code class="jsx">export default function App() &#123;  return (    &lt;div&gt;      &lt;Routes&gt;        &lt;Route path=&quot;home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;          &lt;Route path=&quot;message&quot; element=&#123;&lt;Message /&gt;&#125;&gt;            &lt;Route path=&quot;detail/:id/:name/:age&quot; element=&#123;&lt;Detail /&gt;&#125; /&gt;          &lt;/Route&gt;        &lt;/Route&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><p>传递参数</p><pre><code class="jsx">&lt;Link to=&#123;`detail/$&#123;item.id&#125;/$&#123;item.name&#125;/$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;</code></pre><p>使用 <code>useParams()</code> 接收 <code>params</code> 参数。<code>useParams()</code> 返回一个参数对象。</p><pre><code class="jsx">import React from &#39;react&#39;import &#123; useParams, useMatch &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  // 解构赋值  const &#123; id, name, age &#125; = useParams()  return (    &lt;div&gt;      &lt;li&gt;id:&#123;id&#125;&lt;/li&gt;      &lt;li&gt;name:&#123;name&#125;&lt;/li&gt;      &lt;li&gt;age:&#123;age&#125;&lt;/li&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="传递-search参数"><a href="#传递-search参数" class="headerlink" title="传递 search参数"></a>传递 search参数</h4><p>和 5 版本一样，正常注册路由即可。</p><pre><code class="jsx">&lt;Route path=&quot;detail&quot; element=&#123;&lt;Detail /&gt;&#125; /&gt;</code></pre><p>传递参数。</p><pre><code class="jsx">&lt;Link to=&#123;`detail?id=$&#123;item.id&#125;&amp;name=$&#123;item.name&#125;&amp;age=$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;</code></pre><p>使用 <code>useSearchParams()</code> 接收参数。该方法返回一个包含两个元素的数组：<code>search</code> 参数和修改 <code>search</code> 参数的方法。</p><pre><code class="jsx">import React from &#39;react&#39;import &#123; useSearchParams &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  // 数组的解构赋值  const [searchParams, setSearchParams] = useSearchParams()  // 需要调用 get() 方法获取对应的参数值  const id = searchParams.get(&#39;id&#39;)  const name = searchParams.get(&#39;name&#39;)  const age = searchParams.get(&#39;age&#39;)  function change() &#123;    setSearchParams(&#39;id=666&amp;name=Lily&amp;age=888&#39;)  &#125;  return (    &lt;div&gt;      &lt;li&gt;id:&#123;id&#125;&lt;/li&gt;      &lt;li&gt;name:&#123;name&#125;&lt;/li&gt;      &lt;li&gt;age:&#123;age&#125;&lt;/li&gt;      &lt;button onClick=&#123;change&#125;&gt;Change search params&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="传递-state-参数"><a href="#传递-state-参数" class="headerlink" title="传递 state 参数"></a>传递 state 参数</h4><p>和 5 版本一样，正常注册路由即可。</p><pre><code class="jsx">&lt;Route path=&quot;detail&quot; element=&#123;&lt;Detail /&gt;&#125; /&gt;</code></pre><p>传递参数，这里相较于 5 版本有所不同，不必写到一个对象里面。</p><pre><code class="jsx">&lt;Link to=&quot;detail&quot; state=&#123;&#123; id: item.id, name: item.name, age: item.age &#125;&#125;&gt;  &#123;item.name&#125;&lt;/Link&gt;</code></pre><p>使用 <code>useLocation()</code> 接收参数。该方法返回路由组件的 <code>location</code> 对象，就是 5 版本路由组件的 <code>location</code> 属性，其中包含 <code>state</code> 参数。</p><pre><code class="jsx">import &#123; useLocation &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  // 连续解构赋值  const &#123;    state: &#123; id, name, age &#125;,  &#125; = useLocation()  return (    &lt;div&gt;      &lt;li&gt;id:&#123;id&#125;&lt;/li&gt;      &lt;li&gt;name:&#123;name&#125;&lt;/li&gt;      &lt;li&gt;age:&#123;age&#125;&lt;/li&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="useNavigate-编程式路由导航"><a href="#useNavigate-编程式路由导航" class="headerlink" title="useNavigate() 编程式路由导航"></a>useNavigate() 编程式路由导航</h3><p><code>useNavigate()</code> 返回一个函数，调用该函数实现编程式路由导航。函数有两种参数传递方式。</p><p>第一种方式传递两个参数：路由和相关参数。参数只能设置 <code>replace</code> 和 <code>state</code>。<strong style="color:red">想要传递 <code>params</code> 和 <code>search</code> 参数直接在路由带上</strong>。</p><p>第二种方式传递数字，代表前进或后退几步。</p><pre><code class="jsx">import React, &#123; useState &#125; from &#39;react&#39;import &#123; Outlet, useNavigate &#125; from &#39;react-router-dom&#39;export default function Message() &#123;  const [list] = useState([    &#123; id: 1, name: &#39;Bruce&#39;, age: 33 &#125;,    &#123; id: 2, name: &#39;You&#39;, age: 3 &#125;,    &#123; id: 3, name: &#39;React&#39;, age: 333 &#125;,  ])  const navigate = useNavigate()  function showDetail(item) &#123;    navigate(&#39;detail&#39;, &#123;      replace: true,      state: &#123;        id: item.id,        name: item.name,        age: item.age,      &#125;,    &#125;)  &#125;  function back() &#123;    navigate(1)  &#125;  function forward() &#123;    navigate(-1)  &#125;  return (    &lt;div&gt;      &lt;ul&gt;        &#123;list.map((item) =&gt; &#123;          return (            &lt;li key=&#123;item.id&#125;&gt;              &lt;button onClick=&#123;() =&gt; showDetail(item)&#125;&gt;查看详情&lt;/button&gt;              &lt;button onClick=&#123;back&#125;&gt;后退&lt;/button&gt;              &lt;button onClick=&#123;forward&#125;&gt;前进&lt;/button&gt;            &lt;/li&gt;          )        &#125;)&#125;      &lt;/ul&gt;      &lt;Outlet&gt;&lt;/Outlet&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="Other-Hooks-了解"><a href="#Other-Hooks-了解" class="headerlink" title="Other Hooks(了解)"></a>Other Hooks(了解)</h3><h4 id="useMatch"><a href="#useMatch" class="headerlink" title="useMatch()"></a>useMatch()</h4><p>返回路由组件的 <code>match</code> 数据，即 5 版本中的 <code>match</code> 属性。</p><p>必须传入该组件对应的路由规则才能正确返回，否则返回 <code>null</code>。</p><pre><code class="jsx">// Detail.jsximport &#123; useParams, useMatch &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  const match = useMatch(&#39;home/message/detail/:id/:name/:age&#39;)  console.log(match)  return (    &lt;div&gt;      &lt;li&gt;id&lt;/li&gt;    &lt;/div&gt;  )&#125;/*params: &#123;id: &#39;1&#39;, name: &#39;tom&#39;, age: &#39;33&#39;&#125;pathname: &quot;/home/message/detail/1/tom/33&quot;pathnameBase: &quot;/home/message/detail/1/tom/33&quot;pattern: &#123;path: &#39;home/message/detail/:id/:name/:age&#39;, caseSensitive: false, end: true&#125;*/</code></pre><h4 id="useInRouterContext"><a href="#useInRouterContext" class="headerlink" title="useInRouterContext"></a>useInRouterContext</h4><p>如果组件在 <code>&lt;Router&gt;</code> 的上下文中呈现，则 <code>useInRouterContext</code> 钩子返回 <code>true</code>，否则返回 <code>false</code>。即组件有没有被包裹在 <code>&lt;BrowserRouter&gt;</code> 这种东西里面。这个对第三方组件库有用处。</p><h4 id="useNavigationType"><a href="#useNavigationType" class="headerlink" title="useNavigationType"></a>useNavigationType</h4><p>返回当前的导航类型（用户是如何来到当前页面的）。</p><p>返回值：<code>POP</code>、<code>PUSH</code>、<code>REPLACE</code>。</p><p><code>POP</code> 是指在浏览器中直接打开了这个路由组件（<code>刷新页面</code>）。</p><h4 id="useOutlet"><a href="#useOutlet" class="headerlink" title="useOutlet"></a>useOutlet</h4><p>用来呈现当前组件中渲染的嵌套路由。</p><pre><code class="jsx">const result = useOutlet()console.log(result)// 如果嵌套路由没有挂载,则返回 null// 如果嵌套路由已经挂载,则展示嵌套的路由对象</code></pre><h4 id="useResolvedPath"><a href="#useResolvedPath" class="headerlink" title="useResolvedPath"></a>useResolvedPath</h4><p>给定一个 URL 值，解析其中的：<code>path</code>、<code>search</code>、<code>hash</code> 值。</p><pre><code class="jsx">const res = useResolvedPath(&#39;/user?id=001&amp;name=tom#React&#39;)console.log(res)/*hash: &#39;#React&#39;pathname: &#39;/user&#39;search: &#39;?id=001&amp;name=tom&#39;*/</code></pre>]]></content>
    
    
    <summary type="html">react基础、react-router5/6、react-redux等</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="react" scheme="https://heliufang.github.io/tags/react/"/>
    
  </entry>
  
</feed>
