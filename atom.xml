<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>贺刘芳的搬砖日记</title>
  
  <subtitle>每天多学一点知识,就少写一行代码</subtitle>
  <link href="https://heliufang.github.io/atom.xml" rel="self"/>
  
  <link href="https://heliufang.github.io/"/>
  <updated>2022-12-30T09:16:24.166Z</updated>
  <id>https://heliufang.github.io/</id>
  
  <author>
    <name>贺刘芳</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react笔记</title>
    <link href="https://heliufang.github.io/2022/12/30/1608754051799977984/images/"/>
    <id>https://heliufang.github.io/2022/12/30/1608754051799977984/images/</id>
    <published>2022-12-30T09:15:28.000Z</published>
    <updated>2022-12-30T09:16:24.166Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1wy4y1D7JT">尚硅谷React教程（2022加更，B站超火react教程）</a></p><h2 id="react入门"><a href="#react入门" class="headerlink" title="react入门"></a>react入门</h2><p>React：用于构建用户界面的 JavaScript 库。由 <code>Facebook</code> 开发且开源。</p><p>原生 JavaScript 的痛点：</p><ul><li>操作 DOM 繁琐、效率低</li><li>使用 JavaScript 直接操作 DOM，浏览器进行大量重绘重排</li><li>原生 JavaScript 没有组件化编码方案，代码复用率低</li></ul><p>React 的特点：</p><ul><li>采用组件化模式、声明式编码，提高开发效率和组件复用率</li><li>在 <code>React Native</code> 中可用 React 语法进行移动端开发</li><li>使用虚拟 DOM 和 Diffing 算法，减少与真实 DOM 的交互</li></ul><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><ul><li><code>react.development.js</code> ：React 核心库</li><li><code>react-dom.development.js</code> ：提供 DOM 操作的 React 扩展库</li><li><code>babel.min.js</code> ：解析 JSX 语法，转换为 JS 代码</li></ul><pre><code class="html">&lt;!-- 引入react核心库 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入babel，用于将jsx转为js --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 准备容器 --&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;!-- 此处一定要写babel，表示写的不是 JS，而是 JSX，并且靠 babel 翻译 --&gt;&lt;script type=&quot;text/babel&quot;&gt;        // 创建虚拟dom        let VDOM = &lt;div&gt;Hello React&lt;/div&gt;        // 渲染        ReactDOM.render(VDOM,document.getElementById(&#39;app&#39;))&lt;/script&gt;</code></pre><h3 id="创建虚拟DOM的两种方式"><a href="#创建虚拟DOM的两种方式" class="headerlink" title="创建虚拟DOM的两种方式"></a>创建虚拟DOM的两种方式</h3><p>两种方式是：js和jsx</p><ul><li>使用 JS 创建虚拟 DOM 比 JSX 繁琐</li><li>JSX 可以让程序员更加简单地创建虚拟 DOM，相当于语法糖</li><li>最终 babel 会把 JSX 语法转换为 JS</li></ul><blockquote><p>开发中一般使用jsx的方式，也就是入门案例中使用的方式，会jsx就行</p></blockquote><p>第一种：使用js创建</p><pre><code class="jsx">//1.使用 React 提供的 API 创建虚拟DOMconst VDOM = React.createElement(&#39;h1&#39;, &#123; id: &#39;title&#39; &#125;, React.createElement(&#39;span&#39;, &#123;&#125;, &#39;Hello,React&#39;))//2.渲染虚拟DOM到页面ReactDOM.render(VDOM, document.getElementById(&#39;app&#39;))</code></pre><p>第二种：使用jsx创建(<strong style="color:red">掌握</strong>)  例子见入门案例</p><h3 id="虚拟DOM和真实DOM"><a href="#虚拟DOM和真实DOM" class="headerlink" title="虚拟DOM和真实DOM"></a>虚拟DOM和真实DOM</h3><p>关于虚拟 DOM：</p><ol><li>本质是 Object 类型的对象（一般对象）</li><li>虚拟 DOM 比较<strong style="color:red">“轻”</strong>，真实 DOM 比较<strong style="color:red">“重”</strong>，因为虚拟 DOM 是 React 内部在用，无需真实 DOM 上那么多的属性。</li><li>虚拟 DOM 最终会被 React 转化为真实 DOM，呈现在页面上。</li></ol><pre><code class="jsx">//如果VDOM如果有多行，可以用()包起来const VDOM = (    &lt;h1 id=&quot;title&quot;&gt;    &lt;span&gt;Hello,React&lt;/span&gt;    &lt;/h1&gt;)ReactDOM.render(VDOM, document.getElementById(&#39;app&#39;))const TDOM = document.getElementById(&#39;demo&#39;)console.log(&#39;虚拟DOM&#39;, VDOM)console.log(&#39;真实DOM&#39;, TDOM)</code></pre><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><ul><li>全称：JavaScript XML</li><li>React 定义的类似于 XML 的 JS 扩展语法；本质是 <code>React.createElement()</code> 方法的语法糖</li><li>作用：简化创建虚拟 DOM</li></ul><h4 id="JSX的语法规则"><a href="#JSX的语法规则" class="headerlink" title="JSX的语法规则"></a>JSX的语法规则</h4><ul><li>定义虚拟 DOM 时，不要写引号</li><li>标签中混入 JS 表达式需要使用 <code>&#123;&#125;</code></li><li>指定类名不用 <code>class</code>，使用 <code>className</code></li><li>内联样式，使用 <code>style=&#123; &#123; key: value &#125; &#125;</code> 的形式</li><li>只能有一个根标签</li><li>标签必须闭合，单标签结尾必须添加 <code>/</code>：<code>&lt;input type=&quot;text&quot; /&gt;</code></li><li>标签首字母小写，则把标签转换为 HTML 对应的标签，若没有，则报错</li><li>标签首字母大写，则渲染对应组件，若没有定义组件，则报错</li></ul><pre><code class="jsx">let title = &#39;HeLLOjSx&#39;let VDOM = (    &lt;div title=&#123;title.toUpperCase()&#125;&gt;    &lt;div className=&quot;info&quot;&gt;info&lt;/div&gt;&lt;div style=&#123;&#123;fontSize: '26px',color: 'red'&#125;&#125;&gt;style内联样式&lt;/div&gt;&lt;/div&gt;)ReactDOM.render(VDOM,document.getElementById(&quot;app&quot;))</code></pre><h4 id="js语句和表达式的区别"><a href="#js语句和表达式的区别" class="headerlink" title="js语句和表达式的区别"></a>js语句和表达式的区别</h4><ul><li>表达式：一个表达式会产生一个<code>值</code>，可以放在任何一个需要值的地方</li></ul><pre><code class="js">aa + bdemo(1)arr.map()function test() &#123;&#125;</code></pre><ul><li>语句(代码)：</li></ul><pre><code class="js">if()&#123;&#125;for()&#123;&#125;switch()&#123;case:xxxx&#125;</code></pre><pre><code class="jsx">let arr = [&#39;vue&#39;,&#39;react&#39;,&#39;angular&#39;]let VDOM = (    &lt;ul&gt;    &#123;        arr.map( v =&gt; &lt;li&gt;&#123;v&#125;&lt;/li&gt; )    &#125;      &lt;/ul&gt;)ReactDOM.render(VDOM,document.getElementById(&quot;app&quot;))</code></pre><h2 id="react面向组件编程"><a href="#react面向组件编程" class="headerlink" title="react面向组件编程"></a>react面向组件编程</h2><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>要点：</p><ul><li>组件名称<strong style="color:red">首字母必须大写</strong>，否则会解析成普通标签导致报错，详见 JSX 语法规则</li><li>函数需返回一个虚拟 DOM</li><li>渲染组件时需要使用标签形式，同时标签必须闭合</li></ul><p>渲染组件的过程：</p><ul><li>React 解析标签，寻找对应组件</li><li>发现组件是函数式组件，则调用函数，将返回的虚拟 DOM 转换为真实 DOM ，并渲染到页面中</li></ul><pre><code class="jsx">//1.创建函数式组件  function MyComponent() &#123;    console.log(this)//undefined    return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;  &#125;  //2.渲染组件到页面  ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&#39;app&#39;))</code></pre><blockquote><p>注意： 上面函数组件内部this 是 undefined，因为 babel 编译后开启了严格模式</p></blockquote><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>要点：</p><ul><li>使用class关键字来定义组件</li><li>使用extends来继承React.Component类</li><li>类中使用render方法来返回虚拟DOM</li></ul><p>组件渲染过程：</p><ul><li>React 解析组件标签，寻找组件</li><li>发现是类式组件，则 <code>new</code> 该类的实例对象，通过实例调用原型上的 <code>render</code> 方法</li><li>将 <code>render</code> 返回的虚拟 DOM 转为真实 DOM ，渲染到页面上·</li></ul><pre><code class="jsx">// 创建类式组件  class MyComponent extends React.Component &#123;    render() &#123;      console.log(&#39;render中的this：&#39;, this)      return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;/h2&gt;    &#125;  &#125;  ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&#39;app&#39;))</code></pre><h3 id="组件实例的三大属性"><a href="#组件实例的三大属性" class="headerlink" title="组件实例的三大属性"></a>组件实例的三大属性</h3><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p><code>state</code> 是组件实例对象最重要的属性，值为对象。又称为状态机，通过更新组件的 <code>state</code> 来更新对应的页面显示。</p><p>要点：</p><ul><li>初始化 <code>state</code></li><li>React 中事件绑定</li><li><code>this</code> 指向问题</li><li><code>setState</code> 修改 <code>state</code> 状态</li><li><code>constructor</code> 、<code>render</code> 、自定义方法的调用次数</li></ul><pre><code class="jsx">class Sum extends React.Component&#123;    constructor(props)&#123;// 调用一次        super(props)        //初始化state        this.state = &#123;count: 0&#125;        //解决this为undefined问题,将原型上面的add方法改变this之后，挂在实例上        this.add = this.add.bind(this)         console.log(this)    &#125;    add()&#123;//这样写是挂在原型上        console.log(&quot;add&quot;,this)        //更新state的值        this.setState(&#123;            count: this.state.count + 1        &#125;)    &#125;    render()&#123;//调用 1+N次        return (            // 注意绑定事件的方式:a)驼峰 b)带上&#123;&#125;  onClick=&#123;this.add&#125;                &lt;div&gt;                    sum的值：&#123; this.state.count &#125;&lt;br/&gt;                    &lt;button onClick=&#123;this.add&#125;&gt;+1&lt;/button&gt;                                    &lt;/div&gt;           )    &#125;&#125;ReactDOM.render(&lt;Sum /&gt;,document.getElementById(&quot;app&quot;))</code></pre><p>简化版(<strong style="color:red">推荐</strong>)</p><pre><code class="jsx">class Sum extends React.Component&#123;    // = 表示直接挂在组件实例身上    state = &#123;count: 0&#125;    //采用箭头函数 + 赋值语句形式 this指向外面组件的this    add = () =&gt; &#123;         console.log(&quot;add&quot;,this) //this为组件实例        //更新state的值        this.setState(&#123;count: this.state.count + 1&#125;)    &#125;    render()&#123;//调用 1+N次        return (            &lt;div&gt;                sum的值：&#123; this.state.count &#125;&lt;br/&gt;                &lt;button onClick=&#123;this.add&#125;&gt;+1&lt;/button&gt;                            &lt;/div&gt;            )    &#125;&#125;ReactDOM.render(&lt;Sum /&gt;,document.getElementById(&quot;app&quot;))</code></pre><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>每个组件对象都有 <code>props</code> 属性，组件标签的属性都保存在 <code>props</code> 中。<code>props</code> 是<code>只读</code>的，不能修改。</p><h5 id="props的基本使用"><a href="#props的基本使用" class="headerlink" title="props的基本使用"></a>props的基本使用</h5><p>通过标签属性传值,会包装在组件的props属性上面。</p><pre><code class="jsx">class Person extends React.Component &#123;    render()&#123;        console.log(this.props)//&#123;name: &#39;青阳&#39;, age: 18, gender: &#39;男&#39;&#125;        const &#123;name , age, gender&#125; = this.props        return (            &lt;div&gt;                &lt;div&gt;name: &#123;name&#125;&lt;/div&gt;                &lt;div&gt;age:  &#123;age&#125;&lt;/div&gt;                &lt;div&gt;gender: &#123;gender&#125;&lt;/div&gt;            &lt;/div&gt;        )    &#125;&#125;// 类似于标签属性传值 注意：数值要用&#123;&#125;ReactDOM.render(&lt;Person name=&quot;青阳&quot; age=&#123;18&#125; gender=&quot;男&quot;/&gt;,document.getElementById(&#39;app&#39;))</code></pre><h5 id="批量传递props"><a href="#批量传递props" class="headerlink" title="批量传递props"></a>批量传递props</h5><pre><code class="jsx">class Person extends React.Component &#123;    render()&#123;        console.log(this.props)        const &#123;name , age, gender&#125; = this.props        return (            &lt;div&gt;                &lt;div&gt;name: &#123;name&#125;&lt;/div&gt;                &lt;div&gt;age:  &#123;age&#125;&lt;/div&gt;                &lt;div&gt;gender: &#123;gender&#125;&lt;/div&gt;            &lt;/div&gt;        )    &#125;&#125;const p = &#123;name: &#39;青阳&#39;,age: 19,gender: &#39;男&#39;&#125;//通过...批量传递propsReactDOM.render(&lt;Person &#123;...p&#125; /&gt;,document.getElementById(&#39;app&#39;))</code></pre><h5 id="props的类型限制"><a href="#props的类型限制" class="headerlink" title="props的类型限制"></a>props的类型限制</h5><p>在 <code>React 15.5</code> 以前，<code>React</code> 身上有一个 <code>PropTypes</code> 属性可直接使用，即 <code>name: React.PropTypes.string.isRequired</code> ，没有把 <code>PropTypes</code> 单独封装为一个模块。</p><p>从 <code>React 15.5</code> 开始，把 <code>PropTypes</code> 单独封装为一个模块，需要额外导入使用。</p><blockquote><p>了解即可,用的时候再看,老项目可能使用这种，最新一般使用ts来做类型校验.</p></blockquote><pre><code class="jsx">&lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;  class Person extends React.Component &#123;    render() &#123;      const &#123; name, age, sex &#125; = this.props      return (        &lt;ul&gt;          &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;          &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;          &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt;        &lt;/ul&gt;      )    &#125;  &#125;  // 类型和必要性限制  Person.propTypes = &#123;    name: PropTypes.string.isRequired,    sex: PropTypes.string,    age: PropTypes.number,    // 限制 speak 为函数    speak: PropTypes.func,  &#125;  // 指定默认值  Person.defaultProps = &#123;    sex: &#39;male&#39;,    age: 19,  &#125;  ReactDOM.render(&lt;Person name=&quot;Vue&quot; sex=&quot;male&quot; age=&#123;11&#125; speak=&#123;speak&#125; /&gt;, document.getElementById(&#39;test&#39;))  function speak() &#123;    console.log(&#39;speaking...&#39;)  &#125;&lt;/script&gt;</code></pre><p><code>Person.propTypes</code> 和 <code>Person.defaultProps</code> 可以看作在类身上添加属性，利用 <code>static</code> 关键词就能在类内部进行声明。因此所谓简写只是从类外部移到类内部。</p><pre><code class="jsx">&lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;  class Person extends React.Component &#123;    static propTypes = &#123;      name: PropTypes.string.isRequired,      sex: PropTypes.string,      age: PropTypes.number,      // 限制 speak 为函数      speak: PropTypes.func,    &#125;    static defaultProps = &#123;      sex: &#39;male&#39;,      age: 19,    &#125;    render() &#123;      const &#123; name, age, sex &#125; = this.props      return (        &lt;ul&gt;          &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;          &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;          &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt;        &lt;/ul&gt;      )    &#125;  &#125;  ReactDOM.render(&lt;Person name=&quot;Vue&quot; sex=&quot;male&quot; age=&#123;11&#125; speak=&#123;speak&#125; /&gt;, document.getElementById(&#39;test&#39;))  function speak() &#123;    console.log(&#39;speaking...&#39;)  &#125;&lt;/script&gt;</code></pre><h5 id="函数组件使用props"><a href="#函数组件使用props" class="headerlink" title="函数组件使用props"></a>函数组件使用props</h5><p>由于函数可以传递参数，因此函数式组件可以使用 <code>props</code> 。</p><pre><code class="jsx">function Person(props)&#123;    const &#123;name,age,gender&#125; = props    return &lt;div&gt;个人信息 name：&#123;name&#125; , age：&#123;age&#125; , gender：&#123;gender&#125;&lt;/div&gt;&#125;Person.propTypes = &#123;    age: PropTypes.number.required&#125;Person.defaultProps = &#123;    age: 10&#125;const p = &#123;name: &#39;tom&#39;,gender: &#39;男&#39;&#125;ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="类组件的构造器和props"><a href="#类组件的构造器和props" class="headerlink" title="类组件的构造器和props"></a>类组件的构造器和props</h5><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#constructor">官网文档说明</a>  构造函数一般用在两种情况：</p><ul><li>通过给 <code>this.state</code> 赋值对象来初始化内部 <code>state</code></li><li>为事件处理函数绑定实例</li></ul><pre><code class="jsx">constructor(props) &#123;  super(props)  // 初始化 state  this.state = &#123; isHot: true, wind: &#39;微风&#39; &#125;  // 解决 this 指向问题  this.changeWeather = this.changeWeather.bind(this)&#125;</code></pre><blockquote><p>因此构造器一般都不需要写。如果要在构造器内使用 <code>this.props</code> 才声明构造器，并且需要在最开始调用 <code>super(props)</code></p></blockquote><h4 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h4><p>Refs 提供了一种方式，允许我们<strong style="color:red">访问 DOM 节点</strong>或在 render 方法中创建的 React 元素。</p><h5 id="字符串形式的ref"><a href="#字符串形式的ref" class="headerlink" title="字符串形式的ref"></a>字符串形式的ref</h5><p>这种形式已过时，效率不高，<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs">官方</a> 不建议使用。</p><pre><code class="jsx">class Demo extends React.Component&#123;    showInput = () =&gt; &#123;        //2.使用ref        const &#123; myRef &#125; = this.refs        console.log(myRef) //input标签dom        console.log(myRef.value) //input标签的值    &#125;    render()&#123;        return (           &lt;div&gt;            &#123;/*1.定义ref*/&#125;            &lt;input type=&quot;text&quot; ref=&quot;myRef&quot; /&gt;            &lt;button type=&quot;button&quot; onClick=&#123;this.showInput&#125;&gt;点击显示输入框内容&lt;/button&gt;        &lt;/div&gt;        )    &#125;&#125;  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="回调形式的ref"><a href="#回调形式的ref" class="headerlink" title="回调形式的ref"></a>回调形式的ref</h5><pre><code class="jsx">class Demo extends React.Component&#123;    showInput = () =&gt; &#123;        console.log(this.myInput.value);    &#125;    render()&#123;        return (            &lt;div&gt;              &#123;/*                  通过回调将input标签的dom 挂在实例的 myInput属性上                  由于是箭头函数，因此 `this` 是 `render` 函数里的 `this` ，即组件实例              */&#125;              &lt;input type=&quot;text&quot; ref=&#123;input =&gt; this.myInput = input&#125; /&gt;              &lt;button type=&quot;button&quot; onClick=&#123;this.showInput&#125;&gt;点击显示输入框内容&lt;/button&gt;            &lt;/div&gt;       )    &#125;&#125;  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="createRef形式的ref"><a href="#createRef形式的ref" class="headerlink" title="createRef形式的ref"></a>createRef形式的ref</h5><p>该方式通过调用 <code>React.createRef</code> 返回一个容器用于存储节点，且一个容器只能存储一个节点。</p><pre><code class="jsx">class Demo extends React.Component&#123;    //1.创建ref对象    myRef = React.createRef()    showInput = () =&gt; &#123;        //3.使用ref对象        console.log(this.myRef.current) //input dom对象        console.log(this.myRef.current.value);    &#125;    render()&#123;        return (            &lt;div&gt;                &#123;/* 2.绑定ref对象 */&#125;                &lt;input type=&quot;text&quot; ref=&#123;this.myRef&#125; /&gt;                &lt;button type=&quot;button&quot; onClick=&#123;this.showInput&#125;&gt;点击显示输入框内容&lt;/button&gt;            &lt;/div&gt;            )        &#125;&#125;  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul><li>React 使用自定义事件，而非原生 DOM 事件，即 <code>onClick、onBlur</code> ：为了更好的兼容性</li><li>React 的事件通过事件委托方式进行处理：为了高效</li><li>通过 <code>event.target</code> 可获取触发事件的 DOM 元素：勿过度使用 <code>ref</code></li></ul><p>当触发事件的元素和需要操作的元素为同一个时，可以不使用 <code>ref</code> ：</p><pre><code class="jsx">class Demo extends React.Component &#123;  showData2 = (event) =&gt; &#123;    alert(event.target.value)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;input onBlur=&#123;this.showData2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot; /&gt;        &amp;nbsp;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>包含表单的组件分类：</p><ul><li>非受控组件：现用现取。即需要使用时，再获取节点得到数据</li><li>受控组件：类似于<code> Vue 双向绑定</code>的从视图层绑定到数据层</li></ul><p>尽量使用受控组件，因为非受控组件需要使用大量的 <code>ref</code> 。</p><h4 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h4><p>主要是通过ref来实现</p><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = (e) =&gt; &#123;        e.preventDefault();        const &#123;username,password&#125; = this        console.log(username.value,&quot;,&quot;,password.value);    &#125;    render()&#123;        return (            &lt;div&gt;                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;                账号：&lt;input type=&quot;text&quot; ref=&#123;c =&gt; this.username = c&#125;/&gt;&lt;br/&gt;                    密码：&lt;input type=&quot;password&quot; ref=&#123;c =&gt; this.password = c&#125;/&gt;&lt;br/&gt;                        &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;                &lt;/form&gt;            &lt;/div&gt;            )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><h5 id="受控组件基础"><a href="#受控组件基础" class="headerlink" title="受控组件基础"></a>受控组件基础</h5><p>通过表单的onChange事件，当内容变化时，将数据更新到state中</p><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = e =&gt; &#123;        e.preventDefault();//阻止默认提交        const &#123;username,password&#125; = this.state        console.log(username,&quot;,&quot;,password);    &#125;    setUsername = e =&gt; &#123;        this.setState(&#123;username: e.target.value&#125;)    &#125;    setPassword = e =&gt; &#123;        this.setState(&#123;password: e.target.value&#125;)    &#125;    render()&#123;            return (                &lt;div&gt;                    &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;                    账号：&lt;input type=&quot;text&quot; onChange=&#123;this.setUsername&#125;/&gt;&lt;br/&gt;                        密码：&lt;input type=&quot;password&quot; onChange=&#123;this.setPassword&#125;/&gt;&lt;br/&gt;                            &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;                    &lt;/form&gt;                &lt;/div&gt;            )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><p>对上述受控组件的代码进行优化，希望把 <code>saveUsername</code> 和 <code>savePassword</code> 合并为一个函数。有如下两种方案。</p><ul><li>高阶函数：参数为函数或者返回一个函数的函数，如 <code>Promise、setTimeout、Array.map()</code></li><li>函数柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</li></ul><h5 id="受控组件柯里化"><a href="#受控组件柯里化" class="headerlink" title="受控组件柯里化"></a>受控组件柯里化</h5><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = (e) =&gt; &#123;        e.preventDefault();        const &#123;username,password&#125; = this.state        console.log(username,&quot;,&quot;,password);    &#125;    setFormData = name =&gt; &#123;        return e =&gt; &#123;//函数调用返回一个函数,多次接受参数统一处理            this.setState(&#123;[name]: e.target.value&#125;)        &#125;    &#125;    render()&#123;        return (            &lt;div&gt;            &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;            账号：&lt;input type=&quot;text&quot; onChange=&#123;this.setFormData(&#39;username&#39;)&#125;/&gt;&lt;br/&gt;            密码：&lt;input type=&quot;password&quot; onChange=&#123;this.setFormData(&#39;password&#39;)&#125;/&gt;&lt;br/&gt;            &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;            &lt;/form&gt;            &lt;/div&gt;            )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="受控组件不用柯里化"><a href="#受控组件不用柯里化" class="headerlink" title="受控组件不用柯里化"></a>受控组件不用柯里化</h5><p>和柯里化差不多,只不过是在onChange里面定义一个箭头函数来接受参数</p><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = (e) =&gt; &#123;        e.preventDefault();        const &#123;username,password&#125; = this.state        console.log(username,&quot;,&quot;,password);    &#125;    setFormData = (e,name) =&gt; &#123;        this.setState(&#123;[name]: e.target.value&#125;)    &#125;    render()&#123;        return (         &lt;div&gt;            &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;         账号：&lt;input type=&quot;text&quot; onChange=&#123;e =&gt; this.setFormData(e,&#39;username&#39;) &#125;/&gt;             密码：&lt;input type=&quot;password&quot; onChange=&#123;e =&gt; this.setFormData(e,&#39;password&#39;) &#125;/&gt;              &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;            &lt;/form&gt;        &lt;/div&gt;        )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="生命周期-旧版"><a href="#生命周期-旧版" class="headerlink" title="生命周期-旧版"></a>生命周期-旧版</h4><p><strong>初始化阶段</strong>：<code>ReactDOM.render()</code> 触发的初次渲染</p><ul><li><code>constructor</code></li><li><code>componentWillMount</code></li><li><code>render</code></li><li><code>componentDidMount</code></li></ul><p><strong>更新阶段</strong></p><ol><li>父组件重新 <code>render</code> 触发的更新</li></ol><ul><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code> ：控制组件是否更新的阀门，返回值为布尔值，默认为 <code>true</code> 。若返回 <code>false</code> ，则后续流程不会进行。</li><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul><ol><li>组件内部调用 <code>this.setState()</code> 修改状态</li></ol><ul><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul><ol><li>组件内部调用 <code>this.forceUpdate()</code> 强制更新</li></ol><ul><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul><p><strong>卸载阶段</strong>：<code>ReactDOM.unmountComponentAtNode()</code> 触发</p><ul><li><code>componentWillUnmount</code></li></ul><p><img src="/2022/12/30/1608754051799977984/images/react-lifecyle-old.5c4592bd.png" alt="React Lifecycle"></p><h4 id="生命周期-新版"><a href="#生命周期-新版" class="headerlink" title="生命周期-新版"></a>生命周期-新版</h4><p><a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html">更改内容</a>：</p><ul><li>废弃三个钩子：<code>componentWillMount</code> 、<code>componentWillReceiveProps</code> 、 <code>componentWillUpdate</code> 。在新版本中这三个钩子需要加 <code>UNSAFE_</code> 前缀才能使用，后续可能会废弃。</li><li>新增两个钩子（实际场景用得很少）：<code>getDerivedStateFromProps</code> 、<code>getSnapshotBeforeUpdate</code></li></ul><p><img src="/2022/12/30/1608754051799977984/images/react-lifecycle-new.7009279b.png" alt="React LIfecycle New"></p><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops">static getDerivedStateFromProps(props, state)</a>：</p><ul><li>需使用 <code>static</code> 修饰</li><li>需返回一个对象更新 <code>state</code> 或返回 <code>null</code></li><li>适用于如下情况：<code>state</code> 的值任何时候都取决于 <code>props</code></li></ul><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate">getSnapshotBeforeUpdate(prevProps, prevState)</a>：</p><ul><li>在组件更新之前获取快照</li><li>得组件能在发生更改之前从 DOM 中捕获一些信息（如滚动位置）</li><li>返回值将作为参数传递给 <code>componentDidUpdate()</code></li></ul><pre><code class="jsx">static getDerivedStateFromProps(props,state)&#123;  console.log(&#39;getDerivedStateFromProps&#39;,props,state);  return null&#125;getSnapshotBeforeUpdate()&#123;  console.log(&#39;getSnapshotBeforeUpdate&#39;);  return &#39;atguigu&#39;&#125;componentDidUpdate(preProps,preState,snapshotValue)&#123;  console.log(&#39;componentDidUpdate&#39;,preProps,preState,snapshotValue);&#125;</code></pre><pre><code class="jsx">// getSnapshotBeforeUpdate 案例class NewsList extends React.Component &#123;  state = &#123; newsArr: [] &#125;  componentDidMount() &#123;    setInterval(() =&gt; &#123;      //获取原状态      const &#123; newsArr &#125; = this.state      //模拟一条新闻      const news = &#39;新闻&#39; + (newsArr.length + 1)      //更新状态      this.setState(&#123; newsArr: [news, ...newsArr] &#125;)    &#125;, 1000)  &#125;  getSnapshotBeforeUpdate() &#123;    return this.refs.list.scrollHeight  &#125;  componentDidUpdate(preProps, preState, height) &#123;    this.refs.list.scrollTop += this.refs.list.scrollHeight - height  &#125;  render() &#123;    return (      &lt;div className=&quot;list&quot; ref=&quot;list&quot;&gt;        &#123;this.state.newsArr.map((n, index) =&gt; &#123;          return (            &lt;div key=&#123;index&#125; className=&quot;news&quot;&gt;              &#123;n&#125;            &lt;/div&gt;          )        &#125;)&#125;      &lt;/div&gt;    )  &#125;&#125;ReactDOM.render(&lt;NewsList /&gt;, document.getElementById(&#39;test&#39;))</code></pre><h4 id="最重要的三个钩子"><a href="#最重要的三个钩子" class="headerlink" title="最重要的三个钩子"></a>最重要的三个钩子</h4><ul><li><code>render</code> ：初始化渲染和更新渲染</li><li><code>componentDidMount</code> ：进行初始化，如开启定时器、发送网络请求、订阅消息</li><li><code>componentWillUnmount</code> ：进行收尾，如关闭定时器、取消订阅消息</li></ul><h3 id="虚拟DOM和diff算法"><a href="#虚拟DOM和diff算法" class="headerlink" title="虚拟DOM和diff算法"></a>虚拟DOM和diff算法</h3><p><img src="/2022/12/30/1608754051799977984/images/Diff.ae9f4adc.png" alt="Diff"></p><p><strong><code>key</code> 的作用：</strong></p><p><code>key</code> 是虚拟 DOM 对象的标识，可提高页面更新渲染的效率。</p><p>当状态中的数据发生变化时，React 会根据新数据生成新的虚拟 DOM ，接着对新旧虚拟 DOM 进行 Diff 比较，规则如下：</p><ul><li>旧虚拟 DOM 找到和新虚拟 DOM 相同的 key：<ul><li>若内容没变，直接复用真实 DOM</li><li>若内容改变，则生成新的真实 DOM ，替换页面中之前的真实 DOM</li></ul></li><li>旧虚拟 DOM 未找到和新虚拟 DOM 相同的 key：根据数据创建新的真实 DOM ，渲染到页面</li></ul><p><strong>使用 <code>index</code> 作为 <code>key</code> 可能引发的问题：</strong></p><ul><li>若对数据进行逆序添加、逆序删除等破坏顺序的操作，会进行没有必要的真实 DOM 更新。界面效果没问题，但效率低下。</li><li>如果结构中包含输入类的 DOM（如 input 输入框） ，则会产生错误的 DOM 更新。</li><li>若不存在对数据逆序添加、逆序删除等破坏顺序的操作，则没有问题。</li></ul><pre><code class="jsx">// 使用 index 作为 key 引发的问题class Person extends React.Component &#123;  state = &#123;    persons: [      &#123; id: 1, name: &#39;小张&#39;, age: 18 &#125;,      &#123; id: 2, name: &#39;小李&#39;, age: 19 &#125;,    ],  &#125;  add = () =&gt; &#123;    const &#123; persons &#125; = this.state    const p = &#123; id: persons.length + 1, name: &#39;小王&#39;, age: 20 &#125;    this.setState(&#123; persons: [p, ...persons] &#125;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h2&gt;展示人员信息&lt;/h2&gt;        &lt;button onClick=&#123;this.add&#125;&gt;添加小王&lt;/button&gt;        &lt;h3&gt;使用index作为key&lt;/h3&gt;        &lt;ul&gt;          &#123;this.state.persons.map((personObj, index) =&gt; &#123;            return (              &lt;li key=&#123;index&#125;&gt;                &#123;personObj.name&#125;---&#123;personObj.age&#125;                &lt;input type=&quot;text&quot; /&gt;              &lt;/li&gt;            )          &#125;)&#125;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h2 id="react脚手架"><a href="#react脚手架" class="headerlink" title="react脚手架"></a>react脚手架</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ul><li>全局安装 React 脚手架：<code>npm i -g create-react-app</code></li><li>创建项目：<code>create-react-app 项目名称</code></li><li>进入文件夹：<code>cd 项目名称</code></li><li>启动项目：<code>npm start</code></li></ul><p>上述方式已经过时，改用下方命令。详见<a href="https://create-react-app.dev/docs/getting-started">官方说明</a>。</p><pre><code class="shell">npx create-react-app my-appcd my-appnpm start</code></pre><h3 id="项目结构说明"><a href="#项目结构说明" class="headerlink" title="项目结构说明"></a>项目结构说明</h3><p><code>public</code> ：静态资源文件</p><ul><li><code>manifest.json</code> ：应用加壳（把网页变成安卓&#x2F;IOS 软件）的配置文件</li><li><code>robots.txt</code> ：爬虫协议文件</li></ul><p><code>src</code> ：源码文件</p><ul><li><code>App.test.js</code> ：用于给 <code>App</code> 组件做测试，一般不用</li><li><strong style="color:red">index.js</strong> ：入口文件</li><li><code>reportWebVitals.js</code> ：页面性能分析文件，需要 <code>web-vitals</code> 库支持</li><li><code>setupTests.js</code> ：组件单元测试文件，需要 <code>jest-dom</code> 库支持</li></ul><p><img src="/2022/12/30/1608754051799977984/images/React-cli.5baa9e94.png" alt="React-cli structure"></p><p><code>index.html</code> 代码分析：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;!-- %PUBLIC_URL% 代表 public 文件夹的路径 --&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;!-- 开启理想视口，用于做移动端网页的适配 --&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;    &lt;!-- 用于配置浏览器页签+地址栏的颜色(仅支持安卓手机浏览器) --&gt;    &lt;meta name=&quot;theme-color&quot; content=&quot;red&quot; /&gt;    &lt;!-- 网站描述 --&gt;    &lt;meta name=&quot;description&quot; content=&quot;Web site created using create-react-app&quot; /&gt;    &lt;!-- 用于指定网页添加到手机主屏幕后的图标 --&gt;    &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;    &lt;!-- 应用加壳时的配置文件 --&gt;    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;    &lt;title&gt;React App&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 若浏览器不支持 js 则展示标签中的内容 --&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>删除项目中不必要的文件，并且使用jsx文件来定义组件</p><p><img src="/2022/12/30/1608754051799977984/images/image-20220911172638523.png" alt="image-20220911172638523"></p><h3 id="TodoList-案例总结"><a href="#TodoList-案例总结" class="headerlink" title="TodoList 案例总结"></a>TodoList 案例总结</h3><ol><li>拆分组件、实现静态组件，注意：<code>className</code> 、<code>style</code> 的写法</li><li>动态初始化列表，如何确定将数据放在哪个组件的 <code>state</code> 中？</li></ol><ul><li>某个组件使用：放在其自身的 <code>state</code> 中</li><li>某些组件使用：放在他们共同的父组件 <code>state</code> 中，即<strong>状态提升</strong></li></ul><ol><li>关于父子之间通信：</li></ol><ul><li>父传子：直接通过 <code>props</code> 传递</li><li>子传父：父组件通过 <code>props</code> 给子组件传递一个函数，子组件调用该函数</li></ul><pre><code class="jsx">// 父组件class Father extends Component &#123;  state: &#123;    todos: [&#123; id: &#39;001&#39;, name: &#39;吃饭&#39;, done: true &#125;],    flag: true,  &#125;  addTodo = (todo) =&gt; &#123;    const &#123; todos &#125; = this.state    const newTodos = [todo, ...todos]    this.setState(&#123; todos: newTodos &#125;)  &#125;  render() &#123;    return &lt;List todos=&#123;this.state.todos&#125; addTodo=&#123;this.addTodo&#125; /&gt;  &#125;&#125;// 子组件class Son extends Component &#123;  // 由于 addTodo 是箭头函数，this 指向父组件实例对象，因此子组件调用它相当于父组件实例在调用  handleClick = () =&gt; &#123;    this.props.addTodo(&#123; id: &#39;002&#39;, name: &#39;敲代码&#39;, done: false &#125;)  &#125;  render() &#123;    return &lt;button onClick=&#123;this.handleClick&#125;&gt;添加&lt;/button&gt;  &#125;&#125;</code></pre><ol><li>注意 <code>defaultChecked</code> 和 <code>checked</code> 的区别，类似的还有：<code>defaultValue</code> 和 <code>value</code></li><li>状态在哪里，操作状态的方法就在哪里</li></ol><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>方法一：</p><p>在 <code>package.json</code> 文件中进行配置：</p><pre><code class="json">&quot;proxy&quot;: &quot;http://localhost:5000&quot;</code></pre><ul><li>优点：配置简单，前端请求资源可不加前缀</li><li>缺点：不能配置多个代理</li><li>工作方式：当请求了 3000 端口号（本机）不存在的资源时，就会把请求转发给 5000 端口号服务器</li></ul><p>方法二：</p><p>在 <code>src</code> 目录下创建代理配置文件 <code>setupProxy.js</code> ，进行配置：</p><pre><code class="jsx">const proxy = require(&#39;http-proxy-middleware&#39;)module.exports = function (app) &#123;  app.use(    //api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)    proxy(&#39;/api1&#39;, &#123;      //配置转发目标地址(能返回数据的服务器地址)      target: &#39;http://localhost:5000&#39;,      //控制服务器接收到的请求头中host字段的值      /*      changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000      changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000      changeOrigin默认值为false，但一般将changeOrigin改为true      */      changeOrigin: true,      //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)      pathRewrite: &#123; &#39;^/api1&#39;: &#39;&#39; &#125;,    &#125;),    proxy(&#39;/api2&#39;, &#123;      target: &#39;http://localhost:5001&#39;,      changeOrigin: true,      pathRewrite: &#123; &#39;^/api2&#39;: &#39;&#39; &#125;,    &#125;)  )&#125;</code></pre><h2 id="消息订阅发布机制"><a href="#消息订阅发布机制" class="headerlink" title="消息订阅发布机制"></a>消息订阅发布机制</h2><p>即 React 中兄弟组件或任意组件之间的通信方式。（类似vue的bus）</p><ul><li>先订阅，再发布（隔空对话）</li><li>适用于任意组件间通信</li><li>要在 <code>componentWillUnmount</code> 钩子中取消订阅</li></ul><p>使用的工具库：<a href="https://www.npmjs.com/package/pubsub-js">PubSubJS</a> </p><pre><code>npm i pubsub-js --save</code></pre><p>基础用法：</p><pre><code class="jsx">import PubSub from &#39;pubsub-js&#39;// 发布消息PubSub.publish(&#39;topic&#39;, &#39;hello react&#39;)// 订阅消息 token是一个标识，类似setTimeout会有个返回值作为标识let token = PubSub.subscribe(&#39;topic&#39;, (msg, data) =&gt; &#123;  console.log(msg, data)&#125;)// 取消订阅PubSub.unsubscribe(token)</code></pre><h2 id="解构赋值再认识"><a href="#解构赋值再认识" class="headerlink" title="解构赋值再认识"></a>解构赋值再认识</h2><p>熟悉一下连续解构赋值、连续解构赋值+重命名</p><pre><code class="js">let obj = &#123; a: &#123; b: 1 &#125; &#125;//传统解构赋值const &#123; a &#125; = obj//连续解构赋值const &#123;  a: &#123; b &#125;,&#125; = obj//连续解构赋值 + 重命名const &#123;  a: &#123; b: value &#125;,&#125; = obj</code></pre><h2 id="nanoid生成唯一标识"><a href="#nanoid生成唯一标识" class="headerlink" title="nanoid生成唯一标识"></a>nanoid生成唯一标识</h2><p><a href="https://gitee.com/mirrors/nanoid">https://gitee.com/mirrors/nanoid</a></p><p>生成唯一标识的一个库</p><pre><code class="shell">npm install --save nanoid</code></pre><p>使用</p><pre><code class="js">import &#123;nanoid&#125; from &#39;nanoid&#39;console.log(nanoid())</code></pre><h2 id="react-router5"><a href="#react-router5" class="headerlink" title="react-router5"></a>react-router5</h2><h3 id="路由的理解"><a href="#路由的理解" class="headerlink" title="路由的理解"></a>路由的理解</h3><p>何为路由？</p><ul><li>一个路由是一个映射关系</li><li><code>key</code> 为路径，<code>value</code> 可能是 <code>function</code> 或 <strong style="color:red">组件</strong></li></ul><p>后端路由：</p><ul><li><code>value</code> 是 <code>function</code> ，用于处理客户端的请求</li><li>注册路由：<code>router.get(path, function(req, res))</code></li><li>工作过程：Node 接收到请求，根据路径匹配路由，调用对应函数处理请求，返回响应数据</li></ul><p>前端路由：</p><ul><li><code>value</code> 是组件</li><li>注册路由：<code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code></li><li>工作过程：浏览器路径变为 <code>/test</code> ，展示 <code>Test</code> 组件</li></ul><h3 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h3><p>安装 <code>react-router-dom</code> </p><pre><code class="shell">// 安装 5.X 版本路由npm install react-router-dom@5.2.0 -S</code></pre><p>最新默认是安装的6.x版本，这里以 <code>5.x</code> 版本为例展示基本使用,后面再写6.x版本的使用</p><p>导航区使用 <code>&lt;Link&gt;</code>，展示区使用 <code>&lt;Route&gt;</code>。</p><h4 id="Link组件"><a href="#Link组件" class="headerlink" title="Link组件"></a>Link组件</h4><blockquote><p>定义链接，用来替换a标签</p></blockquote><ul><li><p>to属性：定义点击之后切换的路径</p></li><li><p>className属性： 定义类名</p></li><li><p>标签体：定义显示的名称</p></li></ul><p>【例如】</p><pre><code class="html">&lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;about&lt;/Link&gt;</code></pre><h4 id="Route组件"><a href="#Route组件" class="headerlink" title="Route组件"></a>Route组件</h4><blockquote><p>路由组件匹配成功之后的展示区</p></blockquote><ul><li>path属性：匹配的路径</li><li>component属性：匹配成功后展示的组件</li></ul><p>【例如】</p><pre><code class="html">&lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;</code></pre><h4 id="路由入门案例"><a href="#路由入门案例" class="headerlink" title="路由入门案例"></a>路由入门案例</h4><ul><li>复制boostrap.css到public&#x2F;css下,并且在index.html中引入</li></ul><p><img src="/2022/12/30/1608754051799977984/images/image-20220911224233636.png" alt="image-20220911224233636"></p><ul><li><code>&lt;App&gt;</code> 的最外侧包裹 <code>&lt;BrowserRouter&gt;</code> 或 <code>&lt;HashRouter&gt;</code> ：</li></ul><pre><code class="jsx">// index.jsimport React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;import App from &#39;./App&#39;ReactDOM.render(  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;,  document.getElementById(&#39;root&#39;))</code></pre><ul><li>App.jsx</li></ul><pre><code class="jsx">// App.jsximport React, &#123; Component &#125; from &#39;react&#39;import &#123; Link, Route &#125; from &#39;react-router-dom&#39;import Home from &#39;./components/Home&#39;import About from &#39;./components/About&#39;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;div className=&quot;list-group&quot;&gt;          &lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;            About          &lt;/Link&gt;          &lt;Link className=&quot;list-group-item&quot; to=&quot;/home&quot;&gt;            Home          &lt;/Link&gt;        &lt;/div&gt;        &lt;div className=&quot;panel-body&quot;&gt;          &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;          &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;        &lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="路由组件和一般组件"><a href="#路由组件和一般组件" class="headerlink" title="路由组件和一般组件"></a>路由组件和一般组件</h3><p>存放位置不同</p><ul><li>一般组件：<code>components</code></li><li>路由组件：<code>pages</code></li></ul><p><strong style="color:red">写法不同</strong></p><ul><li>一般组件：<code>&lt;Demo/&gt;</code></li><li>路由组件：<code>&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt;</code></li></ul><p><strong style="color:red">接收到的 props不同</strong></p><ul><li>一般组件：标签属性传递</li><li>路由组件：接收到三个固定的属性(history、location、match)</li></ul><pre><code class="js">history:  go: ƒ go(n)  goBack: ƒ goBack()  goForward: ƒ goForward()  push: ƒ push(path, state)  replace: ƒ replace(path, state)location:  pathname: &quot;/home/message/detail/2/hello&quot;  search: &quot;&quot;  state: undefinedmatch:  params: &#123;&#125;  path: &quot;/home/message/detail/:id/:title&quot;  url: &quot;/home/message/detail/2/hello&quot;</code></pre><h3 id="NavLink组件"><a href="#NavLink组件" class="headerlink" title="NavLink组件"></a>NavLink组件</h3><p><code>NavLink</code> 可以实现路由链接的高亮，通过 <code>activeClassName</code> 指定样式名，默认追加类名为 <code>active</code> 。</p><pre><code class="html">&lt;NavLink activeClassName=&quot;navLinkActive&quot; to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;&lt;NavLink activeClassName=&quot;navLinkActive&quot; to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;</code></pre><p>封装 <code>NavLink</code> 组件：由于 <code>NavLink</code> 组件中重复的代码太多，因此进行二次封装。</p><p><strong style="color:red">※ 细节点</strong>：组件标签的内容会传递到 <code>this.props.children</code> 属性中，反过来通过指定标签的 <code>children</code> 属性可以修改组件标签内容</p><pre><code class="jsx">// MyNavLink 组件import React, &#123; Component &#125; from &#39;react&#39;import &#123; NavLink &#125; from &#39;react-router-dom&#39;export default class MyNavLink extends Component &#123;  render() &#123;    // this.props.children 可以取到标签内容，如 About, Home    // 反过来通过指定标签的 children 属性可以修改标签内容   return &lt;NavLink activeClassName=&quot;active&quot; className=&quot;list-group-item&quot; &#123;...this.props&#125;/&gt;  &#125;&#125;</code></pre><pre><code class="html">&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;</code></pre><h3 id="Switch-的使用"><a href="#Switch-的使用" class="headerlink" title="Switch 的使用"></a>Switch 的使用</h3><p><code>Switch</code> 可以提高路由匹配效率，如果匹配成功，则不再继续匹配后面的路由，即单一匹配。</p><pre><code class="html">&lt;!-- 只会展示 Home 组件 --&gt;&lt;Switch&gt;  &lt;Route path=&quot;/about&quot; component=&quot;&#123;About&#125;&quot; /&gt;  &lt;Route path=&quot;/home&quot; component=&quot;&#123;Home&#125;&quot; /&gt;  &lt;Route path=&quot;/home&quot; component=&quot;&#123;Test&#125;&quot; /&gt;&lt;/Switch&gt;</code></pre><h3 id="多级路径刷新样式丢失"><a href="#多级路径刷新样式丢失" class="headerlink" title="多级路径刷新样式丢失"></a>多级路径刷新样式丢失</h3><ul><li><code>public/index.html</code> 中 引入样式时不写 <code>./</code> 写 <code>/</code> （常用）</li><li><code>public/index.html</code> 中 引入样式时不写 <code>./</code> 写 <code>%PUBLIC_URL%</code> （常用）</li><li>使用 <code>HashRouter</code></li></ul><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;%PUBLIC_URL%/css/bootstrap.css&quot; /&gt;</code></pre><h3 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a>路由的严格匹配与模糊匹配</h3><ul><li>默认使用模糊匹配（<code>Route</code>组件的<code>path</code>必须包含<code>Link</code>组件要匹配的路径，且顺序一致）</li><li>开启严格匹配：<code>&lt;Route exact path=&quot;/about&quot; component=&#123;About&#125;/&gt;</code></li><li>严格匹配需要再开，开启可能会导致无法继续匹配二级路由</li></ul><h3 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect (重定向)"></a>Redirect (重定向)</h3><p>一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到 Redirect 指定的路由</p><pre><code class="html">&lt;Switch&gt;  &lt;Route path=&quot;/about&quot; component=&quot;&#123;About&#125;&quot; /&gt;  &lt;Route path=&quot;/home&quot; component=&quot;&#123;Home&#125;&quot; /&gt;  &lt;Redirect to=&quot;/about&quot; /&gt;&lt;/Switch&gt;</code></pre><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul><li>注册子路由需写上父路由的 <code>path</code></li><li>路由的匹配是<strong style="color:red">按照注册路由的顺序进行</strong>的</li></ul><p>父组件</p><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;&lt;Switch&gt;  &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;  &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;  &lt;Redirect to=&quot;/about&quot; /&gt;&lt;/Switch&gt;</code></pre><p>子组件</p><pre><code class="html">&lt;ul className=&quot;nav nav-tabs&quot;&gt;  &lt;li&gt;    &lt;MyNavLink to=&quot;/home/news&quot;&gt;News&lt;/MyNavLink&gt;  &lt;/li&gt;  &lt;li&gt;    &lt;MyNavLink to=&quot;/home/message&quot;&gt;Message&lt;/MyNavLink&gt;  &lt;/li&gt;&lt;/ul&gt;&lt;Switch&gt;  &lt;Route path=&quot;/home/news&quot; component=&#123;News&#125; /&gt;  &lt;Route path=&quot;/home/message&quot; component=&#123;Message&#125; /&gt;  &lt;Redirect to=&quot;/home/news&quot; /&gt;&lt;/Switch&gt;</code></pre><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><p>三种方式：<code>params, search, state</code> 参数</p><p>三种方式对比：</p><ul><li><code>state</code> 方式当前页面刷新可保留参数，但在新页面打开不能保留。前两种方式由于参数保存在 URL 地址上，因此都能保留参数。</li><li><code>params</code> 和 <code>search</code> 参数都会变成字符串</li></ul><pre><code class="html">&lt;!--1.params方式传参 --&gt;&lt;Link to=&#39;/home/message/detail/tom/21&#39;&gt;params&lt;/Link&gt;&lt;Link to=&#123;`/home/message/detail/$&#123;item.name&#125;/$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;&lt;!--2.search方式传参 --&gt;&lt;Link to=&#39;/home/message/detail/?name=tom&amp;age=21&#39;&gt;search&lt;/Link&gt;&lt;Link to=&#123;`/home/message/detail/?id=$&#123;item.name&#125;&amp;title=$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;&lt;!--3.state方式传参 --&gt;&lt;Link to=&#123;&#123;pathname:'/home/message/detail',state: &#123;name: 'tom', age: 21&#125;&#125;&#125;&gt;state&lt;/Link&gt;&lt;!-- params 注册路由 --&gt;&lt;Route path=&#39;/home/message/detail/:name/:age&#39; component=&#123;Detail&#125; /&gt;&lt;!-- search 和 state 按正常注册即可 --&gt;&lt;Route path=&#39;/home/message/detail&#39; component=&#123;Detail&#125; /&gt;</code></pre><p>接收参数</p><pre><code class="js">//1.params方式接受参数const &#123; name, age &#125; = this.props.match.params//2.search方式接受参数import qs from &#39;querystring&#39;const &#123; search &#125; = this.props.locationconst &#123; name, age &#125; = qs.parse(search.slice(1))//3.state方式接受参数const &#123; name, age &#125; = this.props.location.state</code></pre><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>编程式导航是使用路由组件 <code>this.props.history</code> 提供的 API 进行路由跳转：</p><pre><code class="js">this.props.history.push(path, state)this.props.history.replace(path, state)this.props.history.goForward()this.props.history.goBack()this.props.history.go(n)</code></pre><p>三种传参方式的编程式导航</p><pre><code class="js">// 编程式导航传参this.props.history.push(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)this.props.history.push(`/home/message/detail?id=$&#123;id&#125;&amp;title=$&#123;title&#125;`)this.props.history.push(`/home/message/detail`, &#123; id: id, title: title &#125;)</code></pre><h3 id="withRouter-的使用"><a href="#withRouter-的使用" class="headerlink" title="withRouter 的使用"></a>withRouter 的使用</h3><p><code>withRouter</code> 的作用：加工一般组件，让其拥有路由组件的 API ，如 <code>this.props.history.push</code> 等。</p><pre><code class="jsx">import React, &#123;Component&#125; from &#39;react&#39;import &#123;withRouter&#125; from &#39;react-router-dom&#39;class Header extends Component &#123;  ...&#125;export default withRouter(Header) //导出前用withRouter加工一下</code></pre><h3 id="BrowserRouter-和-HashRouter"><a href="#BrowserRouter-和-HashRouter" class="headerlink" title="BrowserRouter 和 HashRouter"></a>BrowserRouter 和 HashRouter</h3><p>底层原理不一样：</p><ul><li><code>BrowserRouter</code> 使用的是 H5 的 history API，不兼容 IE9 及以下版本。</li><li><code>HashRouter</code> 使用的是 URL 的哈希值。</li></ul><p>路径表现形式不一样</p><ul><li><code>BrowserRouter</code> 的路径中没有 <code>#</code> ，如：<code>localhost:3000/demo/test</code></li><li><code>HashRouter</code> 的路径包含#，如：<code>localhost:3000/#/demo/test</code></li></ul><p>刷新后对路由 <code>state</code> 参数的影响</p><ul><li><code>BrowserRouter</code> 没有影响，因为 <code>state</code> 保存在 <code>history</code> 对象中。</li><li><code>HashRouter</code> 刷新后会导致路由 <code>state</code> 参数的丢失！</li></ul><p>备注：<code>HashRouter</code> 可以用于解决一些路径错误相关的<a href="https://brucecai55520.gitee.io/bruceblog/notes/react/react-router5.html#%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%A7%E8%B7%AF%E5%BE%84%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98">问题</a>。</p><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><p><a href="https://redux.js.org/">官网</a></p><p><a href="https://www.redux.org.cn/">中文文档</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Redux 为何物，类似vue中的vuex</p><ul><li>Redux 是用于做 <strong>状态管理</strong> 的 JS 库</li><li>可用于 React、Angular、Vue 等项目中，常用于 React</li><li>集中式管理 React 应用多个组件共享的状态</li></ul><p>何时用 Redux</p><ul><li>某个组件的状态，需要让其他组件拿到（状态共享）</li><li>一个组件需要改变另一个组件的状态（通信）</li><li>使用原则：不到万不得已不要轻易动用</li></ul><p>Redux 工作流程</p><p><img src="/2022/12/30/1608754051799977984/images/redux.4afb4200.png" alt="redux 工作流程图"></p><ul><li>组件想操作 Redux 中的状态：把动作类型和数据告诉 <code>Action Creators</code></li><li><code>Action Creators</code> 创建 <code>action</code> ：同步 <code>action</code> 是一个普通对象，异步 <code>action</code> 是一个函数</li><li><code>Store</code> 调用 <code>dispatch()</code> 分发 <code>action</code> 给 <code>Reducers</code> 执行</li><li><code>Reducers</code> 接收 <code>previousState</code> 、<code>action</code> 两个参数，对状态进行加工后返回新状态</li><li><code>Store</code> 调用 <code>getState()</code> 把状态传给组件</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><ul><li><p>表示动作的对象，包含 2 个属性</p></li><li><p><code>type</code> ：标识属性，值为字符串，唯一，必须属性</p></li><li><p><code>data</code> ：数据属性，类型任意，可选属性。</p></li></ul><p>例如：<code>&#123;type: &#39;increment&#39;, data: 2&#125;</code></p><h4 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h4><ul><li>用于初始化状态、加工状态</li><li>根据旧状态和 <code>action</code> 产生新状态</li><li>是<strong>纯函数</strong></li></ul><blockquote><p>纯函数：输入同样的实参，必定得到同样的输出</p><ul><li>不能改写参数数据</li><li>不产生副作用，如网络请求、输入输出设备（网络请求不稳定）</li><li>不能调用 <code>Date.now()</code> 、<code>Math.random()</code> 等不纯方法</li></ul></blockquote><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><ul><li>Redux 核心对象，内部维护着 <code>state</code> 和 <code>reducer</code></li><li>核心 API<ul><li><code>store.getState()</code> ：获取状态</li><li><code>store.dispatch(action)</code> ：分发任务，触发 <code>reducer</code> 调用，产生新状态</li><li><code>store.subscribe(func)</code> ：注册监听函数，当状态改变自动调用</li></ul></li></ul><h3 id="求和案例"><a href="#求和案例" class="headerlink" title="求和案例"></a>求和案例</h3><ul><li>安装redux</li></ul><pre><code class="shell">npm i redux@4.0.5</code></pre><ul><li>App.jsx</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import Count from &#39;./components/Count&#39;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;Count /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><ul><li>index.js</li></ul><pre><code class="js">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import App from &#39;./App&#39;import store from &#39;./redux/store&#39;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))// 状态改变重新渲染 App 组件store.subscribe(() =&gt; &#123;  ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))&#125;)//react18的写法如下const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))root.render(&lt;App /&gt;)store.subscribe(()=&gt;&#123;    root.render(&lt;App /&gt;)&#125;)</code></pre><ul><li>redux&#x2F;constant.js 定义常量</li></ul><pre><code class="js">// 保存常量值export const INCREMENT = &#39;increment&#39;export const DECREMENT = &#39;decrement&#39;</code></pre><ul><li>redux&#x2F;count_reducer.js</li></ul><pre><code class="js">import &#123; INCREMENT, DECREMENT &#125; from &#39;./constant&#39;//初始化状态const initState = 0export default function countReducer(preState = initState, action) &#123;  const &#123; type, data &#125; = action  switch (type) &#123;    case INCREMENT:      return preState + data    case DECREMENT:      return preState - data    default:      return preState  &#125;&#125;</code></pre><ul><li>redux&#x2F;store.js</li></ul><pre><code class="js">import &#123; createStore &#125; from &#39;redux&#39;//引入为 Count 组件服务的 reducerimport countReducer from &#39;./count_reducer&#39;export default createStore(countReducer)</code></pre><ul><li>count_action.js</li></ul><pre><code class="js">import &#123;INCREMENT,DECREMENT&#125; from &#39;./constant&#39;export const createIncrementAction = data =&gt; (&#123;type: INCREMENT,data&#125;)export const createdecrementAction = data =&gt; (&#123;type: DECREMENT,data&#125;)</code></pre><ul><li>components&#x2F;Count&#x2F;index.jsx</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import store from &#39;../../redux/store&#39;import &#123; createIncrementAction, createDecrementAction &#125; from &#39;../../redux/count_action&#39;export default class Count extends Component &#123;  // 可在组件单独监听 Redux 状态变化  // componentDidMount() &#123;  //     store.subscribe(() =&gt; &#123;  //         this.setState(&#123;&#125;)  //     &#125;)  // &#125;  increment = () =&gt; &#123;    const &#123; value &#125; = this.selectNumber    // 将 value 转为数值    // 手动写 Action 对象    store.dispatch(&#123; type: &#39;increment&#39;, data: value * 1 &#125;)    // 专门创建 Action 对象    store.dispatch(createIncrementAction(value * 1))  &#125;  decrement = () =&gt; &#123;    const &#123; value &#125; = this.selectNumber    store.dispatch(createDecrementAction(value * 1))  &#125;  incrementAsync = () =&gt; &#123;    const &#123; value &#125; = this.selectNumber    setTimeout(() =&gt; &#123;      store.dispatch(createIncrementAction(value * 1))    &#125;, 500)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;当前求和为：&#123;store.getState()&#125;&lt;/h1&gt;        &lt;select ref=&#123;(c) =&gt; (this.selectNumber = c)&#125;&gt;          &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;          &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;          &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;        &lt;/select&gt;        &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;        &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;        &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p><strong style="color:red">编写步骤总结：</strong></p><p>1.创建constant.js定义常量</p><p>2.创建count_reducer.js</p><p>3.根据count_reducer创建store</p><p>4.创建action</p><p>5.在组件中使用 store.dispatch(action)更新数据 ，store.getState()获取数据</p><p><strong style="color:red">注意：</strong></p><ul><li>redux 只负责管理状态，状态改变驱动页面展示要自己写</li><li>可以在 <code>index.js</code> 中统一监听状态变化，也可以在组件中单独监听。注意不能直接 <code>this.render()</code> 调用 <code>render</code> 函数，要通过 <code>this.setState(&#123;&#125;)</code> 间接调用</li><li><code>reducer</code> 由 <code>store</code> 自动触发首次调用，传递的 <code>preState</code> 为 <code>undefined</code> ，<code>action</code> 为 <code>&#123;type: &#39;@@REDUX/ININT_a.5.v.9&#39;&#125;</code> 类似的数据格式，只有 <code>type</code></li></ul><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><blockquote><p>1.延迟的动作不想交给组件，而是 <code>action</code><br>2.当操作状态所需数据要靠异步任务返回时，可用异步 <code>action</code><br>3.创建 <code>action</code> 的函数<strong style="color:red">返回一个函数</strong>，该函数中写异步任务<br>4.异步任务完成后，分发一个同步 <code>action</code> 操作状态<br>5.异步 <code>action</code> 不是必要的，完全可以在组件中等待异步任务结果返回在分发同步 <code>action</code></p></blockquote><p>安装中间件</p><pre><code class="shell">npm i redux-thunk@2.3.0</code></pre><p>对上面的求和案例进行修改</p><ul><li>store.js</li></ul><pre><code class="js">import &#123; createStore, applyMiddleware &#125; from &#39;redux&#39;import countReducer from &#39;./count_reducer&#39;import thunk from &#39;redux-thunk&#39; //引入中间件//创建store的时候，使用中间件export default createStore(countReducer, applyMiddleware(thunk))</code></pre><ul><li>count_action.js</li></ul><pre><code class="js">import &#123; INCREMENT, DECREMENT &#125; from &#39;./constant.js&#39;export const createIncrementAction = (data) =&gt; (&#123; type: INCREMENT, data &#125;)export const createDecrementAction = (data) =&gt; (&#123; type: DECREMENT, data &#125;)// 异步 action 返回一个函数export const createIncrementAsyncAction = (data, time) =&gt; &#123;  return (dispatch) =&gt; &#123;    setTimeout(() =&gt; &#123;      dispatch(createIncrementAction(data))    &#125;, time)  &#125;&#125;</code></pre><ul><li>Count.jsx</li></ul><pre><code class="js">incrementAsync = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  store.dispatch(createIncrementAsyncAction(value * 1))&#125;</code></pre><p>整个过程简单理解：<code>store</code> 在分发 <code>action</code> 时，发现返回一个函数，那它知道这是个异步 <code>action</code> 。因此 <code>store</code> 帮忙执行这个函数(ps：使用<strong style="color:red">redux-thunk</strong>才会执行，否则报错)，同时给这个函数传递 <code>dispatch</code> 方法，等待异步任务完成取到数据后，直接调用 <code>dispatch</code> 方法分发同步 <code>action</code> 。</p><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>React-Redux 是一个插件库，用于简化 React 中使用 Redux 。</p><p><img src="/2022/12/30/1608754051799977984/images/image-20221228140202071.png" alt="image-20221228140202071"></p><p>React-Redux 将组件分为两类：</p><ul><li>UI 组件<ul><li>只负责 UI 呈现，不带有业务逻辑</li><li>通过 <code>props</code> 接收数据</li><li>不能使用 Redux 的 API</li><li>保存在 <code>components</code> 文件夹下</li></ul></li><li>容器组件<ul><li>负责管理数据和业务逻辑，和 Redux 通信，将结果交给 UI 组件</li><li>可使用 Redux 的 API</li><li>保存在 <code>containers</code> 文件夹下</li></ul></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>要点：</p><ul><li>装包：<code>npm i react-redux</code></li></ul><ul><li><code>connect()()</code> ：创建容器组件</li><li><code>mapStateToProps(state)</code> ：映射状态为 UI 组件标签属性，即传递状态</li><li><code>mapDispatchToProps(dispatch)</code> ：传递操作状态的方法</li><li>容器组件中的 <code>store</code> 是靠 <code>props</code> 传进去，而不是在容器组件中直接引入</li></ul><p>【react-redux使用案例】</p><blockquote><p>Count 容器组件</p></blockquote><pre><code class="jsx">// containers/Count/index.jsx// Count 容器组件import CountUI from &#39;../../components/Count&#39;import &#123; connect &#125; from &#39;react-redux&#39;import &#123; createIncrementAction, createDecrementAction, createIncrementAsyncAction &#125; from &#39;../../redux/count_action&#39;function mapStateToProps(state) &#123;  return &#123;    count: state,  &#125;&#125;function mapDispatchToProps(dispatch) &#123;  return &#123;    add: (number) =&gt; dispatch(createIncrementAction(number)),    sub: (number) =&gt; dispatch(createDecrementAction(number)),    addAsync: (number) =&gt; dispatch(createIncrementAsyncAction(number, time)),  &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(CountUI)</code></pre><blockquote><p>App.jsx</p></blockquote><pre><code class="jsx">// App.jsximport React, &#123; Component &#125; from &#39;react&#39;import Count from &#39;./containers/Count&#39;import store from &#39;./redux/store.js&#39;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;Count store=&#123;store&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><blockquote><p>Count UI 组件</p></blockquote><pre><code class="jsx">// components/Count/index.jsx// Count UI 组件increment = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  this.props.add(value * 1)&#125;decrement = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  this.props.sub(value * 1)&#125;incrementAsync = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  this.props.addAsync(value * 1, 500)&#125;</code></pre><h3 id="优化写法"><a href="#优化写法" class="headerlink" title="优化写法"></a>优化写法</h3><p><code>mapDispatchToProps</code> 可以写成对象形式，React-Redux 底层会帮助自动分发。</p><pre><code class="jsx">// 函数写法export default connect(  state =&gt; (&#123;count:state&#125;),  dispatch =&gt; (&#123;    add: number =&gt; dispatch(createIncrementAction(number)),    sub: number =&gt; dispatch(createDecrementAction(number)),    addAsync: (number,time) =&gt; dispatch(createIncrementAsyncAction(number,time)),  &#125;))(CountUI)// 对象写法export default connect(  state =&gt; (&#123; count: state &#125;),  &#123;    add: createIncrementAction,    sub: createDecrementAction,    addAsync: createIncrementAsyncAction,  &#125;)(CountUI)</code></pre><p>React-Redux 容器组件可以自动监测 Redux 状态变化，因此 <code>index.js</code> 不需要手动监听：</p><pre><code class="jsx">//不用写下面这些代码了store.subscribe(() =&gt; &#123;  ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))&#125;)</code></pre><p><code>Provider</code> 组件的使用：让所有组件都能获得状态数据，不必一个一个传递</p><pre><code class="jsx">// index.jsimport React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import App from &#39;./App&#39;import &#123; Provider &#125; from &#39;react-redux&#39;import store from &#39;./redux/store&#39;ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&#39;root&#39;))</code></pre><p>整合容器组件和 UI 组件为一个文件：</p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import &#123;createIncrementAction,createDecrementAction&#125; from &#39;../../redux/count_action&#39;import &#123;connect&#125; from &#39;react-redux&#39;// 定义 UI 组件class Count extends Component &#123;  ...&#125;// 创建容器组件export default connect(  state =&gt; (&#123;count: state&#125;),  &#123;    add: createIncrementAction,    sub: createDecrementAction  &#125;)(Count)</code></pre><h3 id="多组件数据共享"><a href="#多组件数据共享" class="headerlink" title="多组件数据共享"></a>多组件数据共享</h3><p>首先规范化文件结构，容器组件和 UI 组件合为一体后放在 <code>containers</code> 文件夹。<code>redux</code> 文件夹新建 <code>actions</code> 和 <code>reducers</code> 文件夹分别用于存放每个组件对应的 <code>action</code> 和 <code>reducer</code> 。</p><p>新建 <code>Person</code> 组件对应的 <code>action</code> 和 <code>reducer</code> ：</p><pre><code class="jsx">// redux/actions/person.jsimport &#123; ADD_PERSON &#125; from &#39;../constant.js&#39;export const createAddPersonAction = (personObj) =&gt; (&#123; type: ADD_PERSON, data: personObj &#125;)</code></pre><pre><code class="js">// redux/reducers/person.jsimport &#123; ADD_PERSON &#125; from &#39;../constant.js&#39;const initState = [&#123; id: &#39;lsfd&#39;, name: &#39;china&#39;, age: &#39;9999&#39; &#125;]export default function personReducer(preState = initState, action) &#123;  const &#123; type, data &#125; = action  switch (type) &#123;    case ADD_PERSON:      return [data, ...preState]    default:      return preState  &#125;&#125;</code></pre><p>关键步骤：在 <code>store.js</code> 中使用 <code>combineReducers()</code> 整合多个 <code>reducer</code> 来创建 <code>store</code> 对象。</p><p>这样 Redux 中就以对象的形式存储着每个组件的数据。类似于这样：</p><pre><code class="json">&#123;  total: 0,  personList: []&#125;</code></pre><pre><code class="js">// redux/store.jsimport &#123; createStore, applyMiddleware, combineReducers &#125; from &#39;redux&#39;import countReducer from &#39;./reducers/count&#39;import personReducer from &#39;./reducers/person&#39;import thunk from &#39;redux-thunk&#39;const Reducers = combineReducers(&#123; //关键代码！！！  total: countReducer,  personList: personReducer,&#125;)export default createStore(Reducers, applyMiddleware(thunk))</code></pre><p><code>Person</code> 组件中获取 Redux 保存的状态，包括其他组件的数据。</p><pre><code class="js">import React, &#123; Component &#125; from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;import &#123; createAddPersonAction &#125; from &#39;../../redux/actions/person&#39;import &#123; nanoid &#125; from &#39;nanoid&#39;class Person extends Component &#123;  addPerson = () =&gt; &#123;    const name = this.nameInput.value    const age = this.ageInput.value    const personObj = &#123; id: nanoid(), name, age &#125;    this.props.addPerson(personObj)    this.nameInput.value = &#39;&#39;    this.ageInput.value = &#39;&#39;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h2&gt;在Person组件拿到Count组件的数据：&#123;this.props.count&#125;&lt;/h2&gt;        &lt;input type=&quot;text&quot; ref=&#123;(c) =&gt; (this.nameInput = c)&#125; placeholder=&quot;Please input name&quot; /&gt;        &lt;input type=&quot;text&quot; ref=&#123;(c) =&gt; (this.ageInput = c)&#125; placeholder=&quot;Please input age&quot; /&gt;        &lt;button onClick=&#123;this.addPerson&#125;&gt;添加&lt;/button&gt;        &lt;ul&gt;          &#123;this.props.personList.map((item) =&gt; &#123;            return (              &lt;li key=&#123;item.id&#125;&gt;                &#123;item.name&#125; -- &#123;item.age&#125;              &lt;/li&gt;            )          &#125;)&#125;        &lt;/ul&gt;      &lt;/div&gt;    )  &#125;&#125;export default connect(  // state 是 Redux 保存的状态对象  // 容器组件从 Redux 中取出需要的状态，并传递给 UI 组件  state =&gt; (&#123;personList: state.personList, count: state.total&#125;),  &#123;    addPerson: createAddPersonAction  &#125;)(Person)</code></pre><p>一个细节，在 <code>personReducer</code> 中，是按如下方式修改状态的，而没有使用 <code>unshift</code> 方法。在第二种方式，React 会认为状态没有变化从而不会重新渲染页面，因为 <code>preState</code> 保存的是数组地址值，返回的地址和之前的地址是一样的，尽管数组内容发生了改变。而第一种方式返回一个新的数组的地址值，和之前不一样，因此会重新渲染页面。</p><pre><code class="js">// 方式一switch (type) &#123;  case ADD_PERSON:    return [data, ...preState]  default:    return preState&#125;// 方式二switch (type) &#123;  case ADD_PERSON:    preState.unshift(data)    return preState  default:    return preState&#125;</code></pre><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>概念：输入同样的参数，返回同样的输出。</p><p>约束：</p><ul><li>不能修改参数数据</li><li>不产生任何副作用，如网络请求、输入和输出设备</li><li>不能调用 <code>Date.now()</code> 或 <code>Math.random()</code> 等不纯的方法</li></ul><p><code>reducer</code> 的函数必须是纯函数。</p><h3 id="redux开发工具"><a href="#redux开发工具" class="headerlink" title="redux开发工具"></a>redux开发工具</h3><ul><li><p>Chrome 安装 Redux DevTools 开发者工具</p></li><li><p>项目下载依赖包 <code>npm i redux-devtools-extension --save-dev</code>，</p></li><li><p>最后在 <code>store.js</code> 进行配置：</p></li></ul><pre><code class="js">import &#123; composeWithDevTools &#125; from &#39;redux-devtools-extension&#39;...export default createStore(Reducers, composeWithDevTools(applyMiddleware(thunk)))// 不需要异步中间件export default createStore(Reducers, composeWithDevTools())</code></pre><h2 id="react扩展"><a href="#react扩展" class="headerlink" title="react扩展"></a>react扩展</h2><h3 id="setState-更新状态的两种写法"><a href="#setState-更新状态的两种写法" class="headerlink" title="setState 更新状态的两种写法"></a>setState 更新状态的两种写法</h3><p>对象式：<code>setState(stateChange, [callback])</code></p><ul><li><code>stateChange</code> 为状态改变对象(该对象可以体现出状态的更改)</li><li><code>callback</code> 是可选的回调函数, 它在状态更新完毕、界面也更新后才被调用</li></ul><p>函数式：<code>setState(updater, [callback])</code></p><ul><li>updater 为返回 stateChange 对象的函数。</li><li>updater 可以接收到 state 和 props。</li></ul><p>说明：</p><ul><li>React 状态更新是异步的。下述代码打印的 <code>count</code> 值是上一次的值，而非更新后的。可在第二个参数回调中获取更新后的状态。</li></ul><pre><code class="js">add = () =&gt; &#123;  this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count)&#125;add = () =&gt; &#123;  this.setState(&#123; count: this.state.count + 1 &#125;, () =&gt; &#123;    console.log(this.state.count)  &#125;)&#125;</code></pre><ul><li><code>callback</code> 回调在 <code>componentDidMount</code> 钩子之后执行</li><li>对象式写法可以看做函数式写法的语法糖</li></ul><pre><code class="js">add = () =&gt; &#123;  this.setState((state, props) =&gt; &#123;    return &#123; count: state.count + props.step &#125;  &#125;)&#125;</code></pre><h3 id="路由组件懒加载-lazyLoad"><a href="#路由组件懒加载-lazyLoad" class="headerlink" title="路由组件懒加载 lazyLoad"></a>路由组件懒加载 lazyLoad</h3><pre><code class="jsx">import React, &#123; Component, lazy, Suspense &#125; from &#39;react&#39;import Loading from &#39;./Loading&#39;// 通过 lazy 函数配合 import() 函数动态加载路由组件// 路由组件代码会被分开打包const Home = lazy(() =&gt; import(&#39;./Home&#39;)) const About = lazy(() =&gt; import(&#39;./About&#39;))export default Demo extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Demo 组件&lt;/h1&gt;        &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;        &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;        // 通过 &lt;Suspense&gt; 指定在加载得到路由打包文件前显示一个自定义 Loading 界面        &lt;Suspense fallback=&#123;Loading&#125;&gt;          &lt;Switch&gt;            &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;&gt;            &lt;Route path=&quot;/about&quot; component=&#123;About&#125;&gt;          &lt;/Switch&gt;        &lt;/Suspense&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h3><blockquote><p>Hook 是 React 16.8.0 增加的新特性，让我们能在函数式组件中使用 <code>state</code> 和其他特性</p></blockquote><h4 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h4><ul><li><code>State Hook</code> 让函数式组件也可拥有 <code>state</code> 状态。</li><li>语法：<code>const [Xxx, setXxx] = React.useState(initValue)</code></li><li><code>useState()</code> 参数：状态初始化值；返回值：包含 2 个元素的数组，分别为状态值和状态更新函数</li><li><code>setXxx()</code> 的 2 种用法：</li></ul><pre><code>setXxx(newValue)setXxx(value =&gt; newValue)</code></pre><p>注意！<strong style="color:orange">新状态值会覆盖原状态值！</strong>因此<strong style="color:red">若有多个状态，只能多次调用 React.useState ，不能使用对象！</strong></p><pre><code class="jsx">import React from &#39;react&#39;export default function StateHook() &#123;    const [count, setCount] = React.useState(0);    const add = () =&gt; setCount(count + 1);    const sub = () =&gt; setCount((count) =&gt; count - 1)    return (        &lt;div&gt;            &lt;h2&gt;状态值：&#123;count&#125;&lt;/h2&gt;            &lt;button onClick=&#123;add&#125;&gt;+1&lt;/button&gt;            &lt;button onClick=&#123;sub&#125;&gt;-1&lt;/button&gt;        &lt;/div&gt;    )&#125;</code></pre><h4 id="Ref-Hook"><a href="#Ref-Hook" class="headerlink" title="Ref Hook"></a>Ref Hook</h4><ul><li><code>Ref Hook</code> 可以在函数式组件存储或查找组件内的标签或其他数据</li><li>语法：<code>const refContainer = React.useRef()</code></li><li>保存标签对象的容器，和 <code>React.createRef()</code> 类似，也是专人专用</li></ul><pre><code class="jsx">import React from &#39;react&#39;export default function RefHook() &#123;  const myref = React.useRef()  const submit = () =&gt; console.log(&#39;myref.current.value&#39;, myref.current.value)  return (    &lt;div&gt;        &lt;input type=&quot;text&quot;  ref=&#123;myref&#125;/&gt;        &lt;button onClick=&#123;submit&#125;&gt;submit&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h4><ul><li><code>Effect Hook</code> 让我们能在函数式组件中执行副作用操作（就是模拟生命周期钩子）</li><li>副作用操作：发送 Ajax 请求、定时器、手动更改真实 DOM</li><li><code>Effect Hook</code> 可以模拟三个钩子：<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code></li><li><code>React.useEffect</code> 第一个参数 <code>return</code> 的函数相当于 <code>componentWillUnmount</code> ，若有多个会按顺序执行</li></ul><pre><code class="js">// 语法React.useEffect(() =&gt; &#123;  ...  return () =&gt; &#123;    // 组件卸载前执行，即 componentWillUnmount 钩子    ...  &#125;&#125;, [stateValue])// 模拟 componentDidMount// 第二个参数数组为空，表示不监听任何状态的更新// 因此只有页面首次渲染会执行输出React.useEffect(() =&gt; &#123;  console.log(&#39;DidMount&#39;)  return () =&gt; &#123;    console.log(&#39;WillUnmount 1&#39;)  &#125;&#125;, [])// 模拟全部状态 componentDidUpdate// 若第二个参数不写，表示监听所有状态的更新React.useEffect(() =&gt; &#123;  console.log(&#39;All DidUpdate&#39;)  return () =&gt; &#123;    console.log(&#39;WillUnmount 2&#39;)  &#125;&#125;)// 模拟部分状态 componentDidUpdate// 第二个参数数组写上状态，表示只监听这些状态的更新React.useEffect(() =&gt; &#123;  console.log(&#39;Part DidUpdate&#39;)  return () =&gt; &#123;    console.log(&#39;WillUnmount 3&#39;)  &#125;&#125;, [count, name])// 若调用 ReactDOM.unmountComponentAtNode(document.getElementById(&#39;root&#39;))// 会输出 WillUnmount 1、2、3</code></pre><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><ul><li><code>Fragment</code> 标签本身不会被渲染成一个真实 DOM 标签，有点像 Vue 的 <code>template</code>。</li><li>用空标签也有相同效果，但是空标签不能传递任何属性，<code>Fragment</code> 标签可以传递 <code>key</code> 属性，遍历时候可用。</li></ul><pre><code class="jsx">import React, &#123; Component, Fragment &#125; from &#39;react&#39;export default class Demo extends Component &#123;  render() &#123;    return (      &lt;Fragment key=&#123;1&#125;&gt;        &lt;input type=&quot;text&quot; /&gt;        &lt;input type=&quot;text&quot; /&gt;      &lt;/Fragment&gt;    )    // 或    return (      &lt;&gt;        &lt;input type=&quot;text&quot; /&gt;        &lt;input type=&quot;text&quot; /&gt;      &lt;/&gt;    )  &#125;&#125;</code></pre><h3 id="Context-了解"><a href="#Context-了解" class="headerlink" title="Context (了解)"></a>Context (了解)</h3><p>Context 是一种组件间通信方式，常用于祖父组件与子孙组件。实际开发一般不用，一般用 React-Redux</p><p>用法说明：</p><pre><code class="jsx">1) 创建Context容器对象：const XxxContext = React.createContext()2) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：&lt;XxxContext.Provider value=&#123;数据&#125;&gt;  子组件&lt;/XxxContext.Provider&gt;3) 后代组件读取数据：// 第一种方式：仅适用于类组件// 声明接收contextstatic contextType = xxxContext// 读取context中的value数据this.context//第二种方式: 可用于函数组件与类组件&lt;XxxContext.Consumer&gt;  &#123;    // value就是context中的value数据    value =&gt; (      ...    )  &#125;&lt;/XxxContext.Consumer&gt;</code></pre><p>举个例子：</p><pre><code class="js">// context.jsimport React from &#39;react&#39;export const MyContext = React.createContext()export const &#123; Provider, Consumer &#125; = MyContext</code></pre><pre><code class="jsx">// A.jsximport React, &#123; Component &#125; from &#39;react&#39;import B from &#39;./B.jsx&#39;import &#123; Provider &#125; from &#39;./context.js&#39;export default class A extends Component &#123;  state = &#123; username: &#39;tom&#39;, age: 18 &#125;  render() &#123;    const &#123; username, age &#125; = this.state    return (      &lt;div&gt;        &lt;h3&gt;A组件&lt;/h3&gt;        &lt;h4&gt;用户名是:&#123;username&#125;&lt;/h4&gt;        &lt;Provider value=&#123;&#123; username, age &#125;&#125;&gt;          &lt;B /&gt;        &lt;/Provider&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><pre><code class="jsx">// B.jsximport React, &#123; Component &#125; from &#39;react&#39;import C from &#39;./C.jsx&#39;export default class B extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;B组件&lt;/h3&gt;        &lt;C /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><pre><code class="jsx">// C.jsximport React, &#123; Component &#125; from &#39;react&#39;import &#123; MyContext &#125; from &#39;./context.js&#39;export default class C extends Component &#123;  static contextType = MyContext  render() &#123;    const &#123; username, age &#125; = this.context    return (      &lt;div&gt;        &lt;h3&gt;C组件&lt;/h3&gt;        &lt;h4&gt;          从A组件接收到的用户名:&#123;username&#125;,年龄:&#123;age&#125;        &lt;/h4&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><pre><code class="jsx">// C.jsx 为函数式组件import &#123; Consumer &#125; from &#39;./context.js&#39;export default function C() &#123;  return (    &lt;div&gt;      &lt;h3&gt;我是C组件&lt;/h3&gt;      &lt;h4&gt;        从A组件接收到的用户名:        &lt;Consumer&gt;&#123;(value) =&gt; `$&#123;value.username&#125;,年龄是$&#123;value.age&#125;`&#125;&lt;/Consumer&gt;      &lt;/h4&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="组件渲染优化"><a href="#组件渲染优化" class="headerlink" title="组件渲染优化"></a>组件渲染优化</h3><p>问题：</p><ul><li>只要调用 <code>setState()</code> ，即使没有修改状态，组件也会重新 <code>render()</code></li><li>只要父组件重新渲染，即使子组件没有使用父组件的状态，也会重新 <code>render()</code></li></ul><p>原因：</p><ul><li><code>shouldComponentUpdate()</code> 钩子默认总是返回 <code>true</code></li></ul><p>改进：</p><ul><li>只有组件的 <code>state</code> 或 <code>props</code> 的数据发生改变时才重新渲染</li></ul><p>方式：</p><ol><li>手动重写 <code>shouldComponentUpdate(nextProps, nextState)</code> 的逻辑，只有数据发生改变才返回 <code>true</code></li><li>使用 <code>PureComponent</code> ，它重写了 <code>shouldComponentUpdate()</code> ， 只有 <code>state</code> 或 <code>props</code> 数据有变化才返回 <code>true</code></li></ol><blockquote><p>TIP</p><ul><li>它只是进行 <code>state</code> 和 <code>props</code> 数据的浅比较, 如果只是数据对象内部数据变了, 返回 <code>false</code>。即对于引用数据类型，比较的是地址引用</li><li>不要直接修改 <code>state</code> 数据, 而是要产生新数据</li></ul></blockquote><pre><code class="js">import React, &#123; PureComponent &#125; from &#39;react&#39;class Demo extends PureComponent &#123;  ...  addStu = () =&gt; &#123;    // 不会渲染    const &#123; stus &#125; = this.state    stus.unshift(&#39;小刘&#39;)    this.setState(&#123; stus &#125;)    // 重新渲染    const &#123; stus &#125; = this.state    this.setState(&#123; stus: [&#39;小刘&#39;, ...stus] &#125;)  &#125;  ...&#125;</code></pre><h3 id="render-props-插槽"><a href="#render-props-插槽" class="headerlink" title="render props (插槽)"></a>render props (插槽)</h3><blockquote><p>类似于 Vue 中的插槽技术</p></blockquote><p>如何向组件内部动态传入带内容的结构（即标签或组件）？</p><ul><li>Vue：插槽技术</li><li>React：<ul><li>使用 <code>children props</code>：通过组件标签体传入结构</li><li>使用 <code>render props</code>：通过组件标签属性传入结构，可携带数据</li></ul></li></ul><p><code>children props</code> 方式：</p><ul><li>组件标签体内容会存储到 <code>this.props.children</code> 中</li><li>缺点：A 组件无法向 B 组件传递数据</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;export default class Parent extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;Parent组件&lt;/h3&gt;        &lt;A&gt;          &lt;B /&gt;        &lt;/A&gt;      &lt;/div&gt;    )  &#125;&#125;class A extends Component &#123;  state = &#123; name: &#39;tom&#39; &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;A组件&lt;/h3&gt;        &#123;this.props.children&#125;      &lt;/div&gt;    )  &#125;&#125;class B extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;B组件&lt;/h3&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p><code>render props</code> 方式：</p><ul><li><code>&lt;A render=&#123;(name) =&gt; &lt;B name=&#123;name&#125; /&gt;&#125; /&gt;</code></li><li><code>&#123;this.props.render(name)&#125;</code></li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;export default class Parent extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;Parent组件&lt;/h3&gt;        &lt;A render=&#123;(name) =&gt; &lt;B name=&#123;name&#125; /&gt;&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;class A extends Component &#123;  state = &#123; name: &#39;tom&#39; &#125;  render() &#123;    const &#123; name &#125; = this.state    return (      &lt;div&gt;        &lt;h3&gt;A组件&lt;/h3&gt;        &#123;this.props.render(name)&#125;      &lt;/div&gt;    )  &#125;&#125;class B extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;B组件,&#123;this.props.name&#125;&lt;/h3&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><blockquote><p>TIP</p><p>错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面。</p><p>注意：只在生产环境（项目上线）起效</p></blockquote><p>特点：</p><ul><li>只能捕获<strong>后代组件生命周期</strong>产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</li><li>简单理解就是只能捕获后代组件生命周期钩子里面代码的错误</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import Child from &#39;./Child&#39;export default class Parent extends Component &#123;  state = &#123;    //用于标识子组件是否产生错误    hasError: &#39;&#39;,  &#125;  // 当子组件出现错误，会触发调用，并携带错误信息  static getDerivedStateFromError(error) &#123;    // render 之前触发    // 返回新的 state    return &#123; hasError: error &#125;  &#125;  // 子组件产生错误时调用该钩子  componentDidCatch(error, info) &#123;    console.log(error, info)    console.log(&#39;此处统计错误，反馈给服务器&#39;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h2&gt;Parent组件&lt;/h2&gt;        &#123;this.state.hasError ? &lt;h2&gt;网络不稳定，稍后再试&lt;/h2&gt; : &lt;Child /&gt;&#125;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="组件通信方式总结"><a href="#组件通信方式总结" class="headerlink" title="组件通信方式总结"></a>组件通信方式总结</h3><ul><li><code>props</code></li><li>消息订阅发布：<code>pubs-sub</code></li><li>集中管理：Redux、dva 等</li><li>Context</li></ul><p>推荐搭配：</p><ul><li>父子组件：<code>props</code></li><li>兄弟组件：消息订阅-发布、集中式管理</li><li>祖孙组件(跨级组件)：消息订阅-发布、集中式管理、<code>conText</code>(开发用的少，封装插件用的多即 React-Redux)</li></ul><h2 id="react-router6"><a href="#react-router6" class="headerlink" title="react-router6"></a>react-router6</h2><p><a href="https://reactrouter.com/">官方文档</a></p><p>React Router 发布了三个不同的包：</p><ul><li><code>react-router</code>：路由核心库，提供许多组件、钩子</li><li><code>react-router-dom</code>：包括了 <code>react-router</code> 所有内容，同时添加了用于 DOM 的组件，如 <code>&lt;BrowserRouter&gt;</code></li><li><code>react-router-native</code>：包括了 <code>react-router</code> 所有内容，同时添加了用于 ReactNative 的 API，如 <code>&lt;NativeRouter&gt;</code></li></ul><p>与 React Router 5.x 版本的区别：</p><ul><li>内置组件的变化：移除 <code>&lt;Switch/&gt;</code>，新增 <code>&lt;Routes/&gt;</code>……</li><li>语法变化：<code>component=&#123;About&#125;</code> 变成 <code>element=&#123;&lt;About/&gt;&#125;</code>……</li><li>新增 hook：<code>useParams</code>、<code>useNavigate</code>、<code>useMatch</code>……</li><li>官方明确表示推荐使用函数式组件</li></ul><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装 6 版本的 React Router。</p><pre><code class="shell">npm install react-router-dom</code></pre><p><code>index.js</code> 文件引入 <code>&lt;BrowserRouter&gt;</code>。</p><pre><code class="jsx">// 从 react-dom/client 引入 ReactDOMimport ReactDOM from &#39;react-dom/client&#39;import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;import App from &#39;./App&#39;// React 18 的语法发生改变了ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;)</code></pre><p><code>App.js</code> 设置路由链接和注册路由。<code>&lt;Route caseSensitive&gt;</code> 属性用于指定匹配时是否区分大小写（默认为 false）</p><pre><code class="jsx">import &#123; NavLink, Routes, Route &#125; from &#39;react-router-dom&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;// React 18 默认使用函数式组件了export default function App() &#123;  return (    &lt;div&gt;      &lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &lt;Routes&gt;        &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;        &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h3><p><code>&lt;BrowserRouter&gt;</code> 用于包裹整个应用。</p><pre><code class="jsx">import ReactDOM from &#39;react-dom/client&#39;import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;import App from &#39;./App&#39;ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;)</code></pre><h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><p>作用与 <code>&lt;BrowserRouter&gt;</code> 一样，但 <code>&lt;HashRouter&gt;</code> 修改的是地址栏的 hash 值。</p><p>6.x 版本中 <code>&lt;HashRouter&gt;</code>、<code>&lt;BrowserRouter&gt;</code> 的用法与 5.x 相同。</p><h3 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h3><p>6 版本中移出了 <code>&lt;Switch&gt;</code>，引入了新的替代者：<code>&lt;Routes&gt;</code>。</p><p><code>&lt;Routes&gt;</code> 和 <code>&lt;Route&gt;</code> 要配合使用，且必须要用 <code>&lt;Routes&gt;</code> 包裹 <code>&lt;Route&gt;</code>。</p><h3 id="Navigate-重定向"><a href="#Navigate-重定向" class="headerlink" title="Navigate-重定向"></a>Navigate-重定向</h3><p>只要 <code>&lt;Navigate&gt;</code> 组件被渲染，就会修改路径，切换视图。可用于<code>路由重定向</code>。</p><p><code>replace</code> 属性用于控制跳转模式（push 或 replace，默认是 push）。</p><pre><code class="jsx">import &#123; NavLink, Routes, Route, Navigate &#125; from &#39;react-router-dom&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;export default function App() &#123;  return (    &lt;div&gt;      &lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &lt;Routes&gt;        &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;        &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;        &lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&quot;/about&quot; /&gt;&#125;&gt;&lt;/Route&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><pre><code class="jsx">import React, &#123; useState &#125; from &#39;react&#39;import &#123; Navigate &#125; from &#39;react-router-dom&#39;export default function Home() &#123;  const [sum, setSum] = useState(1)  return (    &lt;div&gt;      &lt;h1&gt;Home&lt;/h1&gt;      &#123;/* 根据sum的值决定是否切换视图 */&#125;      &#123;sum === 1 ? &lt;h4&gt;sum的值为&#123;sum&#125;&lt;/h4&gt; : &lt;Navigate to=&quot;/about&quot; replace=&#123;true&#125; /&gt;&#125;      &lt;button onClick=&#123;() =&gt; setSum(2)&#125;&gt;将sum变为 2&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="useRoutes-路由表"><a href="#useRoutes-路由表" class="headerlink" title="useRoutes() 路由表"></a>useRoutes() 路由表</h3><p>路由规则可以单独抽出一个模块。</p><pre><code class="jsx">// 路由表// routes/index.jsimport &#123; Navigate &#125; from &#39;react-router-dom&#39;import About from &#39;../components/About&#39;import Home from &#39;../components/Home&#39;const routes = [    &#123;        path: &#39;/about&#39;,        element: &lt;About /&gt;    &#125;,    &#123;        path: &#39;/home&#39;,        element: &lt;Home /&gt;    &#125;,    &#123;        path: &#39;/&#39;,        element: &lt;Navigate to=&quot;/home&quot; /&gt;    &#125;]export default routes</code></pre><pre><code class="jsx">// 引入路由表// App.jsimport &#123; NavLink, useRoutes &#125; from &#39;react-router-dom&#39;import routes from &#39;./routes&#39;export default function App() &#123;  // 生成路由规则  const element = useRoutes(routes)  return (    &lt;div&gt;      &lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &#123;element&#125;    &lt;/div&gt;  )&#125;</code></pre><h3 id="Outlet-嵌套路由"><a href="#Outlet-嵌套路由" class="headerlink" title="Outlet 嵌套路由"></a>Outlet 嵌套路由</h3><ul><li>嵌套路由中，需要使用 <code>&lt;Outlet&gt;</code> 设置子路由的路由出口，即在何处渲染子路由。</li><li>设置二级路由链接时，可以是 <code>to=&quot;news&quot;</code>、<code>to=&quot;./news&quot;</code>，但不能是 <code>to=&quot;/news&quot;</code>。</li></ul><p>不使用路由表的嵌套路由：</p><pre><code class="jsx">// App.jsexport default function App() &#123;  return (    &lt;div&gt;      &lt;NavLink to=&quot;about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &lt;Routes&gt;        &lt;Route path=&quot;about&quot; element=&#123;&lt;About /&gt;&#125; /&gt;        &lt;Route path=&quot;home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;          &lt;Route path=&quot;news&quot; element=&#123;&lt;News /&gt;&#125; /&gt;          &lt;Route path=&quot;message&quot; element=&#123;&lt;Message /&gt;&#125; /&gt;        &lt;/Route&gt;        &lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&quot;about&quot; /&gt;&#125; /&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><p>使用路由表的嵌套路由：</p><pre><code class="jsx">// 路由表const routes = [  &#123;    path: &#39;/about&#39;,    element: &lt;About /&gt;,  &#125;,  &#123;    path: &#39;/home&#39;,    element: &lt;Home /&gt;,    // 定义二级路由，注意不要加 /    children: [      &#123;        path: &#39;news&#39;,        element: &lt;News /&gt;,      &#125;,      &#123;        path: &#39;message&#39;,        element: &lt;Message /&gt;,      &#125;,    ],  &#125;,  &#123;    path: &#39;/&#39;,    element: &lt;Navigate to=&quot;/about&quot; /&gt;,  &#125;,]</code></pre><pre><code class="jsx">// Home 子组件import React, &#123; Fragment &#125; from &#39;react&#39;import &#123; NavLink, Outlet &#125; from &#39;react-router-dom&#39;export default function Hello() &#123;  return (    &lt;Fragment&gt;      &lt;h2&gt;I am Hello!&lt;/h2&gt;      &#123;/* 子路由链接 */&#125;      &lt;NavLink to=&quot;news&quot;&gt;News&lt;/NavLink&gt;      &lt;NavLink to=&quot;message&quot;&gt;Message&lt;/NavLink&gt;      &lt;hr /&gt;      &#123;/* 子路由出口 */&#125;      &lt;Outlet&gt;&lt;/Outlet&gt;    &lt;/Fragment&gt;  )&#125;</code></pre><h3 id="NavLink-路由高亮"><a href="#NavLink-路由高亮" class="headerlink" title="NavLink 路由高亮"></a>NavLink 路由高亮</h3><p>实现导航的 “高亮” 效果，6 版本不能直接指定高亮类名，需要通过函数返回。该函数传入一个对象，类似于 <code>&#123;isActive: true&#125;</code> 标识路由是否被激活。</p><p>默认情况下，当 <code>Home</code> 的子组件匹配成功，<code>Home</code> 的导航也会高亮，<code>end</code> 属性可移除该效果。</p><pre><code class="jsx">// NavLink 默认类名是 active，下面是指定自定义类名//自定义样式&lt;NavLink    to=&quot;login&quot;    className=&#123;(&#123; isActive &#125;) =&gt; &#123;        console.log(&#39;home&#39;, isActive)        return isActive ? &#39;base MyClass&#39; : &#39;base&#39;    &#125;&#125;&gt;about&lt;/NavLink&gt;// 默认情况下，当 Home 的子组件匹配成功，Home 的导航也会高亮// 当 NavLink 上添加了 end 属性后，若 Home 的子组件匹配成功，则 Home 的导航没有高亮效果。&lt;NavLink to=&quot;home&quot; end &gt;home&lt;/NavLink&gt;</code></pre><h3 id="路由传参-1"><a href="#路由传参-1" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="传递-params参数"><a href="#传递-params参数" class="headerlink" title="传递 params参数"></a>传递 params参数</h4><p>注册路由时声明 <code>params</code> 参数，和 React Router 5 一样。</p><pre><code class="jsx">export default function App() &#123;  return (    &lt;div&gt;      &lt;Routes&gt;        &lt;Route path=&quot;home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;          &lt;Route path=&quot;message&quot; element=&#123;&lt;Message /&gt;&#125;&gt;            &lt;Route path=&quot;detail/:id/:name/:age&quot; element=&#123;&lt;Detail /&gt;&#125; /&gt;          &lt;/Route&gt;        &lt;/Route&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><p>传递参数</p><pre><code class="jsx">&lt;Link to=&#123;`detail/$&#123;item.id&#125;/$&#123;item.name&#125;/$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;</code></pre><p>使用 <code>useParams()</code> 接收 <code>params</code> 参数。<code>useParams()</code> 返回一个参数对象。</p><pre><code class="jsx">import React from &#39;react&#39;import &#123; useParams, useMatch &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  // 解构赋值  const &#123; id, name, age &#125; = useParams()  return (    &lt;div&gt;      &lt;li&gt;id:&#123;id&#125;&lt;/li&gt;      &lt;li&gt;name:&#123;name&#125;&lt;/li&gt;      &lt;li&gt;age:&#123;age&#125;&lt;/li&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="传递-search参数"><a href="#传递-search参数" class="headerlink" title="传递 search参数"></a>传递 search参数</h4><p>和 5 版本一样，正常注册路由即可。</p><pre><code class="jsx">&lt;Route path=&quot;detail&quot; element=&#123;&lt;Detail /&gt;&#125; /&gt;</code></pre><p>传递参数。</p><pre><code class="jsx">&lt;Link to=&#123;`detail?id=$&#123;item.id&#125;&amp;name=$&#123;item.name&#125;&amp;age=$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;</code></pre><p>使用 <code>useSearchParams()</code> 接收参数。该方法返回一个包含两个元素的数组：<code>search</code> 参数和修改 <code>search</code> 参数的方法。</p><pre><code class="jsx">import React from &#39;react&#39;import &#123; useSearchParams &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  // 数组的解构赋值  const [searchParams, setSearchParams] = useSearchParams()  // 需要调用 get() 方法获取对应的参数值  const id = searchParams.get(&#39;id&#39;)  const name = searchParams.get(&#39;name&#39;)  const age = searchParams.get(&#39;age&#39;)  function change() &#123;    setSearchParams(&#39;id=666&amp;name=Lily&amp;age=888&#39;)  &#125;  return (    &lt;div&gt;      &lt;li&gt;id:&#123;id&#125;&lt;/li&gt;      &lt;li&gt;name:&#123;name&#125;&lt;/li&gt;      &lt;li&gt;age:&#123;age&#125;&lt;/li&gt;      &lt;button onClick=&#123;change&#125;&gt;Change search params&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="传递-state-参数"><a href="#传递-state-参数" class="headerlink" title="传递 state 参数"></a>传递 state 参数</h4><p>和 5 版本一样，正常注册路由即可。</p><pre><code class="jsx">&lt;Route path=&quot;detail&quot; element=&#123;&lt;Detail /&gt;&#125; /&gt;</code></pre><p>传递参数，这里相较于 5 版本有所不同，不必写到一个对象里面。</p><pre><code class="jsx">&lt;Link to=&quot;detail&quot; state=&#123;&#123; id: item.id, name: item.name, age: item.age &#125;&#125;&gt;  &#123;item.name&#125;&lt;/Link&gt;</code></pre><p>使用 <code>useLocation()</code> 接收参数。该方法返回路由组件的 <code>location</code> 对象，就是 5 版本路由组件的 <code>location</code> 属性，其中包含 <code>state</code> 参数。</p><pre><code class="jsx">import &#123; useLocation &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  // 连续解构赋值  const &#123;    state: &#123; id, name, age &#125;,  &#125; = useLocation()  return (    &lt;div&gt;      &lt;li&gt;id:&#123;id&#125;&lt;/li&gt;      &lt;li&gt;name:&#123;name&#125;&lt;/li&gt;      &lt;li&gt;age:&#123;age&#125;&lt;/li&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="useNavigate-编程式路由导航"><a href="#useNavigate-编程式路由导航" class="headerlink" title="useNavigate() 编程式路由导航"></a>useNavigate() 编程式路由导航</h3><p><code>useNavigate()</code> 返回一个函数，调用该函数实现编程式路由导航。函数有两种参数传递方式。</p><p>第一种方式传递两个参数：路由和相关参数。参数只能设置 <code>replace</code> 和 <code>state</code>。<strong style="color:red">想要传递 <code>params</code> 和 <code>search</code> 参数直接在路由带上</strong>。</p><p>第二种方式传递数字，代表前进或后退几步。</p><pre><code class="jsx">import React, &#123; useState &#125; from &#39;react&#39;import &#123; Outlet, useNavigate &#125; from &#39;react-router-dom&#39;export default function Message() &#123;  const [list] = useState([    &#123; id: 1, name: &#39;Bruce&#39;, age: 33 &#125;,    &#123; id: 2, name: &#39;You&#39;, age: 3 &#125;,    &#123; id: 3, name: &#39;React&#39;, age: 333 &#125;,  ])  const navigate = useNavigate()  function showDetail(item) &#123;    navigate(&#39;detail&#39;, &#123;      replace: true,      state: &#123;        id: item.id,        name: item.name,        age: item.age,      &#125;,    &#125;)  &#125;  function back() &#123;    navigate(1)  &#125;  function forward() &#123;    navigate(-1)  &#125;  return (    &lt;div&gt;      &lt;ul&gt;        &#123;list.map((item) =&gt; &#123;          return (            &lt;li key=&#123;item.id&#125;&gt;              &lt;button onClick=&#123;() =&gt; showDetail(item)&#125;&gt;查看详情&lt;/button&gt;              &lt;button onClick=&#123;back&#125;&gt;后退&lt;/button&gt;              &lt;button onClick=&#123;forward&#125;&gt;前进&lt;/button&gt;            &lt;/li&gt;          )        &#125;)&#125;      &lt;/ul&gt;      &lt;Outlet&gt;&lt;/Outlet&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="Other-Hooks-了解"><a href="#Other-Hooks-了解" class="headerlink" title="Other Hooks(了解)"></a>Other Hooks(了解)</h3><h4 id="useMatch"><a href="#useMatch" class="headerlink" title="useMatch()"></a>useMatch()</h4><p>返回路由组件的 <code>match</code> 数据，即 5 版本中的 <code>match</code> 属性。</p><p>必须传入该组件对应的路由规则才能正确返回，否则返回 <code>null</code>。</p><pre><code class="jsx">// Detail.jsximport &#123; useParams, useMatch &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  const match = useMatch(&#39;home/message/detail/:id/:name/:age&#39;)  console.log(match)  return (    &lt;div&gt;      &lt;li&gt;id&lt;/li&gt;    &lt;/div&gt;  )&#125;/*params: &#123;id: &#39;1&#39;, name: &#39;tom&#39;, age: &#39;33&#39;&#125;pathname: &quot;/home/message/detail/1/tom/33&quot;pathnameBase: &quot;/home/message/detail/1/tom/33&quot;pattern: &#123;path: &#39;home/message/detail/:id/:name/:age&#39;, caseSensitive: false, end: true&#125;*/</code></pre><h4 id="useInRouterContext"><a href="#useInRouterContext" class="headerlink" title="useInRouterContext"></a>useInRouterContext</h4><p>如果组件在 <code>&lt;Router&gt;</code> 的上下文中呈现，则 <code>useInRouterContext</code> 钩子返回 <code>true</code>，否则返回 <code>false</code>。即组件有没有被包裹在 <code>&lt;BrowserRouter&gt;</code> 这种东西里面。这个对第三方组件库有用处。</p><h4 id="useNavigationType"><a href="#useNavigationType" class="headerlink" title="useNavigationType"></a>useNavigationType</h4><p>返回当前的导航类型（用户是如何来到当前页面的）。</p><p>返回值：<code>POP</code>、<code>PUSH</code>、<code>REPLACE</code>。</p><p><code>POP</code> 是指在浏览器中直接打开了这个路由组件（<code>刷新页面</code>）。</p><h4 id="useOutlet"><a href="#useOutlet" class="headerlink" title="useOutlet"></a>useOutlet</h4><p>用来呈现当前组件中渲染的嵌套路由。</p><pre><code class="jsx">const result = useOutlet()console.log(result)// 如果嵌套路由没有挂载,则返回 null// 如果嵌套路由已经挂载,则展示嵌套的路由对象</code></pre><h4 id="useResolvedPath"><a href="#useResolvedPath" class="headerlink" title="useResolvedPath"></a>useResolvedPath</h4><p>给定一个 URL 值，解析其中的：<code>path</code>、<code>search</code>、<code>hash</code> 值。</p><pre><code class="jsx">const res = useResolvedPath(&#39;/user?id=001&amp;name=tom#React&#39;)console.log(res)/*hash: &#39;#React&#39;pathname: &#39;/user&#39;search: &#39;?id=001&amp;name=tom&#39;*/</code></pre>]]></content>
    
    
    <summary type="html">react基础、react-router5/6、react-redux等</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="react" scheme="https://heliufang.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vue3.2新特性笔记</title>
    <link href="https://heliufang.github.io/2022/12/09/1601805950963027968/images/"/>
    <id>https://heliufang.github.io/2022/12/09/1601805950963027968/images/</id>
    <published>2022-12-09T13:20:28.000Z</published>
    <updated>2022-12-21T03:49:38.304Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hh411p79n/">vue3.2视频教程</a></p><h2 id="script-setup基本语法"><a href="#script-setup基本语法" class="headerlink" title="script setup基本语法"></a>script setup基本语法</h2><p>要使用这个语法，需要将 <code>setup</code> 属性添加到 <code>&lt;script&gt;</code> 代码块上：</p><p>里面的代码会被编译成组件<code> setup()</code> 函数的内容。</p><p>这也就意味着与普通的 <code>&lt;script&gt;</code> 只在组件被首次引入的时候<strong style="color:red">仅执行一次不同</strong>，<code>&lt;script setup&gt;</code> 中的代码会在<strong style="color:red">每次组件实例被创建的时候执行</strong>。这一点非常的重要，也就是写在<code> &lt;script setup&gt;</code> 中的代码，例如初始化的赋值等在组件每次实例创建时都重新执行一次。</p><pre><code class="html">&lt;script setup&gt;const a = ref(1);console.log(&#39;hello script setup&#39;)&lt;/script&gt;</code></pre><p>当使用 <code>&lt;script setup&gt;</code> 的时候，任何在<code> &lt;script setup&gt;</code> 声明的顶层的绑定 (包括声明的<code>变量</code>，<code>函数声明</code>，以及 <code>import 引入的内容</code>) 都能<strong style="color:red">在模板中直接使用，不再需要使用 return 导出。</strong></p><h2 id="script-setup新特性"><a href="#script-setup新特性" class="headerlink" title="script setup新特性"></a>script setup新特性</h2><h3 id="自动组件名推断"><a href="#自动组件名推断" class="headerlink" title="自动组件名推断"></a>自动组件名推断</h3><p>在 vue2.x options API 和使用普通的 <code>&lt;script&gt;</code> 的情况下，都可以为组件进行命名</p><p>但是在 <code>&lt;script setup&gt;</code> 下，却并没有提供直接的方式来设置的组件的名称，因此，vue 在上述情况下会依据它的<strong style="color:red">文件名</strong>来自动推断组件名称。</p><p>例如：名为 <code>Foo.vue</code> 的文件可以在模板中用 <code>&lt;Foo/&gt;</code> 引用它自己，在 devtools 中看到的组件名称也是 <code>Foo</code>。</p><p>使用 <code>&lt;script setup&gt;</code> 的情况下如何修改注册组件名呢？？&#x3D;&#x3D;&#x3D;&gt;使用script</p><pre><code class="html">&lt;script lang=&quot;ts&quot;&gt;export default &#123; name: &#39;CustomComponentsName&#39; &#125;&lt;/script&gt;&lt;script setup lang=&quot;ts&quot;&gt;// code&lt;/script&gt;&lt;template&gt;    &lt;p&gt;利用 script 自定义组件名称&lt;/p&gt;&lt;/template&gt;</code></pre><h3 id="普通组件"><a href="#普通组件" class="headerlink" title="普通组件"></a>普通组件</h3><p><code>&lt;script setup&gt;</code> 中引入组件后可直接在模板使用，不再需要注册了。</p><pre><code class="html">&lt;script setup lang=&#39;ts&#39;&gt;import SaySomething from &quot;./Components/SaySomething.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;SaySomething /&gt;&lt;/template&gt;</code></pre><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>动态组件仍然是使用 <code>is</code>，相对于 vue2.x 没有变化</p><pre><code class="html">&lt;script setup lang=&#39;ts&#39;&gt;import &#123; ref &#125; from &quot;vue&quot;;import Bar from &quot;./Components/Bar.vue&quot;;import Foo from &quot;./Components/Foo.vue&quot;;const condition = ref(false);setTimeout(() =&gt; condition.value = true, 2000);&lt;/script&gt;&lt;template&gt;  &lt;component :is=&quot;condition ? Bar : Foo&quot;/&gt;&lt;/template&gt;</code></pre><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>因为自动组件名推断的缘故，一个单文件组件可以通过它的文件名被其自己所引用。例如：名为 Foo.vue 的组件可以在其模板中用 <code>&lt;Foo/&gt;</code> 引用它自己。</p><p>请注意这种方式相比于 import 导入的组件和自主注册的组件<strong style="color:red">优先级更低</strong>。所有如果有命名的 import 导入和组件的推断名冲突了，可以使用 import 别名导入：</p><pre><code class="js">import &#123; Foo as FooChild &#125; from &#39;./components&#39;</code></pre><h3 id="命名空间组件"><a href="#命名空间组件" class="headerlink" title="命名空间组件"></a>命名空间组件</h3><p>可以使用带点的组件标记，例如 <code>&lt;Foo.Bar&gt;</code> 来引用嵌套在对象属性中的组件。这在需要从单个文件中导入多个组件的时候非常有用：</p><p><code>Components/index.ts</code> 用于导出组件</p><pre><code class="js">import Foo from &#39;./Foo.vue&#39;;import Bar from &#39;./Bar.vue&#39;;export &#123; Foo, Bar &#125;;</code></pre><p><code>index.vue</code> 基于命名空间使用组件</p><pre><code class="html">&lt;script setup lang=&#39;ts&#39;&gt;import * as Form from &quot;../Components&quot;;&lt;/script&gt;&lt;template&gt;  &lt;Form.Foo /&gt;  &lt;Form.Bar /&gt;&lt;/template&gt;</code></pre><h3 id="props的使用"><a href="#props的使用" class="headerlink" title="props的使用"></a>props的使用</h3><p>接受父组件传递过来的属性</p><h4 id="definedProps"><a href="#definedProps" class="headerlink" title="definedProps"></a>definedProps</h4><p>为了在<code> &lt;script setup&gt;</code> 中 声明 props ，必须使用 <code>defineProps</code> API，这是一个宏命令，不需要导入，直接可在<code> &lt;script setup&gt;</code> 使用且只能在 <code>&lt;script setup&gt;</code> 中使用，有两种方式可以使用这个宏命令类声明 props，<code>运行时声明</code>和<code>类型声明式</code>，不同的方式下使用这个宏命令后 props 将具备不同的类型推断。</p><ul><li>使用运行时声明（runtime declaration）</li></ul><p>defineProps 运行时声明的基本用法如下，<code>仅支持运行时的校验</code>。<em>和vue2类似</em></p><pre><code class="java">&lt;script setup lang=&#39;ts&#39;&gt;const props = defineProps(&#123;    foo: String,    bar: &#123;      type: Number,      required: true    &#125;&#125;)&lt;/script&gt;</code></pre><ul><li>类型声明（type declaration）</li></ul><p><code>defineProps</code> 类型声明的基本用法如下，完美的支持 IDE 的类型推断和检查。<strong style="color:red">推荐这种方式</strong></p><pre><code class="html">&lt;script setup lang=&#39;ts&#39;&gt;const props = defineProps&lt;&#123;  foo?: string  //?表示可选,不带?表示必传  bar: number&#125;&gt;()&lt;/script&gt;</code></pre><p>运行时声明和类型声明的比较</p><table><thead><tr><th>类型</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>运行时声明</td><td>不使用 ts 的情况下能够对 props 进行一定的、运行时的类型校验</td><td>1. 运行时校验2. 只能进行基本类型的校验3. 编码时无任何提示</td></tr><tr><td>类型声明</td><td>完美的支持类型的校验，包括props 的完美类型约束、父组件在传 props 时的提示以及子组件在使用 props 的提示</td><td>目前 ts 的<strong style="color:red">接口暂时只支持写在本组件的文件内</strong>，未来应该会实现可从外部导入的，但目前可通过ts自动扫描types来解决</td></tr></tbody></table><h4 id="widthDefaults"><a href="#widthDefaults" class="headerlink" title="widthDefaults"></a>widthDefaults</h4><p><code>defineProps</code> 使用类型声明时的不足之处在于，它没有可以给 props 提供默认值的方式。为了解决这个问题，提供了 <code>withDefaults</code> 宏命令。</p><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;const props = withDefaults(defineProps&lt;&#123;  title?: string,  list?: List.Basic[],&#125;&gt;(), &#123;  title: &#39;Hello withDefaults&#39;,  list: () =&gt; [&#123; id: 3, content: &#39;3&#39;, isDone: false &#125;],&#125;);&lt;/script&gt;</code></pre><p>注意：<code>widthDefaults</code> 是为了给 <code>defineProps</code> 使用类型声明时提供添加默认值的的方法，因此，需要注意这仅仅适用于 <code>&lt;script setup lang=&#39;ts&#39;&gt;</code> 且 <code>defineProps</code> 使用类型声明。</p><h3 id="自定义事件-defineEmits"><a href="#自定义事件-defineEmits" class="headerlink" title="自定义事件-defineEmits"></a>自定义事件-defineEmits</h3><p>在 <code>&lt;script setup&gt;</code> 中 声明 <code>emit</code> ，必须使用 <code>defineEmits</code> API，这也是一个宏命令。同样可采用运行时声明和类型声明式两种方式，在类型声明下 <code>emit</code> 将具备完美的类型推断。</p><ul><li>运行时声明</li></ul><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;// 这样是没有任何的类型检查的const emit = defineEmits([&#39;handleClick&#39;, &#39;handleChange&#39;]);const handleClick = () =&gt; emit(&#39;handleClick&#39;, Date.now()+&#39;&#39;);const handleChange = () =&gt; emit(&#39;handleChange&#39;, Date.now());&lt;/script&gt;</code></pre><ul><li>类型声明</li></ul><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;interface Click &#123;  id: string,  val: number,&#125;// 完美的类型检查// List.Basic 是基于 ts 自动扫描 types 文件夹以及 delcare namespace 自动导入的const emit = defineEmits&lt;&#123;  (e: &#39;handleClickWithTypeDeclaration&#39;, data: Click): void,  (e: &#39;handleChangeWithTypeDeclaration&#39;, data: List.Basic): void,&#125;&gt;();const handleClickWithTypeDeclaration = () =&gt; emit(&#39;handleClickWithTypeDeclaration&#39;, &#123; id: &#39;1&#39;, val: Date.now() &#125;);const handleChangeWithTypeDeclaration = () =&gt; emit(&#39;handleChangeWithTypeDeclaration&#39;, &#123;  id: 1,  content: &#39;change&#39;,  isDone: false,&#125;);&lt;/script&gt;</code></pre><p>跟 <code>defineProps</code> 一样，运行时声明和类型声明式同样不可同时使用，且类型声明只能用于在 ts 环境下。</p><h3 id="显示的暴露-defineExpose"><a href="#显示的暴露-defineExpose" class="headerlink" title="显示的暴露-defineExpose"></a>显示的暴露-defineExpose</h3><p>官方文档指出默认情况下使用 <code>&lt;script setup&gt;</code> 的组件是默认关闭的，也就是说通过<code>模板 ref</code> 或者 <code>$parent</code> 链获取到的子组件的实例，并不会暴露任何在<code> &lt;script setup&gt;</code> 中声明的绑定（变量，函数）。</p><p>为了在<code> &lt;script setup&gt;</code> 组件中明确要暴露出去的属性，那么就需要使用 <code>defineExpose</code> 这个宏命令。</p><pre><code class="html">&lt;script setup&gt;import &#123; ref &#125; from &#39;vue&#39;const a = 1const b = ref(2)defineExpose(&#123;  a,  b&#125;)&lt;/script&gt;</code></pre><p>当父组件通过模板 ref 的方式获取到当前子组件的实例，获取到的实例会像这样 <code>&#123; a: number, b: number &#125;</code> (ref 会和在普通实例中一样被自动解包)</p><h3 id="useSlots-和-useAttrs"><a href="#useSlots-和-useAttrs" class="headerlink" title="useSlots 和 useAttrs"></a>useSlots 和 useAttrs</h3><p>在 <code>&lt;script setup&gt;</code> 使用 <code>slots</code> 和 <code>attrs</code> 获取插槽和兜底属性，可以用 <code>useSlots</code> 和 <code>useAttrs</code> 两个函数</p><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useSlots, useAttrs &#125; from &quot;vue&quot;;const slot = useSlots();console.log(&#39;TestUseSlots&#39;, slot.header &amp;&amp; slot.header());        // 获取到使用插槽的具体信息  const attrs = useAttrs();console.log(&#39;TestUseAttrs&#39;, attrs);        // 获取到使用组件时传递的 attributes&lt;/script&gt;&lt;template&gt;  &lt;h1&gt; Here is slots test!!&lt;/h1&gt;  &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;&lt;/template&gt;</code></pre><p><code>useSlots</code> 和 <code>useAttrs</code> 是真实的运行时函数，它会返回与 <code>setupContext.slots</code> 和 <code>setupContext.attrs</code> 等价的值，同样也能在普通的 <code>composition API</code> 中使用。</p><h3 id="与普通的script一起使用"><a href="#与普通的script一起使用" class="headerlink" title="与普通的script一起使用"></a>与普通的script一起使用</h3><p><code>&lt;script setup&gt;</code> 可以和普通的 <code>&lt;script&gt;</code> 一起使用。普通的 <code>&lt;script&gt; </code>在有这些需要的情况下或许会被使用到：</p><ul><li>无法在<code>&lt;script setup&gt;</code>声明的选项，例如 inheritAttrs 或通过插件启用的自定义的选项。</li><li>显示定义组件的名称。</li><li>运行副作用或者创建只需要执行一次的对象。</li></ul><pre><code class="html">&lt;script&gt;// 普通 &lt;script&gt;, 在模块范围下执行(只执行一次)runSideEffectOnce()// 声明额外的选项export default &#123;  inheritAttrs: false,  customOptions: &#123;&#125;&#125;&lt;/script&gt;&lt;script setup&gt;// 在 setup() 作用域中执行 (对每个实例皆如此)&lt;/script&gt;</code></pre><p>注意：如果同时使用 <code>&lt;script setup&gt;</code> 和 <code>&lt;script&gt;</code> ，那么将打破 <code>&lt;script setup&gt;</code> 的默认关闭（即外部无法获取组件内部的属性和方法），此时，子组件内部的属性和方法都将在外部可获取到，如 <code>ref.xxx</code></p><h3 id="顶层await-了解"><a href="#顶层await-了解" class="headerlink" title="顶层await(了解)"></a>顶层await(了解)</h3><p><code>await</code> 的使用必须是要在<code>async</code> 语法糖的包裹下，否者将无法执行，为了更简化代码， <code>&lt;script setup&gt;</code> 中可以使用顶层 <code>await</code>。</p><pre><code class="html">&lt;script setup&gt;const post = await fetch(`/api/post/1`).then(r =&gt; r.json())&lt;/script&gt;</code></pre><h2 id="限制使用src-导入-了解"><a href="#限制使用src-导入-了解" class="headerlink" title="限制使用src 导入(了解)"></a>限制使用src 导入(了解)</h2><p>SFC 的三个模块都可以通过 <code>src</code> 的方式进行导入，如下所示：</p><pre><code class="html">&lt;template src=&quot;./template.html&quot;&gt;&lt;/template&gt;&lt;style src=&quot;./style.css&quot;&gt;&lt;/style&gt;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;</code></pre><p>但是在<code> &lt;script setup&gt;</code>下强烈建议不使用 Src 导入。</p><p>由于模块执行语义的差异，<code>&lt;script setup&gt;</code> 中的代码依赖单文件组件的上下文。当将其移动到外部的 .js 或者 .ts 文件中的时候，对于开发者和工具来说都会感到混乱。因而<code> &lt;script setup&gt;</code> 不能和<code> src attribute</code> 一起使用。</p><h2 id="style-v-bind-新特性"><a href="#style-v-bind-新特性" class="headerlink" title="style  v-bind 新特性"></a>style  v-bind 新特性</h2><h3 id="style-module-了解"><a href="#style-module-了解" class="headerlink" title="style module(了解)"></a>style module(了解)</h3><p>设计和使用上跟 Vue2.x 是一致的，因此也不多赘述。<br>唯一新的点是使用 <code>&lt;script setup&gt;</code> 时，可以使用 <code>useCssModule</code> API 获取到 css module 对象。</p><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useCssModule &#125; from &quot;vue&quot;;const css = useCssModule();console.log(css);        // &#123; blue: &quot;_blue_13cse_5&quot;, red: &quot;_red_13cse_2&quot;&#125;&lt;/script&gt;&lt;style module&gt;.red &#123;  color: red;&#125;.blue &#123;  color: blue;&#125;&lt;/style&gt;</code></pre><h3 id="动态css"><a href="#动态css" class="headerlink" title="动态css"></a>动态css</h3><p>单文件组件的 <code>&lt;style&gt;</code> 标签可以通过 <code>v-bind</code> 这一 CSS 函数将 CSS 的值关联到动态的组件状态上，<strong>有了这一特性，可以将大量的动态样式通过状态来驱动了，而不是写动态的 calss 类名或者获取 dom 来动态设置了</strong>。</p><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &quot;vue&quot;;const color = ref(&#39;red&#39;);setTimeout(() =&gt; color.value = &#39;blue&#39; , 2000);&lt;/script&gt;&lt;template&gt;  &lt;p&gt;hello&lt;/p&gt;&lt;/template&gt;&lt;style scoped&gt;p &#123;  color: v-bind(color);&#125;&lt;/style&gt;</code></pre><h2 id="volar插件"><a href="#volar插件" class="headerlink" title="volar插件"></a>volar插件</h2><p>vue3必备vscode的插件，安装后有代码提示、点击css类&#x2F;组件跳转、自动补全等等功能！</p>]]></content>
    
    
    <summary type="html">vue3.2新特性，以setup语法糖为核心的相关api学习笔记</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>node笔记</title>
    <link href="https://heliufang.github.io/2022/10/30/1593064784100724736/images/"/>
    <id>https://heliufang.github.io/2022/10/30/1593064784100724736/images/</id>
    <published>2022-10-30T11:19:28.000Z</published>
    <updated>2022-11-17T02:07:10.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node基本概念"><a href="#node基本概念" class="headerlink" title="node基本概念"></a>node基本概念</h2><h3 id="node是什么"><a href="#node是什么" class="headerlink" title="node是什么"></a>node是什么</h3><p>node.js，也叫作node，或者nodejs，指的都是一个东西。</p><ol><li><a href="https://nodejs.org/">node.js官方网站</a></li><li><a href="http://nodejs.cn/">node.js中文网</a></li><li><a href="https://cnodejs.org/">node.js 中文社区</a></li><li><a href="https://www.runoob.com/nodejs/nodejs-tutorial.html">菜鸟教程-node</a></li></ol><p>Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。 </p><ul><li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</li></ul><pre><code>1. nodejs是在服务端运行javascript的运行环境2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎。</code></pre><ul><li>Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，使其轻量又高效。  </li><li>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li></ul><p><strong>nodejs的本质：不是一门新的编程语言，nodejs是javascript运行在服务端的运行环境，编程语言还是javascript</strong></p><h3 id="nodejs与浏览器的区别"><a href="#nodejs与浏览器的区别" class="headerlink" title="nodejs与浏览器的区别"></a>nodejs与浏览器的区别</h3><p>相同点：nodejs与浏览器都是浏览器的运行环境，都能够解析js程序。对于ECMAScript语法来说，在nodejs和浏览器中都能运行。</p><p>不同点：<code>nodejs无法使用DOM和BOM的操作</code>，浏览器无法执行nodejs中的文件操作等功能</p><p><img src="/2022/10/30/1593064784100724736/images/image-20221024215658030.png" alt="image-20221024215658030"></p><h3 id="nodejs可以干什么？"><a href="#nodejs可以干什么？" class="headerlink" title="nodejs可以干什么？"></a>nodejs可以干什么？</h3><ol><li>开发服务端程序</li><li>开发命令行工具（CLI），比如npm,webpack,gulp,less,sass等</li><li>开发桌面应用程序（借助 node-webkit、<code>electron</code> 等框架实现）</li></ol><h2 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h2><p>下载地址</p><ul><li><a href="https://nodejs.org/en/download/">当前版本</a></li><li><a href="https://nodejs.org/en/download/releases/">历史版本</a></li></ul><p>官网术语解释</p><ul><li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li><li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入。</li></ul><p>下载之后一直点下一步即可完成安装，安装之后查看node版本</p><pre><code class="bash">node -v</code></pre><h2 id="运行node程序"><a href="#运行node程序" class="headerlink" title="运行node程序"></a>运行node程序</h2><h3 id="repl方式"><a href="#repl方式" class="headerlink" title="repl方式"></a>repl方式</h3><ol><li>REPL 全称: Read-Eval-Print-Loop（交互式解释器）<ul><li>R 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</li><li>E 执行 - 执行输入的数据结构</li><li>P 打印 - 输出结果</li><li>L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。</li></ul></li><li>在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能）<ul><li>直接在控制台输入 <code>node</code> 命令进入 REPL 环境</li></ul></li><li>按两次 Control + C 退出REPL界面 或者 输入 <code>.exit</code> 退出 REPL 界面<ul><li>按住 control 键不要放开, 然后按两下 c 键</li></ul></li></ol><p><img src="/2022/10/30/1593064784100724736/images/image-20221024220716342.png" alt="image-20221024220716342"></p><h3 id="node执行js文件方式-掌握"><a href="#node执行js文件方式-掌握" class="headerlink" title="node执行js文件方式(掌握)"></a>node执行js文件方式(掌握)</h3><ul><li>创建js文件 <code>helloworld.js</code></li></ul><ul><li>写nodejs的内容：<code>console.log(&#39;hello nodejs&#39;)</code></li><li>打开命令窗口 <code>cmd</code><ul><li>shift加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li><li>给vscode安装<code>terminal</code>插件，直接在vscode中执行</li></ul></li><li>执行命令：<code>node helloworld.js</code></li></ul><p>注意：<strong style="color:red">在nodejs中是无法使用DOM和BOM的内容的，因此<code>document, window</code>等内容是无法使用的。</strong></p><h2 id="node常用模块"><a href="#node常用模块" class="headerlink" title="node常用模块"></a>node常用模块</h2><h3 id="global模块-全局变量"><a href="#global模块-全局变量" class="headerlink" title="global模块(全局变量)"></a>global模块(全局变量)</h3><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p><p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 <code>global</code>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p><p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p><p>常用的global属性</p><pre><code class="js">console: //用于打印日志setTimeout/clearTimeout: //设置清除延时器setInterval/clearInterval: //设置清除定时器__dirname: //当前文件的路径，不包括文件名__filename： //获取当前文件的路径，包括文件名//与模块化相关的，模块化的时候会用到requireexportsmodule</code></pre><h3 id="fs模块-操作文件"><a href="#fs模块-操作文件" class="headerlink" title="fs模块(操作文件)"></a>fs模块(操作文件)</h3><blockquote><p>fs模块是nodejs中最常用的一个模块，因此掌握fs模块非常的有必要，fs模块的方法非常多,用到了哪个查哪个即可。</p><p>文档地址：<a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p></blockquote><p>  在nodejs中，提供了fs模块，这是node的核心模块</p><p>  注意：</p><ol><li>除了global模块中的内容可以直接使用，其他<strong style="color:red">模块都是需要加载的</strong>。</li><li>fs模块不是全局的，不能直接使用。因此需要导入才能使用。</li></ol><pre><code class="js">let fs = require(&quot;fs&quot;);</code></pre><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><blockquote><p>语法：fs.readFile(path[,options], callback</p><p>path: 带文件名称的文件路径</p><p>options： 文件编码(可选) 若不传则返回buffer对象</p><p>callback(err,data):   文件读完的回调</p></blockquote><p>方式1：不传编码参数,回调函数中可以得到buffer对象,需要使用toString转化成字符串</p><pre><code class="js">let fs = require(&#39;fs&#39;)fs.readFile(&#39;1.txt&#39;,(err,data) =&gt; &#123;    console.log(data) //打印buffer对象    console.log(data.toString()) //正常打印字符串&#125;)</code></pre><p>方式2： 传编码参数,回调函数中可以得到读取到的字符串</p><pre><code class="js">let fs = require(&#39;fs&#39;)fs.readFile(&#39;1.txt&#39;,&#39;utf-8&#39;,(err,data) =&gt; &#123;    console.log(&#39;data :&gt;&gt; &#39;, data);&#125;)</code></pre><p>关于Buffer对象</p><pre><code>1. Buffer对象是Nodejs用于处理二进制数据的。2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制。3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象4. Buffer对象可以调用toString()方法转换成字符串。</code></pre><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><blockquote><p>语法：fs.writeFile(filepath, data[, options], callback)</p><p>filepath：带文件名称的文件路径</p><p>data： 要写入的文件内容</p><p>callback(err)： 写入成功之后的回调</p></blockquote><p>注意：此方式会把之前文件的内容覆盖</p><pre><code class="js">let fs = require(&#39;fs&#39;)fs.writeFile(&#39;2.txt&#39;,&#39;node写文件&#39;,err =&gt; &#123;    console.log(&#39;写入成功！&#39;)&#125;)</code></pre><h4 id="追加文件"><a href="#追加文件" class="headerlink" title="追加文件"></a>追加文件</h4><blockquote><p>语法：fs.appendFile(filepath, data[, options], callback)</p><p>filepath：带文件名称的文件路径</p><p>data： 要追加的文件内容</p><p>callback(err)： 追加成功之后的回调</p></blockquote><pre><code class="js">let fs = require(&#39;fs&#39;)fs.appendFile(&#39;2.txt&#39;,&#39;我是追加的&#39;,err =&gt; &#123;    console.log(&#39;追加成功！&#39;)&#125;)</code></pre><p>思考：如果没有appendFile，通过readFile与writeFile应该怎么实现？</p><pre><code>先把之前的内容readFile读取再将之前的内容+新内容拼串最后把拼接好的内容通过writeFile写入文件</code></pre><h4 id="文件的同步与异步"><a href="#文件的同步与异步" class="headerlink" title="文件的同步与异步"></a>文件的同步与异步</h4><blockquote><p>fs中所有的文件操作，都提供了异步和同步两种方式</p></blockquote><p>异步方式：不会阻塞代码的执行</p><pre><code class="js">//异步方式var fs = require(&quot;fs&quot;);console.log(111);fs.readFile(&quot;2.txt&quot;, &quot;utf8&quot;, function(err, data)&#123;  if(err) &#123;    return console.log(&quot;读取文件失败&quot;, err);  &#125;  console.log(data);&#125;);console.log(&quot;222&quot;);</code></pre><p>同步方式：会阻塞代码的执行</p><pre><code class="js">//同步方式console.log(111);var result = fs.readFileSync(&quot;2.txt&quot;, &quot;utf-8&quot;);console.log(result);console.log(222);</code></pre><p><strong style="color:red">总结</strong>：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p><h4 id="其他api（了解）"><a href="#其他api（了解）" class="headerlink" title="其他api（了解）"></a>其他api（了解）</h4><p>方法有很多，但是用起来都非常的简单，学会查文档。文档：<a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>fs.readFile(path, callback)</code></td><td>读取文件内容（异步）</td></tr><tr><td><code>fs.readFileSync(path)</code></td><td>读取文件内容（同步）</td></tr><tr><td><code>fs.writeFile(path, data, callback)</code></td><td>写入文件内容（异步）</td></tr><tr><td><code>fs.writeFileSync(path, data)</code></td><td>写入文件内容（同步）</td></tr><tr><td><code>fs.appendFile(path, data, callback)</code></td><td>追加文件内容（异步）</td></tr><tr><td><code>fs.appendFileSync(path, data)</code></td><td>追加文件内容（同步）</td></tr><tr><td><code>fs.rename(oldPath, newPath, callback)</code></td><td>重命名文件（异步）</td></tr><tr><td><code>fs.renameSync(oldPath, newPath)</code></td><td>重命名文件（同步）</td></tr><tr><td><code>fs.unlink(path, callback)</code></td><td>删除文件（异步）</td></tr><tr><td><code>fs.unlinkSync(path)</code></td><td>删除文件（同步）</td></tr><tr><td><code>fs.mkdir(path, mode, callback)</code></td><td>创建文件夹（异步）</td></tr><tr><td><code>fs.mkdirSync(path, mode)</code></td><td>创建文件夹（同步）</td></tr><tr><td><code>fs.rmdir(path, callback)</code></td><td>删除文件夹（异步）</td></tr><tr><td><code>fs.rmdirSync(path)</code></td><td>删除文件夹（同步）</td></tr><tr><td><code>fs.readdir(path, option, callback)</code></td><td>读取文件夹内容（异步）</td></tr><tr><td><code>fs.readdirSync(path, option)</code></td><td>读取文件夹内容（同步）</td></tr><tr><td><code>fs.stat(path, callback)</code></td><td>查看文件状态（异步）</td></tr><tr><td><code>fs.statSync(path)</code></td><td>查看文件状态（同步）</td></tr></tbody></table><h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><h4 id="创建服务器基本步骤"><a href="#创建服务器基本步骤" class="headerlink" title="创建服务器基本步骤"></a>创建服务器基本步骤</h4><pre><code class="js">//1. 导入http模块，http模块是node的核心模块，作用是用来创建http服务器的。let http = require(&quot;http&quot;);//2. 创建服务器-createServer方法let server = http.createServer();//3. 服务器处理请求-on监听request事件server.on(&quot;request&quot;, function() &#123;  console.log(&quot;我接收到请求了&quot;);&#125;);//4. 启动服务器，监听某个端口-通过listen监听某个端口来启动服务server.listen(9999, function()&#123;  console.log(&quot;服务器启动成功了, 请访问： http://localhost:9999&quot;);&#125;);</code></pre><p>详细说明</p><ol><li>给服务器注册request事件，只要服务器接收到了客户端的请求，就会触发request事件</li><li>request事件有两个参数，request表示请求对象，可以获取所有与请求相关的信息，response是响应对象，可以获取所有与响应相关的信息。</li><li>服务器监听的端口范围为：1-65535之间，推荐使用3000以上的端口，因为3000以下的端口一般留给系统使用</li></ol><h4 id="request对象详解"><a href="#request对象详解" class="headerlink" title="request对象详解"></a>request对象详解</h4><p>文档地址：<a href="http://nodejs.cn/api/http.html#http_message_headers">http://nodejs.cn/api/http.html#http_message_headers</a></p><p>常见属性：</p><pre><code class="javascript">method： 请求的方式url： 请求的地址headers: 所有的请求头信息rawHeaders： 所有的请求头信息（数组的方式）</code></pre><p>例如</p><pre><code class="js">let http = require(&#39;http&#39;)let server = http.createServer()server.on(&#39;request&#39;,(request,response) =&gt; &#123;    let &#123;method,url&#125; = request    console.log(&#39;method :&gt;&gt; &#39;, method);    console.log(&#39;url :&gt;&gt; &#39;, url);&#125;)server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))</code></pre><p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求。</p><p>小结：request对象中，常用的就是<code>method</code>和<code>url</code>两个参数</p><h4 id="response对象详解"><a href="#response对象详解" class="headerlink" title="response对象详解"></a>response对象详解</h4><p>文档地址：<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p><p>常见的属性和方法：</p><pre><code class="javascript">res.write(data): 给浏览器发送请求体，可以调用多次，从而提供连续的请求体res.end();   通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成。res.end(data); 结束请求，并且响应一段内容，相当于res.write(data) + res.end()res.statusCode: 响应的的状态码 200 404 500res.statusMessage: 响应的状态信息， OK Not Found ,会根据statusCode自动设置。res.setHeader(name, value); 设置响应头信息， 比如content-typeres.writeHead(statusCode, statusMessage, options); 设置响应头，同时可以设置状态码和状态信息。</code></pre><p><strong>注意：必须先设置响应头，才能设置响应体。</strong> </p><p>案例</p><pre><code class="js">let http = require(&#39;http&#39;)let server = http.createServer()server.on(&#39;request&#39;,(req,res) =&gt; &#123;    // res.writeHead(200,&#123;&#39;content-type&#39;: &#39;application/json&#39;&#125;)    // res.write(JSON.stringify(&#123;name: &#39;tom&#39; , age: 18&#125;))    // res.end()    //res.setHeader(&#39;content-type&#39;, &#39;application/json&#39;)    res.end(JSON.stringify(&#123;name: &#39;jerry&#39; , age: 18&#125;))&#125;)server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))</code></pre><h4 id="根据不同请求输出不同响应数据"><a href="#根据不同请求输出不同响应数据" class="headerlink" title="根据不同请求输出不同响应数据"></a>根据不同请求输出不同响应数据</h4><ul><li><a href="http://nodejs.cn/api/http.html#http_message_url">request.url</a></li><li><code>req.url</code>：获取请求路径<ul><li>例如：请求<code>http://127.0.0.1:3000/index</code> 获取到的是：<code>/index</code></li><li>例如：请求<code>http://127.0.0.1:3000/</code> 获取到的是：<code>/</code></li><li>例如：请求<code>http://127.0.0.1:3000</code> 获取到的是：<code>/</code></li></ul></li></ul><pre><code class="js">let http = require(&#39;http&#39;)let server = http.createServer()server.on(&#39;request&#39;,(req,res) =&gt; &#123;    let &#123;url&#125; = req    console.log(&#39;url :&gt;&gt; &#39;, url);    let pageName = &#39;未知页面&#39;    if(&#39;/&#39; === url)&#123;        pageName = &#39;首页&#39;    &#125;else if(&#39;/login&#39; === url)&#123;           pageName = &#39;登录页&#39;    &#125;    res.setHeader(&#39;content-type&#39;, &#39;application/json&#39;)    res.end(pageName)&#125;)server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))</code></pre><h4 id="服务器响应文件"><a href="#服务器响应文件" class="headerlink" title="服务器响应文件"></a>服务器响应文件</h4><p>浏览器中输入的URL地址，仅仅是一个标识，不与服务器中的目录一致。</p><p>也就是说：返回什么内容是由服务端的逻辑决定</p><pre><code class="js">let http = require(&#39;http&#39;)let fs = require(&#39;fs&#39;)let server = http.createServer()server.on(&#39;request&#39;,(req,res) =&gt; &#123;    let &#123;url&#125; = req    console.log(&#39;url :&gt;&gt; &#39;, url);    let pageName = &#39;error.html&#39;    if(&#39;/&#39; === url)&#123;        pageName = &#39;index.html&#39;    &#125;else if(&#39;/login&#39; === url)&#123;           pageName = &#39;login.html&#39;    &#125;    //读取不同的文件,返回    fs.readFile(`./pages/$&#123;pageName&#125;`,&#39;utf-8&#39;,(err,data) =&gt; &#123;        res.setHeader(&#39;content-type&#39;, &#39;text/html&#39;)        res.end(data)    &#125;)&#125;)server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))</code></pre><h4 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h4><ul><li>MIME(Multipurpose Internet Mail Extensions)多用途Internet邮件扩展类型 是一种表示文档性质和格式的标准化方式</li><li>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的MIME类型附加到响应对象的头部是非常重要的</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types">MIME 类型</a></li></ul><h5 id="mime模块"><a href="#mime模块" class="headerlink" title="mime模块"></a>mime模块</h5><ul><li>作用：获取文件的MIME类型</li><li>安装：<code>npm i mime</code></li></ul><pre><code class="js">let mime = require(&#39;mime&#39;)// 获取路径对应的MIME类型mime.getType(&#39;txt&#39;)                    // ⇨ &#39;text/plain&#39;// 根据MIME获取到文件后缀名mime.getExtension(&#39;text/plain&#39;)        // ⇨ &#39;txt&#39;</code></pre><h3 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h3><ul><li>说明：用于 URL 处理与解析</li><li>注意：通过url拿到的查询参数都是字符串格式</li></ul><pre><code class="js">// 导入url模块let url = require(&#39;url&#39;)// 解析 URL 字符串并返回一个 URL 对象// 第一个参数：表示要解析的URL字符串// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象let res = url.parse(&#39;http://localhost:3000/details?id=1&amp;name=jack&#39;, true)console.log(res.query) // &#123; id: &#39;1&#39;, name: &#39;jack&#39; &#125;</code></pre><h3 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h3><h4 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h4><p>语法：path.join(path1,path2…)</p><p>作用：用来拼接字符串</p><pre><code class="js">const path = require(&#39;path&#39;)//1 基本用法(掌握)const res1 = path.join(__dirname,&#39;1.txt&#39;)console.log(&#39;res1:&#39;,res1) // res1: D:\webcode\node-test\6.path模块\1.txt//2 一个../ 会抵消一个上一级目录(了解)const res2 = path.join(__dirname,&#39;../&#39;,&#39;1.txt&#39;)console.log(&#39;res2:&#39;,res2) // res2: D:\webcode\node-test\1.txt//3 ./ 会被忽略(了解)const res3 = path.join(__dirname,&#39;./&#39;,&#39;1.txt&#39;)console.log(&#39;res3:&#39;,res3) // res3: D:\webcode\node-test\6.path模块\1.txt</code></pre><h4 id="获取文件名"><a href="#获取文件名" class="headerlink" title="获取文件名"></a>获取文件名</h4><p>使用 <code>path.basename()</code> 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名</p><p>语法：path.basename(path[, ext])</p><ul><li>path: 文件路径</li><li>ext: 文件扩展名（可选）</li></ul><pre><code class="js">const path = require(&#39;path&#39;)const filepath = &#39;D:/webcode/node-test/1.txt&#39;//获取文件名带后缀console.log(path.basename(filepath))//1.txt //获取文件名不带后缀console.log(path.basename(filepath,&#39;.txt&#39;))//1 </code></pre><h4 id="获取扩展名"><a href="#获取扩展名" class="headerlink" title="获取扩展名"></a>获取扩展名</h4><p>语法：<code>path.extname(filepath)</code></p><pre><code class="js">const filepath = &#39;D:/webcode/node-test/1.txt&#39;//获取扩展名console.log(path.extname(filepath)) //.txt</code></pre><h2 id="包管理器-npm"><a href="#包管理器-npm" class="headerlink" title="包管理器-npm"></a>包管理器-npm</h2><h3 id="npm的基本概念"><a href="#npm的基本概念" class="headerlink" title="npm的基本概念"></a>npm的基本概念</h3><ul><li>node package manager</li><li><a href="https://npmjs.com/">npm官网</a></li><li><a href="https://www.npmjs.com.cn/">npm中文文档</a></li></ul><pre><code>1. npm 是node的包管理工具，2. 它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。3. 来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。npm 由三个独立的部分组成：    网站    注册表（registry）    命令行工具 (CLI)</code></pre><ul><li>作用：通过<code>npm</code>来快速安装开发中使用的包</li><li>npm不需要安装，只要安装了node，就自带了<code>npm</code></li></ul><h3 id="npm基本使用"><a href="#npm基本使用" class="headerlink" title="npm基本使用"></a>npm基本使用</h3><ul><li>初始化包</li></ul><pre><code class="js">npm init;    //这个命令用于初始化一个包，创建一个package.json文件，我们的项目都应该先执行npm initnpm init -y;  //快速的初始化一个包， 不能是一个中文名</code></pre><ul><li>安装包</li></ul><pre><code class="js">npm install 包名;  //安装指定的包名的最新版本到项目中npm install 包名@版本号;  //安装指定包的指定版本npm i 包名； //简写</code></pre><ul><li>卸载包</li></ul><pre><code class="js">npm uninstall 包名;  //卸载已经安装的包npm uni 包名；//简写</code></pre><h3 id="本地安装和全局安装"><a href="#本地安装和全局安装" class="headerlink" title="本地安装和全局安装"></a>本地安装和全局安装</h3><p>有两种方式用来安装 npm 包：本地安装和全局安装。选用哪种方式来安装，取决于你如何使用这个包。 </p><ul><li>全局安装：如果你想将其作为一个命令行工具，那么你应该将其安装到全局。这种安装方式后可以让你在任何目录下使用这个命令。比如less命令，webpack命令。</li><li>本地安装：如果你自己的模块依赖于某个包，并通过 Node.js 的 <code>require</code> 加载，那么你应该选择本地安装，这种方式也是 <code>npm install</code> 命令的默认行为。</li></ul><pre><code class="js">// 全局安装,会把npm包安装到C:\Users\cc\AppData\Roaming\npm目录下，作为命令行工具使用npm install -g 包名;//本地安装，会把npm包安装到当前项目的node_modules文件中，作为项目的依赖npm install 包名;  </code></pre><h3 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h3><p>package.json文件，包（项目）描述文件，用来管理组织一个包（项目），它是一个纯JSON格式的。</p><ul><li>作用：描述当前项目（包）的信息，描述当前包（项目）的依赖项</li><li>如何生成：<code>npm init</code>或者<code>npm init -y</code></li><li>作用<ul><li>作为一个标准的包，必须要有<code>package.json</code>文件进行描述</li><li>一个项目的node_modules目录通常都会很大，不用拷贝node_modules目录，可以通过package.json文件配合<code>npm install</code>直接安装项目所有的依赖项</li></ul></li><li>描述内容</li></ul><pre><code class="js">&#123;  &quot;name&quot;: &quot;03-npm&quot;,  //描述了包的名字，不能有中文  &quot;version&quot;: &quot;1.0.0&quot;,  //描述了包的的版本信息， x.y.z  如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。  &quot;description&quot;: &quot;&quot;, //包的描述信息  &quot;main&quot;: &quot;index.js&quot;, //入口文件（模块化加载规则的时候详细的讲）  &quot;scripts&quot;: &#123;  //配置一些脚本，在vue的时候会用到，现在体会不到    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;keywords&quot;: [],  //关键字（方便搜索）  &quot;author&quot;: &quot;&quot;,  //作者的信息  &quot;license&quot;: &quot;ISC&quot;,  //许可证，开源协议  &quot;dependencies&quot;: &#123;   //重要，项目的依赖， 方便代码的共享  通过 npm install可以直接安装所有的依赖项    &quot;bootstrap&quot;: &quot;^3.3.7&quot;,    &quot;jquery&quot;: &quot;^3.3.1&quot;  &#125;&#125;</code></pre><p><strong>注意：一个合法的package.json，必须要有name和version两个属性</strong> </p><p>如果安装失败， 可以通过以下命令清除npm缓存：</p><pre><code class="js">npm cache clean -f  // -f强制清除</code></pre><h3 id="npm下载加速-nrm"><a href="#npm下载加速-nrm" class="headerlink" title="npm下载加速-nrm"></a>npm下载加速-nrm</h3><ul><li>nrm：npm registry manager（npm仓库地址管理工具）</li><li>安装：<code>npm i -g nrm</code></li></ul><pre><code class="bash"># 带*表示当前正在使用的地址# 查看仓库地址列表nrm ls# 切换仓库地址nrm use taobao</code></pre><h2 id="nodemon-自动重启"><a href="#nodemon-自动重启" class="headerlink" title="nodemon 自动重启"></a>nodemon 自动重启</h2><ul><li>作用：监视到js文件修改后，自动重启node程序</li><li>安装：<code>npm i -g nodemon</code></li><li>使用：<code>nodemon app.js</code> 运行node程序</li></ul><h2 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art-template 模板引擎"></a>art-template 模板引擎</h2><ul><li><a href="https://aui.github.io/art-template/zh-cn/docs/">文档</a></li><li>安装： <code>npm install art-template</code></li></ul><ul><li>核心方法</li></ul><pre><code class="js">// 基于模板路径渲染模板//参数1：文件的路径//参数2：数据//返回值：返回渲染后的内容// template(filename, data)let html = template(path.join(__dirname, &quot;pages&quot;, &quot;index.html&quot;), &#123;name:&quot;大吉大利，今晚吃鸡&quot;&#125;);</code></pre><p><strong>注意点：文件的路径必须是绝对路径</strong></p><h2 id="服务端重定向"><a href="#服务端重定向" class="headerlink" title="服务端重定向"></a>服务端重定向</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 状态码说明</a></li><li><a href="http://shuai.be/archives/301-302-redirection/">301 和 302</a></li><li>说明：服务端可以通过HTTP状态码让浏览器中的页面重定向</li></ul><pre><code class="js">res.writeHead(302, &#123;  &#39;Location&#39;: &#39;/&#39;&#125;)res.end()</code></pre><h2 id="post请求参数处理"><a href="#post请求参数处理" class="headerlink" title="post请求参数处理"></a>post请求参数处理</h2><p>说明：POST请求可以发送大量数据，没有大小限制</p><pre><code class="js">// 接受POST参数var postData = []// 给req注册一个data事件， 只要浏览器给服务器发送post请求，data事件就会触发// post请求发送的数据量可以很大， 这个data事件会触发多次，一块一块的传输// 要把所有的chunk都拼接起来// data事件：用来接受客户端发送过来的POST请求数据var result = &quot;&quot;;req.on(&#39;data&#39;, function (chunk) &#123;  result += chunk;&#125;)// end事件：当POST数据接收完毕时，触发req.on(&#39;end&#39;, function () &#123;  cosnole.log(result); &#125;)</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化规范：</p><ul><li>AMD:  requirejs</li><li>CMD:  seajs  玉伯  浏览器端的模块 </li><li>commonJS： nodejs  服务端的模块</li></ul><blockquote><p>在nodejs中，应用由模块组成，nodejs中采用commonJS模块规范。</p></blockquote><ol><li>一个js文件就是一个模块</li><li>每个模块都是一个独立的作用域，在这个而文件中定义的变量、函数、对象都是私有的，对其他文件不可见。</li></ol><h3 id="node模块分类"><a href="#node模块分类" class="headerlink" title="node模块分类"></a>node模块分类</h3><ul><li><p>1 核心模块</p><ul><li>由 node 本身提供，不需要单独安装（npm），可直接引入使用。例如：fs模块、path模块等</li></ul></li><li><p>2 第三方模块</p><ul><li>由社区或个人提供，需要通过npm安装后使用。</li></ul></li><li><p>3 自定义模块</p><ul><li><p>由开发人员创建的模块（JS文件）</p></li><li><p>基本使用：1 创建模块 2 引入模块</p></li><li><p>注意：自定义模块的路径必须以<code>./</code>获取<code>../</code>开头</p></li><li><pre><code class="js">// 加载模块require(&#39;./a&#39;)     // 推荐使用，省略.js后缀！require(&#39;./a.js&#39;)</code></pre></li></ul></li></ul><h3 id="模块的导入导出"><a href="#模块的导入导出" class="headerlink" title="模块的导入导出"></a>模块的导入导出</h3><h4 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h4><ul><li>通过<code>require(&quot;fs&quot;)</code>来加载模块</li><li>如果是第三方模块，需要先使用npm进行下载</li><li>如果是自定义模块，需要加上相对路径<code>./</code>或者<code>../</code>,可以省略<code>.js</code>后缀，如果文件名是<code>index.js</code>那么index.js也可以省略。</li><li>模块可以被多次导入，但是<code>只会在第一次加载</code></li></ul><h4 id="模块导出"><a href="#模块导出" class="headerlink" title="模块导出"></a>模块导出</h4><p>在模块的内部，<strong style="color:red">module变量代表的就是当前模块</strong>，它的<code>exports</code>属性就是对外的接口，加载某个模块，加载的就是<code>module.exports</code>属性，这个属性指向一个空的对象。</p><pre><code class="js">//module.exports指向的是一个对象，我们给对象增加属性即可。//module.exports.num = 123;//module.exports.age = 18;//通过module.exports也可以导出一个值，但是多次导出会覆盖module.exports = &#39;123&#39;;module.exports = &quot;abc&quot;;</code></pre><h4 id="module-exports与exports"><a href="#module-exports与exports" class="headerlink" title="module.exports与exports"></a>module.exports与exports</h4><ul><li><code>exports</code> 是 <code>module.exports</code> 的引用</li><li>注意：给 <code>module.exports</code> 赋值会<code>切断</code>与 <code>exports</code> 之间的联系<ul><li>1 直接添加属性两者皆可</li><li>2 赋值操作时，只能使用 <code>module.exports</code></li></ul></li></ul><pre><code class="js">console.log( module.exports === exports ) // ==&gt; true// 等价操作module.exports.num = 123exports.num = 123// 赋值操作：不要使用 exports = &#123;&#125;module.exports = &#123;&#125;</code></pre><h4 id="第三方模块代码执行流程-了解"><a href="#第三方模块代码执行流程-了解" class="headerlink" title="第三方模块代码执行流程(了解)"></a>第三方模块代码执行流程(了解)</h4><p>以mime包为例</p><ul><li>先基于当前文件模块所属目录找 node_modules 目录</li><li>如果找到，则去该目录中找 mime 目录</li><li>如果找到 mime 目录，则找该目录中的 package.json 文件</li><li>如果找到 package.json 文件，则找该文件中的 main 属性</li><li>如果找到 main 属性，则拿到该属性对应的文件路径</li><li>如果找到 mime 目录之后<ul><li>发现没有 package.json</li><li>或者 有 package.json 没有 main 属性</li><li>或者 有 main 属性，但是指向的路径不存在</li><li>则 node 会默认去看一下 mime 目录中有没有 index.js index.node index.json 文件</li></ul></li><li>如果找不到 index 或者找不到 mime 或者找不到 node_modules</li><li>则进入上一级目录找 node_moudles 查找规则同上</li><li>如果上一级还找不到，继续向上，一直到当前文件所属磁盘根目录</li><li>如果最后到磁盘根目录还找不到，最后报错：<code>can not find module xxx</code></li></ul><h3 id="CommonJS-规范参考文档"><a href="#CommonJS-规范参考文档" class="headerlink" title="CommonJS 规范参考文档"></a>CommonJS 规范参考文档</h3><ul><li><a href="http://nodejs.cn/api/modules.html">module (模块)</a></li><li><a href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS规范</a></li><li><a href="http://www.jianshu.com/p/09ffac7a3b2c">浅析JS模块规范：AMD，CMD，CommonJS</a></li></ul><h2 id="node操作mysql数据库"><a href="#node操作mysql数据库" class="headerlink" title="node操作mysql数据库"></a>node操作mysql数据库</h2><p>数据库准备：</p><p>1.安装mysql5数据库</p><p>2.在mysql中创建nodedb这个数据库（可利用Navicat图形工具）</p><p>3.在nodedb数据库中添加users表 （可利用Navicat图形工具）</p><p>建表sql语句如下：</p><pre><code class="sql">SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for users-- ----------------------------DROP TABLE IF EXISTS `users`;CREATE TABLE `users`  (  `id` int(11) NOT NULL AUTO_INCREMENT,  `username` varchar(255) ,  `password` varchar(255) ,  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;SET FOREIGN_KEY_CHECKS = 1;</code></pre><h3 id="配置-mysql-模块"><a href="#配置-mysql-模块" class="headerlink" title="配置 mysql 模块"></a>配置 mysql 模块</h3><ol><li>安装 mysql 模块</li></ol><pre><code class="bash">npm install mysql</code></pre><ol start="2"><li>建立连接</li></ol><pre><code class="js">const mysql = require(&#39;mysql&#39;)const db = mysql.createPool(&#123;  host: &#39;127.0.0.1&#39;,  user: &#39;root&#39;, //mysql账号  password: &#39;root&#39;,//mysql密码  database: &#39;nodedb&#39;, //自己创建的mysql库 &#125;)</code></pre><ol start="3"><li>测试是否正常工作</li></ol><pre><code class="js">db.query(&#39;select 1&#39;, (err, results) =&gt; &#123;  if (err) console.log(err.message)  console.log(results)&#125;)</code></pre><h3 id="node操作mysql增删改查"><a href="#node操作mysql增删改查" class="headerlink" title="node操作mysql增删改查"></a>node操作mysql增删改查</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>第一种添加方式：</p><pre><code class="js">//1.准备数据const &#123;name,username,password&#125; = &#123;name: &#39;汤姆&#39;, username: &#39;tom&#39;, password: &#39;123&#39;&#125;//2.准备sql ?标识占位符const sqlStr = &#39;insert into users (name,username, password) values(?,?,?)&#39;//3.执行sql 参数1：sql字符串  参数2：占位符对应的数据 参数3：插入之后的回调db.query(sqlStr,[name,username,password],(err,res) =&gt; &#123;  if(err) console.log(&#39;err :&gt;&gt; &#39;, err);  console.log(&#39;res :&gt;&gt; &#39;, res);  if(res.affectedRows == 1) console.log(&#39;插入成功！&#39;)&#125;)</code></pre><p>第二种添加方式：向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据：</p><pre><code class="js">const obj = &#123;name: &#39;汤姆&#39;, username: &#39;tom&#39;, password: &#39;123&#39;&#125;db.query(&#39;insert into  users set ?&#39;,obj,(err,res) =&gt; &#123;   if(err) console.log(&#39;err :&gt;&gt; &#39;, err)   console.log(&#39;res :&gt;&gt; &#39;, res);   if(res.affectedRows == 1) console.log(&#39;插入成功11！&#39;)&#125;)</code></pre><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code class="js">//查询数据db.query(&#39;select * from users&#39;,(err,res) =&gt; &#123;  console.log(&#39;res :&gt;&gt; &#39;, res);&#125;)</code></pre><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><pre><code class="js">const &#123;username,password,name,id&#125; = &#123;id: 3, name: &#39;杰瑞&#39;, username: &#39;jerry&#39;, password: &#39;456&#39;&#125;const sqlStr = &#39;update users set username=?,password=?,name=? where id=?&#39;db.query(sqlStr,[username,password,name,id],(err,res) =&gt; &#123;//注意第二个参数的顺序   if(err) console.log(&#39;err :&gt;&gt; &#39;, err)   if(res.affectedRows == 1) console.log(&#39;修改成功！&#39;)&#125;)</code></pre><p>快捷修改方式</p><pre><code class="js">const obj = &#123;id: 3, name: &#39;杰瑞1&#39;, username: &#39;jerry1&#39;, password: &#39;4516&#39;&#125;const sqlStr = &#39;update users set ? where id=?&#39;db.query(sqlStr,[obj,obj.id],(err,res) =&gt; &#123;//注意第二个参数的顺序  if(err) console.log(&#39;err :&gt;&gt; &#39;, err)  if(res.affectedRows == 1) console.log(&#39;修改成功！&#39;)&#125;)</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre><code class="js">db.query(&#39;delete from users where id=?&#39;,[1],(err,res) =&gt; &#123;  if(res.affectedRows == 1) console.log(&#39;删除成功！&#39;)&#125;)</code></pre><h2 id="node操作mongodb数据库"><a href="#node操作mongodb数据库" class="headerlink" title="node操作mongodb数据库"></a>node操作mongodb数据库</h2><p>安装：<code>npm i  mongodb</code></p><pre><code class="js">// 导入 mongodb，并获取到客户端对象const MongoClient = require(&#39;mongodb&#39;).MongoClient// 连接数据库服务地址const url = &#39;mongodb://localhost:27017&#39;// 连接数据库MongoClient.connect(url, function (err, client) &#123;  if (err) &#123;    return console.log(&#39;链接数据库失败&#39;, err)  &#125;  console.log(&#39;数据库链接成功&#39;);  // 获取集合对象  const db = client.db(&#39;nodedb&#39;)  // 关闭数据库链接  client.close()&#125;)</code></pre><h3 id="数据增删改查"><a href="#数据增删改查" class="headerlink" title="数据增删改查"></a>数据增删改查</h3><ul><li>添加数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)// 添加db.collection(&#39;users&#39;)  // 添加一条数据  .insert(&#123;name: &#39;rose&#39;, age: 19&#125;, function (err, data) &#123;    console.log(data);  &#125;)  // 添加多条数据  .insertMany([&#123; name: &#39;tom&#39;, age: 20 &#125;, &#123; name: &#39;jerry&#39;, age: 21 &#125;], function (err, data) &#123;    console.log(data);  &#125;)</code></pre><ul><li>查询数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)// 查询db.collection(&#39;users&#39;).find().toArray(function (err, data) &#123;  console.log(data)&#125;)</code></pre><ul><li>修改数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)db.collection(&#39;users&#39;).update(&#123; name: &#39;tom&#39; &#125;, &#123; $set: &#123; age: 22 &#125; &#125;, function (err, result) &#123;    console.log(result);  &#125;)</code></pre><ul><li>删除数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)db.collection(&#39;users&#39;)  // 删除一条数据：  .deleteOne(&#123;name: &#39;rose&#39;&#125;, function (err, result) &#123;    console.log(result);  &#125;)  // 删除多条数据：  .deleteMany(&#123;age: &#123;$lt: 20&#125;&#125;, function (err, result) &#123;    console.log(result);  &#125;)</code></pre><h2 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>安装express</li></ul><pre><code class="bash">npm i express</code></pre><ul><li>案例</li></ul><pre><code class="js">// 导入 expressvar express = require(&#39;express&#39;)// 创建 express实例，也就是创建 express服务器var app = express()// 路由app.get(&#39;/&#39;, function (req, res) &#123;  res.send(&#39;Hello World!&#39;)&#125;)// 启动服务器app.listen(3000, function () &#123;  console.log(&#39;服务器已启动&#39;)&#125;)</code></pre><p>参数说明</p><ul><li><code>express()</code>：创建一个Express应用，并返回，即：app</li><li><code>app.get()</code>：注册一个GET类型的路由<ul><li>注意：只要注册了路由，所有的请求都会被处理（未配置的请求路径，响应404）</li></ul></li><li><code>res.send()</code>：发送数据给客户端，并自动设置Content-Type<ul><li>参数可以是：字符串、数组、对象、Buffer</li><li>注意：只能使用一次</li></ul></li><li><code>req</code> 和 <code>res</code>：与http模块中的作用相同，是扩展后的请求和响应对象</li></ul><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ul><li>通过 <code>express.static()</code> 方法可创建静态资源服务器，向外开放访问静态资源。</li><li>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，<strong style="color:red">存放静态文件的目录名不会出现在 URL 中</strong></li><li>访问静态资源时，会根据托管顺序查找文件</li><li>可为静态资源访问路径添加前缀</li></ul><pre><code class="js">app.use(express.static(&#39;static&#39;))app.use(&#39;/web&#39;, express.static(&#39;web&#39;))//可直接访问 static 目录下的静态资源http://localhost:3000/img/2.jpg//通过带有 /web 前缀的地址访问 bruce 目录下的文件http://localhost:8080/web/img/1.jpg</code></pre><h3 id="request和response"><a href="#request和response" class="headerlink" title="request和response"></a>request和response</h3><h4 id="request常用方法"><a href="#request常用方法" class="headerlink" title="request常用方法"></a>request常用方法</h4><ul><li>query属性：获取get请求参数，是一个对象</li></ul><pre><code class="js">//传参：http://localhost:8088/user?name=jerry&amp;age=18//处理请求app.get(&#39;/user&#39;,(req,resp) =&gt; &#123;    resp.send(req.query)//将get参数直接返回&#125;)</code></pre><ul><li>body：获取POST请求参数，需要配置<code>body-parser</code>模块， POST请求参数</li></ul><pre><code class="js">//导入bodyParser模块const bodyParser = require(&#39;body-parser&#39;)//将POST请求参数转化为对象，存储到req.body中 (application/x-www-form-urlencoded方式)app.use(bodyParser.urlencoded(&#123; extended: true &#125;))app.post(&#39;/user&#39;,(req,resp) =&gt; &#123;    resp.send(req.body)//将post参数直接返回&#125;)</code></pre><ul><li>params：获取restful风格的参数</li></ul><pre><code class="js">//传参：http://localhost:8088/user/jerry/19app.put(&#39;/user/:name/:age&#39;,(req,resp) =&gt; &#123;    resp.send(req.params)//将restful参数直接返回&#125;)</code></pre><h4 id="response常用方法"><a href="#response常用方法" class="headerlink" title="response常用方法"></a>response常用方法</h4><pre><code class="js">// send() 发送数据给客户端，并自动设置Content-Typeres.send()// 发送文件给浏览器，并根据文件后缀名自动设置Content-Type// 注意：文件路径必须是绝对路径res.sendFile(path.join(__dirname, &#39;index.html&#39;))// 设置HTTP响应码res.status(200)；// 设置响应头res.set(&#39;Content-Type&#39;, &#39;text/plain&#39;)res.set(&#123;  &#39;Content-Type&#39;: &#39;text/plain&#39;,  &#39;cute&#39;: &#39;fangfang&#39;&#125;)// 重定向res.redirect(&#39;/index&#39;)</code></pre><h3 id="expres中使用art-template"><a href="#expres中使用art-template" class="headerlink" title="expres中使用art-template"></a>expres中使用art-template</h3><p>安装</p><pre><code class="bash">npm install art-template npm install express-art-template</code></pre><p>给express绑定一个模版引擎</p><pre><code class="js">//给express设置模版引擎//参数1： 模版引擎的后缀名，  以后的模版文件都应该是 html结尾//参数2： 使用什么模版引擎app.engine(&quot;html&quot;, require(&#39;express-art-template&#39;))</code></pre><p>通过<code>res.render()</code>渲染模版引擎</p><pre><code class="js">//参数1； 模版文件的路径,相对路径，回去views目录下查找//参数2： 数据res.render(path.join(__dirname, &quot;index.html&quot;), &#123;name:&quot;zs&quot;&#125;)</code></pre><p>关于模版引擎的配置（了解）</p><pre><code class="js">//模版文件默认去aa目录下查找  默认值：  viewsapp.set(&quot;views&quot;, &quot;aa&quot;);//设置模板引擎的默认后缀app.set(&quot;view engine&quot;, &quot;html&quot;);</code></pre><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>创建路由模块：</p><pre><code class="js">// router.jsconst express = require(&#39;express&#39;)// 创建路由对象const router = express.Router()// 挂载具体路由router.get(&#39;/user/list&#39;, (req, res) =&gt; &#123;  res.send(&#39;Get user list.&#39;)&#125;)router.post(&#39;/user/add&#39;, (req, res) =&gt; &#123;  res.send(&#39;Add new user.&#39;)&#125;)// 向外导出路由对象module.exports = router</code></pre><p>注册路由模块：</p><pre><code class="js">const express = require(&#39;express&#39;)const router = require(&#39;./router&#39;)const app = express()// 注册路由模块，添加访问前缀app.use(&#39;/api&#39;, router) //测试时记得代码 /api 前缀app.listen(8088, () =&gt; &#123;  console.log(&#39;http://127.0.0.1&#39;)&#125;)</code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li>中间件是指流程的中间处理环节</li><li>服务器收到请求后，可先调用中间件进行预处理(比如登录拦截、错误拦截等)</li><li>中间件是一个函数，包含 <code>req, res, next</code> 三个参数，<code>next()</code> 参数把流转关系交给下一个中间件或路由</li></ul><p>中间件注意事项；</p><ul><li>在注册路由之前注册中间件（错误级别中间件除外）</li><li>中间件可连续调用多个</li><li>别忘记调用 <code>next()</code> 函数</li><li><code>next()</code> 函数后别写代码</li><li>多个中间件共享 <code>req</code>、 <code>res</code>对象</li></ul><h4 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h4><ul><li>通过 <code>app.use()</code> 定义的中间件为全局中间件</li></ul><pre><code class="js">const express = require(&#39;express&#39;)const app = express()// 定义第一个全局中间件app.use((req, res, next) =&gt; &#123;  console.log(&#39;调用了第1个全局中间件&#39;)  next()&#125;)// 定义第二个全局中间件app.use((req, res, next) =&gt; &#123;  console.log(&#39;调用了第2个全局中间件&#39;)  next()&#125;)app.get(&#39;/user&#39;, (req, res) =&gt; &#123;  res.send(&#39;User page.&#39;)&#125;)app.listen(80, () =&gt; &#123;  console.log(&#39;http://127.0.0.1&#39;)&#125;)</code></pre><h4 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h4><pre><code class="js">const express = require(&#39;express&#39;)const app = express()// 定义中间件函数const mw1 = (req, res, next) =&gt; &#123;  console.log(&#39;调用了第一个局部生效的中间件&#39;)  next()&#125;const mw2 = (req, res, next) =&gt; &#123;  console.log(&#39;调用了第二个局部生效的中间件&#39;)  next()&#125;// 两种定义局部中间件的方式app.get(&#39;/hello&#39;, mw2, mw1, (req, res) =&gt; res.send(&#39;hello page.&#39;))app.get(&#39;/about&#39;, [mw1, mw2], (req, res) =&gt; res.send(&#39;about page.&#39;))app.get(&#39;/user&#39;, (req, res) =&gt; res.send(&#39;User page.&#39;))app.listen(80, function () &#123;  console.log(&#39;Express server running at http://127.0.0.1&#39;)&#125;)</code></pre><h4 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h4><h5 id="应用级别的中间件"><a href="#应用级别的中间件" class="headerlink" title="应用级别的中间件"></a>应用级别的中间件</h5><p>通过 <code>app.use()</code> 或 <code>app.get()</code> 或 <code>app.post()</code> ，绑定到 <code>app</code> 实例上的中间件</p><h5 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h5><p>绑定到 <code>express.Router()</code> 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 <code>app</code> 实例上，路由级别中间件绑定到 <code>router</code> 实例上。</p><pre><code class="js">const app = express()const router = express.Router()router.use(function (req, res, next) &#123;  console.log(1)  next()&#125;)app.use(&#39;/&#39;, router)</code></pre><h5 id="错误级别的中间件"><a href="#错误级别的中间件" class="headerlink" title="错误级别的中间件"></a>错误级别的中间件</h5><ul><li>用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</li><li>错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 <code>(err, req, res, next)</code> 。</li><li>错误级别的中间件必须注册在所有路由之后</li></ul><pre><code class="js">const express = require(&#39;express&#39;)const app = express()app.get(&#39;/&#39;, (req, res) =&gt; &#123;  throw new Error(&#39;服务器内部发生了错误！&#39;)  res.send(&#39;Home page.&#39;)&#125;)// 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃app.use((err, req, res, next) =&gt; &#123;  console.log(&#39;发生了错误！&#39; + err.message)  res.send(&#39;Error：&#39; + err.message)&#125;)app.listen(80, function () &#123;  console.log(&#39;Express server running at http://127.0.0.1&#39;)&#125;)</code></pre><h5 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h5><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p><ul><li><code>express.static</code> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li><li><code>express.json</code> 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li><li><code>express.urlencoded</code> 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li></ul><pre><code class="js">app.use(express.json())app.use(express.urlencoded(&#123; extended: false &#125;))</code></pre><h5 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h5><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><ul><li>CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</li><li>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</li><li>CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li><li>CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</li></ul><h4 id="CORS-常见响应头"><a href="#CORS-常见响应头" class="headerlink" title="CORS 常见响应头"></a>CORS 常见响应头</h4><ul><li><code>Access-Control-Allow-Origin</code>：制定了允许访问资源的外域 URL</li></ul><pre><code class="js">res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://bruceblog.io&#39;)res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)</code></pre><ul><li><code>Access-Control-Allow-Headers</code></li><li>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：<code>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</code></li><li>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 A<code>ccess-Control-Allow-Headers</code> 对额外的请求头进行声明，否则这次请求会失败！</li></ul><pre><code class="js">res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type, X-Custom-Header&#39;)</code></pre><ul><li><code>Access-Control-Allow-Methods</code></li><li>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 <code>Access-Control-Alow-Methods</code> 来指明实际请求所允许使用的 HTTP 方法</li></ul><pre><code class="js">res.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, GET, DELETE, HEAD&#39;)res.setHEader(&#39;Access-Control-Allow-Methods&#39;, &#39;*&#39;)</code></pre><h4 id="CORS-请求分类"><a href="#CORS-请求分类" class="headerlink" title="CORS 请求分类"></a>CORS 请求分类</h4><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><ul><li>请求方式：GET、POST、HEAD 三者之一</li><li>HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application&#x2F;x-www-formurlencoded、multipart&#x2F;form-data、text&#x2F;plain）</li></ul><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><ul><li>请求方式为 GET、POST、HEAD 之外的请求 Method 类型</li><li>请求头中包含自定义头部字段</li><li>向服务器发送了 application&#x2F;json 格式的数据</li></ul><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p><h4 id="express中使用cors"><a href="#express中使用cors" class="headerlink" title="express中使用cors"></a>express中使用cors</h4><p>安装中间件：<code>npm install cors</code><br>导入中间件：<code>const cors = require(&#39;cors&#39;)</code><br>配置中间件：<code>app.use(cors())</code></p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><h3 id="jwt认证"><a href="#jwt认证" class="headerlink" title="jwt认证"></a>jwt认证</h3><p>前后端分离推荐使用 JWT（JSON Web Token）认证机制，是目前最流行的跨域认证解决方案</p><h4 id="Session-的局限性"><a href="#Session-的局限性" class="headerlink" title="Session 的局限性"></a>Session 的局限性</h4><ul><li>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</li><li>当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。</li><li>当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制</li></ul><h4 id="JWT-工作原理图"><a href="#JWT-工作原理图" class="headerlink" title="JWT 工作原理图"></a>JWT 工作原理图</h4><p>用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p><p><img src="/2022/10/30/1593064784100724736/images/image-20221030192657149.png" alt="image-20221030192657149"></p><h4 id="JWT-组成部分"><a href="#JWT-组成部分" class="headerlink" title="JWT 组成部分"></a>JWT 组成部分</h4><ul><li>Header、Payload、Signature</li><li>Payload 是真正的用户信息，加密后的字符串</li><li>Header 和 Signature 是安全性相关部分，保证 Token 安全性</li><li>三者使用 <code>.</code> 分隔</li></ul><pre><code class="js">Header.Payload.SignatureeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTcsInVzZXJuYW1lIjoiQnJ1Y2UiLCJwYXNzd29yZCI6IiIsIm5pY2tuYW1lIjoiaGVsbG8iLCJlbWFpbCI6InNjdXRAcXEuY29tIiwidXNlcl9waWMiOiIiLCJpYXQiOjE2NDE4NjU3MzEsImV4cCI6MTY0MTkwMTczMX0.bmqzAkNSZgD8IZxRGGyVlVwGl7EGMtWitvjGD-a5U5c</code></pre><h4 id="JWT的使用方式"><a href="#JWT的使用方式" class="headerlink" title="JWT的使用方式"></a>JWT的使用方式</h4><ul><li>客户端会把 JWT 存储在 localStorage 或 sessionStorage 中</li><li>此后客户端与服务端通信需要携带 JWT 进行身份认证，将 JWT 存在 HTTP 请求头 Authorization 字段中</li><li>加上 Bearer 前缀</li></ul><pre><code class="text">Authorization: Bearer &lt;token&gt;</code></pre><h4 id="Express-使用-JWT认证"><a href="#Express-使用-JWT认证" class="headerlink" title="Express 使用 JWT认证"></a>Express 使用 JWT认证</h4><ol><li>安装：<code>jsonwebtoken</code> 用于生成 JWT 字符串;<code>express-jwt</code> 用于将 JWT 字符串解析还原成 JSON 对象</li></ol><pre><code class="bash">npm install jsonwebtoken express-jwt</code></pre><ol start="2"><li>定义 secret 密钥</li></ol><ul><li>为保证 JWT 字符串的安全性，防止其在网络传输过程中被破解，需定义用于加密和解密的 secret 密钥</li><li>生成 JWT 字符串时，使用密钥加密信息，得到加密好的 JWT 字符串</li><li>把 JWT 字符串解析还原成 JSON 对象时，使用密钥解密</li></ul><pre><code class="js">const jwt = require(&#39;jsonwebtoken&#39;)const expressJWT = require(&#39;express-jwt&#39;)// 密钥为任意字符串const secretKey = &#39;hlf&#39;</code></pre><ol start="3"><li>生成 JWT 字符串</li></ol><pre><code class="js">app.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;  ...  res.send(&#123;    status: 200,    message: &#39;登录成功&#39;,    // jwt.sign() 生成 JWT 字符串    // 参数：用户信息对象、加密密钥、配置对象-token有效期    // 尽量不保存敏感信息，因此只有用户名，没有密码    token: jwt.sign(&#123;username: userInfo.username&#125;, secretKey, &#123;expiresIn: &#39;10h&#39;&#125;)  &#125;)&#125;)</code></pre><ol start="4"><li>JWT 字符串还原为 JSON 对象</li></ol><ul><li>客户端访问有权限的接口时，需通过请求头的 <code>Authorization</code> 字段，将 Token 字符串发送到服务器进行身份认证</li><li>服务器可以通过 express-jwt 中间件将客户端发送过来的 Token 解析还原成 JSON 对象</li></ul><pre><code class="js">// unless(&#123; path: [/^\/api\//] &#125;) 指定哪些接口无需jwt认证app.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\/api\//] &#125;))</code></pre><ol start="5"><li>获取用户信息</li></ol><ul><li>当 express-jwt 中间件配置成功后，即可在那些有权限的接口中，使用 <code>req.user</code> 对象，来访问从 JWT 字符串中解析出来的用户信息</li></ul><pre><code class="js">app.get(&#39;/admin/getinfo&#39;, (req, res) =&gt; &#123;  console.log(req.user)  res.send(&#123;    status: 200,    message: &#39;获取信息成功&#39;,    data: req.user,  &#125;)&#125;)</code></pre><ol start="6"><li>捕获解析 JWT 失败后产生的错误</li></ol><ul><li>当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行</li><li>通过 Express 的错误中间件，捕获这个错误并进行相关的处理</li></ul><pre><code class="js">app.use((err, req, res, next) =&gt; &#123;  if (err.name === &#39;UnauthorizedError&#39;) &#123;    return res.send(&#123; status: 401, message: &#39;Invalid token&#39; &#125;)  &#125;  res.send(&#123; status: 500, message: &#39;Unknown error&#39; &#125;)&#125;)</code></pre><h3 id="session认证"><a href="#session认证" class="headerlink" title="session认证"></a>session认证</h3><p>服务端渲染推荐使用 Session 认证机制</p><h4 id="session认证原理"><a href="#session认证原理" class="headerlink" title="session认证原理"></a>session认证原理</h4><p><img src="/2022/10/30/1593064784100724736/images/image-20221030194211947.png" alt="image-20221030194211947"></p><h4 id="Express中使用session认证"><a href="#Express中使用session认证" class="headerlink" title="Express中使用session认证"></a>Express中使用session认证</h4><ol><li>安装 express-session 中间件</li></ol><pre><code class="bash">npm install express-session</code></pre><ol start="2"><li>配置中间件</li></ol><pre><code class="js">const session = require(&#39;express-session&#39;)app.use(  session(&#123;    secret: &#39;hlf&#39;, // secret 的值为任意字符串    resave: false,    saveUninitalized: true,  &#125;))</code></pre><ol start="3"><li>向 session 中存数据</li></ol><p>中间件配置成功后，可通过 <code>req.session</code> 访问 session 对象，存储用户信息</p><pre><code class="js">app.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;  req.session.user = req.body  req.session.isLogin = true  res.send(&#123; status: 0, msg: &#39;login done&#39; &#125;)&#125;)</code></pre><ol start="4"><li>从 session 取数据</li></ol><pre><code class="js">app.get(&#39;/api/username&#39;, (req, res) =&gt; &#123;  if (!req.session.isLogin) &#123;    return res.send(&#123; status: 1, msg: &#39;fail&#39; &#125;)  &#125;  res.send(&#123; status: 0, msg: &#39;success&#39;, username: req.session.user.username &#125;)&#125;)</code></pre><ol start="5"><li>清空 session</li></ol><pre><code class="js">app.post(&#39;/api/logout&#39;, (req, res) =&gt; &#123;  // 清空当前客户端的session信息  req.session.destroy()  res.send(&#123; status: 0, msg: &#39;logout done&#39; &#125;)&#125;)</code></pre>]]></content>
    
    
    <summary type="html">含node基础、express框架、jwt认证、session认证等内容</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="node" scheme="https://heliufang.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>vue3笔记</title>
    <link href="https://heliufang.github.io/2022/07/09/1545789245413789696/images/"/>
    <id>https://heliufang.github.io/2022/07/09/1545789245413789696/images/</id>
    <published>2022-07-09T10:34:28.000Z</published>
    <updated>2022-12-21T03:49:27.149Z</updated>
    
    <content type="html"><![CDATA[<p>b站vue3教学视频：<a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=136">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=136</a></p><h1 id="vue3快速上手"><a href="#vue3快速上手" class="headerlink" title="vue3快速上手"></a>vue3快速上手</h1><h2 id="vue3简介"><a href="#vue3简介" class="headerlink" title="vue3简介"></a>vue3简介</h2><p><font color="red">2020年9月18日</font>，Vue.js发布3.0版本，代号：One Piece（海贼王）<br>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a><br>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></p><p><img src="/2022/07/09/1545789245413789696/images/image-20220709144941109.png" alt="image-20220709144941109"></p><h2 id="Vue3带来了什么"><a href="#Vue3带来了什么" class="headerlink" title="Vue3带来了什么"></a>Vue3带来了什么</h2><h3 id="性能的提升"><a href="#性能的提升" class="headerlink" title="性能的提升"></a>性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="源码的升级"><a href="#源码的升级" class="headerlink" title="源码的升级"></a>源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="拥抱TypeScript"><a href="#拥抱TypeScript" class="headerlink" title="拥抱TypeScript"></a>拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h2 id="创建vue3的工程"><a href="#创建vue3的工程" class="headerlink" title="创建vue3的工程"></a>创建vue3的工程</h2><h3 id="使用vue-cli创建"><a href="#使用vue-cli创建" class="headerlink" title="使用vue-cli创建"></a>使用vue-cli创建</h3><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><pre><code class="bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve</code></pre><h3 id="使用-vite-创建"><a href="#使用-vite-创建" class="headerlink" title="使用 vite 创建"></a>使用 vite 创建</h3><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="/2022/07/09/1545789245413789696/images/image-20220709145533098.png" alt="image-20220709145533098"></p><pre><code class="bash">## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev</code></pre><h1 id="常用-Composition-API"><a href="#常用-Composition-API" class="headerlink" title="常用 Composition API"></a>常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="setup函数"><a href="#setup函数" class="headerlink" title="setup函数"></a>setup函数</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li><font color="red">组件中所用到的：数据、方法等等，均要配置在setup中。</font></li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li><font color="red">尽量不要与Vue2.x配置混用</font>（都用3了就不要写vue2的那套了）<ul><li>Vue2.x配置（data、methods、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a>ref函数</h2><ul><li>作用: <font color="red" style="font-weight:bold">定义一个响应式的数据</font></li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。RefImpl</li><li>JS中操作数据： <code>xxx.value</code> （<font color="red" style="font-weight:bold">无论是基本类型还是对象类型</font>）</li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="reactive函数"><a href="#reactive函数" class="headerlink" title="reactive函数"></a>reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong><ul><li>js中、模板中都不需要操作xxx.value操作数据，可以直接操作</li></ul></li><li>reactive定义的响应式数据是<strong>深层次的</strong>。(vue2中并不是)</li><li><font color="red" style="font-weight:bold">内部基于 ES6 的 Proxy 实现</font>，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="Vue3-0中的响应式原理"><a href="#Vue3-0中的响应式原理" class="headerlink" title="Vue3.0中的响应式原理"></a>Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><pre><code class="js">Object.defineProperty(data, &#39;count&#39;, &#123;    get () &#123;&#125;,     set () &#123;&#125;&#125;)</code></pre></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li>实现原理: <ul><li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li><li>通过Reflect（反射）:  对源对象的属性进行操作。</li><li>MDN文档中描述的Proxy与Reflect：<ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><pre><code class="js">new Proxy(data, &#123;    // 拦截读取属性值    get (target, prop) &#123;        return Reflect.get(target, prop)    &#125;,    // 拦截设置属性值或添加新属性    set (target, prop, value) &#123;        return Reflect.set(target, prop, value)    &#125;,    // 拦截删除属性    deleteProperty (target, prop) &#123;        return Reflect.deleteProperty(target, prop)    &#125;&#125;)proxy.name = &#39;tom&#39;   </code></pre></li></ul></li></ul></li></ul><h2 id="reactive对比ref"><a href="#reactive对比ref" class="headerlink" title="reactive对比ref"></a>reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="setup的注意点"><a href="#setup的注意点" class="headerlink" title="setup的注意点"></a>setup的注意点</h2><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><ul><li>父组件给子组件传递的属性和自定义事件，子组件一定要接受一下，否则会抛出警告</li></ul><p><img src="/2022/07/09/1545789245413789696/images/image-20220709164507893.png" alt="image-20220709164507893"></p><h2 id="计算属性与监视"><a href="#计算属性与监视" class="headerlink" title="计算属性与监视"></a>计算属性与监视</h2><h3 id="computed函数"><a href="#computed函数" class="headerlink" title="computed函数"></a>computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><pre><code class="js">import &#123;computed&#125; from &#39;vue&#39;setup()&#123;    ...    //计算属性——简写    let fullName = computed(()=&gt;&#123;        return person.firstName + &#39;-&#39; + person.lastName    &#125;)    //计算属性——完整    let fullName = computed(&#123;        get()&#123;            return person.firstName + &#39;-&#39; + person.lastName        &#125;,        set(value)&#123;            const nameArr = value.split(&#39;-&#39;)            person.firstName = nameArr[0]            person.lastName = nameArr[1]        &#125;    &#125;)&#125;</code></pre></li></ul><h3 id="watch函数"><a href="#watch函数" class="headerlink" title="watch函数"></a>watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><pre><code class="js">//情况一：监视ref定义的响应式数据 immediate表示初始化之后马上执行一次watch(sum,(newValue,oldValue)=&gt;&#123;    console.log(&#39;sum变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true&#125;) //情况二：监视多个ref定义的响应式数据//此时newValue,oldValue分别为两个数组watch([sum,msg],(newValue,oldValue)=&gt;&#123;    console.log(&#39;sum或msg变化了&#39;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;    console.log(&#39;person变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性 watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;//注意第一个参数要用箭头函数    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况,这个就是情况四watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</code></pre></li></ul><h3 id="watchEffect函数"><a href="#watchEffect函数" class="headerlink" title="watchEffect函数"></a>watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><pre><code class="js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123;    const x1 = sum.value    const x2 = person.age    console.log(&#39;watchEffect配置的回调执行了&#39;)&#125;)</code></pre></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li><li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li></ul></li></ul><h3 id="vue2生命周期"><a href="#vue2生命周期" class="headerlink" title="vue2生命周期"></a>vue2生命周期</h3><p><img src="https://cn.vuejs.org/images/lifecycle.png"></p><h3 id="vue3生命周期"><a href="#vue3生命周期" class="headerlink" title="vue3生命周期"></a>vue3生命周期</h3><p><img src="https://v3.cn.vuejs.org/images/lifecycle.svg"></p><h2 id="自定义hook函数"><a href="#自定义hook函数" class="headerlink" title="自定义hook函数"></a>自定义hook函数</h2><ul><li>什么是hook？—— 本质是一个函数，<font color="red" style="font-weight:bold">把setup函数中使用的Composition API进行了封装</font>。</li><li>类似于vue2.x中的mixin。</li><li>自定义hook的优势: <strong>复用代码, 让setup中的逻辑更清楚易懂</strong>。</li></ul><p>使用方法：把setup可以复用的逻辑代码抽离到一个js文件，然后在需要用的地方import导入即可</p><h2 id="toRef和toRefs"><a href="#toRef和toRefs" class="headerlink" title="toRef和toRefs"></a>toRef和toRefs</h2><ul><li><p>作用：创建一个 ref 对象，<font color="red" style="font-weight:bold">其value值指向另一个对象中的某个属性</font>（注意这里是指向）</p></li><li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p></li><li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><pre><code class="js">setup()&#123;    let person = reactive(&#123;      name: &#39;tom&#39;,      age: 18    &#125;)    let name = toRef(person,&#39;name&#39;)//创建一个 ref 对象    let props = toRefs(person) //批量创建多个ref对象，返回一个ref数组    console.log(props);    return &#123;      //name:toRef(person,&#39;name&#39;)      ...props    &#125;  &#125;</code></pre><p>页面上直接使用</p><pre><code class="html">&lt;div&gt;name:&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;div&gt;age:&#123;&#123;age&#125;&#125;&lt;/div&gt;</code></pre><h1 id="其它-Composition-API"><a href="#其它-Composition-API" class="headerlink" title="其它 Composition API"></a>其它 Composition API</h1><h2 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h2><ul><li>shallowReactive：<font color="red" style="font-weight:bold">只处理对象最外层属性的响应式</font>（浅响应式）。</li><li>shallowRef：<font color="red" style="font-weight:bold">只处理基本数据类型的响应式, 不进行对象的响应式处理</font>。<ul><li>也就是说：  shallowRef(对象)—》不处理      shallowRef(基本类型)—》处理</li></ul></li><li>什么时候使用?<ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li></ul></li></ul><h2 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的-<font color="red" style="font-weight:bold">第一层只读</font>（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。(正好和reactive相反)</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，<font color="orange" style="font-weight:bold">使其永远不会再成为响应式对象</font>。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h2><ul><li><p>作用：创建一个<font color="green" style="font-weight:bold">自定义的 ref</font>，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><pre><code class="vue">&lt;template&gt;    &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;    &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;    import &#123;ref,customRef&#125; from &#39;vue&#39;    export default &#123;        name:&#39;Demo&#39;,        setup()&#123;            // let keyword = ref(&#39;hello&#39;) //使用Vue准备好的内置ref            //自定义一个myRef            function myRef(value,delay)&#123;                let timer                //通过customRef去实现自定义                return customRef((track,trigger)=&gt;&#123;                    return&#123;                        get()&#123;                            track() //告诉Vue这个value值是需要被“追踪”的                            return value                        &#125;,                        set(newValue)&#123;                            clearTimeout(timer)                            timer = setTimeout(()=&gt;&#123;                                value = newValue                                trigger() //告诉Vue去更新界面                            &#125;,delay)                        &#125;                    &#125;                &#125;)            &#125;            let keyword = myRef(&#39;hello&#39;,500) //使用程序员自定义的ref            return &#123;                keyword            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre></li></ul><h2 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h2><p><img src="https://v3.cn.vuejs.org/images/components_provide.png"></p><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><pre><code class="js">setup()&#123;    ......    let car = reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)    provide(&#39;car&#39;,car)    ......&#125;</code></pre></li><li><p>后代组件中：</p><pre><code class="js">setup(props,context)&#123;    ......    const car = inject(&#39;car&#39;)    return &#123;car&#125;    ......&#125;</code></pre></li></ol></li></ul><h2 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a>响应式数据的判断</h2><ul><li>isRef: 检查一个值<strong style="color:red">是否为一个 ref 对象</strong></li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h1><h2 id="Options-API-存在的问题"><a href="#Options-API-存在的问题" class="headerlink" title="Options API 存在的问题"></a>Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="Composition-API-的优势-1"><a href="#Composition-API-的优势-1" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"></p><h1 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h1><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><pre><code class="vue">&lt;!--移动位置可以写body,或者id选择器等--&gt;&lt;teleport to=&quot;移动位置&quot;&gt;    &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;        &lt;div class=&quot;dialog&quot;&gt;            &lt;h3&gt;我是一个弹窗&lt;/h3&gt;            &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/teleport&gt;</code></pre></li></ul><h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><pre><code class="js">import &#123;defineAsyncComponent&#125; from &#39;vue&#39;const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;))</code></pre></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><pre><code class="vue">&lt;template&gt;    &lt;div class=&quot;app&quot;&gt;        &lt;h3&gt;我是App组件&lt;/h3&gt;        &lt;Suspense&gt;            &lt;template v-slot:default&gt;                &lt;Child/&gt;            &lt;/template&gt;            &lt;template v-slot:fallback&gt;                &lt;h3&gt;加载中.....&lt;/h3&gt;            &lt;/template&gt;        &lt;/Suspense&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre></li></ul></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="全局API的转移"><a href="#全局API的转移" class="headerlink" title="全局API的转移"></a>全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><pre><code class="js">//注册全局组件Vue.component(&#39;MyButton&#39;, &#123;  data: () =&gt; (&#123;    count: 0  &#125;),  template: &#39;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#39;&#125;)//注册全局指令Vue.directive(&#39;focus&#39;, &#123;  inserted: el =&gt; el.focus()&#125;</code></pre></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="其他改变"><a href="#其他改变" class="headerlink" title="其他改变"></a>其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><pre><code class="css">.v-enter,.v-leave-to &#123;  opacity: 0;&#125;.v-leave,.v-enter-to &#123;  opacity: 1;&#125;</code></pre></li><li><p>Vue3.x写法</p><pre><code class="css">.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;.v-leave-from,.v-enter-to &#123;  opacity: 1;&#125;</code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><pre><code class="vue">&lt;my-component  v-on:close=&quot;handleComponentEvent&quot;  v-on:click=&quot;handleNativeClickEvent&quot;/&gt;</code></pre></li><li><p>子组件中声明自定义事件</p><pre><code class="vue">&lt;script&gt;  export default &#123;    emits: [&#39;close&#39;]  &#125;&lt;/script&gt;</code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
    
    
    <summary type="html">vue3笔记整理</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript笔记</title>
    <link href="https://heliufang.github.io/2022/07/09/1551862167303753728/images/"/>
    <id>https://heliufang.github.io/2022/07/09/1551862167303753728/images/</id>
    <published>2022-07-09T03:03:28.000Z</published>
    <updated>2022-07-26T09:20:56.619Z</updated>
    
    <content type="html"><![CDATA[<p>B站教学视频：<a href="https://www.bilibili.com/video/BV1Xy4y1v7S2">尚硅谷TypeScript教程（李立超老师TS新课）</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>TypeScript是JavaScript的超集。</li><li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li><li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li><li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。</li><li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局ts的命令</p><pre><code>npm i -g typescript</code></pre><p>装好之后输入下面指令即可看到版本号，表示安装成功</p><pre><code>tsc -v</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>新建xxx.ts文件,ts文件里面随便写点js代码</p><ul><li>进入命令行</li><li>进入ts文件所在目录</li><li>执行初始化配置文件的命令： tsc –init</li><li>执行命令：tsc xxx.ts</li></ul><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>略。要用的时候再去查询</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><table><thead><tr><th align="center">类型</th><th align="center">例子</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">number</td><td align="center">1, -33, 2.5</td><td align="center">任意数字</td></tr><tr><td align="center">string</td><td align="center">‘hi’, “hi”, <code>hi</code></td><td align="center">任意字符串</td></tr><tr><td align="center">boolean</td><td align="center">true、false</td><td align="center">布尔值true或false</td></tr><tr><td align="center">字面量</td><td align="center">其本身</td><td align="center">限制变量的值就是该字面量的值</td></tr><tr><td align="center"><strong style="color:red">any</strong></td><td align="center">*</td><td align="center">任意类型</td></tr><tr><td align="center"><strong style="color:red">unknown</strong></td><td align="center">*</td><td align="center">类型安全的any</td></tr><tr><td align="center">void</td><td align="center">空值（undefined）</td><td align="center">没有值（或undefined）</td></tr><tr><td align="center"><strong style="color:red">never</strong></td><td align="center">没有值</td><td align="center">不能是任何值</td></tr><tr><td align="center">object</td><td align="center">{name:’孙悟空’}</td><td align="center">任意的JS对象</td></tr><tr><td align="center">array</td><td align="center">[1,2,3]</td><td align="center">任意JS数组</td></tr><tr><td align="center"><strong style="color:red">tuple（元祖）</strong></td><td align="center">[4,5]</td><td align="center">元素，TS新增类型，固定长度数组</td></tr><tr><td align="center"><strong style="color:red">enum</strong></td><td align="center">enum{A, B}</td><td align="center">枚举，TS中新增类型</td></tr></tbody></table><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><ul><li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p></li><li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p></li><li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p></li></ul><p>语法：</p><pre><code class="typescript">let 变量: 类型;let 变量: 类型 = 值;function fn(参数: 类型, 参数: 类型): 类型&#123;    ...&#125;</code></pre><h3 id="自动类型判断"><a href="#自动类型判断" class="headerlink" title="自动类型判断"></a>自动类型判断</h3><ul><li>TS拥有自动的类型判断机制</li><li>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</li><li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li></ul><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><pre><code class="typescript">let decimal: number = 6;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744;let big: bigint = 100n; //es11</code></pre><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><pre><code class="typescript">let isDone: boolean = false;</code></pre><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><pre><code class="typescript">let color: string = &quot;blue&quot;;color = &#39;red&#39;;let fullName: string = `Bob Bobbington`;let age: number = 37;let sentence: string = `my name is $&#123;fullName&#125;.I&#39;ll be $&#123;age + 1&#125; years old next month.`;</code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p><pre><code class="typescript">let color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;let num: 1 | 2 | 3 | 4 | 5;</code></pre><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>任意类型(不安全),<strong style="color:red">会使ts的类型判断失效</strong></p><pre><code class="typescript">let d: any = 4;d = &#39;hello&#39;;d = true;d.sayHello() //不会报错</code></pre><h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p>任意类型(安全)</p><pre><code class="typescript">let notSure: unknown = 4;notSure = &#39;hello&#39;;//d.sayHello() //会报错</code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>没有值（当时可以是undefined）</p><pre><code class="typescript">let unusable: void = undefined;</code></pre><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>从不会出现的值，没有值，不能是任何值,永远不会有返回结果（返回“从不”的函数不能具有可访问的终结点）</p><pre><code class="typescript">let good: never;// good = &#39;123&#39;; //error// good = undefined; //error// good = null; //error function goodFun(): never &#123;    // return &#39;123&#39;; //error    // return;  //error    // return undefined; //error    // return null; //error    // console.log(&#39;123&#39;); //error    throw new Error(&#39;error&#39;); //只有这种不报错&#125;</code></pre><h3 id="object（没啥用）"><a href="#object（没啥用）" class="headerlink" title="object（没啥用）"></a>object（没啥用）</h3><pre><code class="typescript">let obj: object = &#123;&#125;;</code></pre><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><pre><code class="typescript">let list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3]; //有点像java的泛型</code></pre><h3 id="tuple（元祖）"><a href="#tuple（元祖）" class="headerlink" title="tuple（元祖）"></a>tuple（元祖）</h3><p>指定数组内部元素的类型和个数</p><pre><code class="typescript">let x: [string, number];x = [&quot;hello&quot;, 10]; </code></pre><h3 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h3><pre><code class="typescript">// 不给默认值Red-0  Green-1 Blue-2enum Color &#123;  Red,  Green,  Blue,&#125;let c: Color = Color.Green;// 给默认值Red-1  Green-2 Blue-3enum Color &#123;  Red = 1,  Green,  Blue,&#125;let c: Color = Color.Green;// 给默认值Red-1  Green-2 Blue-4enum Color &#123;  Red = 1,  Green = 2,  Blue = 4,&#125;let c: Color = Color.Green;</code></pre><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p><p>第一种： 使用as</p><pre><code class="typescript">let someValue: unknown = &quot;this is a string&quot;;let strLength: number = (someValue as string).length;</code></pre><p>第二种：类似java的强制类型转换</p><pre><code class="typescript">let someValue: unknown = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length;</code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象是程序中一个非常重要的思想。简而言之就是程序之中所有的操作都需要通过对象来完成。</p><ul><li>举例来说：<ul><li>操作浏览器要使用window对象</li><li>操作网页要使用document对象</li><li>操作控制台要使用console对象</li></ul></li></ul><p>一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。</p><p>在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。</p><ul><li>定义类</li></ul><pre><code class="typescript">class 类名 &#123;    属性名: 类型;        constructor(参数: 类型)&#123;        this.属性名 = 参数;    &#125;    方法名()&#123;        ....    &#125;&#125;</code></pre><ul><li>示例</li></ul><pre><code class="typescript">class Person&#123;    name: string;    age: number;    constructor(name: string, age: number)&#123;        this.name = name;        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;</code></pre><ul><li>使用类</li></ul><pre><code class="typescript">const p = new Person(&#39;孙悟空&#39;, 18);p.sayHello();</code></pre><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p></li><li><p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</p></li><li><p>只读属性（readonly）：</p><ul><li>如果在声明属性时添加一个<strong style="color:red">readonly</strong>，则属性便成了<strong style="color:red">只读</strong>属性无法修改</li></ul></li><li><p>TS中属性具有三种修饰符：</p><ul><li>public（默认值），可以在类、子类和实例对象中修改</li><li>protected ，可以在类、子类中修改</li><li>private ，可以在类中修改</li></ul></li></ul><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><pre><code class="typescript">class Person&#123;    public name: string; // 写或什么都不写,都是public    public age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以在类中修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中可以修改    &#125;&#125;const p = new Person(&#39;孙悟空&#39;, 18);p.name = &#39;猪八戒&#39;;// 可以通过对象修改</code></pre><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><pre><code class="typescript">class Person&#123;    protected name: string;    protected age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中可以修改    &#125;&#125;const p = new Person(&#39;孙悟空&#39;, 18);p.name = &#39;猪八戒&#39;;// 不能修改</code></pre><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><pre><code class="typescript">class Person&#123;    private name: string;    private age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中不能修改    &#125;&#125;const p = new Person(&#39;孙悟空&#39;, 18);p.name = &#39;猪八戒&#39;;// 不能修改</code></pre><h4 id="属性存取器"><a href="#属性存取器" class="headerlink" title="(*)属性存取器"></a>(*)属性存取器</h4><ul><li><p>对于一些不希望被任意修改的属性，可以将其设置为private</p></li><li><p>直接将其设置为private将导致无法再通过对象修改其中的属性</p></li><li><p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p></li><li><p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p></li></ul><pre><code class="typescript">class Person&#123;    private _name: string;    constructor(name: string)&#123;        this._name = name;    &#125;    get name()&#123;        return this._name;    &#125;    set name(name: string)&#123;        this._name = name;    &#125;&#125;const p1 = new Person(&#39;孙悟空&#39;);console.log(p1.name); // 通过getter读取name属性p1.name = &#39;猪八戒&#39;; // 通过setter修改name属性</code></pre><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><ul><li><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p></li><li><p>静态属性（方法）使用static开头</p></li></ul><pre><code class="typescript">class Tools&#123;    static PI = 3.1415926;        static sum(num1: number, num2: number)&#123;        return num1 + num2    &#125;&#125;console.log(Tools.PI);console.log(Tools.sum(123, 456));</code></pre><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>在类中，使用this表示当前对象</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>继承是面向对象中的又一个特性</li><li>通过继承可以将其他类中的属性和方法引入到当前类中</li><li>通过继承可以在不修改类的情况下完成对类的扩展</li></ul><pre><code class="typescript">class Animal&#123;    name: string;    age: number;    constructor(name: string, age: number)&#123;        this.name = name;        this.age = age;    &#125;&#125;class Dog extends Animal&#123;    bark()&#123;        console.log(`$&#123;this.name&#125;在汪汪叫！`);    &#125;&#125;const dog = new Dog(&#39;旺财&#39;, 4);dog.bark();</code></pre><ul><li>重写:发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</li></ul><pre><code class="typescript">class Animal&#123;    name: string;    age: number;    constructor(name: string, age: number)&#123;        this.name = name;        this.age = age;    &#125;    run()&#123;        console.log(`父类中的run方法！`);    &#125;&#125;class Dog extends Animal&#123;    bark()&#123;        console.log(`$&#123;this.name&#125;在汪汪叫！`);    &#125;    run()&#123;        console.log(`子类中的run方法，会重写父类中的run方法！`);    &#125;&#125;const dog = new Dog(&#39;旺财&#39;, 4);dog.bark();</code></pre><p>在子类中可以使用<strong style="color:red">super</strong>来完成对父类的引用</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</p><pre><code class="typescript">abstract class Animal&#123;    abstract run(): void;    bark()&#123;        console.log(&#39;动物在叫~&#39;);    &#125;&#125;class Dog extends Animals&#123;    run()&#123;        console.log(&#39;狗在跑~&#39;);    &#125;&#125;</code></pre><p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。</p><ul><li>示例（<strong style="color:red">检查对象类型-开发中常用</strong>）：</li></ul><pre><code class="typescript">interface Person&#123;    name: string;    sayHello():void;&#125;function fn(per: Person)&#123;    per.sayHello();&#125;fn(&#123;name:&#39;孙悟空&#39;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);</code></pre><ul><li>示例（实现）</li></ul><pre><code class="typescript">interface Person&#123;    name: string;    sayHello():void;&#125;class Student implements Person&#123;    constructor(public name: string) &#123;    &#125;    sayHello() &#123;        console.log(&#39;大家好，我是&#39;+this.name);    &#125;&#125;</code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。</p><ul><li>举个例子</li></ul><pre><code class="typescript">function test(arg: any): any&#123;    return arg;&#125;</code></pre><p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</p><ul><li>使用泛型</li></ul><pre><code class="typescript">function test&lt;T&gt;(arg: T): T&#123;    return arg;&#125;</code></pre><p>这里的<code>&lt;T&gt;</code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。那么如何使用上边的函数呢？</p><p>方式一（直接使用）</p><pre><code class="typescript">test(10)</code></pre><p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p><p><strong style="color:red">方式二</strong>（指定类型—&gt;这种更好）</p><pre><code class="typescript">test&lt;number&gt;(10)</code></pre><ul><li>同时指定多个泛型，泛型间使用逗号隔开</li></ul><pre><code class="typescript">function test&lt;T, K&gt;(a: T, b: K): K&#123;    return b;&#125;test&lt;number, string&gt;(10, &quot;hello&quot;);</code></pre><p>使用泛型时，完全可以将泛型当成是一个普通的类去使用</p><ul><li>类中同样可以使用泛型</li></ul><pre><code class="typescript">class MyClass&lt;T&gt;&#123;    prop: T;    constructor(prop: T)&#123;        this.prop = prop;    &#125;&#125;</code></pre><ul><li>除此之外，也可以对泛型的范围进行约束</li></ul><pre><code class="typescript">interface MyInter&#123;    length: number;&#125;function test&lt;T extends MyInter&gt;(arg: T): number&#123;    return arg.length;&#125;</code></pre><p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。</p>]]></content>
    
    
    <summary type="html">TypeScript入门笔记整理</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="typescript" scheme="https://heliufang.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>vue-router笔记</title>
    <link href="https://heliufang.github.io/2022/07/06/1545650198544519168/images/"/>
    <id>https://heliufang.github.io/2022/07/06/1545650198544519168/images/</id>
    <published>2022-07-06T13:13:28.000Z</published>
    <updated>2022-12-21T03:49:16.241Z</updated>
    
    <content type="html"><![CDATA[<p>vue-router官网：<a href="https://v3.router.vuejs.org/zh/guide/essentials/navigation.html">https://v3.router.vuejs.org/zh/guide/essentials/navigation.html</a></p><h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>只有一个页面，切换页面不通过服务器刷新页面，而是通过路由和ajax。</p><h2 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h2><p>用 Vue.js + Vue Router 创建单页应用</p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3><p>Bar.vue</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;bar组件&lt;/div&gt;&lt;/template&gt;</code></pre><p>Foo.vue</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;foo组件&lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="定义路由规则"><a href="#定义路由规则" class="headerlink" title="定义路由规则"></a>定义路由规则</h3><p>router&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;import Foo from &#39;../views/Foo.vue&#39;import Bar from &#39;../views/Bar.vue&#39;Vue.use(VueRouter)const routes = [  &#123;    path: &#39;/foo&#39;, // 匹配的路径    component: Foo // 匹配的组件  &#125;,  &#123;    path: &#39;/bar&#39;,    component: Bar  &#125;]const router = new VueRouter(&#123;  routes&#125;)export default router</code></pre><h3 id="main-js挂载路由"><a href="#main-js挂载路由" class="headerlink" title="main.js挂载路由"></a>main.js挂载路由</h3><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router&#39;import store from &#39;./store&#39;Vue.config.productionTip = falsenew Vue(&#123;  router,//挂载路由  store,  render: h =&gt; h(App)&#125;).$mount(&#39;#app&#39;)</code></pre><h3 id="app-vue展示组件和导航"><a href="#app-vue展示组件和导航" class="headerlink" title="app.vue展示组件和导航"></a>app.vue展示组件和导航</h3><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;APP组件&lt;/h2&gt;    &lt;!--router-link 组件来导航： 通过传入 `to` 属性指定链接    &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签      active-class:表示激活的样式      --&gt;    &lt;router-link to=&quot;/foo&quot; active-class=&quot;active&quot;&gt;foo&lt;/router-link&gt;&amp;nbsp;    &lt;router-link to=&quot;/bar&quot; active-class=&quot;active&quot;&gt;bar&lt;/router-link&gt;    &lt;!-- --&gt;    &lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;less&quot;&gt;  .active&#123;    color: red;  &#125;&lt;/style&gt;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.router.js中定义路由 </p><p>2.main.js中挂载路由</p><p>3.router-link定义路由导航   router-view 定义路由展示区域</p><p>4.main.js中注入路由器之后，在任何组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由</p><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>其实就是restful风格的路径传参</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>第一步：创建组件</p><pre><code class="html">&lt;template&gt;    &lt;!-- 获取路由的路径参数 $route.params --&gt;    &lt;div&gt;user组件id: &#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><p>第二步：router&#x2F;index.js配置路由</p><pre><code class="js">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;import Foo from &#39;../views/Foo.vue&#39;import Bar from &#39;../views/Bar.vue&#39;import User from &#39;../views/User.vue&#39;Vue.use(VueRouter)const routes = [  //....  &#123;    path: &#39;/user/:id&#39;,// 动态路径参数 以冒号开头    component: User  &#125;]const router = new VueRouter(&#123;  routes&#125;)export default router</code></pre><p>第三步：app.vue中使用</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;APP组件&lt;/h2&gt;    &lt;!--此处传递一个666参数,对应路由的id--&gt;    &lt;router-link to=&quot;/user/666&quot; active-class=&quot;active&quot;&gt;User&lt;/router-link&gt;&amp;nbsp;    &lt;!-- --&gt;    &lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>也可以在一个路由中设置多段“路径参数”，对应的值都会设置到 <code>$route.params</code> 中。例如：</p><table><thead><tr><th>模式</th><th>匹配路径</th><th>$route.params</th></tr></thead><tbody><tr><td>&#x2F;user&#x2F;:username</td><td>&#x2F;user&#x2F;evan</td><td><code>&#123; username: &#39;evan&#39; &#125;</code></td></tr><tr><td>&#x2F;user&#x2F;:username&#x2F;post&#x2F;:post_id</td><td>&#x2F;user&#x2F;evan&#x2F;post&#x2F;123</td><td><code>&#123; username: &#39;evan&#39;, post_id: &#39;123&#39; &#125;</code></td></tr></tbody></table><p>如果是通过？传参那么对应的值会设置到<code>$route.query</code>中</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;APP组件&lt;/h2&gt;    &lt;!--通过？传参那么对应的值会设置到`$route.query`--&gt;    &lt;router-link to=&quot;/user?id=1&amp;name=tom&quot; active-class=&quot;active&quot;&gt;User&lt;/router-link&gt;&amp;nbsp;    &lt;!-- --&gt;    &lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h3><p>从 <code>/user/1</code> 导航到  <code>/user/2</code>，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子(destroyed)不会再被调用</strong>。</p><p>例如: 从666切换到777的时候，user组件的destroyed方法不会被调用</p><ul><li>app.vue</li></ul><pre><code class="html">&lt;router-link to=&quot;/user/666&quot; active-class=&quot;active&quot;&gt;User666&lt;/router-link&gt;&amp;nbsp;&lt;router-link to=&quot;/user/777&quot; active-class=&quot;active&quot;&gt;User777&lt;/router-link&gt;&amp;nbsp;</code></pre><ul><li>user.vue</li></ul><pre><code class="html">&lt;template&gt;    &lt;!-- 获取路由的路径参数 --&gt;    &lt;div&gt;user组件id: &#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  destroyed () &#123;    console.log(&#39;User组件被销毁&#39;)  &#125;,  //   watch: &#123;  //     $route (to, from) &#123;  //       console.log(to, from)  //     &#125;  //   &#125;,  beforeRouteUpdate (to, from, next) &#123;    console.log(to, from)    next()  &#125;&#125;&lt;/script&gt;</code></pre><p>两种方式：  监听路由参数的变化作出响应</p><p>第一种：watch监听</p><pre><code class="html">watch: &#123;    $route (to, from) &#123;      console.log(to, from)    &#125;  &#125;</code></pre><p>第二种：使用组件内路由守卫<code>beforeRouteUpdate</code>这个路由钩子</p><pre><code class="js"> beforeRouteUpdate (to, from, next) &#123;    console.log(to, from)    next() //千万别忘了放行  &#125;</code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符 (*)"></a>通配符 (*)</h3><p>匹配所有。一般把这个放到最后面用来展示404错误页面</p><pre><code class="js">&#123;    path: &#39;*&#39;,    component: Error  &#125;</code></pre><p>匹配以xxx开头</p><pre><code class="js">&#123;    path: &#39;/user-*&#39;,    component: Test  &#125;</code></pre><p>当使用一个<em>通配符</em>时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过<em>通配符</em>被匹配的部分.也就是user-后面的部分</p><pre><code class="js">// 给出一个路由 &#123; path: &#39;/user-*&#39; &#125;this.$router.push(&#39;/user-admin&#39;)this.$route.params.pathMatch // &#39;admin&#39;// 给出一个路由 &#123; path: &#39;*&#39; &#125;this.$router.push(&#39;/non-existing&#39;)this.$route.params.pathMatch // &#39;/non-existing&#39;</code></pre><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><p>路由定义得越早，优先级就越高。</p><h2 id="嵌套路由-多级路由"><a href="#嵌套路由-多级路由" class="headerlink" title="嵌套路由(多级路由)"></a>嵌套路由(多级路由)</h2><p>在路由中新增一个children数组,数组中的每一个对象就是子路由.</p><p>注意： 子路由的path不要写 &#x2F; </p><p>router&#x2F;index.js</p><pre><code class="js">&#123;    path: &#39;/user&#39;,    component: User,    children: [      &#123;        path: &#39;add&#39;,        component: UserAdd      &#125;,      &#123;        path: &#39;update&#39;,        component: UserUpdate      &#125;    ]  &#125;</code></pre><p>user.vue组件</p><pre><code class="html">&lt;template&gt;    &lt;div class=&quot;main&quot;&gt;      &lt;h1&gt;user组件&lt;/h1&gt;      &lt;router-link to=&quot;/user/add&quot;&gt;添加用户&lt;/router-link&gt;      &lt;router-link to=&quot;/user/update&quot;&gt;修改用户&lt;/router-link&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><p>UserAdd.vue组件</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;新增用户组件&lt;/div&gt;&lt;/template&gt;</code></pre><p>UserUpdate.vue组件</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;修改用户组件&lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候</p><pre><code class="js">&#123;      path: &#39;/user/:userId&#39;,      name: &#39;user&#39;, //给路由起个名字      component: User    &#125;</code></pre><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p><h3 id="router-push"><a href="#router-push" class="headerlink" title="router.push()"></a>router.push()</h3><p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td><td><code>router.push(...)</code></td></tr></tbody></table><p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p><pre><code class="js">// 字符串router.push(&#39;home&#39;)// 对象router.push(&#123; path: &#39;home&#39; &#125;)// 命名的路由router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</code></pre><p>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。</p><pre><code class="js">const userId = &#39;123&#39;router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: &#39;/user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user</code></pre><p>记忆：   <strong>pp不能组合（path和params）</strong></p><h3 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace()"></a>router.replace()</h3><p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td><td><code>router.replace(...)</code></td></tr></tbody></table><h3 id="router-go"><a href="#router-go" class="headerlink" title="router.go()"></a>router.go()</h3><pre><code class="js">// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100)</code></pre><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p><pre><code class="html">&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt;</code></pre><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 s)：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/&#39;,      components: &#123; //这里变为components        default: Foo,        a: Bar, //a,b为名字和router-view中的name属性值对应        b: Baz      &#125;    &#125;  ]&#125;)</code></pre><h2 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/a&#39;, redirect: &#39;/b&#39; &#125;  ]&#125;)</code></pre><p>重定向的目标也可以是一个命名的路由：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/a&#39;, redirect: &#123; name: &#39;foo&#39; &#125;&#125;  ]&#125;)</code></pre><p>甚至是一个方法，动态返回重定向目标：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/a&#39;, redirect: to =&gt; &#123;      // 方法接收 目标路由 作为参数      // return 重定向的 字符串路径/路径对象    &#125;&#125;  ]&#125;)</code></pre><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>“重定向”的意思是，当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢？</p><p><strong><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</strong></p><p>上面对应的路由配置为：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/a&#39;, component: A, alias: &#39;/b&#39; &#125;  ]&#125;)</code></pre><p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p><h2 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h2><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。使用 <code>props</code> 将组件和路由解耦：（简化这种写法 $route.params.id）</p><h3 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h3><p>如果 <code>props</code> 被设置为 <code>true</code>，<code>route.params</code> 将会被设置为组件属性（类似父组件给子组件传值）。</p><pre><code class="js">const User = &#123;  props: [&#39;id&#39;], //这里和父组件给子组件传值一样  template: &#39;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#39;&#125;const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/user/:id&#39;, component: User, props: true &#125;,//props设置为true    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：    &#123;      path: &#39;/user/:id&#39;,      components: &#123; default: User, sidebar: Sidebar &#125;,      props: &#123; default: true, sidebar: false &#125;    &#125;  ]&#125;)</code></pre><h3 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h3><p><code>props</code> 是对象，它会被按原样设置为组件属性。当 <code>props</code> 是<strong>静态</strong>的时候有用。（props后对象是写死的）</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/promotion/from-newsletter&#39;,      component: Promotion,      props: &#123; newsletterPopup: false &#125;    &#125;  ]&#125;)</code></pre><h3 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h3><p>你可以创建一个函数返回 <code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/search&#39;,      component: SearchUser,      props: route =&gt; (&#123; query: route.query.q &#125;)    &#125;  ]&#125;)</code></pre><p>URL <code>/search?q=vue</code> 会将 <code>&#123;query: &#39;vue&#39;&#125;</code> 作为属性传递给 <code>SearchUser</code> 组件。</p><p>请尽可能保持 <code>props</code> 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 <code>props</code>，请使用包装组件，这样 Vue 才可以对状态变化做出反应。</p><h2 id="history工作模式"><a href="#history工作模式" class="headerlink" title="history工作模式"></a>history工作模式</h2><p>hash模式，页面不会重新加载，带#  ，url不好看</p><p>history模式, 页面会重新加载，但是需要后端配合配置，否则就报错了。url好看</p><pre><code class="js">const router = new VueRouter(&#123;  mode: &#39;history&#39;,  routes: [...]&#125;)</code></pre><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>导航守卫主要用来通过跳转或取消的方式守卫导航。分为：全局的, 单个路由独享的,和组件级的</p><p>记住<strong>参数或查询的改变并不会触发进入&#x2F;离开的导航守卫</strong>。你可以通过<a href="https://v3.router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">观察 <code>$route</code> 对象</a>来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫。例如：&#x2F;user&#x2F;1 和 &#x2F;user&#x2F;2 </p><p>守卫说白了，类似拦截器</p><h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p><pre><code class="js">const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123;  // ...&#125;)</code></pre><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p><p>每个守卫方法接收三个参数：</p><ul><li><strong><code>to: Route</code></strong>: 即将要进入的目标 <a href="https://v3.router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1">路由对象</a></li><li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</li><li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。<ul><li><strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li><li><strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li><li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://v3.router.vuejs.org/zh/api/#to"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://v3.router.vuejs.org/zh/api/#router-push"><code>router.push</code></a> 中的选项。</li><li><strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://v3.router.vuejs.org/zh/api/#router-onerror"><code>router.onError()</code></a> 注册过的回调。</li></ul></li></ul><p><strong>确保 <code>next</code> 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错</strong>。这里有一个在用户未能验证身份时重定向到 <code>/login</code> 的示例：</p><pre><code class="js">// BADrouter.beforeEach((to, from, next) =&gt; &#123;  if (to.name !== &#39;Login&#39; &amp;&amp; !isAuthenticated) next(&#123; name: &#39;Login&#39; &#125;)  // 如果用户未能验证身份，则 `next` 会被调用两次  next()&#125;)// GOODrouter.beforeEach((to, from, next) =&gt; &#123;  if (to.name !== &#39;Login&#39; &amp;&amp; !isAuthenticated) next(&#123; name: &#39;Login&#39; &#125;)  else next()&#125;)</code></pre><h3 id="全局后置守卫"><a href="#全局后置守卫" class="headerlink" title="全局后置守卫"></a>全局后置守卫</h3><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p><pre><code class="js">router.afterEach((to, from) =&gt; &#123;  // ...&#125;)</code></pre><h3 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h3><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/foo&#39;,      component: Foo,      beforeEnter: (to, from, next) =&gt; &#123;        // ...      &#125;    &#125;  ]&#125;)</code></pre><p>这些守卫与全局前置守卫的方法参数是一样的。</p><h3 id="组件独享守卫"><a href="#组件独享守卫" class="headerlink" title="组件独享守卫"></a>组件独享守卫</h3><p>可以在路由组件内直接定义以下路由导航守卫：</p><ul><li><code>beforeRouteEnter</code>   <strong>通过路由进入组件之前</strong></li><li><code>beforeRouteUpdate</code> (2.2 新增)   <strong>当前路由改变，但是该组件被复用时调用</strong></li><li><code>beforeRouteLeave</code>   <strong>通过路由离开组件之前</strong></li></ul><pre><code class="js">const Foo = &#123;  template: `...`,  beforeRouteEnter(to, from, next) &#123;    // 在渲染该组件的对应路由被 confirm 前调用    // 不！能！获取组件实例 `this`    // 因为当守卫执行前，组件实例还没被创建  &#125;,  beforeRouteUpdate(to, from, next) &#123;    // 在当前路由改变，但是该组件被复用时调用    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。    // 可以访问组件实例 `this`  &#125;,  beforeRouteLeave(to, from, next) &#123;    // 导航离开该组件的对应路由时调用    // 可以访问组件实例 `this`  &#125;&#125;</code></pre><h3 id="activated和deactivated"><a href="#activated和deactivated" class="headerlink" title="activated和deactivated"></a>activated和deactivated</h3><p>当在router-view开启组件缓存的时候,组件不会调用destoryd生命周期方法,此时可以通过activated和deactivated这两个方法判断当前组件是激活状态还是失活状态。</p><pre><code class="html">&lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;    &lt;keep-alive include=&quot;Foo&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;</code></pre><p>Foo.vue</p><pre><code class="html">&lt;template&gt;    &lt;!-- &lt;div&gt;foo组件：&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt; --&gt;    &lt;div&gt;foo组件：&#123;&#123;query&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Foo&#39;,  props: [&#39;query&#39;],  beforeRouteUpdate (to, from, next) &#123;    console.log(&#39;Foo组件独享守卫--beforeRouteUpdate&#39;, to, from)    next()  &#125;,  activated () &#123; // 组件被激活了    console.log(&#39;Foo组件activated&#39;)  &#125;,  deactivated () &#123;    console.log(&#39;Foo组件deactivated&#39;)  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>定义路由的时候可以配置 <code>meta</code> 字段，那么如何访问这个 <code>meta</code> 字段呢？<code>$route.matched</code> 数组</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/foo&#39;,      component: Foo,      children: [        &#123;          path: &#39;bar&#39;,          component: Bar,          // a meta field          meta: &#123; requiresAuth: true &#125;        &#125;      ]    &#125;  ]&#125;)</code></pre><p>下面例子展示在全局导航守卫中检查元字段：</p><pre><code class="js">router.beforeEach((to, from, next) =&gt; &#123;  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;    // this route requires auth, check if logged in    // if not, redirect to login page.    if (!auth.loggedIn()) &#123;      next(&#123;        path: &#39;/login&#39;,        query: &#123; redirect: to.fullPath &#125;      &#125;)    &#125; else &#123;      next()    &#125;  &#125; else &#123;    next() // 确保一定要调用 next()  &#125;&#125;)</code></pre><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>结合 Vue 的<a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6">异步组件 (opens new window)</a>和 Webpack 的<a href="https://doc.webpack-china.org/guides/code-splitting-async/#require-ensure-/">代码分割功能 (opens new window)</a>，轻松实现路由组件的懒加载。</p><pre><code class="js">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)</code></pre><p>webpackChunkName为打包分块的名称</p>]]></content>
    
    
    <summary type="html">vue-router笔记整理</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
    <category term="vue-router" scheme="https://heliufang.github.io/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>vuex笔记</title>
    <link href="https://heliufang.github.io/2022/07/06/1544666675947900928/images/"/>
    <id>https://heliufang.github.io/2022/07/06/1544666675947900928/images/</id>
    <published>2022-07-06T08:47:28.000Z</published>
    <updated>2022-12-21T03:49:06.122Z</updated>
    
    <content type="html"><![CDATA[<p>vuex官网：<a href="https://v3.vuex.vuejs.org/zh/">https://v3.vuex.vuejs.org/zh/</a></p><p>注意版本对应</p><p><font color="red">vue2要配合vuex3</font></p><p><font color="red">vue3要配合vuex4</font></p><h2 id="vuex简介"><a href="#vuex简介" class="headerlink" title="vuex简介"></a>vuex简介</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。（<strong>说白了就是用来共享数据，可以跨组件全局共享,类似后端的session</strong>）</p><p><img src="/2022/07/06/1544666675947900928/images/image-20220706094034605.png" alt="image-20220706094034605"></p><h2 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h2><p><img src="/2022/07/06/1544666675947900928/images/image-20220706094215433.png" alt="image-20220706094215433"></p><p>两种执行流程：</p><p>第一种(异步)：vue组件—&gt;actions—&gt;mutations—&gt;state</p><p>第二种：vue组件—&gt;mutations—&gt;state</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用<font color="red">vue cli</font>脚手架创建即可</p><h2 id="vuex入门案例"><a href="#vuex入门案例" class="headerlink" title="vuex入门案例"></a>vuex入门案例</h2><p>实现点击按钮+1的案例</p><p><img src="/2022/07/06/1544666675947900928/images/image-20220706100923900.png" alt="image-20220706100923900"></p><ul><li>views&#x2F;Count.vue 组件</li></ul><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;Count组件&lt;/h1&gt;    &lt;button @click=&quot;addToVuex&quot;&gt;vuex的count+1&lt;/button&gt;      &lt;!-- 模板中的this可以省略 --&gt;    &lt;div&gt;vuex中的count：&#123;&#123;$store.state.count&#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Count&#39;,  methods: &#123;    addToVuex () &#123;      this.$store.commit(&#39;add&#39;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><ul><li>store&#x2F;index.js</li></ul><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  getters: &#123;  &#125;,  mutations: &#123;    add (state) &#123;      state.count++    &#125;  &#125;,  actions: &#123;  &#125;,  modules: &#123;  &#125;&#125;)</code></pre><p>总结：</p><p>1&gt;在store.js的<strong>state</strong>中设置需要共享的数据</p><p>2&gt;在组件中通过 <strong>this.$store.state.变量名</strong> 来获取数据</p><p>3&gt;在store.js的mutations中新增改变数据方法add</p><p>4&gt;组件中通过  this.$store.commit(‘mutations中的方法’)来改变数据</p><blockquote><p>数据存在state中，通过提交 mutation 的方式，而非直接改变 <code>store.state.count</code>，是因为能够更明确地追踪到状态的变化</p></blockquote><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>Vuex 使用<strong>单一状态树</strong>，用一个对象就包含了全部的应用层级状态。这也意味着，每个应用将仅仅包含一个 store 实例。所以可以通过store来获取state中的数据</p><p>案例使用两种方式获取state中的数据</p><p>store&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    count: 2,    id: 111  &#125;  // ...&#125;)</code></pre><h3 id="this-store-state-变量"><a href="#this-store-state-变量" class="headerlink" title="this.$store.state.变量"></a>this.$store.state.变量</h3><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;Count组件&lt;/h1&gt;    &lt;!-- 模板中的this可以省略 下面两种其实是一样的--&gt;    &lt;div&gt;第一种vuex中的count：&#123;&#123;$store.state.count&#125;&#125;&lt;/div&gt;    &lt;div&gt;第二种vuex中的count：&#123;&#123;count&#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Count&#39;,  computed: &#123;    // 利用计算属性    count () &#123;      return this.$store.state.count    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="mapState访问"><a href="#mapState访问" class="headerlink" title="mapState访问"></a>mapState访问</h3><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;Count组件&lt;/h1&gt;    &lt;!-- 模板中的this可以省略 --&gt;    &lt;div&gt;vuex中的count：&#123;&#123;myCount+',id:'+myId&#125;&#125;&lt;/div&gt;     &lt;div&gt;vuex中的count：&#123;&#123;count+',id:'+id&#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  name: &#39;Count&#39;,  computed: &#123;    // myCount为自定义名称, count为vuex中state中的名称    ...mapState(&#123; myCount: &#39;count&#39;, myId: &#39;id&#39; &#125;),    // 当映射的计算属性的名称与 state 的子节点名称相同时，可以给 mapState 传一个字符串数组。    ...mapState([&#39;count&#39;, &#39;id&#39;])  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>Vuex 允许我们在 store 中定义“getter”（<strong>可以认为是 store 的计算属性</strong>）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><h3 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h3><ul><li>定义store&#x2F;index.js</li></ul><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    todos: [      &#123; id: 1, text: &#39;111&#39;, done: true &#125;,      &#123; id: 2, text: &#39;222&#39;, done: false &#125;,      &#123; id: 3, text: &#39;333&#39;, done: true &#125;    ]  &#125;,  getters: &#123;    // 接收一个参数    // doneTodos(state)&#123;    //   return state.todos.filter(v =&gt; v.done)    // &#125;,    doneTodos: state =&gt; state.todos.filter(v =&gt; v.done),    // 接收两个参数    doneTodosCount: (state, getters) =&gt; getters.doneTodos.length  &#125;  // ...&#125;)</code></pre><ul><li>组件中访问</li></ul><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;demo组件&lt;/h1&gt;    &lt;div&gt;id: &#123;&#123;$store.getters.doneTodos[0].id&#125;&#125;&lt;/div&gt;    &lt;div&gt;text: &#123;&#123;$store.getters.doneTodos[0].text&#125;&#125;&lt;/div&gt;    &lt;div&gt;done: &#123;&#123;$store.getters.doneTodos[0].done&#125;&#125;&lt;/div&gt;    &lt;div&gt;doneTodosCount: &#123;&#123;$store.getters.doneTodosCount&#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h3><p>通过让 getter 返回一个函数，来实现给 getter 传参</p><p>定义store&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    todos: [      &#123; id: 1, text: &#39;111&#39;, done: true &#125;,      &#123; id: 2, text: &#39;222&#39;, done: false &#125;,      &#123; id: 3, text: &#39;333&#39;, done: true &#125;    ]  &#125;,  getters: &#123;    // 让 getter 返回一个函数，来实现给 getter 传参    getTodoById: state =&gt; id =&gt; state.todos.find(v =&gt; v.id === id)  &#125;   // ...&#125;)</code></pre><p>组件中 可以传参</p><pre><code class="html">&lt;div&gt;getTodoById: &#123;&#123;$store.getters.getTodoById(3).text&#125;&#125;&lt;/div&gt;</code></pre><h3 id="mapGetters访问"><a href="#mapGetters访问" class="headerlink" title="mapGetters访问"></a>mapGetters访问</h3><p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性</p><p>和前面的mapState类似</p><p>定义store&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    todos: [      &#123; id: 1, text: &#39;111&#39;, done: true &#125;,      &#123; id: 2, text: &#39;222&#39;, done: false &#125;,      &#123; id: 3, text: &#39;333&#39;, done: true &#125;    ]  &#125;,  getters: &#123;    // 接收一个参数    // doneTodos(state)&#123;    //   return state.todos.filter(v =&gt; v.done)    // &#125;,    doneTodos: state =&gt; state.todos.filter(v =&gt; v.done),    // 接收两个参数    doneTodosCount: (state, getters) =&gt; getters.doneTodos.length,    // 让 getter 返回一个函数，来实现给 getter 传参    getTodoById: state =&gt; id =&gt; state.todos.find(v =&gt; v.id === id)  &#125;&#125;)</code></pre><p>组件中</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;demo组件&lt;/h1&gt;    &lt;div&gt;id: &#123;&#123;myDoneTodos[0].id&#125;&#125;&lt;/div&gt;    &lt;div&gt;text: &#123;&#123;myDoneTodos[0].text&#125;&#125;&lt;/div&gt;    &lt;div&gt;done: &#123;&#123;myDoneTodos[0].done&#125;&#125;&lt;/div&gt;    &lt;div&gt;doneTodosCount: &#123;&#123;doneTodosCount&#125;&#125;&lt;/div&gt;    &lt;div&gt;getTodoById: &#123;&#123;getTodoById(3).text&#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#39;vuex&#39;export default &#123;  name: &#39;Count&#39;,  computed: &#123;    ...mapGetters([&#39;doneTodosCount&#39;, &#39;getTodoById&#39;]),    ...mapGetters(&#123; myDoneTodos: &#39;doneTodos&#39; &#125;)  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h2><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。<strong>mutation 必须是同步函数</strong></p><h3 id="不带参数和带参数"><a href="#不带参数和带参数" class="headerlink" title="不带参数和带参数"></a>不带参数和带参数</h3><p>参数也叫载荷</p><p>store&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    add (state) &#123;      state.count++    &#125;,    // 参数也可以是对象、字符串、数组等    addN (state, p) &#123;      state.count += p    &#125;  &#125;&#125;)</code></pre><p>组件中  通过 <strong>store.commit</strong> 方法来调用mutations中的方法</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;demo组件&lt;/h1&gt;    &lt;div&gt;vuex中的count：&#123;&#123;count&#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;$store.commit(&#39;add&#39;)&quot;&gt;点击让 vuex 的count +1&lt;/button&gt;    &lt;button @click=&quot;$store.commit(&#39;addN&#39;,10)&quot;&gt;点击让 vuex 的count +10&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  name: &#39;Count&#39;,  computed: &#123;    ...mapState([&#39;count&#39;])  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="对象风格提交"><a href="#对象风格提交" class="headerlink" title="对象风格提交"></a>对象风格提交</h3><p>store&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    addNObj (state, p) &#123;      //p就是commit提交过来的对象 &#123;type: &#39;addNObj&#39;, n: 10&#125;      state.count += p.n    &#125;  &#125;    //...&#125;)</code></pre><p>组件中</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;demo组件&lt;/h1&gt;    &lt;div&gt;vuex中的count：&#123;&#123;count&#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;addNObj&quot;&gt;点击让 vuex 的count +10&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  name: &#39;Count&#39;,  computed: &#123;    ...mapState([&#39;count&#39;])  &#125;,  methods: &#123;    addNObj () &#123;        //此处提交一个对象参数，而不是像以前那种传两个参数        //type对应mutation中的函数,n代表传来的参数,参数可以是多个      this.$store.commit(&#123;        type: &#39;addNObj&#39;,        n: 10      &#125;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h3><p>使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用</p><p>组件</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;demo组件&lt;/h1&gt;    &lt;div&gt;vuex中的count：&#123;&#123;count&#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;add&quot;&gt;点击让 vuex 的count +1&lt;/button&gt;    &lt;button @click=&quot;myAdd&quot;&gt;点击让 vuex 的count +1&lt;/button&gt;    &lt;button @click=&quot;addN(10)&quot;&gt;点击让 vuex 的count +10&lt;/button&gt;    &lt;button @click=&quot;addNObj(&#123;n: 10&#125;)&quot;&gt;点击让 vuex 的count +10(提交对象)&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapMutations, mapState &#125; from &#39;vuex&#39;export default &#123;  name: &#39;Count&#39;,  computed: &#123;    ...mapState([&#39;count&#39;])  &#125;,  methods: &#123;      //将 this.add() 映射为 this.$store.commit(&#39;add&#39;) ...    ...mapMutations([&#39;add&#39;, &#39;addN&#39;, &#39;addNObj&#39;]),    ...mapMutations(&#123; myAdd: &#39;add&#39; &#125;)  &#125;&#125;&lt;/script&gt;</code></pre><p>store&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    add (state) &#123;      state.count++    &#125;,    addN (state, p) &#123;      state.count += p    &#125;,    addNObj (state, p) &#123;      console.log(p)      state.count += p.n    &#125;  &#125;    //...&#125;)</code></pre><h2 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h2><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><h3 id="分发action"><a href="#分发action" class="headerlink" title="分发action"></a>分发action</h3><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p><p>组件中可以 <strong>this.$store.dispatch(‘xxx’)</strong>  来分发</p><p>store&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    add (state) &#123;      state.count++    &#125;,    addN (state, p) &#123;      state.count += p    &#125;,    addNObj (state, p) &#123;      console.log(p)      state.count += p.n    &#125;  &#125;,  actions: &#123;    // addTimeout (context) &#123;    addTimeout (&#123; commit &#125;) &#123;      // 执行异步操作      setTimeout(() =&gt; &#123;        commit(&#39;add&#39;)      &#125;, 1000)    &#125;,         addNTimeout (&#123; commit &#125;, p) &#123; //普通传参      console.log(p)      setTimeout(() =&gt; &#123;// 执行异步操作        commit(&#39;addN&#39;, p)      &#125;, 1000)    &#125;,    addNObjTimeout (&#123; commit &#125;, p) &#123;//对象风格传参      console.log(p)      setTimeout(() =&gt; &#123;        commit(&#39;addNObj&#39;, p)      &#125;, 1000)    &#125;  &#125;&#125;)</code></pre><p>组件  中 通过 <code>this.$store.dispatch</code> 方法触发：</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;demo组件&lt;/h1&gt;    &lt;div&gt;vuex中的count：&#123;&#123;count&#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;$store.dispatch(&#39;addTimeout&#39;)&quot;&gt;点击等1秒 让 vuex 的count +1&lt;/button&gt;    &lt;button @click=&quot;$store.dispatch(&#39;addNTimeout&#39;,10)&quot;&gt;点击等1秒(载荷) 让 vuex 的count +10&lt;/button&gt;     &lt;button @click=&quot;$store.dispatch(&#123;      type:&#39;addNObjTimeout&#39;,      n:10     &#125;)&quot;&gt;点击等1秒(对象风格) 让 vuex 的count +10&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#39;vuex&#39;export default &#123;  name: &#39;Count&#39;,  computed: &#123;    ...mapState([&#39;count&#39;])  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h3><p>使用mapActions简化上面的例子,将组件的代码改为如下</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;demo组件&lt;/h1&gt;    &lt;div&gt;vuex中的count：&#123;&#123;count&#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;addTimeout&quot;&gt;点击等1秒 让 vuex 的count +1&lt;/button&gt;    &lt;button @click=&quot;addNTimeout(10)&quot;&gt;点击等1秒(载荷) 让 vuex 的count +10&lt;/button&gt;    &lt;button @click=&quot;myAddNObjTimeout(&#123;n:10&#125;)&quot;&gt;点击等1秒(对象) 让 vuex 的count +10&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, mapActions &#125; from &#39;vuex&#39;export default &#123;  name: &#39;Count&#39;,  computed: &#123;    ...mapState([&#39;count&#39;])  &#125;,  methods: &#123;    //将 this.addTimeout() 映射为 this.$store.dispatch(&#39;addTimeout&#39;) ...    ...mapActions([&#39;addTimeout&#39;, &#39;addNTimeout&#39;]),    ...mapActions(&#123; myAddNObjTimeout: &#39;addNObjTimeout&#39; &#125;)  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="组合action"><a href="#组合action" class="headerlink" title="组合action"></a>组合action</h3><p><code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise。（一个action去调用另外一个action）</p><p>组件</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;demo组件&lt;/h1&gt;    &lt;div&gt;vuex中的count：&#123;&#123;count&#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;addNTimeout&quot;&gt;点击1秒后cout+1，再过1秒后count+10&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, mapActions &#125; from &#39;vuex&#39;export default &#123;  name: &#39;Count&#39;,  computed: &#123;    ...mapState([&#39;count&#39;])  &#125;,  methods: &#123;    ...mapActions([&#39;addNTimeout&#39;])  &#125;&#125;&lt;/script&gt;</code></pre><p>store&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    add (state) &#123;      state.count++    &#125;,    addN (state, p) &#123;      state.count += p    &#125;  &#125;,  actions: &#123;    // addTimeout (context) &#123;    addTimeout (&#123; commit &#125;) &#123;      return new Promise((resolve, reject) =&gt; &#123;        // 执行异步操作        setTimeout(() =&gt; &#123;          commit(&#39;add&#39;)          resolve()        &#125;, 1000)      &#125;)    &#125;,   /* addNTimeout (&#123; commit, dispatch &#125;) &#123;      // 将addTimeout这个action组合进来      dispatch(&#39;addTimeout&#39;).then(() =&gt; &#123;        // 执行异步操作        setTimeout(() =&gt; &#123;          commit(&#39;addN&#39;, 10)        &#125;, 1000)      &#125;)    &#125;*/      //用es6的async/await来优化    async addNTimeout (&#123; commit, dispatch &#125;) &#123;      // 将addTimeout这个action组合进来      await dispatch(&#39;addTimeout&#39;)      // 执行异步操作      console.log(&#39;1010101010&#39;)      setTimeout(() =&gt; &#123;        commit(&#39;addN&#39;, 10)      &#125;, 1000)    &#125;  &#125;&#125;)</code></pre><h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</p><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。</p><p>模块化语法总结：</p><pre><code>第一： $store.commit和$store.dispatch 第一个参数为【模块名/方法命名】例如：$store.commit(&#39;moduleA/addN&#39;,10)$store.dispatch(&#39;moduleA/addNTimeout&#39;,10)第二：...mapXXX 第一个参数为模块名字符串,第二个参数和以前的写法一致例如：...mapState(&#39;moduleA&#39;, [&#39;count&#39;]),...mapState(&#39;moduleA&#39;, &#123; moduleAcount: &#39;count&#39; &#125;),第三: ...mapState和...mapGetters写在计算属性(computed)...mapMutations和...mapActions写在方法里(methods)</code></pre><p>【模块化案例】</p><p>store&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)// 当然也可以把moduleA单独放入到一个js文件中const moduleA = &#123;  namespaced: true,//开启命名空间  state: &#123;    count: 123  &#125;,  getters: &#123;    getX2 (state) &#123;      return state.count * 2    &#125;  &#125;,  mutations: &#123;    addN (state, p) &#123;      state.count += p    &#125;  &#125;,  actions: &#123;    addNTimeout (&#123; commit &#125;, p) &#123;      setTimeout(() =&gt; &#123;        commit(&#39;addN&#39;, p)      &#125;, 1000)    &#125;  &#125;&#125;//moduleB ...//modulec ...export default new Vuex.Store(&#123;  modules: &#123;    moduleA      //moduleB ...    //modulec ...  &#125;&#125;)</code></pre><p>组件中使用</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;模块中state的使用&lt;/h1&gt;    &lt;div&gt;moduleA的count：&#123;&#123; $store.state.moduleA.count &#125;&#125;&lt;/div&gt;    &lt;div&gt;moduleA的count：&#123;&#123; count &#125;&#125;&lt;/div&gt;    &lt;div&gt;moduleA的count：&#123;&#123; moduleAcount &#125;&#125;&lt;/div&gt;    &lt;h1&gt;模块中gettters的使用&lt;/h1&gt;    &lt;div&gt;moduleA的getters：&#123;&#123; $store.getters['moduleA/getX2'] &#125;&#125;&lt;/div&gt;    &lt;div&gt;moduleA的getters：&#123;&#123; getX2 &#125;&#125;&lt;/div&gt;    &lt;div&gt;moduleA的getters：&#123;&#123; moduleAGetX2 &#125;&#125;&lt;/div&gt;     &lt;h1&gt;模块中mutations的使用&lt;/h1&gt;    &lt;div&gt;&lt;button @click=&quot;$store.commit(&#39;moduleA/addN&#39;,10)&quot;&gt;moduleA的mutations+10&lt;/button&gt;&lt;/div&gt;    &lt;div&gt;&lt;button @click=&quot;addN(10)&quot;&gt;moduleA的mutations+10&lt;/button&gt;&lt;/div&gt;    &lt;div&gt;&lt;button @click=&quot;moduleAAddN(10)&quot;&gt;moduleA的mutations+10&lt;/button&gt;&lt;/div&gt;     &lt;h1&gt;模块中actions的使用&lt;/h1&gt;    &lt;div&gt;&lt;button @click=&quot;$store.dispatch(&#39;moduleA/addNTimeout&#39;,10)&quot;&gt;moduleA的actions+10&lt;/button&gt;&lt;/div&gt;     &lt;div&gt;&lt;button @click=&quot;addNTimeout(10)&quot;&gt;moduleA的actions+10&lt;/button&gt;&lt;/div&gt;     &lt;div&gt;&lt;button @click=&quot;moduleAAddNTimeout(10)&quot;&gt;moduleA的actions+10&lt;/button&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, mapGetters, mapMutations, mapActions &#125; from &#39;vuex&#39;export default &#123;  name: &#39;Count&#39;,  computed: &#123;    ...mapState(&#39;moduleA&#39;, [&#39;count&#39;]),    ...mapState(&#39;moduleA&#39;, &#123; moduleAcount: &#39;count&#39; &#125;),    ...mapGetters(&#39;moduleA&#39;, [&#39;getX2&#39;]),    ...mapGetters(&#39;moduleA&#39;, &#123; moduleAGetX2: &#39;getX2&#39; &#125;)  &#125;,  methods: &#123;    ...mapMutations(&#39;moduleA&#39;, [&#39;addN&#39;]),    ...mapMutations(&#39;moduleA&#39;, &#123; moduleAAddN: &#39;addN&#39; &#125;),    ...mapActions(&#39;moduleA&#39;, [&#39;addNTimeout&#39;]),    ...mapActions(&#39;moduleA&#39;, &#123; moduleAAddNTimeout: &#39;addNTimeout&#39; &#125;)  &#125;&#125;&lt;/script&gt;</code></pre>]]></content>
    
    
    <summary type="html">vuex笔记整理</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
    <category term="vuex" scheme="https://heliufang.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>黑马头条-vue移动端项目笔记整理</title>
    <link href="https://heliufang.github.io/2022/06/30/1542451686885429248/images/"/>
    <id>https://heliufang.github.io/2022/06/30/1542451686885429248/images/</id>
    <published>2022-06-30T10:10:28.000Z</published>
    <updated>2022-12-21T03:48:43.148Z</updated>
    
    <content type="html"><![CDATA[<p>b站教学视频 <a href="https://www.bilibili.com/video/BV1D3411L7PP">Vue2_项目_黑马头条-移动端项目</a></p><p>视频里配套资料: <a href="http://m6z.cn/6guyjV">http://m6z.cn/6guyjV</a><br>最新的接口基地址: <a href="http://geek.itheima.net/">http://geek.itheima.net/</a></p><p>只记录自己get到的一些知识，详细的老师的配套的笔记里面都有</p><h2 id="vue-cli脚手架创建项目"><a href="#vue-cli脚手架创建项目" class="headerlink" title="vue-cli脚手架创建项目"></a>vue-cli脚手架创建项目</h2><ul><li>安装vue-cli脚手架</li></ul><pre><code>npm install -g @vue/cli</code></pre><ul><li>创建项目  采用自定义方式去创建项目</li></ul><pre><code>vue create hmtt</code></pre><p>上下箭头切换, 回车确认, 空格选中</p><pre><code>? Please pick a preset:  Default ([Vue 2] babel, eslint)  Default (Vue 3 Preview) ([Vue 3] babel, eslint)&gt; Manually select features  </code></pre><p>手动选择特性:  Babel, Router, Vuex,  CSS Pre-processors, Linter</p><pre><code>? Please pick a preset: Manually select features? Check the features needed for your project: (*) Choose Vue version (*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex&gt;(*) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing  </code></pre><p>版本Vue2.x</p><pre><code>? Choose a version of Vue.js that you want to start the project with (Use arrow keys)&gt; 2.x  3.x (Preview) </code></pre><p>路由是否使用history模式：不采用</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630153712490.png" alt="image-20220630153712490"></p><p>css 预处理器: 使用less</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630153737945.png" alt="image-20220630153737945"></p><p>eslint语法风格：Standard (一定)</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630153811062.png" alt="image-20220630153811062"></p><p>检查节点：保存时检查，提交时检查 (提交时可以不选)</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630153831434.png" alt="image-20220630153831434"></p><p>存储插件配置位置：单独放在不同的文件中 </p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630153904318.png" alt="image-20220630153904318"></p><p>接下来，它会问你是否要保存前面的设置作为预设方案，以便后续创建其它项目时直接使用。</p><p>如果选择Y, 保存, 以后就可以一键完成以上步骤</p><p>经过长长的等待，创建完毕, 进入文件夹, 启动项目</p><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><ol><li><p>什么是ESLint?</p><p>代码检查工具</p></li><li><p>为什么要使用ESLint?</p><p>规范我们写代码的格式, 看着整洁 &#x2F; 团队内成员风格统一</p></li><li><p>ESLint在哪里生效?</p><p>webpack开发服务器+ESLint配置检查</p></li></ol><p>规范文档: <a href="http://www.verydoc.net/eslint/00003312.html">http://www.verydoc.net/eslint/00003312.html</a></p><p>规范文档2: <a href="https://standardjs.com/rules-zhcn.html">https://standardjs.com/rules-zhcn.html</a></p><p>规范文档3: <a href="http://eslint.cn/docs/rules/">http://eslint.cn/docs/rules/</a></p><h3 id="vscode的eslint插件"><a href="#vscode的eslint插件" class="headerlink" title="vscode的eslint插件"></a>vscode的eslint插件</h3><p>ctrl+s 这个插件就会修复常见的eslint抛出的错误</p><ul><li>下载这个插件到vscode中</li></ul><p><img src="/2022/06/30/1542451686885429248/images/image-20220630154354610.png" alt="image-20220630154354610"></p><p>注意： 一定要把脚手架工程, 作为vscode<strong>根目录</strong>, 因为eslint要使用配置文件.eslintrc</p><ul><li>一定要配置插件监测的时机, 修改ESLint插件配置</li></ul><p><img src="/2022/06/30/1542451686885429248/images/image-20220630154453277.png" alt="image-20220630154453277"></p><p>不用管别的, 把红框的放在{}内即可</p><pre><code class="json">&quot;eslint.run&quot;: &quot;onType&quot;,&quot;editor.codeActionsOnSave&quot;: &#123;    &quot;source.fixAll.eslint&quot;: true&#125;</code></pre><p>更多的规则可以参考这里: <a href="https://www.cnblogs.com/jiaoshou/p/12218642.html">https://www.cnblogs.com/jiaoshou/p/12218642.html</a></p><p>.eslintrc.js 配置文件关闭驼峰命名</p><pre><code class="js">rules: &#123;    &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;warn&#39; : &#39;off&#39;,    &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;warn&#39; : &#39;off&#39;,    // 取消文件和变量的驼峰命名    &#39;vue/multi-word-component-names&#39;: 0,    camelcase: &#39;off&#39;  &#125;</code></pre><h2 id="vant组件库"><a href="#vant组件库" class="headerlink" title="vant组件库"></a>vant组件库</h2><p>移动端组件库</p><p>vant官网：<a href="https://vant-contrib.gitee.io/vant/v2/#/zh-CN/quickstart">https://vant-contrib.gitee.io/vant/v2/#/zh-CN/quickstart</a></p><ul><li>下载vant组件库</li></ul><pre><code class="js">yarn add vant# Vue 2 项目，安装 Vant 2：npm i vant@latest-v2 -S</code></pre><ul><li>下载插件</li></ul><pre><code class="js">yarn add babel-plugin-import -D</code></pre><ul><li>在babel.config.js-添加如下配置</li></ul><pre><code class="js">module.exports = &#123;    // ...省略了其他    plugins: [        [&#39;import&#39;, &#123;            libraryName: &#39;vant&#39;,            libraryDirectory: &#39;es&#39;,            style: true        &#125;, &#39;vant&#39;]    ]&#125;;</code></pre><p>一定要重启vscode和webpack开发服务器才会生效</p><h3 id="组件库样式的定制"><a href="#组件库样式的定制" class="headerlink" title="组件库样式的定制"></a>组件库样式的定制</h3><p>vant组件配置 - <strong>less文件</strong></p><ul><li>src&#x2F;styles&#x2F;cover.less - vant定制less变量统一在这管理</li></ul><pre><code class="css">// NavBar导航@nav-bar-background-color:#007bff;@nav-bar-title-text-color:white;</code></pre><ul><li>vue.config.js - 注释变量, 放开引入文件路径</li></ul><pre><code class="js">// 不要手动写绝对路径, 用代码来动态获取, 绝对地址const path = require(&#39;path&#39;)// console.log(__dirname) // 当前文件, 所在文件夹, 的绝对路径// 盘符:/......../工程名字, 后面自己拼接 src/styles/cover.lessmodule.exports = &#123;  css: &#123;    loaderOptions: &#123;      less: &#123;        modifyVars: &#123;          // 直接覆盖变量          // &#39;nav-bar-background-color&#39;: &#39;#007bff&#39;,          // &#39;nav-bar-title-text-color&#39;: &#39;white&#39;,          // 或者可以通过 less 文件覆盖（文件路径为绝对路径）          hack: `true; @import &quot;$&#123;path.resolve(__dirname, &#39;src/styles/cover.less&#39;)&#125;&quot;;`        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>一定要重启webpack开发服务器, 然后观察效果</p><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><p>PC端一般都是1:1用px还原UI设计图, 靠内容撑开高度</p><p>移动端一般都是<strong>rem单位进行适配</strong></p><p>步骤：</p><ul><li>下载amfe-flexible    根据网页宽度, 设置html的font-size</li></ul><pre><code class="js">yarn add amfe-flexible</code></pre><ul><li>到main.js引入</li></ul><pre><code class="js">import &quot;amfe-flexible&quot;</code></pre><ul><li>下载postcss和<a href="mailto:&#112;&#x6f;&#115;&#x74;&#x63;&#x73;&#115;&#45;&#112;&#x78;&#116;&#x6f;&#x72;&#x65;&#109;&#x40;&#53;&#x2e;&#49;&#x2e;&#x31;">&#112;&#x6f;&#115;&#x74;&#x63;&#x73;&#115;&#45;&#112;&#x78;&#116;&#x6f;&#x72;&#x65;&#109;&#x40;&#53;&#x2e;&#49;&#x2e;&#x31;</a></li></ul><p>postcss: 后处理css, 编译翻译css代码</p><p>postcss-pxtorem: 把css代码里所有px计算转换成rem</p><pre><code>yarn add postcss postcss-pxtorem@5.1.1</code></pre><ul><li>根目录下创建postcss.config.js文件</li></ul><pre><code class="js">module.exports = &#123;  plugins: &#123;    &#39;postcss-pxtorem&#39;: &#123;      // 能够把所有元素的px单位转成Rem      // rootValue: 转换px的基准值。      // 编码时, 一个元素宽是75px，则换成rem之后就是2rem      rootValue: 37.5,      propList: [&#39;*&#39;]    &#125;  &#125;&#125;</code></pre><p>37.5 是如何得来的?</p><p>UI移动端设计图宽度375px, 而flexible.js会&#x2F;10, 设置html的font-size为37.5</p><p><em>一般屏幕的适配方案为 1rem&#x3D;屏幕宽度的十分之一</em></p><p>总结：</p><ol><li><p>移动端适配选择哪种?</p><p>rem + flexible.js</p></li><li><p>flexible.js作用是什么?</p><p>js代码里获取网页宽度 &#x2F; 10设置html的font-size的值(px单位)</p></li><li><p>代码里px如何自动转换rem?</p><p>postcss和postcss-pxtorem插件</p></li></ol><h2 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h2><ul><li>下载axios</li></ul><pre><code class="js">yarn add axios</code></pre><ul><li>request.js</li></ul><pre><code class="js">import ajax from &#39;axios&#39;import router from &#39;@/router&#39;import &#123; Notify &#125; from &#39;vant&#39;import &#123; getToken &#125; from &#39;@/utils/token&#39;// 创建axios实例const axios = ajax.create(&#123;  baseURL: &#39;http://toutiao.itheima.net&#39;,  timeout: 20000 // 超时时间为20s&#125;)// 添加请求拦截器axios.interceptors.request.use(function (config) &#123;  // 在发送请求之前做些什么  // 如果本地有token则携带在请求头中传给后台  // console.log(config)  if (getToken()?.length &gt; 0 &amp;&amp; config.headers.Authorization === undefined) &#123;    config.headers.Authorization = `Bearer $&#123;getToken()&#125;`  &#125;  return config&#125;, function (error) &#123;  // 对请求错误做些什么  return Promise.reject(error)&#125;)// 添加响应拦截器axios.interceptors.response.use(function (response) &#123;  // 对响应数据做点什么  return response&#125;, function (error) &#123;  // 对响应错误做点什么  /**   * 响应401说明token失效--》跳转到登录页面   */  if (error.response.status === 401) &#123;    router.push(&#39;/login&#39;)    Notify(&#123; type: &#39;danger&#39;, message: &#39;登录已过期&#39; &#125;)  &#125;  return Promise.reject(error)&#125;)// 封装axios方法export default (&#123; url, method = &#39;GET&#39;, data = &#123;&#125;, params = &#123;&#125;, headers = &#123;&#125; &#125;) =&gt; &#123;  return axios(&#123;    url,    method,    data,    params,    headers  &#125;)&#125;</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>axios库中params里的值为null, 会自动忽略此参数和值, 不发给后台</p><p>axios库中data里的值为null, 会发给后台</p><p>axios可以在响应错误的拦截器中，按之前的配置重新发起请求  axios(error.config)</p><ul><li>token的续签</li></ul><p>定义刷新token的接口方法</p><pre><code class="js">// 用户 - 更新tokenexport const refreshTokenAPI = () =&gt; request(&#123;  url: &#39;/v1_0/authorizations&#39;,  method: &#39;PUT&#39;,  headers: &#123;    Authorization: `Bearer $&#123;store.state.refresh_token&#125;`  &#125;&#125;)</code></pre><p>在响应拦截器401处, 调用重新请求token的接口, 然后同步给vuex和本地</p><pre><code class="js">axios.interceptors.response.use(function (response) &#123;   return response&#125;, async function (error) &#123;  if (error.response.status === 401) &#123; // 身份过期    // token续签方式1:    // store.commit(&#39;setToken&#39;, &#39;&#39;)    // router.push(&#123; path: &#39;/login&#39; &#125;)    // token续签方式2: refreshToken(用户无感知)    const res = await refreshTokenAPI()    // 再调用一次未完成的请求啊(用户无感知)    // error.config 就是上一次axios请求的配置对象    // console.dir(error.config)    // 把新的token赋予到下一次axios请求的请求头中    error.config.headers.Authorization = &#39;Bearer &#39; + res.data.data.token    // return到await的地方    return axios(error.config) //重点！！！：通过axios重新发起请求  &#125; else &#123;    return Promise.reject(error)  &#125;&#125;)</code></pre><h2 id="try和catch"><a href="#try和catch" class="headerlink" title="try和catch"></a>try和catch</h2><ol><li>await用于取代then函数, 等待Promise成功结果提取在原地</li><li>await无法获取Promise失败的结果, 一旦失败Promise错误直接抛出到控制台</li></ol><p>可以利用try和catch解决上面的问题</p><pre><code class="js">try &#123;    // 可能会报错的代码(例如await)&#125; catch (err) &#123;    // try里代码报错, 捕捉到这里执行&#125;</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li><p>$router和$route区别是?</p><ul><li><p>$router下用于跳转路由</p></li><li><p>$route是路由信息对象</p></li></ul></li><li><p>路由的push和replace方法区别?</p><ul><li>push跳转后, 可以返回</li><li>replace跳转后, 无法返回</li></ul></li><li><p>什么时候用$route.query 什么时候用$route.params</p><ul><li>$route.params  —&gt;动态路由</li><li>$route.query  —&gt;问号传参</li></ul></li><li><p>路由的懒加载</p></li></ol><p>路由懒加载 - 查看文档: <a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><pre><code class="js">component: Login// 改成这个写法component: () =&gt; import(&#39;@/views/Login.vue&#39;)</code></pre><ol start="5"><li>路由守卫(类似后端的拦截器)</li></ol><p>方法1: 全局前置守卫判断</p><pre><code class="js">router.beforeEach((to, from, next) =&gt; &#123;  // 有token, 不能去登录页  // 无token, 需要用户&quot;权限&quot;的才需要去登录页  if (store.state.token.length &gt; 0 &amp;&amp; to.path === &#39;/login&#39;) &#123;    // 证明有token-已经登录了    next(false) // 阻止跳转原地呆着  &#125; else &#123;    next()  &#125;&#125;)</code></pre><p>方法2: 路由独享守卫（可以理解为局部的守卫，针对某个路由拦截）</p><pre><code class="js">&#123;    path: &#39;/login&#39;,    component: () =&gt; import(/* webpackChunkName: &quot;Login&quot; */ &#39;@/views/Login&#39;),    beforeEnter (to, from, next) &#123;      if (store.state.token.length &gt; 0) &#123; // vuex里有token(代表登录过, 但是一定要注意过期和主动退出要先清除vuex和本地的token, 让其跳转登录页)        return next(false)      &#125;      next()    &#125;&#125;,</code></pre><h2 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h2><p>dayjs第三方库: <a href="https://dayjs.fenxianglu.cn/">https://dayjs.fenxianglu.cn/</a></p><ul><li>安装</li></ul><pre><code class="js">npm install dayjs --save</code></pre><ul><li>使用</li></ul><pre><code class="js">var dayjs = require(&#39;dayjs&#39;)//import dayjs from &#39;dayjs&#39; // ES 2015dayjs().format()</code></pre><p>utils&#x2F;date.js</p><pre><code class="js">import dayjs from &#39;dayjs&#39;import relativeTime from &#39;dayjs/plugin/relativeTime&#39; // 到指定时间需要的插件import &#39;dayjs/locale/zh&#39; // 集成中文/** * .....多久之前 * @param &#123;*&#125; 之前的时间 * @returns 系统时间到之前指定时间的距离值 */export const timeAgo = (targetTime) =&gt; &#123;  // 格式化时间  dayjs.extend(relativeTime)  dayjs.locale(&#39;zh&#39;)  var a = dayjs()  var b = dayjs(targetTime)  return a.to(b) // 返回多久之前...&#125;</code></pre><p>扩展-自己写多久之前</p><pre><code class="js">relativeTime (val) &#123;      const t = new Date(val)      const diff = Date.now() - t.getTime()      const year = Math.floor(diff / (1000 * 3600 * 24 * 365))      if (year) &#123;        return `$&#123;year&#125;年前`      &#125;      const month = Math.floor(diff / (1000 * 3600 * 24 * 30))      if (month) &#123;        return `$&#123;month&#125;月前`      &#125;      const day = Math.floor(diff / (1000 * 3600 * 24))      if (day) &#123;        return `$&#123;day&#125;天前`      &#125;      const hour = Math.floor(diff / (1000 * 3600))      if (hour) &#123;        return `$&#123;hour&#125;小时前`      &#125;      const minute = Math.floor(diff / (1000 * 60))      if (minute) &#123;        return `$&#123;minute&#125;分钟前`      &#125; else &#123;        return &#39;刚才&#39;      &#125;    &#125;</code></pre><h2 id="自定义指令-封装"><a href="#自定义指令-封装" class="headerlink" title="自定义指令-封装"></a>自定义指令-封装</h2><ul><li>utils&#x2F;directives.js, 定义全局自定义指令插件</li></ul><pre><code class="js">import Vue from &#39;vue&#39;// 插件对象(必须有install方法, 才可以注入到Vue.use中)export default &#123;  install () &#123;    Vue.directive(&#39;fofo&#39;, &#123;      inserted (el) &#123;//插入dom的时候执行        fn(el)      &#125;,      update (el) &#123;//更新dom的时候执行        fn(el)      &#125;    &#125;)  &#125;&#125;function fn (el) &#123;  if (el.nodeName === &#39;INPUT&#39; || el.nodeName === &#39;TEXTAREA&#39;) &#123;    // 如果直接是input标签/textarea标签    el.focus()  &#125; else &#123;    // 指令在van-search组件身上, 获取的是组件根标签div, 而input在标签内    const inp = el.querySelector(&#39;input&#39;)    const textArea = el.querySelector(&#39;textarea&#39;)    // 如果找到了    if (inp || textArea) &#123;      inp &amp;&amp; inp.focus()      textArea &amp;&amp; textArea.focus()    &#125; else &#123;      // 本身也不是, 子标签里也没有      console.error(&#39;请把v-fofo用在输入框标签上&#39;)    &#125;  &#125;&#125;</code></pre><ul><li>引入到main.js注册</li></ul><pre><code class="js">import diretivesObj from &#39;@/utils/directives&#39;Vue.use(diretivesObj)</code></pre><p>Vue.use相关文档: <a href="https://cn.vuejs.org/v2/api/#Vue-use">https://cn.vuejs.org/v2/api/#Vue-use</a></p><p>Vue.use(obj)  其实就是注册，内部会调用install方法</p><p>自定义指令的inserted何时执行?</p><ul><li>当指令所在组件, 第一次插入到真实DOM被调用</li></ul><h2 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h2><p>在前端可以通过meta来设置referrer policy(来源策略)，referrer设置成<code>no-referrer</code>，发送请求不会带上referrer信息，对方服务器也就无法拦截了</p><pre><code class="html">&lt;!-- 解决图片403防盗链问题 --&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></pre><p>但是如果他们做了其他判断, 我们依旧拿不到此图片</p><h2 id="给组件加原生事件"><a href="#给组件加原生事件" class="headerlink" title="给组件加原生事件"></a>给组件加原生事件</h2><p>组件默认没有click事件的时候，如果想用click事件怎么办？利用navive</p><pre><code class="html">&lt;article-item              v-for=&quot;obj in articleList&quot;              :key=&quot;obj.art_id&quot;              :obj=&quot;obj&quot;              @click.native=&quot;$router.push(`/article_detail?aid=$&#123;obj.art_id&#125;`)&quot;              :showX=&quot;false&quot;              &gt;&lt;/article-item&gt;</code></pre><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><p>通过.stop来阻止</p><pre><code class="html">&lt;!-- 反馈按钮 --&gt;&lt;van-icon name=&quot;cross&quot; @click.stop=&quot;onCloseClick&quot; /&gt;</code></pre><h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>后面再找点资料详细看看</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>利用 Set 和 Array.from实现</p><pre><code class="js">this.history = Array.from(new Set(this.history)) // 去重</code></pre><h2 id="文件上传-隐藏域"><a href="#文件上传-隐藏域" class="headerlink" title="文件上传-隐藏域"></a>文件上传-隐藏域</h2><p>当点击的是非 input[type&#x3D;’file’] 的时，不会弹出选择文件的框。此时可以设置一个隐藏的文件框，通过js来触发这个文件框的点击事件，从而实现文件上传。</p><pre><code class="html">&lt;van-cell title=&quot;头像&quot; is-link center&gt;    &lt;template #default&gt;        &lt;van-image round class=&quot;avatar&quot; :src=&quot;profile.photo&quot;                    &lt;!-- js触发点击事件 --&gt;                   @click=&quot;$refs.iptFile.click()&quot;/&gt;        &lt;!-- file 选择框 --&gt;        &lt;input               type=&quot;file&quot;               ref=&quot;iptFile&quot;               v-show=&quot;false&quot;               accept=&quot;image/*&quot;               @change=&quot;onFileChange&quot;               /&gt;    &lt;/template&gt;&lt;/van-cell&gt;&lt;script&gt;export default &#123;  methods: &#123;    // 文件选择方法    async onFileChange (ev) &#123;    //   console.log(ev.target.files[0])      if (ev.target.files.length === 0) return // 防止用户未选择图片      const fd = new FormData()      fd.append(&#39;photo&#39;, ev.target.files[0]) // photo在表单里参数名携带      const res = await updatePhotoAPI(fd)      console.log(res)      this.profile.photo = res.data.data.photo // 更新最新头像    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>接口</p><pre><code class="js">// 用户- 更新头像// 注意: formObj的值必须是一个表单对象// &#39;&#123;&quot;a&quot;: 10, &quot;b&quot;: 20&#125;&#39; // 对象格式的JSON字符串// new FormData() // 表单对象export const updatePhotoAPI = (formObj) =&gt; &#123;  return request(&#123;    url: &#39;/v1_0/user/photo&#39;,    method: &#39;PATCH&#39;,    data: formObj    // 如果你的请求体内容是表单对象, 浏览器会自动携带请求头Content-Type为multipart/form-data  &#125;)&#125;</code></pre><h2 id="api接口分文件"><a href="#api接口分文件" class="headerlink" title="api接口分文件"></a>api接口分文件</h2><ul><li>原因: 一个api&#x2F;index.js, 有几百行代码, 不便于管理</li><li>解决: 分散到多个js文件里, 再引入回到统一导出<ul><li>分散的js文件名, 尽量和页面模块同名, 方便查找</li></ul></li></ul><p>问题1: 分文件后, 逻辑页面里都是从api&#x2F;index.js导出的, 难道我们要去改逻辑代码?</p><p>解决: 在api&#x2F;index.js - 中  export * from ‘分散的文件’  (模块重定向)</p><p>意思: 在api&#x2F;index.js 作为入口, 从别的地方把接口倒回来同时导出给外面</p><blockquote><p>export 文档: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export</a></p></blockquote><p>注意; 包括reports.js文件也从统一出口导出, 去修改src&#x2F;components&#x2F;ArticleItem引数据位置</p><p>处理结果 api&#x2F;index.js如下</p><pre><code class="js">export * from &#39;./reports&#39; // 反馈列表数据export * from &#39;./ArticleDetail&#39; // 文章详情相关export * from &#39;./Home&#39; // 首页(频道)相关, 首页文章列表export * from &#39;./Login&#39; // 登录相关export * from &#39;./Search&#39; // 搜索相关export * from &#39;./User&#39; / 用户相关</code></pre><h2 id="大整数问题处理"><a href="#大整数问题处理" class="headerlink" title="大整数问题处理"></a>大整数问题处理</h2><p>JS安全数字范围? 16位的一个数字，超过16位也能显示, 但是精度不准确</p><ol><li><p>定义后台返回数据, 模拟大数</p><blockquote><p>后台数据库id, 生成算法是19位置</p></blockquote><pre><code class="js">const str = &#39;[&#123;&quot;id&quot;: 1302900300041101987&#125;, &#123;&quot;id&quot;: 1205340366642205763&#125;, &#123;&quot;id&quot;: 7689021398237123422&#125;]&#39;</code></pre></li><li><p>尝试用JSON.parse转换, 发现转换后的值不对</p><blockquote><p>后面3位精度错误</p></blockquote><pre><code class="js">console.log(JSON.parse(str))</code></pre></li><li><p>原因: JS范围的安全数打印</p><pre><code class="js">console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991</code></pre><blockquote><p>详细原因可以看这里: <a href="https://lidongxuwork.gitee.io/pages/webFront/javascript/run/0.1+0.2%E9%97%AE%E9%A2%98.html">https://lidongxuwork.gitee.io/pages/webFront/javascript/run/0.1+0.2%E9%97%AE%E9%A2%98.html</a></p></blockquote></li><li><p>解决方案, 可以引入第三方包叫json-bigint</p><blockquote><p>把大数转成字符串保存</p></blockquote><pre><code class="js">npm i json-bigintconst jsonBig = require(&#39;json-bigint&#39;)(&#123; storeAsString: true &#125;)console.log(jsonBig.parse(str))</code></pre></li></ol><h2 id="持久化存储方式"><a href="#持久化存储方式" class="headerlink" title="持久化存储方式"></a>持久化存储方式</h2><p>封装本地持久化方法,方便后期统一管理。(无限套娃，哈哈，前面的axios也是这个套路)</p><ul><li>创建utils&#x2F;storage.js文件, 定义4个方法</li></ul><pre><code class="js">// 本地存储方式// 如果同时有sessionStorage和localStorage, 可以封装2份// 现在我只封装一种统一的方式export const setStorage = (key, value) =&gt; &#123;  localStorage.setItem(key, value)&#125;export const getStorage = (key) =&gt; &#123;  return localStorage.getItem(key)&#125;export const removeStorage = (key) =&gt; &#123;  localStorage.removeItem(key)&#125;export const clearStorage = () =&gt; &#123;  localStorage.clear()&#125;</code></pre><ul><li><p>把所有使用本地存储的地方, 都统一换成这里定义的方法</p><ul><li>在store&#x2F;index.js - vuex中使用过</li><li>在search&#x2F;index.vue - 搜索页面使用过</li></ul></li></ul><h2 id="抽离组件注册"><a href="#抽离组件注册" class="headerlink" title="抽离组件注册"></a>抽离组件注册</h2><p>main.js代码有些多, 分散出去</p><ul><li>创建src&#x2F;VantRegister.js, 把Vant注册的相关代码复制过来</li></ul><pre><code class="js">import Vue from &#39;vue&#39;import &#123; NavBar, Form, Field, Button, Tabbar, TabbarItem, Icon, Tab, Tabs, Cell, List, PullRefresh, ActionSheet, Popup, Row, Col, Badge, Search, Divider, Tag, CellGroup, Image, Dialog, DatetimePicker, Loading, Lazyload &#125; from &#39;vant&#39;Vue.use(Lazyload)Vue.use(Loading)Vue.use(DatetimePicker)Vue.use(Dialog)Vue.use(Image)Vue.use(CellGroup)Vue.use(Tag)Vue.use(Divider)//....</code></pre><ul><li>在main.js引入一下, 让代码执行</li></ul><pre><code class="js">import &#39;./VantRegister&#39;</code></pre><h2 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h2><ul><li>防止组件频繁创建和销毁</li><li>防止网络请求重复无用执行</li></ul><p>组件缓存, 可以实现组件的状态保持。</p><p>结合 vue 内置的 <strong>keep-alive</strong> 组件，可以实现组件的状态保持。</p><p>官方文档地址：<a href="https://cn.vuejs.org/v2/api/#keep-alive">https://cn.vuejs.org/v2/api/#keep-alive</a></p><ol><li><p>在<strong>App.vue</strong>中的router-view外层套上一个keep-alive组件</p><ul><li>缓存的一级路由页面切换不被释放, 但是首页还是会重新请求数据</li></ul></li><li><p>在<strong>Layout.vue</strong>中的router-view外层套上一个keep-alive组件</p><ul><li>这次Home和User页面都被缓存了(二级路由也要管)</li></ul></li><li><p>但发现<strong>搜索页面</strong>和<strong>详情页面</strong>多被缓存起来了 (多次进入不同的文章, 发现都是同一个文章详情)</p></li><li><p>对router-view使用exclude属性来区别, 哪些页面组件可以缓存</p><blockquote><p>特别注意exclude里是组件的name名字(跟路由没什么关系)</p></blockquote><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;keep-alive :exclude=&quot;[&#39;ArticleDetail&#39;, &#39;Login&#39;, &#39;Search&#39;, &#39;SearchResult&#39;]&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre></li></ol><h2 id="头像不更新问题"><a href="#头像不更新问题" class="headerlink" title="头像不更新问题"></a>头像不更新问题</h2><p>User.vue被缓存了, 所以改了头像回到User页面, created里获取用户资料接口不会执行</p><ul><li><p>解决方案1: 把created换成activated钩子函数即可</p></li><li><p>解决方案2: UserEdit.vue修改头像成功后, 更新到vuex中, User页面使用的vuex数据也受到更新</p></li></ul><h2 id="登录未遂的处理"><a href="#登录未遂的处理" class="headerlink" title="登录未遂的处理"></a>登录未遂的处理</h2><ul><li><p>要点赞的时候, 401了, 强制跳转到登录页面了, 保存未遂地址跳转到登录页面</p><blockquote><p>要把tokens续签改掉, 否则不会跳转到登录页面</p></blockquote><pre><code class="js">if (error.response.status === 401) &#123; // 身份过期    // token续签方式1:  去登录页重新登录, token无用, 清掉-确保路由守卫if进不去    store.commit(&#39;setToken&#39;, &#39;&#39;)    console.log(router.currentRoute.fullPath)    //重点1---》将未遂的路径传到登录页    router.push(&#123; path: `/login?path=$&#123;router.currentRoute.fullPath&#125;` &#125;)    // token续签方式2: refreshToken(用户无感知)    // store.commit(&#39;setToken&#39;, &#39;&#39;)    // const res = await refreshTokenAPI()    // store.commit(&#39;setToken&#39;, res.data.data.token)    // 再调用一次未完成的请求啊(用户无感知)    // error.config 就是上一次axios请求的配置对象    // console.dir(error.config)    // 把新的token赋予到下一次axios请求的请求头中    // error.config.headers.Authorization = &#39;Bearer &#39; + res.data.data.token    // return到await的地方    // return ajax(error.config)&#125; else &#123;    return Promise.reject(error)&#125;</code></pre></li></ul><ol start="2"><li><p>在Login&#x2F;index.vue, 登录后, 判断有未遂地址, 跳这里, 否则去&#x2F;路径</p><pre><code class="js">// 跳转到Layout页面this.$router.replace(&#123;    //重点2 登录页进行判断 有未遂地址, 跳这里, 否则去/路径    path: this.$route.query.path || &#39;/layout&#39;&#125;)</code></pre></li></ol><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><blockquote><p>网页所在url的<strong>协议</strong>, <strong>域名</strong>, <strong>端口号</strong>, 和Ajax请求url的<strong>协议</strong>, <strong>域名</strong>, <strong>端口号</strong>有一个对应不上, 就发生跨域</p><p>跨域是浏览器对ajax做出的限制</p></blockquote><p>常见的跨域问题解决方式</p><h3 id="cors方式"><a href="#cors方式" class="headerlink" title="cors方式"></a>cors方式</h3><ul><li><p>前端什么也不用做</p></li><li><p>后端需要开启cors</p><blockquote><p>实际上就是在响应头添加允许跨域的源</p><p>Access-Control-Allow-Origin: 字段和值(意思就是允许去哪些源地址去请求这个服务器)</p></blockquote></li></ul><h3 id="jsonp方式"><a href="#jsonp方式" class="headerlink" title="jsonp方式"></a>jsonp方式</h3><ul><li><p>需要前端和后端同时支持</p><blockquote><p>前端用script+src属性, 发送函数名给后台, 同时准备好同名的函数, 准备接收数据</p><p>后端返回的字符串一定用方法名(数据字符串)格式返回, 到script标签中执行</p><p>调用函数名, 并传递数据</p></blockquote></li><li><p>例子代码(看看就行, 不用尝试)</p><pre><code class="vue">&lt;script&gt;  function callBackFn(data)&#123;    // data就是&#39;&#123;&quot;a&quot;: 10, &quot;b&quot;: 20&#125;&#39;  &#125;&lt;/script&gt;&lt;script src=&quot;http://后台接口地址?callback=callBackFn&quot;&gt;&lt;/script&gt;&lt;!-- 后台接口返回 &#39;callBackFn(&#123;&quot;a&quot;: 10, &quot;b&quot;: 20&#125;)&#39; --&gt;</code></pre></li></ul><h3 id="代理转发"><a href="#代理转发" class="headerlink" title="代理转发"></a>代理转发</h3><p><strong>跨域是浏览器的限制</strong>，自己搭的服务器，开启cors后请求就不限制了。</p><ul><li><p>如果后端jsonp也不弄, cors也不弄, 就给你个接口地址</p><blockquote><p>我们可以在本地弄个服务器, 然后用服务器请求后台服务器接口地址</p></blockquote><p><img src="/2022/06/30/1542451686885429248/images/image-20220630174418046.png" alt="image-20220630174418046"></p></li><li><p>但是vuecli脚手架, 启动了一个webpack开发服务器, 它就能做代理转发</p><ul><li>而且前端和这个服务器是同源的都是8080端口</li></ul></li><li><p>需要修改webpack开发服务器的配置即可</p><blockquote><p>更多配置项参考这里: <a href="https://webpack.docschina.org/configuration/dev-server/#devserverproxy">https://webpack.docschina.org/configuration/dev-server/#devserverproxy</a></p></blockquote><pre><code class="js">devServer: &#123;    proxy: &#123;      // http://c.m.163.com/nc/article/headline/T1348647853363/0-40.html      &#39;/api&#39;: &#123; // 请求相对路径以/api开头的, 才会走这里的配置        target: &#39;http://c.m.163.com&#39;, // 后台接口域名        changeOrigin: true, // 改变请求来源(欺骗后台你的请求是从http://c.m.163.com)        pathRewrite: &#123;          &#39;^/api&#39;: &#39;&#39; // 因为真实路径中并没有/api这段, 所以要去掉这段才能拼接正确地址转发请求        &#125;      &#125;    &#125;  &#125;</code></pre></li><li><p>axios请求的代码</p><pre><code class="js">axios(&#123;    url: &#39;/api/nc/article/headline/T1348647853363/0-40.html&#39;&#125;)</code></pre></li></ul><p>可以使用  <strong>http-server</strong> 这个node工具来搭建一个代理服务来解决跨域问题</p><pre><code>第一步：  使用win +r 打开dos面板，全局安装 npm install -g http-server第二步：  http-server 项目路径 -P 服务器地址</code></pre><h2 id="Hbuilder打包app"><a href="#Hbuilder打包app" class="headerlink" title="Hbuilder打包app"></a>Hbuilder打包app</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>为何要打包APP</li><li>APP分为哪几种类型</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>App有三大类型</p><ul><li><p>原生的App。手机有两大操作系统：苹果，安卓</p><blockquote><p>还有 windows Phone, 鸿蒙</p></blockquote><p>ios,安卓程序员 用各自的编程语言写的代码，只能在某一个平台上运行。分安卓版本和ios版本。</p><ul><li>优点：用户体验好 ；可以调用系统API（拍照，读内存…）。</li><li>缺点：费钱。(大公司一般会雇佣4端程序员)</li></ul></li><li><p>纯h5网站。就是一个移动站（<a href="https://m.jd.com/%EF%BC%89">https://m.jd.com/）</a></p><ul><li>优点：省钱。就是网页。</li><li>缺点：不能调用系统API；没有统一的入口，用户不知道从哪里进来，都要通过浏览器才能访问；</li></ul></li><li><p>混合开发。</p><ul><li>先做一个网站，在网站之外套个原生的壳！能同时具备原生的优点和纯h5网站的优点。</li><li><strong>在原生的App嵌入h5 页</strong></li></ul></li></ul><h3 id="HBuilder开发版"><a href="#HBuilder开发版" class="headerlink" title="HBuilder开发版"></a>HBuilder开发版</h3><p>我们需要借助他, 帮助我们打包一个App</p><p>下载安装, 注册激活， 如果不注册激活，就不能使用它的打包功能</p><p>下载地址: <a href="https://www.dcloud.io/hbuilderx.html">https://www.dcloud.io/hbuilderx.html</a>  (下载App开发版)</p><blockquote><p>先走流程, 提示你注册再注册和激活就行了</p></blockquote><p>&#x3D;&#x3D;必须注册&#x3D;&#x3D;</p><p>&#x3D;&#x3D;必须激活邮箱&#x3D;&#x3D;</p><p>&#x3D;&#x3D;必须绑定手机号&#x3D;&#x3D;</p><h3 id="创建5-App项目"><a href="#创建5-App项目" class="headerlink" title="创建5+App项目"></a>创建5+App项目</h3><p>我们要选择5+App 项目,mui也是一套前端框架，可以选择一个mui项目。</p><ul><li>普通项目。 普通H5项目, Hbuilder内置了几套模板,作用不大,同学们基本都会自己创建</li><li>uni-app。多端应用,一套代码,复用八端,时下最火的一个跨端框架</li><li>wap2App。wap项目转 App , 原来只运在手机上的wap(无线网络协议,诺基亚,爱立信时代)项目 可转app项目</li><li><strong>5+ App</strong>。利用DCloud 的 **<code>5+ Runtime</code>**来做原生能力提供者的 项目</li><li>小程序。微信原生小程序的另外一个编辑器,比微信提供的开发者工具好用,但是现在谁还在用原生写小程序呢?</li><li>快应用 。原生快应用编辑器 , 较为冷门的生态, 目前不太热闹</li></ul><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175509578.png" alt="image-20220630175509578"></p><h3 id="准备打包"><a href="#准备打包" class="headerlink" title="准备打包"></a>准备打包</h3><ol><li><p>把我们vue项目打包好的dist下的一切复制到你刚才的项目-覆盖过来即可 (一定要保留manifest.json文件)</p><blockquote><p>mainfest.json是打包配置文件</p></blockquote><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175552604.png" alt="image-20220630175552604"></p></li><li><p>生成APPID</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175610718.png" alt="image-20220630175610718"></p></li><li><p>去掉通信录权限 (因为我的HBuilder没有身份证认证, 打包不让获取用户通讯录)</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175632784.png" alt="image-20220630175632784"></p></li><li><p>(可选), 如果上面不小心选择No了, 可以去源码处选择 - 删除</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175650163.png" alt="image-20220630175650163"></p></li></ol><h3 id="云打包"><a href="#云打包" class="headerlink" title="云打包"></a>云打包</h3><p><img src="/2022/06/30/1542451686885429248/images/image-20210407171554818.png" alt="image-20210407171554818"></p><p>如果一切正常，你将会在控制台中看到类似如下的结果：</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175836488.png" alt="image-20220630175836488"></p><p>这就是云打包成功了, 下面会出现apk下载的所在文件夹</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>把打包好的apk包, 发到安卓手机上 &#x2F; 电脑模拟器(推荐&lt;夜神模拟器&gt;) 运行即可</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175858730.png" alt="image-20220630175858730"></p><h3 id="iOS问题"><a href="#iOS问题" class="headerlink" title="iOS问题"></a>iOS问题</h3><p>打包ios - 需要申请开发者账号(一年600元人民币): 以后打包的过程参考这个: <a href="https://blog.csdn.net/qq_34440345/article/details/99711586">https://blog.csdn.net/qq_34440345/article/details/99711586</a></p><p>也可以手机给电脑开热点 &#x2F; 只要连接在同一个wifi下, 手机浏览器访问webpack开发服务器局域网ip地址即可</p><h2 id="李老师经验分享"><a href="#李老师经验分享" class="headerlink" title="李老师经验分享"></a>李老师经验分享</h2><p>&#x2F;&#x2F; 写任何需求:<br>&#x2F;&#x2F; 章法<br>&#x2F;&#x2F; 1. html+css(标签和样式搞定)<br>&#x2F;&#x2F; 2. 铺设数据(调整内容, 可能调用接口拿到数据)<br>&#x2F;&#x2F; 3. JS(交互&#x2F;校验….效果), 前端拿到要传递给后台的值<br>&#x2F;&#x2F; 4. 与后台交互(调用后台接口, 回显返回数据提示等)</p><p>&#x2F;&#x2F; 技巧1:<br>&#x2F;&#x2F; 看到变量, 能马上反应过来这个变量里装的什么<br>&#x2F;&#x2F; 每个方法含义, 要什么参数, 返回值有无, 返回值什么意思, 都要马上反应过来<br>&#x2F;&#x2F; 每行代码的意思, 为何这么写, 先模仿老师的思路, 锻炼, 多了经验以后就能自己写了<br>&#x2F;&#x2F; 以上就多读代码多写代码多讨论积累经验</p><p>&#x2F;&#x2F; 技巧2:<br>&#x2F;&#x2F; 前端变量名可以直接跟后端 要求的参数名一致, 这样调用接口就不用再分开写了<br>&#x2F;&#x2F; 前端变量名, 如果装对象, 用obj结尾<br>&#x2F;&#x2F; 前端变量名, 如果装数组, 用arr或者list结尾<br>&#x2F;&#x2F; 前端变量名, 如果装字符串, 用str结尾<br>&#x2F;&#x2F; 这样看到变量能马上反应过来里面装的什么</p><p>&#x2F;&#x2F; 技巧3:<br>&#x2F;&#x2F; 统一判断http状态码, axios的”响应”拦截器<br>&#x2F;&#x2F; axios的”请求”拦截器, 统一给请求配置对象中加入统一的东西<br>&#x2F;&#x2F; 例如: 所有的请求都带上请求头字段Authorization和token值</p><p>&#x2F;&#x2F; 技巧4:<br>&#x2F;&#x2F; 所有状态一起变的, 一个变量控制所有人<br>&#x2F;&#x2F; 每行状态”独立”改变的, 每行对应”对象”里的属性(obj.visible&#x2F;其他属性), 显示隐藏的状态(2种值切换)</p><p>&#x2F;&#x2F; 技巧5:<br>&#x2F;&#x2F; 路由到底是几级的<br>&#x2F;&#x2F; 不要光看路径的个数<br>&#x2F;&#x2F; 实际:<br>&#x2F;&#x2F; 在路由规则数组里的层级</p><p>&#x2F;&#x2F; 技巧6: 什么时候需要提升功能封装<br>&#x2F;&#x2F; (1): 多个页面使用的相同功能<br>&#x2F;&#x2F; (2): 以后可能要扩展和修改的</p><p>&#x2F;&#x2F; 跨域问题:<br>&#x2F;&#x2F; 开发过程:<br>&#x2F;&#x2F; 1. 直接让后台开启cors&#x2F;jsonp, 直接调用(如果用jsonp你要注意你传参的格式)<br>&#x2F;&#x2F; 2. 后台不开cors&#x2F;jsonp, webpack开发服务器, vue.config.js - 代理转发<br>&#x2F;&#x2F; 3. 后台不开cors&#x2F;jsonp, 自己本地node+express搭建服务器(开cors) - 前端请求本地localhost:4005, 本地的请求转发代码(nodejs代码)</p><p>&#x2F;&#x2F; 打包上线:<br>&#x2F;&#x2F; 1. 后台开启cors, 直接用<br>&#x2F;&#x2F; 2. 后台不开cors&#x2F;jsonp, 把前端项目和后台项目放在一个服务器上(同源)<br>&#x2F;&#x2F; 3. 后台代码和前端代码不在一起, 本地自己写一个node+express服务器部署(请求自己的)</p>]]></content>
    
    
    <summary type="html">只记录自己get到的一些知识，详细的老师的配套的笔记里面都有</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
    <category term="移动端" scheme="https://heliufang.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>es6笔记</title>
    <link href="https://heliufang.github.io/2022/06/23/1540182212652175360/images/"/>
    <id>https://heliufang.github.io/2022/06/23/1540182212652175360/images/</id>
    <published>2022-06-23T00:57:28.000Z</published>
    <updated>2022-10-30T02:35:33.765Z</updated>
    
    <content type="html"><![CDATA[<p>b站视频教程1：<a href="https://www.bilibili.com/video/BV18s411E7Nd">尚硅谷ECMAScript教程(ecmascript详解含es5、es6)</a></p><p>b站视频教程2：<a href="https://www.bilibili.com/video/BV1ay4y1r78B">ES6从入门到精通系列(全23讲)</a></p><p>笔记只是记录开发中常用的，详细的可参考文档： </p><p>阮一峰： <a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a></p><p>菜鸟教程：<a href="https://www.runoob.com/w3cnote/es6-tutorial.html">菜鸟教程es6</a></p><h2 id="es简介"><a href="#es简介" class="headerlink" title="es简介"></a>es简介</h2><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><h2 id="es5-严格模式"><a href="#es5-严格模式" class="headerlink" title="es5-严格模式"></a>es5-严格模式</h2><p>语法和行为改变：</p><ul><li>必须用var声明变量</li><li>禁止自定义的函数中的this指向window</li><li>创建eval作用域(不会污染全局作用域)</li><li>对象不能有重名的属性</li></ul><p>使用：</p><ul><li>在全局或函数的第一条语句定义为<code>&#39;user strict&#39;;    </code></li><li>如果浏览器不支持,只解析为一条简单的语句,没有任何副作用</li></ul><p>【案例】</p><pre><code class="js">//&#39;use strict&#39; //开启严格模式//1.必须用var声明变量//a = 1 //报错 //2.对象不能有重名的属性// var obj = &#123;//     name: &#39;tom&#39;,//     name: &#39;jerry&#39;// &#125;//3.禁止自定义的函数中的this指向window// function Person(name,age)&#123;//     console.log(this) //undefined//     this.name = name//     this.age = age// &#125;// Person(&#39;tom&#39;,&#39;1&#39;)//4.创建eval作用域-关闭严格模式打印两个30var b = 20eval(&#39;var b = 30;console.log(&quot;eval:&quot;,b)&#39;) //30console.log(b) //20</code></pre><h2 id="es5-JSON扩展"><a href="#es5-JSON扩展" class="headerlink" title="es5-JSON扩展"></a>es5-JSON扩展</h2><ul><li><p>JSON.stringify(obj&#x2F;arr)：   json对象转字符串</p></li><li><p>JSON.parse(jsonStr)： json字符串转json对象 注意json的属性名要加双引号</p></li></ul><p>【案例】</p><pre><code class="js">//1.json对象转字符串var obj = &#123;name:&#39;tom&#39;,age:&#39;18&#39;&#125;var jsonStr = JSON.stringify(obj)console.log(jsonStr)console.log(typeof jsonStr) //string//2.json字符串转json对象 注意json的属性名要加双引号var jsonStr = &#39;&#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#39;;var json = JSON.parse(jsonStr)console.log(json)//console.log(typeof json)</code></pre><h2 id="es5-Object对象方法扩展"><a href="#es5-Object对象方法扩展" class="headerlink" title="es5-Object对象方法扩展"></a>es5-Object对象方法扩展</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623101229029.png" alt="image-20220623101229029"></p><p>【案例】</p><pre><code class="js">//================1.Object.createvar obj = &#123;name:&#39;tom&#39;,age:18&#125;var obj1 = Object.create(obj,&#123;    sex: &#123;        value: &#39;男&#39;,        writable: true, //是否可修改        configurable: true,//是否可删除        enumerable: true//是否能用for in枚举对象    &#125;&#125;)obj1.sex = &#39;女&#39;//delete obj1.sex//console.log(obj1.sex)//=================2.Object.definePropertiesvar obj2 = &#123;firstname: &#39;jerry&#39;,lastname: &#39;jack&#39;&#125;Object.defineProperties(obj2,&#123;    fullname: &#123;        get: function()&#123; //获取扩展属性的值            console.log(&#39;get调用了&#39;);            return this.firstname+&quot; &quot;+this.lastname        &#125;,        set: function(data)&#123;//设置扩展属性的值            console.log(&#39;set调用了&#39;,data);            var rs = data.split(&#39; &#39;)            this.firstname = rs[0]            this.lastname = rs[1]        &#125;    &#125;&#125;)console.log(obj2.fullname)obj2.fullname = &#39;qin yang&#39;console.log(obj2.fullname)</code></pre><p><img src="/2022/06/23/1540182212652175360/images/image-20220623103422946.png" alt="image-20220623103422946"></p><p>【案例】</p><pre><code class="js">var obj3 = &#123;    firstname: &#39;lucy&#39;,    lastname: &#39;lu&#39;,    get fullname()&#123;//获取扩展属性的值        console.log(&#39;get调用了&#39;);        return this.firstname+&quot; &quot;+this.lastname    &#125;,    set fullname(data)&#123;//设置扩展属性的值        console.log(&#39;set调用了&#39;,data);        var rs = data.split(&#39; &#39;)        this.firstname = rs[0]        this.lastname = rs[1]    &#125;&#125;console.log(obj3.fullname)obj3.fullname = &#39;zhang san&#39;console.log(obj3.fullname)</code></pre><h2 id="es5-数组的扩展"><a href="#es5-数组的扩展" class="headerlink" title="es5-数组的扩展"></a>es5-数组的扩展</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623104111791.png" alt="image-20220623104111791"></p><p>除上面五个扩展还有两个扩展</p><ul><li>some:  遍历数组，如果有至少一个满足条件，就返回true，否则返回false</li><li>every:  遍历数组，当所有的元素返回true，才返回true，否则返回false</li></ul><p>【案例】</p><pre><code class="js">//返回指定元素第一次出现的下标var arr1 = [1,2,3,2,5]console.log(arr1.indexOf(2)) //1 从前取console.log(arr1.lastIndexOf(2))//3 从后取//遍历数组arr1.forEach(function(value,index,arr)&#123;    console.log(value,index,arr);&#125;)//加工数组var arr2 = arr1.map(function(v,i,arr)&#123;    return &#39;我是：&#39;+v&#125;)console.log(arr2) //[&#39;我是：1&#39;, &#39;我是：2&#39;, &#39;我是：3&#39;, &#39;我是：2&#39;, &#39;我是：5&#39;]//过滤数组 比如取出大于2的var arr3 = arr1.filter(function(v,i,arr)&#123;    return v &gt; 2&#125;)console.log(arr3) // [3, 5]</code></pre><h2 id="es5-bind-call-apply"><a href="#es5-bind-call-apply" class="headerlink" title="es5 bind call apply"></a>es5 bind call apply</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623105247328.png" alt="image-20220623105247328"></p><p>【案例】</p><pre><code class="js">function showThis(a,b)&#123;    console.log(&#39;hello:&#39;,this.name+&quot;-&quot;+this.age+&quot;参数：&quot;+a,b)&#125;//直接调用 this为windowshowThis() //hello: -undefined参数：undefined undefinedfunction Person(name,age)&#123;    this.name = name    this.age = age&#125;var person= new Person(&#39;tom&#39;,18)//通过call,把this改成了person,call和apply的区别是传参的方式不同//showThis.call(person)//hello: tom-18参数：undefined undefined//showThis.apply(person)//hello: tom-18参数：undefined undefinedshowThis.call(person,&#39;a&#39;,&#39;b&#39;)//hello: tom-18参数：a bshowThis.apply(person,[&#39;a&#39;,&#39;b&#39;])//hello: tom-18参数：a b//通过bind改变this,bind不会立即执行而是需要调用一下showThis.bind(person)()//hello: tom-18参数：undefined undefinedshowThis.bind(person,&#39;a&#39;,&#39;b&#39;)()//hello: tom-18参数：a b</code></pre><h2 id="es6-let和const"><a href="#es6-let和const" class="headerlink" title="es6 let和const"></a>es6 let和const</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><img src="/2022/06/23/1540182212652175360/images/image-20220623110845037.png" alt="image-20220623110845037"></p><p>【案例】</p><pre><code class="js">//1.不能重复声明let a = 1//let a = 1 //Identifier &#39;a&#39; has already been declared//2.不存在变量提升// console.log(b) //UncaughtReferenceError: b is not defined// let b = 2//3.在块作用域有效if(true)&#123;    //var c = 1    let c = 1&#125;//console.log(c) //UncaughtReferenceError: c is not defined</code></pre><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><img src="/2022/06/23/1540182212652175360/images/image-20220623111524970.png" alt="image-20220623111524970"></p><p>【案例】</p><pre><code class="js">//不能修改const PI = 3.14//PI = 3.1415 //Uncaught TypeError: Assignment to constant variable.//对象可修改属性,不可修改引用const obj = &#123;name:&#39;tom&#39;,age: 16&#125;//obj = &#123;&#125; ////Uncaught TypeError: Assignment to constant variable.obj.name = &#39;jerry&#39;console.log(obj)</code></pre><h2 id="es6-对象的解构赋值"><a href="#es6-对象的解构赋值" class="headerlink" title="es6 对象的解构赋值"></a>es6 对象的解构赋值</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623112143166.png" alt="image-20220623112143166"></p><p>【案例】</p><pre><code class="js">//对象的解构let obj = &#123;name: &#39;tom&#39;,age: 18&#125;let &#123;name,age&#125; = objconsole.log(name,age) //tom 18//数组的解构let arr = [1,2,3,true]let [a,b] = arrconsole.log(a,b) //1 2let [,,c,d] = arr console.log(c,d)//3 true//解构应用function showObj(&#123;name,age&#125;)&#123;    console.log(name,age)&#125;showObj(obj) //tom 18</code></pre><h2 id="es6-模板字符串"><a href="#es6-模板字符串" class="headerlink" title="es6 模板字符串"></a>es6 模板字符串</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623112822655.png" alt="image-20220623112822655"></p><pre><code class="js">var obj = &#123;name: &#39;tom&#39;,age: 18&#125;var str = `我叫$&#123;obj.name&#125;，今年$&#123;obj.age&#125;岁了`console.log(str);</code></pre><h2 id="es6-对象的简写"><a href="#es6-对象的简写" class="headerlink" title="es6 对象的简写"></a>es6 对象的简写</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623113115363.png" alt="image-20220623113115363"></p><p>【案例】</p><pre><code class="js">var name = &#39;tom&#39;var age = 18// var obj = &#123;//     name: name,//     age: age,//     sayHello: function()&#123;//         console.log(this.name,this.age)//     &#125;// &#125;//简写var obj = &#123;    name,    age,    sayHello()&#123;        console.log(this.name,this.age)    &#125;&#125;console.log(obj)obj.sayHello()</code></pre><h2 id="es6-形参默认值"><a href="#es6-形参默认值" class="headerlink" title="es6 形参默认值"></a>es6 形参默认值</h2><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><p>【案例】</p><pre><code class="js">function add(a=1,b=1)&#123;    console.log(a+b)&#125;add() //2//add(1,2) //3</code></pre><h2 id="es6-箭头函数"><a href="#es6-箭头函数" class="headerlink" title="es6 箭头函数"></a>es6 箭头函数</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623120217016.png" alt="image-20220623120217016"></p><p>【箭头函数基础案例】</p><pre><code class="js">let f = v=&gt;v;//等同于let f = function(v)&#123;    return v;&#125;// 有一个参数let add = value =&gt; value;// 有两个参数let add = (value,value2) =&gt; value + value2;//等同于let add = (value1,value2)=&gt;&#123;        return value1 + value2;&#125; // 无参数let fn = () =&gt;  console.log(&quot;hello world&quot;)//等同于let doThing = () =&gt; &#123;    console.log(&quot;hello world&quot;)&#125;//如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。let getId = id =&gt; (&#123;id: id,name: &#39;mjj&#39;&#125;) //注意let obj = getId(1);</code></pre><p>【箭头函数this案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;button id=&quot;btn1&quot;&gt;btn1&lt;/button&gt;        &lt;script&gt;            //箭头函数内部没有this,会一直往外找找到非箭头函数的this,如果没有则指向window            let btn1 = document.getElementById(&#39;btn1&#39;)            // let obj = &#123;            //     name: &#39;tom&#39;,            //     age: 18,            //     sayHello: function()&#123;            //         btn1.onclick = function()&#123;            //             console.log(this) //btn1            //         &#125;            //     &#125;            // &#125;                        // let obj = &#123;            //     name: &#39;tom&#39;,            //     age: 18,            //     sayHello: function()&#123;            //         btn1.onclick = () =&gt; console.log(this) //obj            //     &#125;            // &#125;                        let obj = &#123;                name: &#39;tom&#39;,                age: 18,                sayHello: () =&gt; &#123;                    btn1.onclick = () =&gt; console.log(this) //window                &#125;                            &#125;            obj.sayHello()        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>【补充】</p><p> 箭头函数中没有arguments对象</p><pre><code class="js">var getVal = (a,b) =&gt; &#123;    console.log(arguments);    return a + b;&#125;console.log(getVal(1,2)); //arguments is not defined</code></pre><p> 箭头函数不能使用new关键字来实例化对象</p><pre><code class="js">let Person = ()=&gt;&#123;&#125;let p1 = new Person();// Person is not a constructor</code></pre><h2 id="es6-Symbol"><a href="#es6-Symbol" class="headerlink" title="es6 Symbol"></a>es6 Symbol</h2><p>不常用,了解即可</p><p><img src="/2022/06/23/1540182212652175360/images/image-20220623230202509.png" alt="image-20220623230202509"></p><p>对象的Symbol.iterator属性,指向该对象默认的遍历器方法</p><p>【案例】</p><pre><code class="js">//1.创建Symbol,symbol表示独一无二的值,不用new关键字let symbol1 = Symbol()let symbol2 = Symbol()console.log(symbol1 == symbol2);//false//2.symbol作为对象的属性,要用[]存取var obj = &#123;&#125;obj[symbol1] = &#39;123&#39;//console.log(obj.symbol1) //undefinedconsole.log(obj[symbol1])//3.传参标识-这种一般用来定义常量let symbol3 = Symbol(&#39;a&#39;)let symbol4 = Symbol(&#39;b&#39;)console.log(symbol3)console.log(symbol4)const PREFIX = Symbol(&#39;PREFIX&#39;)console.log(PREFIX)</code></pre><h2 id="es6-iterator-遍历器"><a href="#es6-iterator-遍历器" class="headerlink" title="es6 iterator 遍历器"></a>es6 iterator 遍历器</h2><p>和Java的迭代器差不多</p><p><img src="/2022/06/23/1540182212652175360/images/image-20220623232906861.png" alt="image-20220623232906861"></p><p>【案例】</p><pre><code class="js">/*对象的Symbol.iterator属性,指向该对象默认的遍历器方法            数组、字符串、arguments、set/map             已经自带的这个属性所以可以使用 for of方法遍历*/var arr  = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]for (let s of arr) &#123;    console.log(s);&#125;var str = &#39;efg&#39;for (let s of str) &#123;    console.log(s);&#125;//使用迭代器var it = arr[Symbol.iterator]()//每调用一次指针就会往后移动一次,到最后的时候done会变为trueconsole.log(it.next());//&#123;done: false,value: &quot;a&quot;&#125;console.log(it.next());//&#123;done: false,value: &quot;b&quot;&#125;console.log(it.next());//&#123;done: false,value: &quot;c&quot;&#125;console.log(it.next());//&#123;done: true,value: &quot;undefined&quot;&#125;</code></pre><h2 id="es6-generator"><a href="#es6-generator" class="headerlink" title="es6 generator"></a>es6 generator</h2><p>了解即可,后面的async&#x2F;await可以简化这个</p><p><img src="/2022/06/23/1540182212652175360/images/image-20220624094806654.png" alt="image-20220624094806654"></p><p>【案例】</p><pre><code class="js">//可以把异步任务放到yield后面,从而解决回调地狱问题function* myGenerator()&#123;    console.log(&#39;开始执行了&#39;)    let a = yield &#39;hello&#39;    yield console.log(111)    let b = yield &#39;hi&#39;    console.log(&#39;执行结束了&#39;)&#125;//此处函数体内代码还不会执行，需要使用next方法let mg = myGenerator()//使用next方法执行,就是前面迭代器console.log(mg.next())//&#123;value: &#39;hello&#39;, done: false&#125;mg.next() //111console.log(mg.next())//&#123;value: &#39;hi&#39;, done: false&#125;console.log(mg.next())//&#123;value: undefined, done: true&#125;</code></pre><p>【案例2-next方法传参数】</p><p><img src="/2022/06/23/1540182212652175360/images/image-20220624101808142.png" alt="image-20220624101808142"></p><h2 id="es6-promise"><a href="#es6-promise" class="headerlink" title="es6 promise"></a>es6 promise</h2><ul><li>理解</li></ul><pre><code>1.Promise对象：代表了未来某个将要发生的事件，通常是一个异步操作。有了Promise对象,可以将异步操作以同步的流程表达出来，避免了层层调用的回调函数(俗称”回调地狱“)ES6的Promise是一个构造函数,用来生成promise实例promise对象的三个状态* pending：初始化状态* fullfilled: 成功状态* rejected: 失败状态2.使用promise基本步骤第一步：创建promise对象let promise = new Promise((resolve,reject) =&gt;&#123;    //初始化promise状态为pending    //执行异步操作...    if(异步操作成功)&#123;        resolve(value) //修改promise的状态为fullfilled    &#125;else&#123;        reject(errMsg) //修改promise的状态为rejected    &#125;&#125;)第二步： 调用promise的then(成功的回调,失败的回调)promise.then(function()&#123;    result =&gt; console.log(result),    errorMsg =&gt; alert(errorMsg)&#125;)【.then的返回值仍然是promise,意味着可以链式调用then,从而解决回调地狱问题】3.应用* 使用promise实现超时处理* 使用promise封装ajax请求</code></pre><p>【promise原理代码】</p><pre><code class="js">console.log(&#39;111&#39;)var flag = falselet promise = new Promise((resolve,reject) =&gt; &#123;    //自动初始化promise状态为pending    console.log(&#39;222&#39;)    //执行异步任务    setTimeout(()=&gt;&#123;        if(flag)&#123;            resolve(&#39;哈哈&#39;) //成功,修改promise的状态为fullfilled        &#125;else&#123;            reject(&#39;哦嘛噶&#39;) //失败,修改promise的状态为rejected        &#125;    &#125;,2000)&#125;)console.log(&#39;333&#39;)promise.then((res)=&gt;&#123;//成功的回调    console.log(`$&#123;res&#125; success`)&#125;,(err)=&gt;&#123;//失败的回调    console.log(`$&#123;err&#125; error`)&#125;)</code></pre><p>【链式调用例子】~解决回调地狱问题！！！</p><pre><code class="js">const p = new Promise(function(resolve,reject)&#123;  resolve(1);&#125;).then(function(value)&#123; // 第一个then // 1  console.log(value);  return value * 2;&#125;).then(function(value)&#123; // 第二个then // 2  console.log(value);&#125;).then(function(value)&#123; // 第三个then // undefined  console.log(value);  return Promise.resolve(&#39;resolve&#39;); &#125;).then(function(value)&#123; // 第四个then // resolve  console.log(value);  return Promise.reject(&#39;reject&#39;); &#125;).then(function(value)&#123; // 第五个then //reject:reject  console.log(&#39;resolve:&#39; + value);&#125;, function(err) &#123;  console.log(&#39;reject:&#39; + err);&#125;);</code></pre><h2 id="es6-async"><a href="#es6-async" class="headerlink" title="es6 async"></a>es6 async</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623222054560.png" alt="image-20220623222054560"></p><p>【案例】</p><pre><code class="js">var flag = truefunction f1() &#123;    return new Promise((resolve, reject) =&gt; &#123;        //自动初始化promise状态为pending        console.log(&#39;222&#39;)        //执行异步任务        setTimeout(() =&gt; &#123;            if (flag) &#123;                resolve(&#39;哈哈&#39;) //成功,修改promise的状态为fullfilled            &#125; else &#123;                reject(&#39;哦嘛噶&#39;) //失败,修改promise的状态为rejected            &#125;        &#125;, 2000)    &#125;)&#125;//async就不用写.then了async function test() &#123;    try&#123;        console.log(&#39;test start&#39;);        let result = await f1() //获取resolve和reject传来的参数        console.log(&#39;test end&#39;,result);    &#125;catch(e)&#123;        /*await可以直接获取到后面Promise成功状态传递的参数        但是却捕捉不到失败状态,所以通过try catch来处理*/        console.log(e)    &#125;&#125;test()</code></pre><h2 id="es6-三点运算符"><a href="#es6-三点运算符" class="headerlink" title="es6 三点运算符"></a>es6 三点运算符</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623114113668.png" alt="image-20220623114113668"></p><p>【案例】</p><pre><code class="js">//扩展运行符-函数参数function fun(...args)&#123; //三点运算符作为参数,必须放到最后    // arguments.forEach(function(v,i,arr)&#123;    //     console.log(v)    // &#125;)    args.forEach(function(v,i,arr)&#123;        console.log(v)    &#125;)&#125;fun(1,2,3)//扩展运算符-数组var arr = [1,2,3]var arr2 = [4,6,...arr]arr2[2] = 8console.log(arr,arr2)//扩展运算符-对象var obj = &#123;name:&#39;tom&#39;,age: 18&#125;var obj2 = &#123;...obj,sex: &#39;男&#39;&#125;obj2.name = &#39;jerry&#39;console.log(obj,obj2)</code></pre><h2 id="es6-class类使用"><a href="#es6-class类使用" class="headerlink" title="es6 class类使用"></a>es6 class类使用</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623145804030.png" alt="image-20220623145804030"></p><p>【案例】</p><pre><code class="js">class Person&#123;//class 定义类    constructor(name,age)&#123; //定义构造方法        this.name = name        this.age = age    &#125;    sayHello()&#123;        console.log(this.name,this.age)    &#125;&#125;let person = new Person(&#39;tom&#39;,16) //创建实例console.log(Person.prototype.constructor == Person) //trueconsole.log(person)class Student extends Person&#123; //实现继承    constructor(name,age,sex)&#123;        super(name,age) //调用父类的构造方法        this.sex = sex    &#125;    //重写父类方法    sayHello()&#123;        console.log(this.name,this.age,this.sex)    &#125;&#125;let stu = new Student(&#39;jerry&#39;,16,&#39;女&#39;)console.log(stu)stu.sayHello()</code></pre><h2 id="es6-字符串和数值的扩展"><a href="#es6-字符串和数值的扩展" class="headerlink" title="es6 字符串和数值的扩展"></a>es6 字符串和数值的扩展</h2><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><p><img src="/2022/06/23/1540182212652175360/images/image-20220623162158471.png" alt="image-20220623162158471"></p><p>【案例】</p><pre><code class="js">let str = &#39;abcdedddd&#39;;console.log(str.includes(&#39;a&#39;))//trueconsole.log(str.startsWith(&#39;a&#39;));//trueconsole.log(str.endsWith(&#39;e&#39;));//trueconsole.log(str.repeat(2));//abcdeddddabcdedddd</code></pre><h3 id="数值扩展（了解）"><a href="#数值扩展（了解）" class="headerlink" title="数值扩展（了解）"></a>数值扩展（了解）</h3><p><img src="/2022/06/23/1540182212652175360/images/image-20220623162633567.png" alt="image-20220623162633567"></p><h2 id="es6-数组方法的扩展"><a href="#es6-数组方法的扩展" class="headerlink" title="es6 数组方法的扩展"></a>es6 数组方法的扩展</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623162800442.png" alt="image-20220623162800442"></p><p>【案例】</p><pre><code class="js">//1.Array.from()function fun()&#123;    let arr = Array.from(arguments) //将伪数组转化成数组    console.log(arr instanceof Array) //true&#125;fun(1,2,3)//2.Array.of(...)let arr = Array.of(&#39;a&#39;,1,2,true)console.log(arr instanceof Array) //trueconsole.log(arr);//[&#39;a&#39;, 1, 2, true]//3.find和findIdexlet nums = [1,2,3,4,5]let rs = nums.find((v,i,arr) =&gt; v&gt;3)//找出第一个大于3的数字console.log(rs) //4var rsIndex = nums.findIndex( v =&gt; v&gt;3) //找出第一个大于3的数字的下标console.log(rsIndex);//3</code></pre><h2 id="es6-对象方法的扩展"><a href="#es6-对象方法的扩展" class="headerlink" title="es6 对象方法的扩展"></a>es6 对象方法的扩展</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623170827016.png" alt="image-20220623170827016"></p><p>【案例】</p><pre><code class="js">console.log(0 == -0) //trueconsole.log(NaN == NaN) //false//下面两个正好和上面两个相反console.log(Object.is(0,-0)) //falseconsole.log(Object.is(NaN,NaN));//true//***将对象的属性复制到目标对象上,并把目标对象返回let obj = &#123;&#125;let obj1 = &#123;username: &#39;tom&#39;,age: 18&#125;let rs1 = Object.assign(obj,obj1,&#123;sex:&#39;男&#39;&#125;) //返回目标对象console.log(rs1 == obj) //trueconsole.log(obj == obj1) //falselet rs2 = Object.assign(&#123;&#125;,obj1,&#123;sex:&#39;女&#39;&#125;) //返回目标对象console.log(rs2)//直接操作原型let obj2 = &#123;&#125;obj2.__proto__ = obj1console.log(obj2.username)</code></pre><h2 id="es6-深拷贝和浅拷贝"><a href="#es6-深拷贝和浅拷贝" class="headerlink" title="es6 深拷贝和浅拷贝"></a>es6 深拷贝和浅拷贝</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220624111713688.png" alt="image-20220624111713688"></p><p>【浅拷贝案例】</p><pre><code class="js">//===========浅拷贝var obj = &#123;name: &#39;tom&#39;,age:18,hobby:[1,2,3]&#125;var obj1 = Object.assign(&#123;&#125;,obj) //数组对象拷贝的是引用console.log(obj == obj1)//falseobj1.name = &#39;jerry&#39;obj1.hobby[0] = &#39;a&#39;console.log(obj,obj1);var arr = [&#39;a&#39;,1,&#123;name: &#39;tom&#39;,age:18&#125;]var arr1 = arr.concat()console.log(arr == arr1); //falsearr1[2].name = &#39;jerry&#39; //对象拷贝的是引用console.log(arr,arr1);var arr2 = [&#39;a&#39;,1,&#123;name: &#39;tom&#39;,age:18&#125;]var arr3 = arr2.slice(0)console.log(arr2 == arr3) //falsearr3[2].name = &#39;jerry&#39; //对象拷贝的是引用console.log(arr2,arr3);</code></pre><p>【深拷贝案例】</p><pre><code class="js">//====深拷贝            //首先知道：利用Object.prototype.toString.call(target) 来判断类型console.log(Object.prototype.toString.call(&#39;a&#39;)); console.log(Object.prototype.toString.call(1));var arr = [1,2,3]var obj = &#123;&#125;console.log(Object.prototype.toString.call(arr))//[object Array]console.log(Object.prototype.toString.call(obj))//[object Object]//最终用下面的写法来判断类型console.log(Object.prototype.toString.call(obj).slice(8,-1))//Objectconsole.log(Object.prototype.toString.call(arr).slice(8,-1))//Array//深拷贝代码实现，重点是实现对象和数组的拷贝//a.判断类型function checkType(target)&#123;    return Object.prototype.toString.call(target).slice(8,-1)&#125;//b.for in + 递归实现深拷贝function clone(target)&#123;    let rs;    let type = checkType(target)    if(type === &#39;Object&#39;)&#123;        rs = &#123;&#125;    &#125;else if(type === &#39;Array&#39;)&#123;        rs = []    &#125;else&#123;//如果拷贝其它类型,直接返回        return target    &#125;    //遍历每一项    for (let i in target) &#123;//对象：i为属性名  数组：i为下标        let val = target[i]//取出每一项        if(checkType(val) === &#39;Object&#39; || checkType(val) === &#39;Array&#39;)&#123;            //如果是则递归拷贝            rs[i] = clone(val)        &#125;else&#123;            rs[i] = val        &#125;    &#125;    return rs&#125;var arr = [&#39;a&#39;,1,&#123;name: &#39;tom&#39;,age:18&#125;]var arr1 = clone(arr)console.log(arr == arr1);arr1[2].name = &#39;jerry&#39;console.log(arr,arr1);//当然，最简单是JSON.parse(JSON.stringify(json对象)) 来拷贝// var arrs =  [&#39;a&#39;,1,&#123;name: &#39;tom&#39;,age:18&#125;]// var arrs1 = JSON.parse(JSON.stringify(arrs))// console.log(arrs == arrs1);// arrs1[2].name = &#39;jerry&#39;// console.log(arrs,arrs1);</code></pre><h2 id="es6-set和map容器"><a href="#es6-set和map容器" class="headerlink" title="es6 set和map容器"></a>es6 set和map容器</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623172257632.png" alt="image-20220623172257632"></p><p>【案例】</p><pre><code class="js">//1.set//let set = new Set()let set = new Set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;]) //实例化set.add(1) //加数据set.add(2)set.add(1)console.log(set) //&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2&#125;console.log(set.has(&#39;a&#39;)) //trueconsole.log(set.size) //5set.delete(1) //删除数据console.log(set)set.clear() //清空setconsole.log(set)//2.map//let map = new Map()//注意：如要初始化数据，需要使用二维数组初始化let map = new Map([[&#39;hobby&#39;,&#39;篮球&#39;],[&#39;school&#39;,&#39;清华大学&#39;]])map.set(&#39;username&#39;,&#39;tom&#39;)map.set(&#39;password&#39;,&#39;123&#39;)map.set(&#39;age&#39;,10)console.log(map)console.log(map.get(&#39;hobby&#39;))//篮球console.log(map.has(&#39;age&#39;));//trueconsole.log(map.size);//5console.log(map.delete(&#39;age&#39;))//true 删除数据console.log(map)map.clear() //清空setconsole.log(map);</code></pre><h2 id="es6-for-of"><a href="#es6-for-of" class="headerlink" title="es6 for of"></a>es6 for of</h2><p><img src="/2022/06/23/1540182212652175360/images/image-20220623174123119.png" alt="image-20220623174123119"></p><p>【案例】</p><pre><code class="js">//遍历数组var arr = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]for (let s of arr) &#123;    console.log(s);&#125;//遍历setlet set = new Set([&#39;s1&#39;,&#39;s2&#39;,&#39;s3&#39;])//console.log(set)for (let s of set) &#123;    console.log(s)&#125;//遍历字符串let str = &#39;es6&#39;for(s of str)&#123;    console.log(s);&#125;//遍历伪数组function fun()&#123;    for (let s of arguments) &#123;        console.log(s);    &#125;&#125;fun(&#39;w&#39;,&#39;s&#39;,&#39;z&#39;)</code></pre><h2 id="es7-幂运算和数组包含"><a href="#es7-幂运算和数组包含" class="headerlink" title="es7 幂运算和数组包含"></a>es7 幂运算和数组包含</h2><ul><li><p>指数运算符-幂运算 **</p></li><li><p>Array.prototype.includes(value) 判断数组中是否包含指定的value</p></li></ul><p>【案例】</p><pre><code class="js">//指数运算let rs = 3 ** 3console.log(rs) //27//数组包含指定valuevar arr = [&#39;abc&#39;,&#39;c&#39;,&#39;d&#39;,true]console.log(arr.includes(&#39;a&#39;)) //falseconsole.log(arr.includes(&#39;abc&#39;)) //true</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><h3 id="export和import"><a href="#export和import" class="headerlink" title="export和import"></a>export和import</h3><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p><ul><li>新建一个index.js模块，内容如下</li></ul><pre><code class="js">//导出属性// export const name = &#39;tom&#39;// //导出方法// export function sayHello()&#123;//     console.log(&#39;hello&#39;)// &#125;//也可以按下面这样const name = &#39;tom&#39;function sayHello()&#123;    console.log(&#39;hello&#39;)&#125;export &#123;name,sayHello&#125; //导出</code></pre><ul><li>html页面导入模块</li></ul><pre><code class="html">&lt;!-- 别忘了加上 type=&quot;module&quot; 否则会报错 --&gt;&lt;script type=&quot;module&quot;&gt;    import &#123;name,sayHello&#125; from &#39;./module/index.js&#39;    console.log(name) //tom    sayHello() //hello&lt;/script&gt;</code></pre><h3 id="export-default和import"><a href="#export-default和import" class="headerlink" title="export default和import"></a>export default和import</h3><p>使用<code>export default</code>命令为模块指定默认输出</p><ul><li>新建一个export-default.js模块，内容如下</li></ul><pre><code class="js">export default function foo()&#123;    console.log(&#39;foo...&#39;)&#125;//或者按下面这样写// function foo()&#123;//     console.log(&#39;foo...&#39;)// &#125;// export default foo</code></pre><ul><li>html页面导入模块</li></ul><pre><code class="html">&lt;script type=&quot;module&quot;&gt;    import customFoo from &#39;./module/export-default.js&#39;    customFoo() //foo...&lt;/script&gt;</code></pre>]]></content>
    
    
    <summary type="html">学习es6之后整理的笔记</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="es6" scheme="https://heliufang.github.io/tags/es6/"/>
    
    <category term="js" scheme="https://heliufang.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js高级-笔记</title>
    <link href="https://heliufang.github.io/2022/06/21/1543080309820624896/images/"/>
    <id>https://heliufang.github.io/2022/06/21/1543080309820624896/images/</id>
    <published>2022-06-21T13:20:28.000Z</published>
    <updated>2022-07-25T08:59:41.849Z</updated>
    
    <content type="html"><![CDATA[<p>b站视频教程 <a href="https://www.bilibili.com/video/BV14s411E7qf">尚硅谷JavaScript高级教程</a></p><p>部分知识和<a href="https://www.bilibili.com/video/BV1YW411T7GX">尚硅谷js基础篇</a>重复了，这里只摘选一些重要的不重复的知识整理笔记： this、原型与原型链、执行上下文、作用域和作用域链、闭包、对象的创建、继承</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><pre><code>1. this是什么?  * 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window  * 所有函数内部都有一个变量this  * 它的值是调用函数的当前对象2. 如何确定this的值?  * test(): window  * p.test(): p  * new test(): 新创建的对象  * p.call(obj): obj</code></pre><p>【案例】</p><pre><code class="js">function Person(color) &#123;     // console.log(this)     this.color = color;     this.getColor = function () &#123;         // console.log(this)         return this.color;     &#125;;     this.setColor = function (color) &#123;         // console.log(this)         this.color = color;     &#125;; &#125;Person(&quot;red&quot;); //this是谁?  windowvar p = new Person(&quot;yello&quot;); //this是谁?  新创建的对象p.getColor(); //this是谁? pvar obj = &#123;&#125;;p.setColor.call(obj, &quot;black&quot;); //this是谁? objvar test = p.setColor;test(); //this是谁? windowfunction fun1() &#123;    function fun2() &#123;        console.log(this);    &#125;    fun2(); //this是谁? window&#125;fun1();</code></pre><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h3><pre><code>1. 函数的prototype属性  * 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)  * 原型对象中有一个属性constructor, 它指向函数对象2. 给原型对象添加属性(一般都是方法)  * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)</code></pre><p>【案例】</p><pre><code class="js">// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)console.log(Date.prototype, typeof Date.prototype)function Fun () &#123;&#125;console.log(Fun.prototype)  // 默认指向一个Object空对象(没有我们的属性)// 原型对象中有一个属性constructor, 它指向函数对象console.log(Date.prototype.constructor===Date)console.log(Fun.prototype.constructor===Fun)//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问Fun.prototype.test = function () &#123;    console.log(&#39;test()&#39;)&#125;var fun = new Fun()fun.test()</code></pre><h3 id="显式原型和隐式原型"><a href="#显式原型和隐式原型" class="headerlink" title="显式原型和隐式原型"></a>显式原型和隐式原型</h3><pre><code>1. 每个函数function都有一个prototype，即显式原型(属性)2. 每个实例对象都有一个__proto__，可称为隐式原型(属性)3. 对象的隐式原型的值为其对应构造函数的显式原型的值4. 内存结构(图)5. 总结:  * 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象  * 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值  * 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)</code></pre><p>【案例】</p><pre><code class="js">//定义构造函数function Fn() &#123;   // 内部语句: this.prototype = &#123;&#125;&#125;// 1. 每个函数function都有一个prototype，即显式原型属性, 默认指向一个空的Object对象console.log(Fn.prototype)// 2. 每个实例对象都有一个__proto__，可称为隐式原型//创建实例对象var fn = new Fn()  // 内部语句: this.__proto__ = Fn.prototypeconsole.log(fn.__proto__)// 3. 对象的隐式原型的值为其对应构造函数的显式原型的值console.log(Fn.prototype===fn.__proto__) // true//给原型添加方法Fn.prototype.test = function () &#123;    console.log(&#39;test()&#39;)&#125;//通过实例调用原型的方法fn.test()</code></pre><p>【内存图】</p><p><img src="/2022/06/21/1543080309820624896/images/image-20220620173026278.png" alt="image-20220620173026278"></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><pre><code>1. 原型链(图解)  * 访问一个对象的属性时，    * 先在自身属性中查找，找到返回    * 如果没有, 再沿着__proto__这条链向上查找, 找到返回    * 如果最终没找到, 返回undefined  * 别名: 隐式原型链  * 作用: 查找对象的属性(方法)2. 构造函数/原型/实体对象的关系(图解)3. 构造函数/原型/实体对象的关系2(图解)4.注意a)函数的显示原型(prototype)指向的对象默认是空Object实例对象(但Object不满足)b)所有函数都是Function的实例(包含Function)c)Object的原型对象是原型链尽头(因为 Object.prototype.__proto__ === null )</code></pre><p>【案例】</p><pre><code class="js">// console.log(Object)//console.log(Object.prototype)console.log(Object.prototype.__proto__)function Fn() &#123;    this.test1 = function () &#123;        console.log(&#39;test1()&#39;)    &#125;&#125;console.log(Fn.prototype)Fn.prototype.test2 = function () &#123;    console.log(&#39;test2()&#39;)&#125;var fn = new Fn()fn.test1()fn.test2()console.log(fn.toString())console.log(fn.test3)// fn.test3()/*  1. 函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)   */console.log(Fn.prototype instanceof Object) // trueconsole.log(Object.prototype instanceof Object) // falseconsole.log(Function.prototype instanceof Object) // true/*  2. 所有函数都是Function的实例(包含Function)  */console.log(Function.__proto__===Function.prototype)/*  3. Object的原型对象是原型链尽头   */console.log(Object.prototype.__proto__) // null</code></pre><h3 id="原型链的属性问题"><a href="#原型链的属性问题" class="headerlink" title="原型链的属性问题"></a>原型链的属性问题</h3><pre><code>1. 读取对象的属性值时: 会自动到原型链中查找2. 【设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值】3. 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</code></pre><p>【案例】</p><pre><code class="js">function Fn() &#123;&#125;Fn.prototype.a = &#39;xxx&#39;var fn1 = new Fn()console.log(fn1.a, fn1) //xxxvar fn2 = new Fn()fn2.a = &#39;yyy&#39;console.log(fn1.a, fn2.a, fn2)  //xxx yyyfunction Person(name, age) &#123;    this.name = name    this.age = age&#125;Person.prototype.setName = function (name) &#123;    this.name = name&#125;var p1 = new Person(&#39;Tom&#39;, 12)p1.setName(&#39;Bob&#39;)console.log(p1)var p2 = new Person(&#39;Jack&#39;, 12)p2.setName(&#39;Cat&#39;)console.log(p2)console.log(p1.__proto__===p2.__proto__) // true</code></pre><h3 id="instanceof与原型链"><a href="#instanceof与原型链" class="headerlink" title="instanceof与原型链"></a>instanceof与原型链</h3><pre><code>1. instanceof是如何判断的?  * 表达式: A instanceof B  * 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false2. Function是通过new自己产生的实例</code></pre><p>【案例】</p><pre><code class="js">/*  案例1   */function Foo() &#123;  &#125;var f1 = new Foo()console.log(f1 instanceof Foo) // trueconsole.log(f1 instanceof Object) // true/*  案例2   */console.log(Object instanceof Function) // trueconsole.log(Object instanceof Object) // trueconsole.log(Function instanceof Function) // trueconsole.log(Function instanceof Object) // truefunction Foo() &#123;&#125;console.log(Object instanceof  Foo) // false</code></pre><p>【下面这个图务必搞懂】</p><p><img src="/2022/06/21/1543080309820624896/images/image-20220620182306573.png" alt="image-20220620182306573"></p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>理解上面的图很快就能做出来</p><pre><code class="js">/*    测试题1    */function A() &#123;&#125;A.prototype.n = 1var b = new A()A.prototype = &#123;    n: 2,    m: 3&#125;var c = new A()console.log(b.n, b.m, c.n, c.m) //1 undefined 2 3/*        测试题2        */function F() &#123; &#125;Object.prototype.a = function () &#123;    console.log(&#39;a()&#39;)&#125;Function.prototype.b = function () &#123;    console.log(&#39;b()&#39;)&#125;var f = new F()f.a() //ok// f.b() //errorF.a() //okF.b() //ok// console.log(f)// console.log(Object.prototype)// console.log(Function.prototype)</code></pre><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><h3 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h3><pre><code>1. 变量声明提升  * 通过var定义(声明)的变量, 在定义语句之前就可以访问到  * 值: undefined2. 函数声明提升  * 通过function声明的函数, 在之前就可以直接调用  * 值: 函数定义(对象)3. 问题: 变量提升和函数提升是如何产生的?</code></pre><p>【案例】</p><pre><code class="js">/*  面试题 : 输出 undefined   */var a = 3function fn () &#123;    console.log(a)    var a = 4    &#125;fn()console.log(b) //undefined  变量提升fn2() //可调用  函数提升// fn3() //不能  变量提升var b = 3function fn2() &#123;    console.log(&#39;fn2()&#39;)&#125;var fn3 = function () &#123;    console.log(&#39;fn3()&#39;)&#125;</code></pre><h3 id="执行上下文-1"><a href="#执行上下文-1" class="headerlink" title="执行上下文"></a>执行上下文</h3><pre><code>1. 代码分类(位置)  * 全局代码  * 函数(局部)代码2. 全局执行上下文  * 在执行全局代码前将window确定为全局执行上下文  * 对全局数据进行预处理    * var定义的全局变量==&gt;undefined, 添加为window的属性    * function声明的全局函数==&gt;赋值(fun), 添加为window的方法    * this==&gt;赋值(window)  * 开始执行全局代码3. 函数执行上下文  * 在【调用函数】, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)  * 对局部数据进行预处理    * 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性    * arguments==&gt;赋值(实参列表), 添加为执行上下文的属性    * var定义的局部变量==&gt;undefined, 添加为执行上下文的属性    * function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法    * this==&gt;赋值(调用函数的对象)  * 开始执行函数体代码</code></pre><p>【案例】</p><pre><code class="js">console.log(a1, window.a1)window.a2()console.log(this)var a1 = 3function a2() &#123;console.log(&#39;a2()&#39;)&#125;console.log(a1)</code></pre><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><pre><code>1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)3. 在函数执行上下文创建后, 将其添加到栈中(压栈)4. 在当前函数执行完后,将栈顶的对象移除(出栈)5. 当所有的代码执行完后, 栈中只剩下window</code></pre><p>【案例】</p><pre><code class="js">var a = 10var bar = function (x) &#123;    var b = 5    foo(x + b)&#125;var foo = function (y) &#123;    var c = 5    console.log(a + c + y)&#125;bar(10)// bar(10)</code></pre><p>【流程分析图】</p><p><img src="/2022/06/21/1543080309820624896/images/image-20220620221429648.png" alt="image-20220620221429648"></p><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><pre><code class="js">/*   测试题1:  先执行变量提升, 再执行函数提升   */function a() &#123; &#125;var aconsole.log(typeof a) // &#39;function&#39;/*  测试题2:*/if (!(b in window)) &#123;    var b = 1&#125;console.log(b) // undefined/*测试题3:*/var c = 1function c(c) &#123;    console.log(c)&#125;console.log(c)//c(2) // 报错//测试3的是因为先c变量提升，再c函数提升，最后给c赋值1   所以c已经变为一个数字了</code></pre><h2 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h2><h3 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h3><pre><code>1. 理解  * 就是一块&quot;地盘&quot;, 一个代码段所在的区域  * 它是静态的(相对于上下文对象), 在编写代码时就确定了2. 分类  * 全局作用域  * 函数作用域  * 没有块作用域(ES6有了)3. 作用  * 隔离变量，不同作用域下同名变量不会有冲突</code></pre><p>【案例】</p><pre><code class="js">//没块作用域if (false) &#123;    var c = 3 //这里会变量提升到全局,如果注释这行,打印c则报错&#125;console.log(c) //undefinedvar a = 10,b = 20function fn(x) &#123;    var a = 100,c = 300;    console.log(&#39;fn()&#39;, a, b, c, x)    function bar(x) &#123;        var a = 1000,            d = 400        console.log(&#39;bar()&#39;, a, b, c, d, x)     &#125;    bar(100) //1000 20 300 400 100    bar(200) //1000 20 300 400 200&#125;fn(10)</code></pre><p>【图解】</p><p><img src="/2022/06/21/1543080309820624896/images/image-20220621091643046.png" alt="image-20220621091643046"></p><h3 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h3><pre><code>1. 区别1  * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时  * 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建  * 函数执行上下文是在调用函数时, 函数体代码执行之前创建2. 区别2  * 【作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化】  * 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放3. 联系  * 执行上下文(对象)是从属于所在的作用域  * 全局上下文环境==&gt;全局作用域  * 函数上下文环境==&gt;对应的函数使用域</code></pre><p>【案例】</p><pre><code class="js">var a = 10,b = 20function fn(x) &#123;    var a = 100,c = 300;    console.log(&#39;fn()&#39;, a, b, c, x)    function bar(x) &#123;        var a = 1000,d = 400        console.log(&#39;bar()&#39;, a, b, c, d, x)    &#125;    bar(100)    bar(200)&#125;fn(10)</code></pre><p>【图解】</p><p><img src="/2022/06/21/1543080309820624896/images/image-20220621091942968.png" alt="image-20220621091942968"></p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><pre><code>1. 理解  * 多个上下级关系的作用域形成的链, 它的方向是从下向上的(【从内到外】)  * 查找变量时就是沿着作用域链来查找的2. 查找一个变量的查找规则  * &lt;1&gt;在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入&lt;2&gt;  * &lt;2&gt;在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入&lt;3&gt;  * &lt;3&gt;再次执行2&gt;的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常</code></pre><p>【案例】</p><pre><code class="js"> var a = 1  function fn1() &#123;    var b = 2    function fn2() &#123;      var c = 3      console.log(c) //3      console.log(b) //2      console.log(a) //1      //console.log(d) //error    &#125;    fn2()  &#125;  fn1()</code></pre><p>【图解】</p><p><img src="/2022/06/21/1543080309820624896/images/image-20220621092803164.png" alt="image-20220621092803164"></p><h3 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h3><pre><code class="js">var x = 10function fn() &#123;    console.log(x) //函数定义的时候作用域已经确定,且不会变化&#125;function show(f) &#123;    var x = 20    f()&#125;show(fn) //10</code></pre><h3 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h3><pre><code class="js">var fn = function() &#123;    console.log(fn)&#125;fn() //打印fn函数var obj = &#123;    fn2: function() &#123;        console.log(fn2) //全局中找不到fn2这个函数    &#125;&#125;//obj.fn2() //报错</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="循环加事件监听问题"><a href="#循环加事件监听问题" class="headerlink" title="循环加事件监听问题"></a>循环加事件监听问题</h3><pre><code class="html">&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;00_引入&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;测试1&lt;/button&gt;&lt;button&gt;测试2&lt;/button&gt;&lt;button&gt;测试3&lt;/button&gt;&lt;!--需求: 点击某个按钮, 提示&quot;点击的是第n个按钮&quot;--&gt;&lt;script type=&quot;text/javascript&quot;&gt;  var btns = document.getElementsByTagName(&#39;button&#39;)  //遍历加监听  /*   * var i 是全局的,for先执行完后,再调用点击事件的时候已经是最后一个i了    * btns.length是伪数组,每次都要计算,为了提高性能,可以按下面这样写   */  // for (var i = 0,length=btns.length; i &lt; length; i++) &#123;  //   var btn = btns[i]  //   btn.onclick = function () &#123;  //     alert(&#39;第&#39;+(i+1)+&#39;个&#39;)  //   &#125;  // &#125;  // console.log(i) //3    //循环执行时,把索引加到btn上,这样就不会出现都是4了  // for (var i = 0,length=btns.length; i &lt; length; i++) &#123;  //   var btn = btns[i]  //   //将btn所对应的下标保存在btn上  //   btn.index = i  //   btn.onclick = function () &#123;  //     alert(&#39;第&#39;+(this.index+1)+&#39;个&#39;)  //   &#125;  // &#125;  //利用闭包  for (var i = 0,length=btns.length; i &lt; length; i++) &#123;    (function (j) &#123;      var btn = btns[j]      btn.onclick = function () &#123;        alert(&#39;第&#39;+(j+1)+&#39;个&#39;)      &#125;    &#125;)(i)  &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><pre><code>1. 如何产生闭包?  * 【当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包】2. 闭包到底是什么?  * 使用chrome调试查看  * 理解一: 闭包是嵌套的内部函数(绝大部分人)  * 理解二: 包含被引用变量(函数)的对象(极少数人)  * 注意: 闭包存在于嵌套的内部函数中3. 产生闭包的条件?  * 函数嵌套  * 内部函数引用了外部函数的数据(变量/函数)</code></pre><p>【案例】</p><pre><code class="js">function fun1()&#123;    var a = 1    //执行函数定义就会产生闭包(不用调用内部函数)    function fun2()&#123;         console.log(a)    &#125;    return fun2 //新版的google要return不然看不到闭包(fun2)&#125;fun1()</code></pre><p><img src="/2022/06/21/1543080309820624896/images/image-20220621141020209.png" alt="image-20220621141020209"></p><h3 id="常见的闭包"><a href="#常见的闭包" class="headerlink" title="常见的闭包"></a>常见的闭包</h3><pre><code>1. 将函数作为另一个函数的返回值2. 将函数作为实参传递给另一个函数调用</code></pre><p>【案例】</p><pre><code class="js">// 1. 将函数作为另一个函数的返回值function fn1() &#123;    var a = 2    function fn2() &#123;        a++        console.log(a)    &#125;    return fn2&#125;var f = fn1()f() // 3f() // 4// 2. 将函数作为实参传递给另一个函数调用function showDelay(msg, time) &#123;    setTimeout(function () &#123;        alert(msg)    &#125;, time)&#125;showDelay(&#39;atguigu&#39;, 2000)//总结起来还是那句话：一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)</code></pre><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><pre><code>1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)问题:  1. 函数执行完后, 函数内部声明的局部变量是否还存在?  一般是不存在, 存在于闭包中的变量才可能存在  2. 在函数外部能直接访问函数内部的局部变量吗? 不能, 但我们可以通过闭包让外部操作它</code></pre><p>【案例】</p><pre><code class="js">function fn1() &#123;    var a = 2    function fn2() &#123;        a++        console.log(a)        // return a    &#125;    function fn3() &#123;        a--        console.log(a)    &#125;    return fn3&#125;var f = fn1()f() // 1f() // 0</code></pre><h3 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h3><pre><code>1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)2. 死亡: 在嵌套的内部函数成为垃圾对象时</code></pre><p>【案例】</p><pre><code class="js">function fn1() &#123;    //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了)    var a = 2    function fn2 () &#123;        a++        console.log(a)    &#125;    return fn2&#125;var f = fn1()f() // 3f() // 4f = null //闭包死亡(包含闭包的函数对象成为垃圾对象)</code></pre><h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><p>自定义js模块</p><p>第一种定义：【myModule.js】</p><pre><code class="js">function myModule() &#123;  //私有数据  var msg = &#39;My atguigu&#39;  //操作数据的函数  function doSomething() &#123;    console.log(&#39;doSomething() &#39;+msg.toUpperCase())  &#125;  function doOtherthing () &#123;    console.log(&#39;doOtherthing() &#39;+msg.toLowerCase())  &#125;  //向外暴露对象(给外部使用的方法)  return &#123;    doSomething: doSomething,    doOtherthing: doOtherthing  &#125;&#125;</code></pre><p>第二种定义：【myModule2.js】  jquery就是这么写的！！！</p><pre><code class="js">//利用立即执行函数+window全局,通过myModule2.xxx 来直接调用，比第一种更方便(function () &#123;  //私有数据  var msg = &#39;My atguigu&#39;  //操作数据的函数  function doSomething() &#123;    console.log(&#39;doSomething() &#39;+msg.toUpperCase())  &#125;  function doOtherthing () &#123;    console.log(&#39;doOtherthing() &#39;+msg.toLowerCase())  &#125;  //向外暴露对象(给外部使用的方法)  window.myModule2 = &#123;    doSomething: doSomething,    doOtherthing: doOtherthing  &#125;&#125;)()</code></pre><h3 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h3><pre><code>1. 缺点  * 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长  * 容易造成内存泄露2. 解决  * 能不用闭包就不用  * 及时释放</code></pre><p>【案例】</p><pre><code class="js">function fn1() &#123;    var arr = new Array[100000]    function fn2() &#123;        console.log(arr.length)    &#125;    return fn2&#125;var f = fn1()f()f = null //让内部函数成为垃圾对象--&gt;回收闭包</code></pre><h3 id="面试题1-1"><a href="#面试题1-1" class="headerlink" title="面试题1"></a>面试题1</h3><pre><code class="js">//代码片段一var name = &quot;The Window&quot;;var object = &#123;    name : &quot;My Object&quot;,    getNameFunc : function()&#123;        return function()&#123;            return this.name;        &#125;;    &#125;&#125;;alert(object.getNameFunc()());  //? The Window//代码片段二var name2 = &quot;The Window&quot;;var object2 = &#123;    name2 : &quot;My Object&quot;,    getNameFunc : function()&#123;        var that = this;        return function()&#123;            return that.name2;        &#125;;    &#125;&#125;;alert(object2.getNameFunc()()); //?  My Object</code></pre><h3 id="面试题2-1"><a href="#面试题2-1" class="headerlink" title="面试题2"></a>面试题2</h3><p>有难度,先了解一些</p><pre><code class="js">function fun(n,o) &#123;    console.log(o)    return &#123;        fun:function(m)&#123;            return fun(m,n)        &#125;    &#125;&#125;var a = fun(0)a.fun(1)a.fun(2)a.fun(3)//undefined,0,0,0var b = fun(0).fun(1).fun(2).fun(3)//undefined,0,1,2var c = fun(0).fun(1)c.fun(2)c.fun(3)//undefined,0,1,1</code></pre><h2 id="对象的创建方式"><a href="#对象的创建方式" class="headerlink" title="对象的创建方式"></a>对象的创建方式</h2><p>这部分内容和js基础部分重复了</p><h3 id="Object构造函数模式"><a href="#Object构造函数模式" class="headerlink" title="Object构造函数模式"></a>Object构造函数模式</h3><pre><code>方式一: Object构造函数模式  * 套路: 先创建空Object对象, 再动态添加属性/方法  * 适用场景: 起始时不确定对象内部数据  * 问题: 语句太多</code></pre><p> 【案例】</p><pre><code class="js">/*  一个人: name:&quot;Tom&quot;, age: 12   */// 先创建空Object对象var p = new Object()p = &#123;&#125; //此时内部数据是不确定的// 再动态添加属性/方法p.name = &#39;Tom&#39;p.age = 12p.setName = function (name) &#123;    this.name = name&#125;//测试console.log(p.name, p.age)p.setName(&#39;Bob&#39;)console.log(p.name, p.age)</code></pre><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><pre><code>方式二: 对象字面量模式  * 套路: 使用&#123;&#125;创建对象, 同时指定属性/方法  * 适用场景: 起始时对象内部数据是确定的  * 问题: 如果创建多个对象, 有重复代码</code></pre><p>【案例】</p><pre><code class="js">var p = &#123;    name: &#39;Tom&#39;,    age: 12,    setName: function (name) &#123;        this.name = name    &#125;&#125;//测试console.log(p.name, p.age)p.setName(&#39;JACK&#39;)console.log(p.name, p.age)var p2 = &#123;  //如果创建多个对象代码很重复    name: &#39;Bob&#39;,    age: 13,    setName: function (name) &#123;        this.name = name    &#125;&#125;</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><pre><code>方式三: 工厂模式  * 套路: 通过工厂函数动态创建对象并返回  * 适用场景: 需要创建多个对象  * 问题: 对象没有一个具体的类型, 都是Object类型</code></pre><p>【案例】</p><pre><code class="js">function createPerson(name, age) &#123; //返回一个对象的函数===&gt;工厂函数    var obj = &#123;        name: name,        age: age,        setName: function (name) &#123;            this.name = name        &#125;    &#125;    return obj&#125;// 创建2个人var p1 = createPerson(&#39;Tom&#39;, 12)var p2 = createPerson(&#39;Bob&#39;, 13)// p1/p2是Object类型function createStudent(name, price) &#123;    var obj = &#123;        name: name,        price: price    &#125;    return obj&#125;var s = createStudent(&#39;张三&#39;, 12000)// s也是Object</code></pre><h3 id="自定义构造函数模式"><a href="#自定义构造函数模式" class="headerlink" title="自定义构造函数模式"></a>自定义构造函数模式</h3><pre><code>方式四: 自定义构造函数模式  * 套路: 自定义构造函数, 通过new创建对象  * 适用场景: 需要创建多个类型确定的对象  * 问题: 每个对象都有相同的数据, 浪费内存</code></pre><p>【案例】</p><pre><code class="js">//定义类型function Person(name, age) &#123;    this.name = name    this.age = age    this.setName = function (name) &#123;        this.name = name    &#125;&#125;var p1 = new Person(&#39;Tom&#39;, 12)p1.setName(&#39;Jack&#39;)console.log(p1.name, p1.age)console.log(p1 instanceof Person)function Student (name, price) &#123;    this.name = name    this.price = price&#125;var s = new Student(&#39;Bob&#39;, 13000)console.log(s instanceof Student)var p2 = new Person(&#39;JACK&#39;, 23)console.log(p1, p2)</code></pre><h3 id="构造函数-原型的组合模式"><a href="#构造函数-原型的组合模式" class="headerlink" title="构造函数+原型的组合模式"></a>构造函数+原型的组合模式</h3><pre><code>方式六: 构造函数+原型的组合模式  * 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上  * 适用场景: 需要创建多个类型确定的对象</code></pre><p>【案例】</p><pre><code class="js">function Person(name, age) &#123; //在构造函数中只初始化一般函数    this.name = name    this.age = age&#125;Person.prototype.setName = function (name) &#123;    this.name = name&#125;var p1 = new Person(&#39;Tom&#39;, 23)var p2 = new Person(&#39;Jack&#39;, 24)console.log(p1, p2)</code></pre><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><pre><code>方式1: 原型链继承  1. 套路    1. 定义父类型构造函数    2. 给父类型的原型添加方法    3. 定义子类型的构造函数    4. 【创建父类型的对象赋值给子类型的原型】    5. 【将子类型原型的构造属性设置为子类型】    6. 给子类型原型添加方法    7. 创建子类型的对象: 可以调用父类型的方法  2. 关键    1. 子类型的原型为父类型的一个实例对象      这种方式只实现了方法的继承</code></pre><p>【案例】 </p><pre><code class="js">//父类型function Supper() &#123;    this.supProp = &#39;Supper property&#39;&#125;Supper.prototype.showSupperProp = function () &#123;    console.log(this.supProp)&#125;//子类型function Sub() &#123;    this.subProp = &#39;Sub property&#39;&#125;// 子类型的原型为父类型的一个实例对象Sub.prototype = new Supper() //关键1// 让子类型的原型的constructor指向子类型Sub.prototype.constructor = Sub//关键2Sub.prototype.showSubProp = function () &#123;    console.log(this.subProp)&#125;var sub = new Sub()sub.showSupperProp()// sub.toString()sub.showSubProp()console.log(sub)  // Sub</code></pre><p>【图解】</p><p><img src="/2022/06/21/1543080309820624896/images/image-20220621165514090.png" alt="image-20220621165514090"></p><h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><pre><code>方式2: 借用构造函数继承(假的)1. 套路:  1. 定义父类型构造函数  2. 定义子类型构造函数  3. 在子类型构造函数中调用父类型构造2. 关键:  1. 在子类型构造函数中通用call()调用父类型构造函数  这种方式只实现了属性的继承</code></pre><p>【案例】</p><pre><code class="js">function Person(name, age) &#123;    this.name = name    this.age = age&#125;function Student(name, age, price) &#123;    Person.call(this, name, age)  // 相当于: this.Person(name, age)    /*this.name = name    this.age = age*/    this.price = price&#125;var s = new Student(&#39;Tom&#39;, 20, 14000)console.log(s.name, s.age, s.price)</code></pre><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><pre><code>方式3: 原型链+借用构造函数的组合继承1. 利用原型链实现对父类型对象的方法继承【继承方法】2. 利用super()借用父类型构建函数初始化相同属性【继承属性】</code></pre><p>【案例】</p><pre><code class="js">function Person(name, age) &#123;    this.name = name    this.age = age&#125;Person.prototype.setName = function (name) &#123;    this.name = name&#125;function Student(name, age, price) &#123;    //核心代码1    Person.call(this, name, age)  // 为了得到属性        this.price = price&#125;//核心代码2Student.prototype = new Person() // 为了能看到父类型的方法//核心代码3Student.prototype.constructor = Student //修正constructor属性Student.prototype.setPrice = function (price) &#123;    this.price = price&#125;var s = new Student(&#39;Tom&#39;, 24, 15000)s.setName(&#39;Bob&#39;)s.setPrice(16000)console.log(s.name, s.age, s.price)</code></pre><h2 id="事件的轮询机制"><a href="#事件的轮询机制" class="headerlink" title="事件的轮询机制"></a>事件的轮询机制</h2><p><img src="/2022/06/21/1543080309820624896/images/image-20220725165906639.png" alt="image-20220725165906639"></p><p><img src="/2022/06/21/1543080309820624896/images/image-20220725165924721.png" alt="image-20220725165924721"></p>]]></content>
    
    
    <summary type="html">这里只摘选一些重要的不重复的知识整理笔记： this、原型与原型链、执行上下文、作用域和作用域链、闭包、对象的创建、继承。</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://heliufang.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js基础-笔记</title>
    <link href="https://heliufang.github.io/2022/06/17/1543080309728350208/images/"/>
    <id>https://heliufang.github.io/2022/06/17/1543080309728350208/images/</id>
    <published>2022-06-17T09:20:28.000Z</published>
    <updated>2022-07-18T08:47:35.098Z</updated>
    
    <content type="html"><![CDATA[<p>b站js基础视频教程： <a href="https://www.bilibili.com/video/BV1YW411T7GX">尚硅谷JavaScript基础</a></p><p>课程相关资料： 链接：<a href="https://pan.baidu.com/s/15e8Ebq1P3D1ZsfSOsj4rSw">https://pan.baidu.com/s/15e8Ebq1P3D1ZsfSOsj4rSw</a>  提取码：<em>abtf</em></p><h2 id="p46-p50-对象的简介"><a href="#p46-p50-对象的简介" class="headerlink" title="p46-p50 对象的简介"></a>p46-p50 对象的简介</h2><h3 id="js的数据类型"><a href="#js的数据类型" class="headerlink" title="js的数据类型"></a>js的数据类型</h3><pre><code>String 字符串Number 数值Boolean 布尔值Null 空值Undefined 未定义</code></pre><p>以上这五种类型属于基本数据类型，以后我们看到的值<strong>只要不是上边的5种，全都是对象</strong>     Object 对象</p><h3 id="对象的简介"><a href="#对象的简介" class="headerlink" title="对象的简介"></a>对象的简介</h3><p>基本数据类型都是单一的值eg：”hello” 123 true。值和值之间没有任何的联系。对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。</p><pre><code>对象的分类：*     1.内建对象*          由ES标准中定义的对象，在任何的ES的实现中都可以使用*          比如：Math String Number Boolean Function Object....* *     2.宿主对象*          由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象*          比如 BOM DOM* *     3.自定义对象*          由开发人员自己创建的对象</code></pre><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>使用new关键字调用的函数，是构造函数constructor</p><p>构造函数是专门用来创建对象的函数</p><p>使用typeof检查一个对象时，会返回object</p><pre><code class="js">var obj = new Object()console.log(typeof obj) //object</code></pre><h3 id="对象的属性的基本操作"><a href="#对象的属性的基本操作" class="headerlink" title="对象的属性的基本操作"></a>对象的属性的基本操作</h3><p>在对象中保存的值称为属性</p><ul><li>添加或修改属性：</li></ul><pre><code>语法：对象.属性名 = 属性值</code></pre><ul><li>读取属性</li></ul><pre><code>语法：对象.属性名</code></pre><p>注意：如果读取对象中没有的属性，不会报错而是会返回undefined</p><ul><li>删除属性</li></ul><pre><code>语法：delete 对象.属性名</code></pre><p>【对象案例】</p><pre><code class="js">//创建对象var obj = new Object()//添加属性obj.name = &#39;tom&#39;obj.age = 18//obj.name = &#39;jerry&#39; //修改属性//删除属性//delete obj.name//console.log(typeof obj) //objectconsole.log(obj.name)</code></pre><h3 id="属性名和属性值"><a href="#属性名和属性值" class="headerlink" title="属性名和属性值"></a>属性名和属性值</h3><h4 id="属性名"><a href="#属性名" class="headerlink" title="属性名"></a>属性名</h4><ul><li><p>对象的属性名不强制要求遵守标识符的规范(什么乱七八糟的名字都可以使用).尽量按照标识符的规范去做</p></li><li><p>特殊的属性名要用[]。在[]中可以直接传递一个<code>变量</code>，这样变量值是多少就会读取那个属性</p></li></ul><pre><code>语法：对象[&quot;属性名&quot;] = 属性值</code></pre><p>【demo】</p><pre><code class="js">var obj = new Object()//属性名可以随意obj.val = 123console.log(obj.val) //特殊的属性名要用[]//obj.123 = 123 // Uncaught SyntaxError: Unexpected numberobj[&#39;123&#39;] = 123console.log(obj[&#39;123&#39;])var nihao = &#39;nihao&#39;obj[nihao] = &#39;你好&#39;console.log(obj[nihao])</code></pre><h4 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h4><p>JS对象的属性值，可以是任意的数据类型，甚至也可以是一个对象和函数</p><pre><code>//属性值var obj = new Object()obj.test = nullobj.test = undefinedobj.test = trueobj.test = function()&#123;&#125;obj.test = new Object()</code></pre><h4 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h4><p>通过该运算符可以检查一个对象中是否含有指定的属性,如果有则返回true，没有则返回false</p><pre><code>语法：&quot;属性名&quot; in 对象</code></pre><pre><code class="js">var obj = new Object()obj.name = &#39;tom&#39;console.log(&quot;name&quot; in obj) //trueconsole.log(&quot;age&quot; in obj) //false</code></pre><h3 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h3><p>基本数据类型：String Number Boolean Null Undefined</p><p>引用数据类型：Object</p><pre><code>* JS中的变量都是保存到栈内存中的，*         基本数据类型的值直接在栈内存中存储，*         值与值之间是独立存在，修改一个变量不会影响其他的变量* *         对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，*         而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，*         当一个通过一个变量修改属性时，另一个也会受到影响当比较两个基本数据类型的值时，就是比较值。             而比较两个引用数据类型时，它是比较的对象的内存地址，【引用类型demo3】             如果两个对象是一摸一样的，但是地址不同，它也会返回false</code></pre><p>【基本数据类型demo】</p><pre><code class="js">var a = 123;var b = a;a++;</code></pre><p><img src="/2022/06/17/1543080309728350208/images/image-20220614110432444.png" alt="image-20220614110432444"></p><p>【引用类型demo1】</p><pre><code class="js">var obj = new Object()obj.name = &#39;swk&#39;var obj2 = objobj2.name = &#39;zbj&#39;console.log(obj) //zbjconsole.log(obj2) //zbj</code></pre><p><img src="/2022/06/17/1543080309728350208/images/image-20220614110552104.png" alt="image-20220614110552104"></p><p>【引用类型demo2】 通过null切断引用</p><pre><code class="js">var obj = new Object()obj.name = &#39;swk&#39;var obj2 = objobj2.name = &#39;zbj&#39;obj2 = nullconsole.log(obj) //zbjconsole.log(obj2) //null</code></pre><p><img src="/2022/06/17/1543080309728350208/images/image-20220614110748416.png" alt="image-20220614110748416"></p><p>【引用类型demo3】</p><pre><code class="false">var obj3 = new Object();var obj4 = new Object();obj3.name = &quot;shs&quot;;obj4.name = &quot;shs&quot;;console.log(obj3 == obj4) //false</code></pre><p><img src="/2022/06/17/1543080309728350208/images/image-20220614110839196.png" alt="image-20220614110839196"></p><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>就是 { } 来创建对象，有点像json</p><pre><code>使用对象字面量，可以在创建对象时，直接指定对象中的属性             * 语法：&#123;属性名:属性值,属性名:属性值....&#125;             *     对象字面量的属性名可以加引号也可以不加，建议不加,             *     如果要使用一些特殊的名字，则必须加引号             *              * 属性名和属性值是一组一组的名值对结构，             *     名和值之间使用:连接，多个名值对之间使用,隔开             *     如果一个属性之后没有其他的属性了，就不要写,</code></pre><p>【对象字面量案例】</p><pre><code class="js">//使用对象字面量创建对象，属性为空var obj = &#123;&#125;obj.name = &#39;jerry&#39;//赋值和前面的一样console.log(obj) //&#123;name: &#39;jerry&#39;&#125;console.log(typeof obj)//object//使用对象字面量创建对象并初始化属性值var obj2 = &#123;    name: &#39;tom&#39;,    age: 18,    gender: &#39;男&#39;,    dog: &#123;name: &#39;旺财&#39;,age: 3&#125;&#125;console.log(obj2)</code></pre><h2 id="p51-p65-函数"><a href="#p51-p65-函数" class="headerlink" title="p51-p65 函数"></a>p51-p65 函数</h2><h3 id="创建和调用函数"><a href="#创建和调用函数" class="headerlink" title="创建和调用函数"></a>创建和调用函数</h3><ul><li>函数创建的三种方式</li></ul><p>第一种：使用构造函数创建(不推荐)</p><pre><code>var func = new Function(&#39;语句...&#39;)</code></pre><p>第二种：使用 函数声明 来创建一个函数</p><pre><code>语法：         function 函数名([形参1,形参2...形参N])&#123;             语句...         &#125;</code></pre><p>第三种：函数表达式创建函数</p><pre><code>var 函数名  = function([形参1,形参2...形参N])&#123;                   语句....             &#125;</code></pre><ul><li>函数的调用</li></ul><pre><code>封装到函数中的代码不会立即执行函数中的代码会在函数调用的时候执行调用函数 语法：函数对象()当调用函数时，函数中封装的代码会按照顺序执行</code></pre><p>【函数的创建和调用案例】</p><pre><code class="js">//1.通过构造函数创建函数对象（不常用）var func = new Function(&#39;console.log(&quot;通过构造函数创建函数对象&quot;)&#39;)func() //调用函数console.log(typeof func) //function//2.通过函数声明来创建函数function func2()&#123;    console.log(&quot;通过函数声明创建函数对象&quot;)&#125;func2() //调用函数//3.通过函数表达式创建函数对象var func3 = function()&#123;    console.log(&quot;通过函数表达式创建函数对象&quot;)&#125;func3() //调用函数</code></pre><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数的参数可以是任意类型，声明的时候不需要写类型。</p><p>函数调用时，解析器不会去检查参数的类型和数量，多余实参不会被赋值，</p><p>如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined。</p><p>【函数的参数案例】</p><pre><code class="js">function sum(a,b)&#123;    console.log(a+b)&#125;//参数类型任意sum(1,2) //3sum(1,&quot;2&quot;) //12sum(true,false) //1  true为1 false为0sum(true,1) //2//参数个数任意sum(1) //NaNsum(1,2,3) //3  自动忽略第三个参数</code></pre><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>可以使用 return 来设置函数的返回值</p><pre><code>*     语法：*         return 值* *     return后的值将会会作为函数的执行结果返回，*         可以定义一个变量，来接收该结果* *  在函数中return后的语句都不会执行* *     如果return语句后不跟任何值就相当于返回一个undefined，*     如果函数中不写return，则也会返回undefined* *     return后可以跟任意类型的值</code></pre><p>【返回值案例】</p><pre><code class="js">function sum(a,b)&#123;    //可以返回任意类型    //return //不写变量或者不写return返回的是undefined    //return a + b    return &#123;        name: &#39;tom&#39;,        age : 18    &#125;    //console.log(&#39;我不会执行&#39;)&#125;var rs = sum(1,2) //定义变量接收返回值console.log(rs)</code></pre><h3 id="函数的实参"><a href="#函数的实参" class="headerlink" title="函数的实参"></a>函数的实参</h3><p>实参可以是任意的数据类型，也可以是一个对象</p><p>当我们的参数过多时，可以将参数封装到一个对象中，然后通过对象传递</p><pre><code class="js">function sayHello(o)&#123;    console.log(&quot;我是&quot;+o.name+&quot;,&quot;+o.age+&quot;岁了,&quot;+&quot;&quot;+o.gender+&quot;人&quot;+&quot;,我在&quot;+o.address);    return o&#125;var obj = &#123;    name:&quot;孙悟空&quot;,    age:18,    address:&quot;花果山&quot;,    gender:&quot;男&quot;&#125;sayHello(obj)//注意下面的区别function fun(a)&#123;    console.log(a)&#125;fun(1)fun(sayHello)fun(sayHello(obj))</code></pre><pre><code>* sayHello(obj)*     调用函数*     相当于使用的函数的返回值* * sayHello*     函数对象*     相当于直接使用函数对象</code></pre><h3 id="函数内部嵌套函数"><a href="#函数内部嵌套函数" class="headerlink" title="函数内部嵌套函数"></a>函数内部嵌套函数</h3><p>函数内部可以声明函数，可以无限嵌套</p><pre><code class="js">function fun1()&#123;    function fun2()&#123;        console.log(&#39;我是 fun2&#39;)    &#125;    return fun2&#125;var a = fun1()//console.log(a)//a()fun1()() //注意一下这种写法</code></pre><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>页面加载后会立即执行.用一个括号把匿名函数包起来,然后再像函数调用那样加个括号运行。</p><p>里面定义的变量是局部变量，不会影响全局的作用域</p><pre><code class="js">//立即执行函数-不带参数(function()&#123;    console.log(&#39;立即运行&#39;)&#125;)();//立即执行函数-带参数(function(a,b)&#123;    console.log(a+b)&#125;)(123,456)</code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>函数也可以称为对象的属性，如果一个函数作为一个对象的属性保存，那么我们称这个函数时这个对象的方法.调用这个函数就说调用对象的方法（method） 但是它只是名称上的区别没有其他的区别</p><pre><code class="js">var obj = &#123;    name: &#39;孙悟空&#39;,    age: 18,    sayName: function()&#123;        console.log(obj.name)    &#125;&#125;function fun()&#123;    console.log(&#39;func&#39;)&#125;fun() //调函数obj.sayName() //调方法</code></pre><h3 id="枚举对象属性"><a href="#枚举对象属性" class="headerlink" title="枚举对象属性"></a>枚举对象属性</h3><p>把对象中所有的属性和值取出来</p><pre><code>//枚举对象中的属性//使用for ... in 语句/** 语法：*     for(var 变量 in 对象)&#123;*     *  &#125;* * for...in语句 对象中有几个属性，循环体就会执行几次*     每次执行时，会将对象中的一个属性的名字赋值给变量</code></pre><p>【枚举对象属性案例】</p><pre><code class="js">var obj = &#123;    name: &#39;swk&#39;,    age: 18,    sayName: function()&#123;        console.log(obj.name)    &#125;&#125;for(var key in obj)&#123;    console.log(key,&quot;:&quot;,obj[key])&#125;</code></pre><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>作用域指一个变量的作用的范围</p><pre><code>全局作用域*              【直接编写在script标签中的JS代码，都在全局作用域】*              全局作用域在页面打开时创建，在页面关闭时销毁*              在全局作用域中有一个全局对象【window】，*                 它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用*              在全局作用域中：*                 【创建的变量都会作为window对象的属性保存】*                 【创建的函数都会作为window对象的方法保存】*              全局作用域中的变量都是全局变量，*                 【在页面的任意的部分都可以访问的到】</code></pre><p>【案例】</p><pre><code class="html">&lt;script&gt;    var c = 345&lt;/script&gt;&lt;script&gt;    var a = 123    function fun()&#123;        console.log(&#39;func&#39;)    &#125;    console.log(window.a)    window.fun()    window.alert(&#39;xxx&#39;)    console.log(c)&lt;/script&gt;</code></pre><h3 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前"></a>声明提前</h3><pre><code>* 变量的声明提前*     使用【var关键字声明的变量】，会在所有的代码执行之前被声明（但是不会赋值），*         但是如果声明变量时不适用var关键字，则变量不会被声明提前* * 函数的声明提前*     使用【函数声明形式】创建的函数 function 函数()&#123;&#125;*         它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数*        使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用    </code></pre><p>【声明提前案例如下】</p><pre><code class="js">//--------1.var声明的变量提前 相当于把var a 提取到代码最前面console.log(a) //undefinedvar a = 123//--------2.没用var声明的变量不提前，所以报错------------------//console.log(b) //报错 Uncaught ReferenceError: b is not defined//b = 456//--------3.函数声明提前-----------fun() //funfunction fun()&#123;    console.log(&#39;fun&#39;)&#125;//-------4.函数表达式，不会被提前创建//fun1() //Uncaught TypeError: fun1 is not a functionvar fun1 = function()&#123;    console.log(&#39;fun1&#39;)&#125;</code></pre><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><pre><code>* 函数作用域    *      调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁*      每调用一次函数就会创建一个新的函数作用域，他们之间是【互相独立】的*      在函数作用域中可以访问到全局作用域的变量*         在全局作用域中无法访问到函数作用域的变量*      【当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用*         如果没有则向上一级作用域中寻找，直到找到全局作用域，*         如果全局作用域中依然没有找到，则会报错ReferenceError】*      【在函数中要访问全局变量可以使用window对象】【在函数作用域也有声明提前的特性】【定义形参就相当于在函数作用域中声明了变量】【在函数中，不用var声明的变量都会成为全局变量】</code></pre><p>【函数作用域案例】</p><pre><code class="js">//1.函数作用域入门var a = 123function fun1()&#123;    var a = 456    console.log(a) //456    console.log(window.a) //123 通过window可以找全局的&#125;fun1()//2.一层层往上找，全局还找不到就报错var b = &#39;b&#39;function fun2()&#123;    var b = &#39;b2&#39;    function fun3()&#123;        //var b = &#39;b3&#39;        console.log(b)    &#125;    return fun3&#125;fun2()()//3.函数作用域内部方法声明提前function fun3()&#123;    //内部方法什么提前    fun4()    function fun4()&#123;        console.log(&#39;fun4&#39;)    &#125;&#125;fun3()//4.函数内部变量声明提前function fun5()&#123;    console.log(c) //undefined    var c = 10    d = 100 //函数内部不用var声明的变量将放入到全局作用域&#125;fun5()console.log(d) //100//5.定义形参就相当于定义了变量(注意这个很容易出错)var e= &#39;eee&#39;function fun6(e)&#123;    console.log(e) //undefined&#125;fun6()</code></pre><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>谷歌浏览器为例，其它类似 首先用f12打开调试模式</p><p><img src="/2022/06/17/1543080309728350208/images/image-20220614150539324.png" alt="image-20220614150539324"></p><p>给某个变量加上监听，右键变量  add selected text to watches</p><p><img src="/2022/06/17/1543080309728350208/images/image-20220614150645658.png" alt="image-20220614150645658"></p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><pre><code>* 解析器在调用函数每次都会向函数内部传递进一个隐含的参数,*     这个隐含的参数就是this，this指向的是一个对象，*     这个对象我们称为函数执行的 上下文对象，*     根据函数的调用方式的不同，this会指向不同的对象*         【1.以函数的形式调用时，this永远都是window】*         【2.以方法的形式调用时，this就是调用方法的那个对象】</code></pre><p>【this案例】</p><pre><code class="js">var name =&#39;全局的name&#39;function fun()&#123;    console.log(this)    console.log(this.name)&#125;//fun() //以函数的形式调用 this是windowvar obj = &#123;name: &#39;tom&#39;,sayName: fun&#125;obj.sayName() //以方法的形式调用 this是调用方法的对象console.log(obj.sayName == fun) //true</code></pre><h3 id="使用工厂函数创建对象"><a href="#使用工厂函数创建对象" class="headerlink" title="使用工厂函数创建对象"></a>使用工厂函数创建对象</h3><p>创建工厂函数,函数中new Object并给属性赋值.</p><pre><code class="js">//创建对象的的工厂方法function createPeople(name,age,gender)&#123;    var obj = new Object()    obj.name = name    obj.age = age    obj.gender = gender    return obj&#125;var luban = createPeople(&#39;鲁班&#39;,6,&#39;男&#39;)console.log(typeof luban,luban)var aql = createPeople(&#39;安其拉&#39;,8,&#39;女&#39;)console.log(typeof aql,aql)//存在缺陷，类型都是object的，后面的构造函数可以解决这个问题</code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code>*     构造函数就是一个普通的函数，创建方式和普通函数没有区别,*     不同的是构造函数习惯上【首字母大写】* * 构造函数和普通函数的区别就是调用方式的不同*     普通函数是直接调用，而构造函数需要使用【new关键字来调用】* * 构造函数的执行流程：*     1.立刻创建一个新的对象*     【2.将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象】*     3.逐行执行函数中的代码*     4.将新建的对象作为返回值返回* * 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。*     我们将通过一个构造函数创建的对象，称为是该类的实例* * this的情况：*     1.当以函数的形式调用时，this是window*     2.当以方法的形式调用时，谁调用方法this就是谁*     3.当以构造函数的形式调用时，this就是新创建的那个对象 * 使用【instanceof】可以检查一个对象是否是一个类的实例                  语法：对象 instanceof 构造函数                如果是，则返回true，否则返回false</code></pre><p>【构造函数案例】</p><pre><code class="js">function Person(name,age)&#123;    console.log(&#39;构造方法执行了&#39;)    this.name = name    this.age = age    this.sayName = function()&#123;        console.log(this.name)    &#125;&#125;//console.log(Person())//undefinedconsole.log(new Person(&#39;嫦娥&#39;,18))console.log(new Person(&#39;猪八戒&#39;,18))function Dog(name,age)&#123;    this.name = name    this.age = age    this.sayName = function()&#123;        console.log(this.name)    &#125;&#125;console.log(new Dog(&#39;旺财&#39;,18))//可以看到打印的类型不同:  一个是Person一个Dog//使用【instanceof】可以检查一个对象是否是一个类的实例console.log(new Dog(&#39;旺财&#39;,18) instanceof Dog) //trueconsole.log(new Person(&#39;猪八戒&#39;,18) instanceof Dog)// falseconsole.log(new Person(&#39;猪八戒&#39;,18) instanceof Object)// true  Object是所有类的父类</code></pre><p>【构造函数优化】</p><pre><code class="js">/**   将函数定义在全局作用域，污染了全局作用域的命名空间*     而且定义在全局作用域中也很不安全*/function fun()&#123;    console.log(this.name)&#125;function Person(name,age)&#123;    console.log(&#39;构造方法执行了&#39;)    this.name = name    this.age = age    //改成引用的方式,提高性能,但是fun声明在全局中,也不是特别合适,后面可以声明到原型中    this.sayName = fun &#125;var per = new Person(&#39;tom&#39;,18)per.sayName()</code></pre><h2 id="p66-p67原型"><a href="#p66-p67原型" class="headerlink" title="p66-p67原型"></a>p66-p67原型</h2><pre><code>* 原型 prototype* *     【创建的每一个函数，解析器都会向函数中添加一个属性prototype】*         这个属性对应着一个对象，这个对象就是所谓的原型对象*     如果函数作为普通函数调用prototype没有任何作用*     当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，*         指向该构造函数的原型对象，我们可以【通过__proto__来访问该属性】* *     【原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，*         我们可以将对象中共有的内容，统一设置到原型对象中。】* * 【当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，*     如果没有则会去原型对象中寻找，如果找到则直接使用】* * 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，*     这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了</code></pre><p>【原型案例1】</p><pre><code class="js">function Person()&#123;                &#125;//console.log(Person.prototype)var per = new Person()var per2 = new Person()console.log(Person.prototype == per.__proto__) //trueconsole.log(Person.prototype == per2.__proto__) //trueconsole.log(per.__proto__ == per2.__proto__) //true//向原型中加入属性per.__proto__.a = &#39;aa&#39;Person.prototype.b = &#39;bb&#39;console.log(Person.prototype.a,Person.prototype.b) //aa bbconsole.log(per.a,per.b) //aa bb//向原型中加入方法Person.prototype.sayHello = function()&#123;    console.log(&#39;hello&#39;)&#125;per.sayHello()//给per添加属性aper.a = &#39;per中的a&#39;console.log(per.a) //先到自己中找，没有再到原型中找</code></pre><p>【原型案例2：通过原型来优化之前的构造函数问题】</p><pre><code class="js">//之前将方法放在全局中不优化，现在通过原型来优化构造函数中的方法Person.prototype.sayName = function fun()&#123;    console.log(&#39;大家好,我是&#39;,this.name)&#125;function Person(name,age)&#123;    //console.log(&#39;构造方法执行了&#39;)    this.name = name    this.age = age&#125;var per1 = new Person(&#39;tom&#39;,18)var per2 = new Person(&#39;jerry&#39;,18)per1.sayName()per2.sayName()</code></pre><p>【原型案例3：原型的其它方法和特性】</p><pre><code class="js">var name = &#39;全局的name&#39;function MyClass()&#123;&#125;MyClass.prototype.name = namevar m1 = new MyClass()//m1.name = &#39;tom&#39;//1.使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回trueconsole.log(&#39;name&#39; in m1) //2.【可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性】//使用该方法只有当对象自身中含有属性时，才会返回trueconsole.log(m1.hasOwnProperty(&#39;name&#39;))/** 3.原型对象也是对象，所以它也有原型，*     当我们使用一个对象的属性或方法时，会现在自身中寻找，*         自身中如果有，则直接使用，*         如果没有则去原型对象中寻找，如果原型对象中有，则使用，*         如果没有则去原型的原型中寻找,直到找到Object对象的原型，*         Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined*/console.log(m1.hasOwnProperty(&#39;hasOwnProperty&#39;)) //falseconsole.log(m1.__proto__.hasOwnProperty(&#39;hasOwnProperty&#39;)) //falseconsole.log(m1.__proto__.__proto__.hasOwnProperty(&#39;hasOwnProperty&#39;))//trueconsole.log(m1.__proto__.__proto__)</code></pre><h2 id="p68-toString"><a href="#p68-toString" class="headerlink" title="p68 toString"></a>p68 toString</h2><p>直接在页面中打印一个对象时，事实上是输出的对象的<strong>toString()方法的返回值</strong></p><p>如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法</p><pre><code class="js">function Person(name,age)&#123;    this.name = name    this.age = age&#125;//修改Person原型的toStringPerson.prototype.toString = function()&#123;    return &quot;Person[name=&quot;+this.name+&quot;,age=&quot;+this.age+&quot;]&quot;;&#125;;var per = new Person(&#39;tom&#39;,18)console.log(per.toString())</code></pre><h2 id="p69-垃圾回收"><a href="#p69-垃圾回收" class="headerlink" title="p69 垃圾回收"></a>p69 垃圾回收</h2><pre><code>*    当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，*         此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，*         所以这种垃圾必须进行清理。*      在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，*         我们不需要也不能进行垃圾回收的操作*      我们需要做的只是要【将不再使用的对象设置null即可】</code></pre><h2 id="p70-78-数组"><a href="#p70-78-数组" class="headerlink" title="p70-78 数组"></a>p70-78 数组</h2><pre><code>* 数组（Array）*      数组也是一个对象*      它和我们普通对象功能类似，也是用来存储一些值的*      不同的是普通对象是使用字符串作为属性名的，*         而【数组使用数字来作为索引操作元素】*      索引：*         从0开始的整数就是索引*      【数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据】</code></pre><h3 id="数组的创建、取值、赋值"><a href="#数组的创建、取值、赋值" class="headerlink" title="数组的创建、取值、赋值"></a>数组的创建、取值、赋值</h3><p>创建方式：通过new Array或者 字面量[]创建</p><pre><code class="js">var arr1 = new Array() //创建长度为0的数组console.log(arr1)var arr2 = new Array(1,2,3) //创建数组并放入三个元素console.log(arr2)var arr3 = new Array(10) //创建长度为10的数组,注意当长度为1时不是加入元素,而是初始化长度console.log(arr3)var arr4 = [1,2,3] //通过字面量创建数组console.log(arr4)</code></pre><p>修改或添加的语法：数组[索引] &#x3D; 值</p><p>取值：数组[索引]    <strong>如果读取不存在的索引，他不会报错而是返回undefined</strong></p><p>注意： <strong>数组中的元素可以是任意的数据类型</strong></p><h3 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h3><pre><code>* 可以使用length属性来获取数组的长度(元素的个数)* 语法：数组.length* * 对于连续的数组，使用length可以获取到数组的长度（元素的个数）* 对于非连续的数组，使用length会获取到数组的最大的索引+1*         尽量不要创建非连续的数组* 修改length*     如果修改的length大于原长度，则多出部分会空出来*   如果修改的length小于原长度，则多出的元素会被删除* 向数组的最后一个位置添加元素* 语法：数组[数组.length] = 值;</code></pre><p>【数组demo】</p><pre><code class="js">//创建数组var arr = new Array()console.log(typeof arr) //objectconsole.log(Array.isArray(arr)) //true//往数组中加元素arr[0] = 1arr[1] = 2arr[2] = 1console.log(arr)//获取数组的值console.log(arr[0])  //1console.log(arr[3]) //undefined//获取数组的长度console.log(arr.length)//修改lengh//arr.length = 10//向数组最后位置添加元素arr[arr.length] = 3arr[arr.length] = 4arr[arr.length] = 5console.log(arr,arr.length)</code></pre><h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><pre><code>*      该方法可以向数组的末尾添加一个或多个元素，并[返回数组的新的长度]*      可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾*      该方法会将数组新的长度作为返回值返回</code></pre><p>【案例】</p><pre><code class="js">var arr = [1,2,3]var rs = arr.push(4,5,6)console.log(arr) //[1,2,3,4,5,6]console.log(rs) //6</code></pre><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回</p><pre><code class="js">var arr = [1,2,3]var rs = arr.pop()console.log(arr) //[1,2]console.log(rs) //3</code></pre><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h4><pre><code>*     向数组开头添加一个或多个元素，并返回新的数组长度*     向前边插入元素以后，其他的元素索引会依次调整</code></pre><p>【案例】</p><pre><code class="js">var arr = [1,2,3]var rs = arr.unshift(&#39;a&#39;)console.log(arr)// [&#39;a&#39;, 1, 2, 3]console.log(rs)//4</code></pre><h4 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h4><p>删除数组的第一个元素，并将被删除的元素作为返回值返回</p><pre><code class="js">var arr = [1,2,3]var rs = arr.shift()console.log(arr)// [ 2, 3]console.log(rs)//1</code></pre><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><pre><code>*      可以用来从数组提取指定元素*      【该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回】*      参数：*         1.截取开始的位置的索引,包含开始索引*         2.截取结束的位置的索引,不包含结束索引*              第二个参数可以省略不写,此时会截取从开始索引往后的所有元素*          索引可以传递一个负值，如果传递一个负值，则从后往前计算*             1 倒数第一个*             2 倒数第二个</code></pre><p>【案例】</p><pre><code class="js">var arr = [1,2,3,4,5,6]//var rs = arr.slice(1,3)//var rs = arr.slice(1)var rs = arr.slice(1,-2) //1指的是索引为1的  -2代表倒数第二个 所以结果是2，3,4console.log(arr) console.log(rs)</code></pre><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><pre><code>*      可以用于删除数组中的指定元素*      【使用splice()会影响到原数组，会将指定元素从原数组中删除】*         并将被删除的元素作为返回值返回*      参数：*         第一个，表示开始位置的索引*         第二个，表示删除的数量*         第三个及以后。。*             可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边</code></pre><p>【案例】</p><pre><code class="js">var arr = [1,2,3,4,5,6]//var rs = arr.splice(0,3)var rs = arr.splice(0,3,7,8,9)console.log(arr)console.log(rs)</code></pre><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>可以连接两个或多个数组，并将新的数组返回。该方法不会对原数组产生影响</p><p>参数：除了写数组也可以是元素</p><pre><code class="js">var arr = [&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;];var arr2 = [&quot;白骨精&quot;,&quot;玉兔精&quot;,&quot;蜘蛛精&quot;];var arr3 = [&quot;二郎神&quot;,&quot;太上老君&quot;,&quot;玉皇大帝&quot;];var rs = arr.concat(arr2,arr3,&#39;唐僧&#39;,&#39;哪吒&#39;)console.log(arr)console.log(rs)</code></pre><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><pre><code>*      该方法可以将数组转换为一个字符串*      【该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回】*      在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符*         如果不指定连接符，则默认使用,作为连接符</code></pre><p>【案例】</p><pre><code class="js">var arr = [&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;];//var rs = arr.join()var rs = arr.join(&quot;-&quot;)console.log(arr)console.log(rs)</code></pre><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><pre><code>*      该方法用来反转数组（前边的去后边，后边的去前边）,返回翻转之后的新数组*      该方法会直接修改原数组</code></pre><p>【案例】</p><pre><code class="js">var arr = [&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;];var rs = arr.reverse()console.log(arr == rs) //trueconsole.log(arr) //[&#39;沙和尚&#39;, &#39;猪八戒&#39;, &#39;孙悟空&#39;]</code></pre><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><pre><code>*     可以用来对数组中的元素进行排序*     也会影响原数组，默认会按照Unicode编码进行排序* 即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，*     所以对数字进排序时，可能会得到错误的结果。* * 我们可以自己来指定排序的规则*     我们可以在sort()添加一个回调函数，来指定排序规则，*         回调函数中需要定义两个形参,*         浏览器将会分别使用数组中的元素作为实参去调用回调函数*         使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边*     浏览器会根据回调函数的返回值来决定元素的顺序，*         如果返回一个大于0的值，则元素会交换位置*         如果返回一个小于0的值，则元素位置不变*         如果返回一个0，则认为两个元素相等，也不交换位置* *     如果需要升序排列，则返回 a-b*         如果需要降序排列，则返回b-a</code></pre><p>【案例】</p><pre><code class="js">var arr = [5,4,2,1,1,3,6,8,7];//var rs = arr.sort() //升序var rs = arr.sort(function(a,b)&#123;    return b-a&#125;) //降序console.log(arr == rs) //trueconsole.log(arr) </code></pre><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>所谓的遍历数组，就是将数组中所有的元素都取出来</p><pre><code>* 一般我们都是使用for循环去遍历数组，*     JS中还为我们提供了一个方法，用来遍历数组* forEach()*          这个方法只支持IE8以上的浏览器*             IE8及以下的浏览器均不支持该方法，所以如果需要兼容IE8，则不要使用forEach*             还是使用for循环来遍历* forEach()方法需要一个函数作为参数*      像这种函数，由我们创建但是不由我们调用的，我们称为回调函数*      数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素*         以实参的形式传递进来，我们可以来定义形参，来读取这些内容*      浏览器会在回调函数中传递三个参数：*         第一个参数，就是当前正在遍历的元素*         第二个参数，就是当前正在遍历的元素的索引*         第三个参数，就是正在遍历的数组</code></pre><p>【例如】</p><pre><code class="js">var arr = [1,2,3,4,5]for(var i=0;i&lt;arr.length;i++)&#123;    console.log(arr[i])&#125;console.log(&#39;----------&#39;)arr.forEach(function(v,i,arr)&#123;    console.log(i,v,arr)&#125;)</code></pre><h2 id="p79-call和apply"><a href="#p79-call和apply" class="headerlink" title="p79 call和apply"></a>p79 call和apply</h2><pre><code>* call()和apply()*      这两个方法都是函数对象的方法，需要通过函数对象来调用*      当对函数调用call()和apply()都会调用函数执行*      在调用call()和apply()可以将一个对象指定为第一个参数*         此时这个对象将会成为函数执行时的this*      call()方法可以将实参在对象之后依次传递*      apply()方法需要将实参封装到一个数组中统一传递* *      this的情况：*         1.以函数形式调用时，this永远都是window*         2.以方法的形式调用时，this是调用方法的对象*         3.以构造函数的形式调用时，this是新创建的那个对象*         4.使用call和apply调用时，this是指定的那个对象</code></pre><p>【案例】</p><pre><code class="js">function fun(a,b) &#123;    console.log(&quot;a = &quot;+a);    console.log(&quot;b = &quot;+b);    console.log(this);&#125;var obj = &#123;    name: &quot;我是obj&quot;,    sayName:function()&#123;        console.log(this.name);    &#125;&#125;;//fun() //以函数调用 this指window//obj.sayName() //以方法调用this指调用方法的对象//fun.call() //this指window//fun.call(obj) //this指obj//fun.apply()//this指window//fun.apply(obj)//this指obj//call和apply的不同点//fun.call(obj,1,2) //1,2为参数//fun.apply(obj,[3,4]) //3,4为参数</code></pre><h2 id="p80-arguments"><a href="#p80-arguments" class="headerlink" title="p80 arguments"></a>p80 arguments</h2><pre><code>* 在调用函数时，浏览器每次都会传递进两个隐含的参数：*     1.函数的上下文对象 this*     2.封装实参的对象 arguments*          arguments是一个类数组对象,它也可以通过索引来操作数据，也可以获取长度*          在调用函数时，我们所传递的实参都会在arguments中保存*          arguments.length可以用来获取实参的长度*          我们即使不定义形参，也可以通过arguments来使用实参，*             只不过比较麻烦*             arguments[0] 表示第一个实参*             arguments[1] 表示第二个实参 。。。*         它里边有一个属性叫做callee，*             这个属性对应一个函数对象，就是当前正在指向的函数的对象</code></pre><p>【案例】</p><pre><code class="js">function fun()&#123;    console.log(arguments.callee == fun) //true    console.log(Array.isArray(arguments))//false    console.log(arguments.length)//3    console.log(arguments[1])//2&#125;fun(1,2,3)</code></pre><h2 id="p81-Date对象"><a href="#p81-Date对象" class="headerlink" title="p81 Date对象"></a>p81 Date对象</h2><p>在JS中使用Date对象来表示一个时间</p><p>创建Date对象的方式</p><pre><code class="js">var d = new Date();//默认为当前时间var d2 = new Date(&quot;2/18/2011 11:10:30&quot;); //日期的格式  月份/日/年 时:分:秒var d3 = new Date(1655436727888) //通过时间戳创建</code></pre><p>Date对象的一些方法</p><pre><code>* getFullYear()*      获取当前日期对象的年份* getMonth()*  获取当前时间对象的月份*      会返回一个0-11的值*         0 表示1月*         1 表示2月*         11 表示12月* getDate()*      获取当前日期对象是几日* getDay()*      获取当前日期对象时周几*      会返回一个0-6的值*         0 表示周日*         1表示周一*         。。。* getTime()*      获取当前日期对象的时间戳*      时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒*         到当前日期所花费的毫秒数（1秒 = 1000毫秒）*      计算机底层在保存时间时使用都是时间戳</code></pre><p>【案例】</p><pre><code class="js">var d = new Date()var year = d.getFullYear()var month = d.getMonth()+1var date = d.getDate()var day = d.getDay()==0?&#39;日&#39;:d.getDay()var hours = d.getHours()var minutes = d.getMinutes()var seconds = d.getSeconds()console.log(year+&quot;-&quot;+month+&quot;-&quot;+date+&quot;-星期&quot;+day+&quot; &quot;+hours+&quot;:&quot;+minutes+&quot;:&quot;+seconds)//获取时间戳var t = d.getTime()console.log(t)//获取当前时间的时间戳console.log(Date.now())</code></pre><h2 id="p82-Math"><a href="#p82-Math" class="headerlink" title="p82 Math"></a>p82 Math</h2><pre><code> Math和其他的对象不同，它不是一个构造函数，*     它属于一个工具类不用创建对象，它里边封装了数学运算相关的属性和方法*      比如*         Math.PI 表示的圆周率* Math.abs()可以用来计算一个数的绝对值* Math.ceil()*      可以对一个数进行向上取整，小数位只有有值就自动进1* Math.floor()*      可以对一个数进行向下取整，小数部分会被舍掉* Math.round()*      可以对一个数进行四舍五入取整* Math.random()*      可以用来生成一个0-1之间的随机数*    生成一个0-10的随机数*      生成一个0-x之间的随机数*         Math.round(Math.random()*x)*      生成一个1-10*      生成一个x-y之间的随机数*         Math.round(Math.random()*(y-x)+x)* Math.max() 可以获取多个数中的最大值* Math.min() 可以获取多个数中的最小值* Math.pow(x,y)*     返回x的y次幂* Math.sqrt()*  用于对一个数进行开方运算</code></pre><p>【案例】</p><pre><code class="js">console.log(Math.PI) //圆周率console.log(Math.abs(-1))//绝对值console.log(Math.ceil(1.2))//向上取整console.log(Math.floor(1.2))//向下取整console.log(Math.round(1.5))//四舍五入console.log(Math.round(Math.random()*9+1)) //获取1-10的随机数console.log(Math.max(10,45,30,100))//最大值console.log(Math.min(10,45,30,100))//最小值</code></pre><h2 id="p83-包装类"><a href="#p83-包装类" class="headerlink" title="p83 包装类"></a>p83 包装类</h2><pre><code>* 基本数据类型*     String Number Boolean Null Undefined* 引用数据类型*     Object* * 在JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象*     String()*         可以将基本数据类型字符串转换为String对象*     Number()*         可以将基本数据类型的数字转换为Number对象*  Boolean()*         可以将基本数据类型的布尔值转换为Boolean对象*     但是注意：我们在【实际应用中不会使用基本数据类型的对象】，*         如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果方法和属性之能添加给对象，不能添加给基本数据类型*     当我们对一些基本数据类型的值去调用属性和方法时，*         浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法*         调用完以后，在将其转换为基本数据类型</code></pre><p>【案例】</p><pre><code class="js">var num = new Number(1)console.log(num == 1) //truevar bool = new Boolean(false)console.log(bool) //boolean对象if(bool)&#123;//非空就是真，会运行    console.log(&#39;我运行了&#39;)&#125;var str = new String(&#39;abc&#39;)str.hello = &#39;def&#39;console.log(str.hello)//defvar s = &#39;123&#39;s.hello = &#39;456&#39;console.log(s.hello) //undefined</code></pre><h2 id="p84-String类"><a href="#p84-String类" class="headerlink" title="p84 String类"></a>p84 String类</h2><pre><code>* 在底层字符串是以字符数组的形式保存的* length属性*     可以用来获取字符串的长度* charAt()*     可以返回字符串中指定位置的字符*     根据索引获取指定的字符    * concat()*     可以用来连接两个或多个字符串*     作用和+一样* indexof()*     该方法可以检索一个字符串中是否含有指定内容*     如果字符串中含有该内容，则会返回其第一次出现的索引*         如果没有找到指定的内容，则返回-1*     可以指定一个第二个参数，指定开始查找的位置* * lastIndexOf();*     该方法的用法和indexOf()一样，*         不同的是indexOf是从前往后找，*         而lastIndexOf是从后往前找*     也可以指定开始查找的位置* slice()*     可以从字符串中截取指定的内容*     【不会影响原字符串，而是将截取到内容返回】*     参数：*         第一个，开始位置的索引（包括开始位置）*         第二个，结束位置的索引（不包括结束位置）*             【如果省略第二个参数，则会截取到后边所有的】*         也可以传递一个负数作为参数，负数的话将会从后边计算* substring()*     可以用来截取一个字符串，可以slice()类似*     参数：*         第一个：开始截取位置的索引（包括开始位置）*         第二个：结束位置的索引（不包括结束位置）*         不同的是这个方法不能接受负值作为参数，*             如果传递了一个负值，则默认使用0*         而且他还自动调整参数的位置，如果第二个参数小于第一个，则自动交换* substr()*     用来截取字符串*     参数：*         1.截取开始位置的索引*         2.截取的长度* split()*     可以将一个字符串拆分为一个数组*     参数：*         -需要一个字符串作为参数，将会根据该字符串去拆分数组*        【如果传递一个空串作为参数，则会将每个字符都拆分为数组中的一个元素】* toUpperCase()*     将一个字符串转换为大写并返回* toLowerCase()*     -将一个字符串转换为小写并返回</code></pre><p>【案例】</p><pre><code class="js">var str = &#39;a,b,c&#39;//var rs = str.concat(&#39;def&#39;,&#39;ghi&#39;)//var rs = str.slice(0,2)//var rs = str.substring(2,-1)var rs = str.substr(0,3)//var rs = str.split(&quot;,&quot;)console.log(rs)</code></pre><h2 id="p85-p90-正则"><a href="#p85-p90-正则" class="headerlink" title="p85-p90 正则"></a>p85-p90 正则</h2><p>了解一下，要用的时候再来看就行</p><pre><code>*     正则表达式用于定义一些字符串的规则，*         计算机可以根据正则表达式，来检查一个字符串是否符合规则，*         获取将字符串中符合规则的内容提取出来* 创建正则表达式的对象* 语法：*     var 变量 = new RegExp(&quot;正则表达式&quot;,&quot;匹配模式&quot;);*  使用typeof检查正则对象，会返回object*     var reg = new RegExp(&quot;a&quot;); 这个正则表达式可以来检查一个字符串中是否含有a*  在构造函数中可以传递一个匹配模式作为第二个参数，*         可以是 *             i 忽略大小写 *             g 全局匹配模式* 正则表达式的方法：*     test()*      使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，*         如果符合则返回true，否则返回false* 使用字面量来创建正则表达式*     语法：var 变量 = /正则表达式/匹配模式* 使用字面量的方式创建更加简单*     使用构造函数创建更加灵活* 使用 | 表示或者的意思* []里的内容也是或的关系* [ab] == a|b* [a-z] 任意小写字母* [A-Z] 任意大写字母* [A-z] 任意字母* [0-9] 任意数字* 量词*     通过量词可以设置一个内容出现的次数*     量词只对它前边的一个内容起作用*     &#123;n&#125; 正好出现n次*     &#123;m,n&#125; 出现m-n次*     &#123;m,&#125; m次以上*     + 至少一个，相当于&#123;1,&#125;*     * 0个或多个，相当于&#123;0,&#125;*     ? 0个或1个，相当于&#123;0,1&#125;*     ^ 表示开头*     $ 表示结尾*   【如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式】* 检查一个字符串中是否含有 .* . 表示任意字符* 在正则表达式中使用\作为转义字符* \. 来表示.* \\  表示\* * 注意：使用构造函数时，由于它的参数是一个字符串，而\是字符串中转义字符，*     如果要使用\则需要使用\\来代替* \w*     任意字母、数字、_  [A-z0-9_]* \W*     除了字母、数字、_  [^A-z0-9_]* \d*     任意的数字 [0-9]* \D*     除了数字 [^0-9]* \s*     空格* \S*     除了空格* \b*     单词边界* \B*     除了单词边界* 字符串的split()*     可以将一个字符串拆分为一个数组*     方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串*     这个方法即使不指定全局匹配，也会全都插分* 字符串的search()*     可以搜索字符串中是否含有指定内容*     如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1*     它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串*     serach()只会查找第一个，即使设置全局匹配也没用* 字符串的match()*     可以根据正则表达式，从一个字符串中将符合条件的内容提取出来*     默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索*         我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容*         可以为一个正则表达式设置多个匹配模式，且顺序无所谓*     match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果* 字符串的replace()*     可以将字符串中指定内容替换为新的内容*  参数：*         1.被替换的内容，可以接受一个正则表达式作为参数*         2.新的内容*  默认只会替换第一个</code></pre><p>【入门案例】</p><pre><code class="js">//var reg = new RegExp(&#39;a&#39;)//检查是否包含a，忽略大小写//var reg = new RegExp(&#39;a&#39;,&#39;i&#39;)//使用字面量来创建正则//var reg = /a/i//检查是否包含a或b，忽略大小写//var reg = /a|b/i// var reg = /[ab]/i// console.log(reg.test(&#39;ac&#39;))//console.log(typeof reg)//a&#123;3&#125;bvar reg = /^a&#123;3&#125;ab$/console.log(reg.test(&#39;aaaab&#39;))</code></pre><h2 id="p91-140"><a href="#p91-140" class="headerlink" title="p91-140"></a>p91-140</h2><h3 id="dom"><a href="#dom" class="headerlink" title="dom"></a>dom</h3><p>DOM，全称Document Object Model文档对象模型。文档表示的就是整个的HTML网页文档</p><p><img src="/2022/06/17/1543080309728350208/images/image-20220617162901955.png" alt="image-20220617162901955"></p><p><img src="/2022/06/17/1543080309728350208/images/image-20220617162930420.png" alt="image-20220617162930420"></p><p><img src="/2022/06/17/1543080309728350208/images/image-20220617163000808.png" alt="image-20220617163000808"></p><h4 id="dom查询"><a href="#dom查询" class="headerlink" title="dom查询"></a>dom查询</h4><ul><li>获取整个文档： document</li><li>获取body： document.body</li><li>根据id获取节点： document.getElementById()</li><li>根据标签名获取：document.getElementsByTagName</li><li>根据类名获取： document.getElementsByClassName</li><li>使用样式选择器查询，返回第一个：document.querySelector()</li><li>使用样式选择器查询，返回所有结果：document.querySelectorAll()</li></ul><h3 id="bom"><a href="#bom" class="headerlink" title="bom"></a>bom</h3><pre><code>* BOM*     浏览器对象模型*     BOM可以使我们通过JS来操作浏览器*     在BOM中为我们提供了一组对象，用来完成对浏览器的操作*     BOM对象*         Window*             代表的是整个浏览器的窗口，同时window也是网页中的全局对象*         Navigator*             代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器*         Location*             代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面*         History*             代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录*                 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页*                 而且该操作只在当次访问时有效*         Screen*             代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息* * *         这些【BOM对象在浏览器中都是作为window对象的属性保存的】，*             可以通过window对象来使用，也可以直接使用</code></pre><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><pre><code>* Navigator*     代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器*     由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了*     【一般我们只会使用userAgent来判断浏览器的信息】，*         userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，*         不同的浏览器会有不同的userAgent</code></pre><p>例如：</p><pre><code class="js">var ua = navigator.userAgent;console.log(ua);if(/firefox/i.test(ua))&#123;    alert(&quot;你是火狐！！！&quot;);&#125;else if(/chrome/i.test(ua))&#123;    alert(&quot;你是Chrome&quot;);&#125;else if(/msie/i.test(ua))&#123;    alert(&quot;你是IE浏览器~~~&quot;);&#125;else if(&quot;ActiveXObject&quot; in window)&#123;    alert(&quot;你是IE11，枪毙了你~~~&quot;);&#125;</code></pre><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><pre><code>/** length*     属性，可以获取到当成访问的链接数量*///alert(history.length);/** back()*     可以用来回退到上一个页面，作用和浏览器的回退按钮一样*///history.back();/** forward()*     可以跳转下一个页面，作用和浏览器的前进按钮一样*///history.forward();/** go()  推荐这个*     可以用来跳转到指定的页面*     它需要一个整数作为参数*         1:表示向前跳转一个页面 相当于forward()*         2:表示向前跳转两个页面*         1:表示向后跳转一个页面*         2:表示向后跳转两个页面*/history.go(-2);</code></pre><h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>该对象中封装了浏览器的地址栏的信息</p><pre><code>//如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）//alert(location);/** 如果直接将location属性修改为一个完整的路径，或相对路径*     则我们页面会自动跳转到该路径，并且会生成相应的历史记录*///location = &quot;http://www.baidu.com&quot;;//location = &quot;01.BOM.html&quot;;/** assign()*     用来跳转到其他的页面，作用和直接修改location一样*///location.assign(&quot;http://www.baidu.com&quot;);/** reload()*     用于重新加载当前页面，作用和刷新按钮一样*     如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面*///location.reload(true);/** replace()*     可以使用一个新的页面替换当前页面，调用完毕也会跳转页面*         不会生成历史记录，不能使用回退按钮回退*/location.replace(&quot;01.BOM.html&quot;);</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件的冒泡</p><pre><code>*     所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发*     在开发中大部分情况冒泡都是有用的,如果不希望发生事件冒泡可以通过事件对象来取消冒泡</code></pre><p>事件的委派</p><pre><code>* 我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的* 我们可以尝试将其绑定给元素的共同的祖先元素* * 事件的委派*     指【将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素*         从而通过祖先元素的响应函数来处理事件。】*  事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能* target*     event中的target表示的触发事件的对象，比如按钮或链接</code></pre><p>事件的传播</p><pre><code>* 事件的传播*     关于事件的传播网景公司和微软公司有不同的理解*     微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，*         然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。*  网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，*         然后在向内传播给后代元素*     W3C综合了两个公司的方案，将事件传播分成了三个阶段*         1.捕获阶段*             在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件*         2.目标阶段*             事件捕获到目标元素，捕获结束开始在目标元素上触发事件*         3.冒泡阶段*             事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件* *         如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true*             一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false* *     IE8及以下的浏览器中没有捕获阶段</code></pre><p>事件的绑定</p><pre><code>* 使用 对象.事件 = 函数 的形式绑定响应函数，*     它只能同时为一个元素的一个事件绑定一个响应函数，*     不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的* addEventListener()*     通过这个方法也可以为元素绑定响应函数*  参数：*         1.事件的字符串，不要on*         2.回调函数，当事件触发时该函数会被调用*         3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false* * 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，*     这样当事件被触发时，响应函数将会按照函数的绑定顺序执行* * 这个方法不支持IE8及以下的浏览器</code></pre><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><pre><code>* JSON*     JS中的对象只有JS自己认识，其他的语言都不认识*     JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，*         并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互*     JSON*         JavaScript Object Notation JS对象表示法*         JSON和JS对象的格式一样，只不过【JSON字符串中的属性名必须加双引号】*             其他的和JS语法一致*         JSON分类：*             1.对象 &#123;&#125;*             2.数组 []* *         JSON中允许的值：*             1.字符串*             2.数值*             3.布尔值*             4.null*             5.对象*             6.数组* 将JSON字符串转换为JS中的对象*     在JS中，为我们提供了一个工具类，就叫JSON*     这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON* json --&gt; js对象*      JSON.parse()*         可以将以JSON字符串转换为js对象*         它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回* JS对象 ---&gt; JSON*     JSON.stringify()*         可以将一个JS对象转换为JSON字符串*         需要一个js对象作为参数，会返回一个JSON字符串* eval()*     这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回*     如果使用eval()执行的字符串中含有&#123;&#125;,它会将&#123;&#125;当成是代码块*         如果不希望将其当成代码块解析，则需要在字符串前后各加一个()* *     eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码，*         但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患</code></pre>]]></content>
    
    
    <summary type="html">js基础笔记整理</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://heliufang.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>uniapp学习笔记</title>
    <link href="https://heliufang.github.io/2022/06/12/1535896316616511488/images/"/>
    <id>https://heliufang.github.io/2022/06/12/1535896316616511488/images/</id>
    <published>2022-06-12T08:05:28.000Z</published>
    <updated>2022-12-21T03:47:42.836Z</updated>
    
    <content type="html"><![CDATA[<p>笔记根据B站<a href="https://www.bilibili.com/video/BV1BJ411W7pX">Uni-App从入门到实战-黑马程序员杭州校区出品</a>视频教程整理</p><p>相关素材：<a href="https://pan.baidu.com/s/1Dkj5iuGRG6j2HzK_8MDxFA">https://pan.baidu.com/s/1Dkj5iuGRG6j2HzK_8MDxFA</a>  提取码:7vm2，搬运来的链接，大家自取</p><p>案例的接口文档：<a href="https://www.showdoc.com.cn/128719739414963?page_id=2513235043485226">https://www.showdoc.com.cn/128719739414963?page_id=2513235043485226</a></p><p>颜色对照表：<a href="https://destiny001.gitee.io/color/">https://destiny001.gitee.io/color/</a></p><h2 id="p1-uniapp简介"><a href="#p1-uniapp简介" class="headerlink" title="p1 uniapp简介"></a>p1 uniapp简介</h2><p><code>uni-app上手简单,可快速开发小程序、h5、安卓、ios应用</code>。学习本课程需有vue基础方可继续，当然了有想学习小程序的，也建议学习本课程，学会uni-app之后，原生小程序也可快速上手。</p><h2 id="p2-uniapp环境搭建"><a href="#p2-uniapp环境搭建" class="headerlink" title="p2 uniapp环境搭建"></a>p2 uniapp环境搭建</h2><p>下载HBuilderX即可：<a href="https://www.dcloud.io/hbuilderx.html">https://www.dcloud.io/hbuilderx.html</a></p><h3 id="创建uniapp项目"><a href="#创建uniapp项目" class="headerlink" title="创建uniapp项目"></a>创建uniapp项目</h3><p><img src="/2022/06/12/1535896316616511488/images/image-20220605214331953.png" alt="image-20220605214331953"></p><h3 id="运行到浏览器"><a href="#运行到浏览器" class="headerlink" title="运行到浏览器"></a>运行到浏览器</h3><p><img src="/2022/06/12/1535896316616511488/images/image-20220605214413231.png" alt="image-20220605214413231"></p><h3 id="运行到微信小程序"><a href="#运行到微信小程序" class="headerlink" title="运行到微信小程序"></a>运行到微信小程序</h3><p><img src="/2022/06/12/1535896316616511488/images/image-20220605214452424.png" alt="image-20220605214452424"></p><p><strong>注意</strong>：需要先在微信小程序中  <code>设置-安全设置  开启端口</code>  否则启动不了。</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220605214536999.png" alt="image-20220605214536999"></p><h3 id="运行到安卓手机"><a href="#运行到安卓手机" class="headerlink" title="运行到安卓手机"></a>运行到安卓手机</h3><p>略</p><h2 id="p3-uniapp项目结构和开发规范"><a href="#p3-uniapp项目结构和开发规范" class="headerlink" title="p3 uniapp项目结构和开发规范"></a>p3 uniapp项目结构和开发规范</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><a href="https://uniapp.dcloud.io/tutorial/project.html#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">项目结构文档</a></p><pre><code>├─pages                 业务页面文件存放的目录│  ├─index│  │  └─index.vue       index页面│  └─list│     └─list.vue        list页面├─static                存放应用引用的本地静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此├─unpackage             非工程代码，一般存放运行或发行的编译结果├─main.js               Vue初始化入口文件├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期├─manifest.json         配置应用名称、appid、logo、版本等打包信息，详见├─pages.json            配置页面路由、导航条、选项卡等页面类信息，详见└─uni.scss              这里是uni-app内置的常用样式变量 </code></pre><h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><p>为了实现多端兼容，综合考虑编译速度、运行性能等因素，<code>uni-app</code> 约定了如下开发规范：</p><ul><li>页面文件遵循 <a href="https://vue-loader.vuejs.org/zh/spec.html">Vue 单文件组件 (SFC) 规范(opens new window)</a></li><li>组件标签靠近小程序规范，详见<a href="https://uniapp.dcloud.io/component/">uni-app 组件规范</a></li><li>接口能力（JS API）靠近微信小程序规范，但需将前缀 <code>wx</code> 替换为 <code>uni</code>，详见<a href="https://uniapp.dcloud.io/api/">uni-app接口规范</a></li><li>数据绑定及事件处理同 <code>Vue.js</code> 规范，同时补充了App及页面的生命周期</li><li>为兼容多端运行，建议使用<code>flex布局</code>进行开发</li></ul><p><strong>总结</strong>：就是小程序的语法和vue的语法结合</p><h2 id="P4-globalStyle全局配置"><a href="#P4-globalStyle全局配置" class="headerlink" title="P4 globalStyle全局配置"></a>P4 globalStyle全局配置</h2><p>对应<code>page.json</code>文件中<code>globalStyle</code>节点</p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">默认值</th><th align="left">描述</th><th align="left">平台差异说明</th></tr></thead><tbody><tr><td align="left">navigationBarBackgroundColor</td><td align="left">HexColor</td><td align="left">#F7F7F7</td><td align="left">导航栏背景颜色（同状态栏背景色）</td><td align="left">APP与H5为#F7F7F7，小程序平台请参考相应小程序文档</td></tr><tr><td align="left">navigationBarTextStyle</td><td align="left">String</td><td align="left">white</td><td align="left">导航栏标题颜色及状态栏前景颜色，仅支持 black&#x2F;white</td><td align="left"></td></tr><tr><td align="left">navigationBarTitleText</td><td align="left">String</td><td align="left"></td><td align="left">导航栏标题文字内容</td><td align="left"></td></tr><tr><td align="left">navigationStyle</td><td align="left">String</td><td align="left">default</td><td align="left">导航栏样式，仅支持 default&#x2F;custom。custom即取消默认的原生导航栏，需看<a href="https://uniapp.dcloud.io/collocation/pages#customnav">使用注意</a></td><td align="left">微信小程序 7.0+、百度小程序、H5、App（2.0.3+）</td></tr><tr><td align="left">backgroundColor</td><td align="left">HexColor</td><td align="left">#ffffff</td><td align="left">下拉显示出来的窗口的背景色</td><td align="left">微信小程序</td></tr><tr><td align="left">backgroundTextStyle</td><td align="left">String</td><td align="left">dark</td><td align="left">下拉 loading 的样式，仅支持 dark &#x2F; light</td><td align="left">微信小程序</td></tr><tr><td align="left">enablePullDownRefresh</td><td align="left">Boolean</td><td align="left">false</td><td align="left">是否开启下拉刷新，详见<a href="https://uniapp.dcloud.io/tutorial/page.html#lifecycle">页面生命周期</a>。</td><td align="left"></td></tr><tr><td align="left">onReachBottomDistance</td><td align="left">Number</td><td align="left">50</td><td align="left">页面上拉触底事件触发时距页面底部距离，单位只支持px，详见<a href="https://uniapp.dcloud.io/tutorial/page.html#lifecycle">页面生命周期</a></td><td align="left"></td></tr></tbody></table><p>更多属性配置可以参考文档：<a href="https://uniapp.dcloud.io/collocation/pages.html#globalstyle">全局配置文档</a></p><h2 id="P5-创建和配置页面"><a href="#P5-创建和配置页面" class="headerlink" title="P5 创建和配置页面"></a>P5 创建和配置页面</h2><p>第一步：新建文件夹以及创建vue文件</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220605221538951.png" alt="image-20220605221538951"></p><p>message.vue的内容如下：</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;message页面&lt;/view&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>第二步：在page.json文件中进行配置</p><p>注意：<strong>pages数组中第一项表示应用启动页</strong></p><p><img src="/2022/06/12/1535896316616511488/images/image-20220605221816965.png" alt="image-20220605221816965"></p><p>测试就可以看到页面了</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220605221952416.png" alt="image-20220605221952416"></p><p>参考：<a href="https://uniapp.dcloud.io/collocation/pages.html#pages">页面样式配置文档</a></p><h2 id="p6-p7-tabBar-配置"><a href="#p6-p7-tabBar-配置" class="headerlink" title="p6-p7 tabBar 配置"></a>p6-p7 tabBar 配置</h2><p><strong>属性说明：</strong></p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">必填</th><th align="left">默认值</th><th align="left">描述</th><th align="left">平台差异说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">HexColor</td><td align="left">是</td><td align="left"></td><td align="left">tab 上的文字默认颜色</td><td align="left"></td></tr><tr><td align="left">selectedColor</td><td align="left">HexColor</td><td align="left">是</td><td align="left"></td><td align="left">tab 上的文字选中时的颜色</td><td align="left"></td></tr><tr><td align="left">backgroundColor</td><td align="left">HexColor</td><td align="left">是</td><td align="left"></td><td align="left">tab 的背景色</td><td align="left"></td></tr><tr><td align="left">borderStyle</td><td align="left">String</td><td align="left">否</td><td align="left">black</td><td align="left">tabbar 上边框的颜色，可选值 black&#x2F;white</td><td align="left">App 2.3.4+ 支持其他颜色值、H5 3.0.0+</td></tr><tr><td align="left">blurEffect</td><td align="left">String</td><td align="left">否</td><td align="left">none</td><td align="left">iOS 高斯模糊效果，可选值 dark&#x2F;extralight&#x2F;light&#x2F;none（参考:<a href="https://ask.dcloud.net.cn/article/36617">使用说明 (opens new window)</a>）</td><td align="left">App 2.4.0+ 支持、H5 3.0.0+（只有最新版浏览器才支持）</td></tr><tr><td align="left">list</td><td align="left">Array</td><td align="left">是</td><td align="left"></td><td align="left">tab 的列表，详见 list 属性说明，最少2个、最多5个 tab</td><td align="left"></td></tr><tr><td align="left">position</td><td align="left">String</td><td align="left">否</td><td align="left">bottom</td><td align="left">可选值 bottom、top</td><td align="left">top 值仅微信小程序支持</td></tr></tbody></table><p><a href="https://uniapp.dcloud.net.cn/collocation/pages.html#tabbar">tabbar文档</a></p><p>第一步：新增contact页面，参考p5。<strong>建完之后别忘了在pages.json中的pages节点下配置路径</strong></p><p><img src="/2022/06/12/1535896316616511488/images/image-20220610110727253.png" alt="image-20220610110727253"></p><p>第二步：将图片拷贝的静态文件夹，有选中的图片和不选中的图片。可以用阿里图标库生成</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220610105106625.png" alt="image-20220610105106625"></p><p>第三步：page.json中配置一下tabbar</p><pre><code class="json">&quot;tabBar&quot;: &#123;        &quot;color&quot;: &quot;#7A7E83&quot;,        &quot;selectedColor&quot;: &quot;#3cc51f&quot;,        &quot;borderStyle&quot;: &quot;black&quot;,        &quot;backgroundColor&quot;: &quot;#ffffff&quot;,        &quot;list&quot;: [            &#123;                &quot;pagePath&quot;: &quot;pages/index/index&quot;,                &quot;iconPath&quot;: &quot;static/image/home.png&quot;,                &quot;selectedIconPath&quot;: &quot;static/image/home-active.png&quot;,                &quot;text&quot;: &quot;主页&quot;            &#125;,             &#123;                &quot;pagePath&quot;: &quot;pages/message/message&quot;,                &quot;iconPath&quot;: &quot;static/image/message.png&quot;,                &quot;selectedIconPath&quot;: &quot;static/image/message-active.png&quot;,                &quot;text&quot;: &quot;信息&quot;            &#125;,            &#123;                &quot;pagePath&quot;: &quot;pages/contact/contact&quot;,                &quot;iconPath&quot;: &quot;static/image/contact.png&quot;,                &quot;selectedIconPath&quot;: &quot;static/image/contact-active.png&quot;,                &quot;text&quot;: &quot;我们&quot;            &#125;        ]    &#125;</code></pre><p>然后在界面就可以看到效果了，点击之后可以切换到对应的界面</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220610111119764.png" alt="image-20220610111119764"></p><h2 id="p8-condition"><a href="#p8-condition" class="headerlink" title="p8 condition"></a>p8 condition</h2><p><a href="https://uniapp.dcloud.net.cn/collocation/pages.html#condition">condition文档</a></p><p>启动模式配置，<strong>仅开发期间生效，用于模拟直达页面的场景</strong>，如：小程序转发后，用户点击所打开的页面。</p><p><strong>属性说明：</strong></p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">是否必填</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">current</td><td align="left">Number</td><td align="left">是</td><td align="left">当前激活的模式，list节点的索引值</td></tr><tr><td align="left">list</td><td align="left">Array</td><td align="left">是</td><td align="left">启动模式列表</td></tr></tbody></table><p><strong>list说明：</strong></p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">是否必填</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">String</td><td align="left">是</td><td align="left">启动模式名称</td></tr><tr><td align="left">path</td><td align="left">String</td><td align="left">是</td><td align="left">启动页面路径</td></tr><tr><td align="left">query</td><td align="left">String</td><td align="left">否</td><td align="left">启动参数，可在页面的 <a href="https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle">onLoad</a> 函数里获得</td></tr></tbody></table><p><strong>注意：</strong> 在 App 里真机运行可直接打开配置的页面，微信开发者工具里需要手动改变编译模式，如下图：</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220610113003166.png" alt="image-20220610113003166"></p><p>第一步：新增details页面</p><p>第二步：在pages.json中添加condition节点，配置如下</p><pre><code class="json">&quot;condition&quot; : &#123; //模式配置，仅开发期间生效        &quot;current&quot;: 0, //当前激活的模式(list 的索引项)        &quot;list&quot;: [            &#123;                &quot;name&quot;: &quot;详情页&quot;, //模式名称                &quot;path&quot;: &quot;pages/details/details&quot;, //启动页面，必选                &quot;query&quot;: &quot;id=10&quot; //启动参数，在页面的onLoad函数里面得到            &#125;        ]    &#125;</code></pre><h2 id="p9-text组件"><a href="#p9-text组件" class="headerlink" title="p9 text组件"></a>p9 text组件</h2><p><a href="https://uniapp.dcloud.net.cn/component/text.html">text组件文档</a></p><p>文本组件。</p><p>用于包裹文本内容。</p><p><strong>属性说明</strong></p><table><thead><tr><th align="left">属性名</th><th align="left">类型</th><th align="left">默认值</th><th align="left">说明</th><th align="left">平台差异说明</th></tr></thead><tbody><tr><td align="left">selectable</td><td align="left">Boolean</td><td align="left">false</td><td align="left">文本是否可选</td><td align="left">App、H5、快手小程序</td></tr><tr><td align="left">user-select</td><td align="left">Boolean</td><td align="left">false</td><td align="left">文本是否可选</td><td align="left">微信小程序</td></tr><tr><td align="left">space</td><td align="left">String</td><td align="left"></td><td align="left">显示连续空格</td><td align="left">App、H5、微信小程序</td></tr><tr><td align="left">decode</td><td align="left">Boolean</td><td align="left">false</td><td align="left">是否解码</td><td align="left">App、H5、微信小程序</td></tr></tbody></table><p><strong>space 值说明</strong></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ensp</td><td align="left">中文字符空格一半大小</td></tr><tr><td align="left">emsp</td><td align="left">中文字符空格大小</td></tr><tr><td align="left">nbsp</td><td align="left">根据字体设置的空格大小</td></tr></tbody></table><p>修改detail.vue</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        &lt;view&gt;&lt;text&gt;不可选文字(默认)&lt;/text&gt;&lt;/view&gt;        &lt;view&gt;&lt;text selectable&gt;可选文字&lt;/text&gt;&lt;/view&gt;        &lt;view&gt;&lt;text&gt;空格隔空    你搞个1&lt;/text&gt;&lt;/view&gt;        &lt;view&gt;&lt;text space=&quot;ensp&quot;&gt;中文字符    空格一半大小&lt;/text&gt;&lt;/view&gt;        &lt;view&gt;&lt;text space=&quot;emsp&quot;&gt;中文字符  空格大小&lt;/text&gt;&lt;/view&gt;        &lt;view&gt;&lt;text space=&quot;nbsp&quot; style=&quot;font-size: 16px;&quot;&gt;根据字体 设置的空格大小&lt;/text&gt;&lt;/view&gt;        &lt;view&gt;&lt;text&gt;解码 &amp; &gt; &lt;/text&gt;&lt;/view&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>测试就可以看到对应的效果</p><h2 id="p10-view组件"><a href="#p10-view组件" class="headerlink" title="p10 view组件"></a>p10 view组件</h2><p><a href="https://uniapp.dcloud.net.cn/component/view.html">view组件文档</a></p><p>视图容器。</p><p>它类似于传统html中的div，用于包裹各种元素内容。</p><p>如果使用<a href="https://uniapp.dcloud.io/tutorial/nvue-outline">nvue (opens new window)</a>，则需注意，包裹文字应该使用<code>&lt;text&gt;</code>组件。</p><p><strong>属性说明</strong></p><table><thead><tr><th align="left">属性名</th><th align="left">类型</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">hover-class</td><td align="left">String</td><td align="left">none</td><td align="left">指定按下去的样式类。当 hover-class&#x3D;”none” 时，没有点击态效果</td></tr><tr><td align="left">hover-stop-propagation</td><td align="left">Boolean</td><td align="left">false</td><td align="left">指定是否阻止本节点的祖先节点出现点击态，App、H5、支付宝小程序、百度小程序不支持（支付宝小程序、百度小程序文档中都有此属性，实测未支持）</td></tr><tr><td align="left">hover-start-time</td><td align="left">Number</td><td align="left">50</td><td align="left">按住后多久出现点击态，单位毫秒</td></tr><tr><td align="left">hover-stay-time</td><td align="left">Number</td><td align="left">400</td><td align="left">手指松开后点击态保留时间，单位毫秒</td></tr></tbody></table><p>在details.vue文件中加入下面的测试代码</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        &lt;view class=&quot;box&quot; hover-class=&quot;box-active&quot; :hover-start-time=&quot;2000&quot; :hover-stay-time=&quot;2000&quot;&gt;            &lt;view class=&quot;childbox&quot; hover-class=&quot;childbox-active&quot; hover-stop-propagation&gt;&lt;/view&gt;        &lt;/view&gt;    &lt;/view&gt;&lt;/template&gt;&lt;style&gt;    .box&#123;        width: 150px;        height: 150px;        background: green;    &#125;    .box-active&#123;        background: deeppink;    &#125;    .childbox&#123;        width: 50px;        height: 50px;        background: greenyellow;    &#125;    .childbox-active&#123;        background: deepskyblue;    &#125;&lt;/style&gt;</code></pre><h2 id="p11-button组件"><a href="#p11-button组件" class="headerlink" title="p11 button组件"></a>p11 button组件</h2><p>按钮组件</p><p><strong>属性说明</strong></p><table><thead><tr><th align="left">属性名</th><th align="left">类型</th><th align="left">默认值</th><th align="left">说明</th><th align="left">平台差异说明</th></tr></thead><tbody><tr><td align="left">size</td><td align="left">String</td><td align="left">default</td><td align="left">按钮的大小</td><td align="left"></td></tr><tr><td align="left">type</td><td align="left">String</td><td align="left">default</td><td align="left">按钮的样式类型</td><td align="left"></td></tr><tr><td align="left">plain</td><td align="left">Boolean</td><td align="left">false</td><td align="left">按钮是否镂空，背景色透明</td><td align="left"></td></tr><tr><td align="left">disabled</td><td align="left">Boolean</td><td align="left">false</td><td align="left">是否禁用</td><td align="left"></td></tr><tr><td align="left">loading</td><td align="left">Boolean</td><td align="left">false</td><td align="left">名称前是否带 loading 图标</td><td align="left">H5、App(App-nvue 平台，在 ios 上为雪花，Android上为圆圈)</td></tr></tbody></table><p>更多属性可以看<a href="https://uniapp.dcloud.net.cn/component/button.html">button组件文档</a></p><p>在details.vue文件中加入下面的测试代码即可看到效果</p><pre><code class="html">&lt;button&gt;默认按钮&lt;/button&gt;&lt;button size=&quot;mini&quot;&gt;mini按钮&lt;/button&gt;&lt;button type=&quot;primary&quot;&gt;type=primary按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; plain&gt;type=primary的镂空按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; disabled&gt;type=primary的禁用按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; loading&gt;type=primary的loading按钮&lt;/button&gt;</code></pre><h2 id="p12-image组件"><a href="#p12-image组件" class="headerlink" title="p12 image组件"></a>p12 image组件</h2><p>图片组件</p><table><thead><tr><th align="left">属性名</th><th align="left">类型</th><th align="left">默认值</th><th align="left">说明</th><th align="left">平台差异说明</th></tr></thead><tbody><tr><td align="left">src</td><td align="left">String</td><td align="left"></td><td align="left">图片资源地址</td><td align="left"></td></tr><tr><td align="left">mode</td><td align="left">String</td><td align="left">‘scaleToFill’</td><td align="left">图片裁剪、缩放的模式</td><td align="left"></td></tr></tbody></table><p><strong>Tips</strong></p><ul><li><code>&lt;image&gt;</code> 组件默认宽度 300px、高度 225px；<code>app-nvue平台，暂时默认为屏幕宽度</code></li><li><code>src</code> 仅支持相对路径、绝对路径，支持 base64 码；</li><li>页面结构复杂，css样式太多的情况，使用 image 可能导致样式生效较慢，出现 “闪一下” 的情况，此时设置 <code>image&#123;will-change: transform&#125;</code> ,可优化此问题。</li><li>自定义组件里面使用 <code>&lt;image&gt;</code>时，若 <code>src</code> 使用相对路径可能出现路径查找失败的情况，故建议使用绝对路径。</li></ul><p><strong>mode 有效值：</strong></p><p>mode 有 14 种模式，其中 5 种是缩放模式，9 种是裁剪模式。</p><table><thead><tr><th align="left">模式</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">缩放</td><td align="left">scaleToFill</td><td align="left">不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素</td></tr><tr><td align="left">缩放</td><td align="left">aspectFit</td><td align="left">保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。</td></tr><tr><td align="left">缩放</td><td align="left">aspectFill</td><td align="left">保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。</td></tr></tbody></table><p>更多参考<a href="https://uniapp.dcloud.net.cn/component/image.html">图片组件文档</a></p><p>在details.vue中加入下面的代码</p><pre><code class="html">&lt;image src=&quot;https://heliufang.gitee.io/2022/03/27/1513842928408203264/images/image-20220319113815361.png&quot;&gt;&lt;/image&gt;        &lt;image src=&quot;https://heliufang.gitee.io/2022/03/27/1513842928408203264/images/image-20220319113815361.png&quot; mode=&quot;aspectFit&quot;&gt;&lt;/image&gt;        &lt;image src=&quot;https://heliufang.gitee.io/2022/03/27/1513842928408203264/images/image-20220319113815361.png&quot; mode=&quot;aspectFill&quot;&gt;&lt;/image&gt;</code></pre><h2 id="p13-uniapp样式-字体图片-sass"><a href="#p13-uniapp样式-字体图片-sass" class="headerlink" title="p13 uniapp样式-字体图片-sass"></a>p13 uniapp样式-字体图片-sass</h2><h3 id="css单位"><a href="#css单位" class="headerlink" title="css单位"></a>css单位</h3><p><a href="https://uniapp.dcloud.net.cn/tutorial/syntax-css.html#%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D">css单位文档</a></p><p><code>uni-app</code> 支持的通用 css 单位包括 px、rpx</p><ul><li>px 即屏幕像素</li><li>rpx 即响应式 px，一种根据屏幕宽度自适应的动态单位。<strong>以 750 宽的屏幕为基准，750rpx 恰好为屏幕宽</strong>度。屏幕变宽，<strong>rpx 实际显示效果会等比放大</strong>，但在 <strong>App（vue2 不含 nvue） 端和 H5（vue2） 端屏幕宽度达到 960px 时，默认将按照 375px 的屏幕宽度进行计算</strong>，具体配置参考：<a href="https://uniapp.dcloud.net.cn/collocation/pages#globalstyle">rpx 计算配置</a> 。</li></ul><blockquote><p><strong>举例说明：</strong></p><ol><li>若设计稿宽度为 750px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 <code>uni-app</code> 里面的宽度应该设为：<code>750 * 100 / 750</code>，结果为：100rpx。</li><li>若设计稿宽度为 640px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 <code>uni-app</code> 里面的宽度应该设为：<code>750 * 100 / 640</code>，结果为：117rpx。</li></ol></blockquote><p>vue 页面支持下面这些普通 H5 单位，但在 nvue 里不支持：</p><ul><li>rem 根字体大小可以通过 <a href="https://uniapp.dcloud.net.cn/component/page-meta#page-meta">page-meta</a> 配置</li><li>vh viewpoint height，视窗高度，1vh 等于视窗高度的 1%</li><li>vw viewpoint width，视窗宽度，1vw 等于视窗宽度的 1%</li></ul><p>新建uniapp-style.vue页面</p><p>假设设计稿的宽度为375px ，盒子的宽度为100px。那么根据公式 750*100&#x2F;375&#x3D;200rpx</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        &lt;view class=&quot;box&quot;&gt;            &lt;text&gt;uniapp&lt;/text&gt;        &lt;/view&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;    .box&#123;        width: 200rpx;        height: 200rpx;        background: red;        font-size: 32rpx;    &#125;&lt;/style&gt;</code></pre><p>打开页面调试工具发现切换到宽度为375px的设备，发现盒子的像素确实是100px</p><h3 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h3><p><a href="https://uniapp.dcloud.net.cn/tutorial/syntax-css.html#%E6%A0%B7%E5%BC%8F%E5%AF%BC%E5%85%A5">样式导入文档</a></p><p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束。</p><p>在uniapp-style.vue页面的同级目录下新建a.css文件，文件内容如下</p><pre><code class="css">.box&#123;    border: 1rpx solid;&#125;</code></pre><p>然后再uniapp-style.vue页面引入</p><pre><code class="html">&lt;style&gt;    @import url(./a.css);    .box&#123;        width: 200rpx;        height: 200rpx;        background: red;        font-size: 32rpx;    &#125;&lt;/style&gt;</code></pre><p>测试发现给盒子加上边框了。</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>目前支持的选择器有：</p><table><thead><tr><th align="left">选择器</th><th align="left">样例</th><th align="left">样例描述</th></tr></thead><tbody><tr><td align="left">.class</td><td align="left">.intro</td><td align="left">选择所有拥有 class&#x3D;”intro” 的组件</td></tr><tr><td align="left">#id</td><td align="left">#firstname</td><td align="left">选择拥有 id&#x3D;”firstname” 的组件</td></tr><tr><td align="left">element</td><td align="left">view</td><td align="left">选择所有 view 组件</td></tr><tr><td align="left">element, element</td><td align="left">view, checkbox</td><td align="left">选择所有文档的 view 组件和所有的 checkbox 组件</td></tr><tr><td align="left">::after</td><td align="left">view::after</td><td align="left">在 view 组件后边插入内容，<strong>仅 vue 页面生效</strong></td></tr><tr><td align="left">::before</td><td align="left">view::before</td><td align="left">在 view 组件前边插入内容，<strong>仅 vue 页面生效</strong></td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>在 <code>uni-app</code> 中不能使用 <code>*</code> 选择器。</li><li>微信小程序自定义组件中仅支持 class 选择器</li><li><code>page</code> 相当于 <code>body</code> 节点，例如：</li></ul><pre><code class="css">&lt;!-- 设置页面背景颜色，使用 scoped 会导致失效 -- &gt;   page &#123;    background-color: #ccc;&#125;</code></pre><h3 id="全局样式与局部样式"><a href="#全局样式与局部样式" class="headerlink" title="全局样式与局部样式"></a>全局样式与局部样式</h3><p>定义在 App.vue 中的样式为全局样式，作用于每一个页面。在 pages 目录下 的 vue 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 App.vue 中相同的选择器。</p><p><strong>注意：</strong></p><ul><li>App.vue 中通过 <code>@import</code> 语句可以导入外联样式，一样作用于每一个页面。</li><li>nvue 页面暂不支持全局样式</li></ul><h3 id="使用scss"><a href="#使用scss" class="headerlink" title="使用scss"></a>使用scss</h3><p>在页面加上 lang&#x3D;”scss” 会自动安装scss插件</p><pre><code class="html">&lt;style lang=&quot;scss&quot;&gt;    @import url(./a.css);    .box&#123;        width: 200rpx;        height: 200rpx;        background: red;        text&#123;            font-size: 16rpx;            color: aqua;        &#125;    &#125;&lt;/style&gt;</code></pre><h3 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h3><p><a href="https://uniapp.dcloud.net.cn/tutorial/syntax-css.html#%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87">字体图标文档</a></p><p><code>uni-app</code> 支持使用字体图标，使用方式与普通 <code>web</code> 项目相同，需要注意以下几点：</p><ul><li>支持 base64 格式字体图标。</li><li>支持网络路径字体图标。</li><li>小程序不支持在 css 中使用本地文件，包括本地的背景图和字体文件。需以 base64 方式方可使用。</li><li>网络路径必须加协议头 <code>https</code>。</li><li>从 <a href="http://www.iconfont.cn/">http://www.iconfont.cn (opens new window)</a>上拷贝的代码，默认是没加协议头的。</li><li>从 <a href="http://www.iconfont.cn/">http://www.iconfont.cn (opens new window)</a>上下载的字体文件，都是同名字体（字体名都叫 iconfont，安装字体文件时可以看到），在 nvue 内使用时需要注意，此字体名重复可能会显示不正常，可以使用工具修改。</li><li>使用本地路径图标字体需注意：<ol><li>为方便开发者，在字体文件小于 40kb 时，<code>uni-app</code> 会自动将其转化为 base64 格式；</li><li>字体文件大于等于 40kb，仍转换为 base64 方式使用的话可能有性能问题，如开发者必须使用，则需自己将其转换为 base64 格式使用，或将其挪到服务器上，从网络地址引用；</li><li>字体文件的引用路径推荐使用以 ~@ 开头的绝对路径。</li></ol></li></ul><pre><code class="css">@font-face &#123;    font-family: test1-icon;    src: url(&#39;~@/static/iconfont.ttf&#39;);&#125;</code></pre><p>第一步：将字体图标文件拷贝到static文件夹下</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220610222656159.png" alt="image-20220610222656159"></p><p>第二步：修改iconfont.css路径，都加上~@路径</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220610222737395.png" alt="image-20220610222737395"></p><p>第三步：使用</p><pre><code class="html">&lt;text class=&quot;iconfont icon-shipin&quot;&gt;&lt;/text&gt;</code></pre><h2 id="p14-16数据绑定和事件绑定"><a href="#p14-16数据绑定和事件绑定" class="headerlink" title="p14 -16数据绑定和事件绑定"></a>p14 -16数据绑定和事件绑定</h2><p>和vue一模一样 <a href="https://uniapp.dcloud.net.cn/tutorial/vue-basics.html#%E4%BB%8B%E7%BB%8D">uniapp官网上的vue文档</a></p><p>新建一个home.vue文件用来测试</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        &lt;view&gt;数据绑定学习(和vue一样)&lt;/view&gt;        &lt;!-- 插值表达式和三目运算符 --&gt;        &lt;view&gt;&#123;&#123;msg&#125;&#125;&lt;/view&gt;        &lt;view&gt;&#123;&#123;"1"+"uniapp"&#125;&#125;&lt;/view&gt;        &lt;view&gt;&#123;&#123;1+1&#125;&#125;&lt;/view&gt;        &lt;view&gt;&#123;&#123;flag?'真的':'假的'&#125;&#125;&lt;/view&gt;        &lt;!-- v-bind绑定数据 --&gt;        &lt;image :src=&quot;imgurl&quot;&gt;&lt;/image&gt;        &lt;!-- v-for循环 --&gt;        &lt;view v-for=&quot;(item,index) in arr&quot; :key=&quot;item.id&quot;&gt;            序号：&#123;&#123;index&#125;&#125;，ID:&#123;&#123;item.id&#125;&#125;,姓名：&#123;&#123;item.name&#125;&#125;，年龄：&#123;&#123;item.age&#125;&#125;        &lt;/view&gt;        &lt;button @click=&quot;clickHandle1&quot;&gt;注册1&lt;/button&gt;        &lt;button type=&quot;primary&quot; @click=&quot;clickHandle2(10,$event)&quot;&gt;注册2&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default&#123;        data()&#123;            return &#123;                msg: &#39;你好&#39;,                flag: false,                imgurl: &#39;https://heliufang.gitee.io/2022/03/27/1513842928408203264/images/image-20220319113815361.png&#39;,                arr: [                    &#123;id: 1,name: &#39;赵云&#39;,age: 18&#125;,                    &#123;id: 2,name: &#39;马超&#39;,age: 28&#125;,                    &#123;id: 3,name: &#39;关羽&#39;,age: 38&#125;,                ]            &#125;        &#125;,        methods: &#123;            clickHandle1(e)&#123;//不传参数获取事件对象                console.log(e)            &#125;,            clickHandle2(num,e)&#123;//传参                console.log(num,e)            &#125;        &#125;    &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><h2 id="p17-应用和页面的生命周期函数"><a href="#p17-应用和页面的生命周期函数" class="headerlink" title="p17 应用和页面的生命周期函数"></a>p17 应用和页面的生命周期函数</h2><p>应用的生命周期函数–App.vue文件中</p><pre><code class="html">&lt;script&gt;    export default &#123;        onLaunch: function() &#123;            console.log(&#39;应用加载完毕-只执行一次&#39;)        &#125;,        onShow: function() &#123;            console.log(&#39;应用显示&#39;)        &#125;,        onHide: function() &#123;            console.log(&#39;应用隐藏&#39;)        &#125;    &#125;&lt;/script&gt;&lt;style&gt;    @import url(./static/fonts/iconfont.css);    /*每个页面公共css */&lt;/style&gt;</code></pre><p>页面的生命周期函数–每个页面中   <a href="https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle">页面生命周期文档</a></p><table><thead><tr><th align="left">函数名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">onLoad</td><td align="left">监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考<a href="https://uniapp.dcloud.net.cn/api/router#navigateto">示例</a></td></tr><tr><td align="left">onShow</td><td align="left">监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</td></tr><tr><td align="left">onReady</td><td align="left">监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发</td></tr><tr><td align="left">onHide</td><td align="left">监听页面隐藏</td></tr></tbody></table><p>例如在message.vue页面中加上页面的生命周期函数</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;message页面&lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default&#123;        onLoad(obj)&#123;            //页面加载完毕,obj是上个页面传递的数据            console.log(&#39;页面加载完毕&#39;,obj)        &#125;,        onShow()&#123;            console.log(&#39;页面显示&#39;)        &#125;,        onReady()&#123;            console.log(&#39;页面初次渲染完毕&#39;)        &#125;,        onHide()&#123;            console.log(&#39;页面隐藏,通过切换tabbar可以看到我&#39;)        &#125;    &#125;&lt;/script&gt;</code></pre><h2 id="p18-下拉刷新"><a href="#p18-下拉刷新" class="headerlink" title="p18 下拉刷新"></a>p18 下拉刷新</h2><p><a href="https://uniapp.dcloud.net.cn/api/ui/pulldown.html">下拉刷新文档</a></p><p>在 js 中定义 onPullDownRefresh 处理函数（和onLoad等生命周期函数同级），监听该页面用户下拉刷新事件。</p><ul><li>需要在 <code>pages.json</code> 里，找到的当前页面的pages节点，并在 <code>style</code> 选项中开启 <code>enablePullDownRefresh</code>。</li></ul><p><img src="/2022/06/12/1535896316616511488/images/image-20220611131049139.png" alt="image-20220611131049139"></p><ul><li>当处理完数据刷新后，<code>uni.stopPullDownRefresh</code> 可以停止当前页面的下拉刷新。</li></ul><p>message.vue代码</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        message页面        &lt;view v-for=&quot;(item) in arr&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;        &lt;button type=&quot;primary&quot; @click=&quot;refreshArr&quot;&gt;按钮触发下拉刷新&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default&#123;        data()&#123;            return &#123;                arr: [&#39;java&#39;,&#39;前端&#39;,&#39;UI&#39;,&#39;测试&#39;]            &#125;        &#125;,        methods: &#123;            refreshArr()&#123;                uni.startPullDownRefresh()            &#125;        &#125;,        onPullDownRefresh()&#123;            setTimeout(() =&gt; &#123;                this.arr = [&#39;UI&#39;,&#39;测试&#39;,&#39;java&#39;,&#39;前端&#39;]                uni.stopPullDownRefresh() //关闭下拉刷新            &#125;,2000)        &#125;,    &#125;&lt;/script&gt;</code></pre><h2 id="p19-上拉-触底-加载"><a href="#p19-上拉-触底-加载" class="headerlink" title="p19 上拉(触底)加载"></a>p19 上拉(触底)加载</h2><p>页面的可以配置触底的距离，也就是距离底部多少距离触发，默认是50</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220611144307276.png" alt="image-20220611144307276"></p><p>页面生命周期中有个onReachBottom方法，用来监听触底。</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        message页面        &lt;view class=&quot;item-class&quot; v-for=&quot;(item) in arr&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;        &lt;button type=&quot;primary&quot; @click=&quot;refreshArr&quot;&gt;按钮触发下拉刷新&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default&#123;        data()&#123;            return &#123;                arr: [&#39;java&#39;,&#39;前端&#39;,&#39;UI&#39;,&#39;测试&#39;]            &#125;        &#125;,        methods: &#123;            refreshArr()&#123;                uni.startPullDownRefresh()            &#125;        &#125;,        onPullDownRefresh()&#123;            setTimeout(() =&gt; &#123;                this.arr = [&#39;UI&#39;,&#39;测试&#39;,&#39;java&#39;,&#39;前端&#39;]                uni.stopPullDownRefresh() //关闭下拉刷新            &#125;,2000)        &#125;,        onReachBottom()&#123;//触底的方法            //es6的语法扩展数组            this.arr = [...this.arr,...[&#39;UI&#39;,&#39;测试&#39;,&#39;java&#39;,&#39;前端&#39;]]            console.log(&#39;触底&#39;,this.arr)        &#125;    &#125;&lt;/script&gt;&lt;style&gt;    .item-class&#123;        height: 200px;    &#125;&lt;/style&gt;</code></pre><h2 id="p20-发送get请求"><a href="#p20-发送get请求" class="headerlink" title="p20  发送get请求"></a>p20  发送get请求</h2><p>搭建本地的node服务</p><p>第一步，根据dtcmsdb4.sql文件来恢复数据库</p><p>第二步,   npm i  安装依赖</p><p>第三步，node .&#x2F;src&#x2F;app.js 来启动服务,注意：默认数据库账号密码都是root，如果本地不是请修改好</p><p>第四步，浏览器输入 <a href="http://localhost:8082/api/getlunbo">http://localhost:8082/api/getlunbo</a>   来访问接口 出现下面这样表示成功</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220611150847478.png" alt="image-20220611150847478"></p><p>uniapp中通过uni.request(OBJECT)  发起网络请求。<a href="https://uniapp.dcloud.net.cn/api/request/request.html">uni.request文档</a></p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        &lt;button type=&quot;primary&quot; @click=&quot;getlunbo&quot;&gt;发起请求&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default&#123;        methods: &#123;            getlunbo()&#123;                uni.request(&#123;                    url: &#39;http://localhost:8082/api/getlunbo&#39;,                    success(resp)&#123;                        console.log(resp)                    &#125;                &#125;)            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><h2 id="p21-数据缓存"><a href="#p21-数据缓存" class="headerlink" title="p21 数据缓存"></a>p21 数据缓存</h2><p><a href="https://uniapp.dcloud.net.cn/api/storage/storage.html">数据缓存文档</a></p><h3 id="uni-setStorage"><a href="#uni-setStorage" class="headerlink" title="uni.setStorage"></a>uni.setStorage</h3><p>将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。</p><h3 id="uni-setStorageSync"><a href="#uni-setStorageSync" class="headerlink" title="uni.setStorageSync"></a>uni.setStorageSync</h3><p>将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。</p><h3 id="uni-getStorage"><a href="#uni-getStorage" class="headerlink" title="uni.getStorage"></a>uni.getStorage</h3><p>从本地缓存中异步获取指定 key 对应的内容。</p><h3 id="uni-getStorageSync"><a href="#uni-getStorageSync" class="headerlink" title="uni.getStorageSync"></a>uni.getStorageSync</h3><p>从本地缓存中同步获取指定 key 对应的内容。</p><h3 id="uni-removeStorage"><a href="#uni-removeStorage" class="headerlink" title="uni.removeStorage"></a>uni.removeStorage</h3><p>从本地缓存中异步移除指定 key。</p><h3 id="uni-removeStorageSync"><a href="#uni-removeStorageSync" class="headerlink" title="uni.removeStorageSync"></a>uni.removeStorageSync</h3><p>从本地缓存中同步移除指定 key。</p><p>测试代码如下</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        &lt;button type=&quot;primary&quot; @click=&quot;saveData&quot;&gt;保存数据&lt;/button&gt;        &lt;button type=&quot;primary&quot; @click=&quot;getData&quot;&gt;获取数据&lt;/button&gt;        &lt;button type=&quot;primary&quot; @click=&quot;removeData&quot;&gt;删除数据&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default&#123;        methods: &#123;            saveData()&#123;                // uni.setStorage(&#123;                //     key: &#39;id&#39;,                //     data: 80,                //     success()&#123;                //         console.log(&#39;保存成功&#39;)                //     &#125;                // &#125;)                uni.setStorageSync(&#39;id&#39;,100)            &#125;,            getData()&#123;                // uni.getStorage(&#123;                //     key: &#39;id&#39;,                //     success(resp)&#123;                //         console.log(&#39;获取成功：&#39;,resp.data)                //     &#125;                // &#125;)                let resp = uni.getStorageSync(&#39;id&#39;)                console.log(&#39;获取成功：&#39;,resp)            &#125;,            removeData()&#123;                // uni.removeStorage(&#123;                //     key: &#39;id&#39;,                //     success() &#123;                //         console.log(&#39;删除成功&#39;)                //     &#125;                // &#125;)                uni.removeStorageSync(&#39;id&#39;)            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><h2 id="p22-图片的上传和预览"><a href="#p22-图片的上传和预览" class="headerlink" title="p22 图片的上传和预览"></a>p22 图片的上传和预览</h2><p><a href="https://uniapp.dcloud.net.cn/api/media/image.html">图片文档</a></p><ul><li>uni.chooseImage(OBJECT)</li></ul><p>从本地相册选择图片或使用相机拍照。</p><p>App端如需要更丰富的相机拍照API（如直接调用前置摄像头），参考<a href="https://www.html5plus.org/doc/zh_cn/camera.html">plus.camera</a></p><ul><li>uni.previewImage(OBJECT)</li></ul><p>预览图片。</p><p>代码如下</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        &lt;button type=&quot;warn&quot; @click=&quot;uploadImg&quot;&gt;上传图片&lt;/button&gt;        &lt;image v-for=&quot;item in imgList&quot; :src=&quot;item&quot; @click=&quot;previewImg(item)&quot;&gt;&lt;/image&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default&#123;        data()&#123;            return&#123;                imgList: []            &#125;        &#125;,        methods: &#123;            uploadImg()&#123;                uni.chooseImage(&#123;                    success: res =&gt; &#123;                        this.imgList = res.tempFilePaths                        //console.log(res)                    &#125;                &#125;)            &#125;,            previewImg(current)&#123;                console.log(&#39;预览图片&#39;)                uni.previewImage(&#123;                    current,//current 为当前显示图片的链接/索引值                    urls: this.imgList //需要预览的图片链接列表                &#125;)            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><h2 id="p23-条件编译跨端兼容"><a href="#p23-条件编译跨端兼容" class="headerlink" title="p23 条件编译跨端兼容"></a>p23 条件编译跨端兼容</h2><p><a href="https://uniapp.dcloud.net.cn/tutorial/platform.html#%E8%B7%A8%E7%AB%AF%E5%85%BC%E5%AE%B9">条件编译文档</a></p><p>条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。</p><table><thead><tr><th>条件编译写法</th><th>说明</th></tr></thead><tbody><tr><td>#ifdef <strong>APP-PLUS</strong> 需条件编译的代码 #endif</td><td>仅出现在 App 平台下的代码</td></tr><tr><td>#ifndef <strong>H5</strong> 需条件编译的代码 #endif</td><td>除了 H5 平台，其它平台均存在的代码</td></tr><tr><td>#ifdef <strong>H5</strong> || <strong>MP-WEIXIN</strong> 需条件编译的代码 #endif</td><td>在 H5 平台或微信小程序平台存在的代码（这里只有||，不可能出现&amp;&amp;，因为没有交集）</td></tr></tbody></table><p>HbuilderX中输入if关键字会有代码提示</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        &lt;!-- #ifdef H5 --&gt;        &lt;view&gt;h5显示&lt;/view&gt;        &lt;!-- #endif --&gt;        &lt;!-- #ifdef MP-WEIXIN --&gt;        &lt;view&gt;微信小程序中显示&lt;/view&gt;        &lt;!-- #endif --&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default&#123;        onLoad() &#123;            // #ifdef H5            console.log(&#39;h5打印&#39;)            // #endif            // #ifdef MP-WEIXIN            console.log(&#39;wx打印&#39;)            // #endif                    &#125;    &#125;&lt;/script&gt;&lt;style&gt;    view&#123;        /* #ifdef H5 */        color: red;        /* #endif */        /* #ifdef MP-WEIXIN */        color: deepskyblue;        /* #endif */    &#125;&lt;/style&gt;</code></pre><h2 id="p24-导航"><a href="#p24-导航" class="headerlink" title="p24 导航"></a>p24 导航</h2><h3 id="navigator组件导航"><a href="#navigator组件导航" class="headerlink" title="navigator组件导航"></a>navigator组件导航</h3><p>页面跳转。  <a href="https://uniapp.dcloud.net.cn/component/navigator.html">navigator文档</a></p><p>该组件类似HTML中的<code>&lt;a&gt;</code>组件，但只能跳转本地页面。目标页面必须在pages.json中注册。</p><p>该组件的功能有API方式，另见：<a href="https://uniapp.dcloud.io/api/router?id=navigateto">https://uniapp.dcloud.io/api/router?id=navigateto(opens new window)</a></p><p><strong>属性说明</strong></p><table><thead><tr><th align="left">属性名</th><th align="left">类型</th><th align="left">默认值</th><th align="left">说明</th><th align="left">平台差异说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left"></td><td align="left">应用内的跳转链接，值为相对路径或绝对路径，如：”..&#x2F;first&#x2F;first”，”&#x2F;pages&#x2F;first&#x2F;first”，注意不能加 <code>.vue</code> 后缀</td><td align="left"></td></tr><tr><td align="left">open-type</td><td align="left">String</td><td align="left">navigate</td><td align="left">跳转方式</td><td align="left"></td></tr></tbody></table><p><strong>open-type 有效值</strong></p><table><thead><tr><th align="left">值</th><th align="left">说明</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">navigate</td><td align="left">对应 uni.navigateTo</td><td align="left">保留当前页面，跳转到应用内的某个页面。带返回按钮</td></tr><tr><td align="left">redirect</td><td align="left">对应 uni.redirectTo</td><td align="left">关闭当前页面，跳转到应用内的某个页面。不带返回按钮</td></tr><tr><td align="left">switchTab</td><td align="left">对应 uni.switchTab</td><td align="left">跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。</td></tr></tbody></table><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p><a href="https://uniapp.dcloud.io/api/router.html">编程式导航文档</a></p><ul><li><p>uni.navigateTo</p></li><li><p>uni.redirectTo</p></li><li><p>uni.switchTab</p></li></ul><p>代码如下：</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        &lt;navigator url=&quot;/pages/details/details&quot;&gt;跳转到详情页(带返回按钮)&lt;/navigator&gt;        &lt;navigator url=&quot;/pages/details/details&quot; open-type=&quot;redirect&quot;&gt;跳转到详情页redirect(不带返回按钮)&lt;/navigator&gt;        &lt;navigator url=&quot;/pages/message/message&quot; open-type=&quot;switchTab&quot;&gt;到tabbar的消息页&lt;/navigator&gt;        &lt;!-- 编程式导航 和上面三个是对应的 --&gt;        &lt;button type=&quot;primary&quot; @click=&quot;routerNavigate&quot;&gt;跳转到详情页(带返回按钮)&lt;/button&gt;        &lt;button type=&quot;primary&quot; @click=&quot;routerRedirect&quot;&gt;跳转到详情页(不带返回按钮)&lt;/button&gt;        &lt;button type=&quot;primary&quot; @click=&quot;routerSwichtab&quot;&gt;到tabbar的消息页&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default&#123;        onUnload() &#123;            console.log(&#39;页面卸载&#39;)        &#125;,        methods: &#123;            routerNavigate()&#123;                uni.navigateTo(&#123;                    url: &#39;/pages/details/details&#39;                &#125;)            &#125;,            routerRedirect()&#123;                uni.redirectTo(&#123;                    url: &#39;/pages/details/details&#39;                &#125;)            &#125;,            routerSwichtab()&#123;                uni.switchTab(&#123;                    url: &#39;/pages/message/message&#39;                &#125;)            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><h2 id="p25-组件的创建和组件生命周期函数"><a href="#p25-组件的创建和组件生命周期函数" class="headerlink" title="p25 组件的创建和组件生命周期函数"></a>p25 组件的创建和组件生命周期函数</h2><blockquote><p>和vue的组件创建以及生命周期是一样的。</p></blockquote><h3 id="组件的创建和使用"><a href="#组件的创建和使用" class="headerlink" title="组件的创建和使用"></a>组件的创建和使用</h3><p>新建components目录，并在目录下新建test组件</p><p><img src="/2022/06/12/1535896316616511488/images/image-20220611221930789.png" alt="image-20220611221930789"></p><p>test组件的内容如下</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        test组件    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&quot;test&quot;    &#125;&lt;/script&gt;</code></pre><p>然后在index.vue中应用test组件</p><pre><code class="html">&lt;template&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;test&gt;&lt;/test&gt;     &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    import test from &#39;../../components/test.vue&#39; //导入test组件    export default &#123;        components:&#123;            test//注册test组件        &#125;    &#125;&lt;/script&gt;</code></pre><h3 id="组件的生命周期函数"><a href="#组件的生命周期函数" class="headerlink" title="组件的生命周期函数"></a>组件的生命周期函数</h3><p>index.vue</p><pre><code class="html">&lt;template&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;test v-if=&quot;flag&quot;&gt;&lt;/test&gt;        &lt;button type=&quot;primary&quot; @click=&quot;toggleTest&quot;&gt;切换test组件&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    import test from &#39;../../components/test.vue&#39;    export default &#123;        components:&#123;            test        &#125;,        data()&#123;            return&#123;                flag: true            &#125;        &#125;,        methods: &#123;            toggleTest()&#123;                this.flag = !this.flag            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><p>test.vue组件</p><pre><code class="html">&lt;template&gt;    &lt;view id=&quot;mout&quot;&gt;        test组件    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&quot;test&quot;,        data() &#123;            return &#123;                num: 10            &#125;;        &#125;,        beforeCreate() &#123;            console.log(&#39;beforeCreate...&#39;,this.num)        &#125;,        created() &#123;            console.log(&#39;created&#39;,this.num) //页面渲染完毕        &#125;,        beforeMount() &#123;            console.log(&#39;beforeMount&#39;,document.getElementById(&#39;mout&#39;))        &#125;,        mounted() &#123;             console.log(&#39;mounted&#39;,document.getElementById(&#39;mout&#39;)) //dom挂载完毕        &#125;,        destroyed() &#123;            console.log(&#39;destroyed&#39;) //页面销毁        &#125;    &#125;&lt;/script&gt;</code></pre><h2 id="p26-组件之间的通信"><a href="#p26-组件之间的通信" class="headerlink" title="p26 组件之间的通信"></a>p26 组件之间的通信</h2><h3 id="父组件—子组件"><a href="#父组件—子组件" class="headerlink" title="父组件—子组件"></a>父组件—子组件</h3><p>父组件传递数据</p><pre><code class="html">&lt;template&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;!-- 通过v-bind给子组件传数据 --&gt;        &lt;test v-if=&quot;flag&quot; :msg=&#39;fmsg&#39;&gt;&lt;/test&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    import test from &#39;../../components/test.vue&#39;    export default &#123;        components:&#123;            test        &#125;,        data()&#123;            return&#123;                flag: true,                fmsg: &#39;儿子你好！&#39;            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><p>子组件接收数据</p><pre><code class="html">&lt;template&gt;    &lt;view id=&quot;mout&quot;&gt;        test组件，父组件传来的数据为：--- &#123;&#123;msg&#125;&#125;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&quot;test&quot;        props: [&#39;msg&#39;],//接受父组件传来的数据    &#125;&lt;/script&gt;</code></pre><h3 id="子组件—父组件"><a href="#子组件—父组件" class="headerlink" title="子组件—父组件"></a>子组件—父组件</h3><p>父组件提供一个方法用来接收子组件的数据</p><pre><code class="html">&lt;template&gt;    &lt;view class=&quot;content&quot;&gt;        &lt;!-- 将func方法传给子组件，子组件通过func方法给父组件传值 --&gt;        &lt;test v-if=&quot;flag&quot;  @func=&quot;receivedSon&quot;&gt;&lt;/test&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    import test from &#39;../../components/test.vue&#39;    export default &#123;        components:&#123;            test        &#125;        methods: &#123;            receivedSon(msg)&#123;                //接收到子组件传来的数据                console.log(msg)            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><p>子组件通过this.$emit调用，来给父组件传值</p><pre><code class="html">&lt;template&gt;    &lt;view id=&quot;mout&quot;&gt;        test组件        &lt;button type=&quot;primary&quot; @click=&quot;sendFather&quot;&gt;给父组件传数据&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&quot;test&quot;,        data() &#123;            return &#123;                num: 10            &#125;;        &#125;,        methods: &#123;            sendFather()&#123;                //通过this.$emit调用，来给父组件传值                this.$emit(&#39;func&#39;,&#39;爸爸你好，我是儿子&#39;)            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><h3 id="全局组件通信"><a href="#全局组件通信" class="headerlink" title="全局组件通信"></a>全局组件通信</h3><p><a href="https://uniapp.dcloud.io/api/window/communication.html">页面通信文档</a></p><h4 id="uni-emit-eventName-OBJECT"><a href="#uni-emit-eventName-OBJECT" class="headerlink" title="uni.$emit(eventName,OBJECT)"></a>uni.$emit(eventName,OBJECT)</h4><p>触发全局的自定义事件，附加参数都会传给监听器回调函数。</p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>eventName</td><td>String</td><td>事件名</td></tr><tr><td>OBJECT</td><td>Object</td><td>触发事件携带的附加参数</td></tr></tbody></table><h4 id="uni-on-eventName-callback"><a href="#uni-on-eventName-callback" class="headerlink" title="uni.$on(eventName,callback)"></a>uni.$on(eventName,callback)</h4><p>监听全局的自定义事件，事件由 <code>uni.$emit</code> 触发，回调函数会接收事件触发函数的传入参数。</p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>eventName</td><td>String</td><td>事件名</td></tr><tr><td>callback</td><td>Function</td><td>事件的回调函数</td></tr></tbody></table><p>【案例：a组件更新b组件的数据】</p><p>新建a组件</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        a组件&lt;button type=&quot;primary&quot; @click=&quot;updateB&quot;&gt;修改b组件的数据&lt;/button&gt;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&quot;a&quot;,        methods: &#123;            updateB()&#123;                uni.$emit(&#39;updateNum&#39;,10) //触发全局的updateNum事件            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><p>新建b组件</p><pre><code class="html">&lt;template&gt;    &lt;view&gt;        b组件的num=&#123;&#123;num&#125;&#125;    &lt;/view&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        name:&quot;b&quot;,        data() &#123;            return &#123;                num: 0            &#125;;        &#125;,        created() &#123;            uni.$on(&#39;updateNum&#39;,num =&gt;&#123; //添加全局的事件                this.num += num            &#125;)        &#125;    &#125;&lt;/script&gt;</code></pre><h2 id="p27-uni-ui扩展组件"><a href="#p27-uni-ui扩展组件" class="headerlink" title="p27 uni-ui扩展组件"></a>p27 uni-ui扩展组件</h2><p>uni-ui是DCloud提供的一个跨端ui库，它是基于vue组件的、flex布局的、无dom的<strong>跨全端ui框架</strong>。</p><p>uni-ui不包括基础组件，<strong>它是基础组件的补充</strong>。</p><p><a href="https://uniapp.dcloud.io/component/uniui/uni-ui.html">uni-ui扩展组件文档</a></p><p>使用方法，登录后下载进入到Hbuilderx即可，默认已经全局注册，无需导入。</p><p>后端项目跟着老师的视频敲就好</p>]]></content>
    
    
    <summary type="html">uni-app上手简单,可快速开发小程序、h5、安卓、ios应用。笔记根据B站【Uni-App从入门到实战-黑马程序员杭州校区出品】视频教程整理</summary>
    
    
    
    <category term="公众号和小程序" scheme="https://heliufang.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="uniapp" scheme="https://heliufang.github.io/tags/uniapp/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习笔记</title>
    <link href="https://heliufang.github.io/2022/03/27/1513842928408203264/images/"/>
    <id>https://heliufang.github.io/2022/03/27/1513842928408203264/images/</id>
    <published>2022-03-27T13:20:28.000Z</published>
    <updated>2022-12-14T14:14:31.491Z</updated>
    
    <content type="html"><![CDATA[<p>本笔记是根据尚硅谷周阳老师的springcloud视频教程整理</p><p>B站视频教程：<a href="https://www.bilibili.com/video/BV18E411x7eT?p=1">尚硅谷SpringCloud框架开发教程</a></p><h2 id="springcloud大纲"><a href="#springcloud大纲" class="headerlink" title="springcloud大纲"></a>springcloud大纲</h2><p>学习大纲如下图</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220319111107904.png" alt="image-20220319111107904"></p><h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p><strong>springboot</strong>：推荐2.x版本,不要去使用1.x版本了</p><p><strong>springboot和springcloud版本</strong>选择的对应关系如下图</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220319112819884.png" alt="image-20220319112819884"></p><p><a href="https://spring.io/projects/spring-cloud#overview">springboot和springcloud版本的对应关系</a></p><p><strong>本课程使用的各技术版本</strong></p><table><thead><tr><th>技术</th><th>版本</th></tr></thead><tbody><tr><td>cloud</td><td>Hoxton.SR1</td></tr><tr><td>boot</td><td>2.2.RELEASE</td></tr><tr><td>cloud</td><td>alibaba 2.1.0.RELEASE</td></tr><tr><td>java</td><td>java8</td></tr><tr><td>Maven</td><td>3.5以上</td></tr><tr><td>mysql</td><td>5.7以上</td></tr></tbody></table><h2 id="cloud各种组件的停更-x2F-替换"><a href="#cloud各种组件的停更-x2F-替换" class="headerlink" title="cloud各种组件的停更&#x2F;替换"></a>cloud各种组件的停更&#x2F;替换</h2><h3 id="以前"><a href="#以前" class="headerlink" title="以前"></a>以前</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220319113815361.png" alt="image-20220319113815361"></p><h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220319114738105.png" alt="image-20220319114738105"></p><h3 id="cloud的相关文档"><a href="#cloud的相关文档" class="headerlink" title="cloud的相关文档"></a>cloud的相关文档</h3><p><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/">H版英文文档</a></p><p><a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">springcloud中文文档</a></p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/">springboot英文文档</a></p><h2 id="微服务架构编码-构建"><a href="#微服务架构编码-构建" class="headerlink" title="微服务架构编码 构建"></a>微服务架构编码 构建</h2><p>约定&gt;配置&gt;编码</p><h3 id="IDEA新建project工作空间"><a href="#IDEA新建project工作空间" class="headerlink" title="IDEA新建project工作空间"></a>IDEA新建project工作空间</h3><ul><li>New Project</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220319153224412.png" alt="image-20220319153224412"></p><ul><li>聚合总父工程名字</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220319153444695.png" alt="image-20220319153444695"></p><ul><li>maven用自己本地的</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220319153603583.png" alt="image-20220319153603583"></p><ul><li>项目编码</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220319154052554.png" alt="image-20220319154052554"></p><ul><li>注解生效激活</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220319154300117.png" alt="image-20220319154300117"></p><ul><li>java版本选8</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220319154402918.png" alt="image-20220319154402918"></p><ul><li>父pom文件：<strong>dependencyManagement</strong>主要用来锁定版本号的,锁定之后,子模块就不需要写版本号了。</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;    &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;modules&gt;        &lt;module&gt;cloud-provider-payment8001&lt;/module&gt;        &lt;module&gt;cloud-api-commons&lt;/module&gt;        &lt;module&gt;cloud-consumer-order80&lt;/module&gt;    &lt;/modules&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;        &lt;junit.version&gt;4.12&lt;/junit.version&gt;        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;        &lt;lombok.version&gt;1.18.0&lt;/lombok.version&gt;        &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;        &lt;druid.version&gt;1.1.16&lt;/druid.version&gt;        &lt;!--&lt;mybatis.spring.boot.version&gt;1.3.2&lt;/mybatis.spring.boot.version&gt; --&gt;        &lt;!--我这里用的mybatis-plus --&gt;        &lt;mybatis.plus.boot.version&gt;3.5.1&lt;/mybatis.plus.boot.version&gt;    &lt;/properties&gt;    &lt;!-- 子模块继承之后，提供作用：锁定版本+子模块不用写groupId和version  --&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;!--  springboot 2.2.2    --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!--  spring cloud Hoxton.SR1   --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;Hoxton.SR1&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!--  spring cloud alibaba 2.1.0.RELEASE    --&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;                &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;druid&lt;/artifactId&gt;                &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--&lt;dependency&gt;                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt;            &lt;/dependency&gt;--&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.baomidou&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;                &lt;version&gt;$&#123;mybatis.plus.boot.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;log4j&lt;/groupId&gt;                &lt;artifactId&gt;log4j&lt;/artifactId&gt;                &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;junit&lt;/groupId&gt;                &lt;artifactId&gt;junit&lt;/artifactId&gt;                &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                &lt;artifactId&gt;lombok&lt;/artifactId&gt;                &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;                &lt;optional&gt;true&lt;/optional&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;fork&gt;true&lt;/fork&gt;                    &lt;addResources&gt;true&lt;/addResources&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><ul><li>maven中跳过单元测试</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220319155316100.png" alt="image-20220319155316100"></p><blockquote><p>父工程创建完成执行mvn:insall将父工程发布到仓库方便子工程继承</p></blockquote><h3 id="热部署的配置"><a href="#热部署的配置" class="headerlink" title="热部署的配置"></a>热部署的配置</h3><p>配置热部署之后,springboot项目可以自动的重启。配置步骤如下：</p><p>第一步：添加依赖到模块中</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><p>第二步：添加依赖到父项目中</p><pre><code class="xml">&lt;build&gt;    &lt;fileName&gt;你自己的工程名字&lt;fileName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;fork&gt;true&lt;/fork&gt;                &lt;addResources&gt;true&lt;/addResources&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>第三步：idea配置 <strong>Enabling automatic build</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324141952206.png" alt="image-20220324141952206"></p><p>第四步：idea配置<strong>Update the value of</strong></p><ul><li><p>在idea中按下： crtl+shift+alt+&#x2F;   </p></li><li><p>选择Registry</p></li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220324142204566.png" alt="image-20220324142204566"></p><ul><li>将下图的两个配置勾上</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220324142406888.png" alt="image-20220324142406888"></p><h3 id="Rest微服务工程搭建"><a href="#Rest微服务工程搭建" class="headerlink" title="Rest微服务工程搭建"></a>Rest微服务工程搭建</h3><h4 id="cloud-api-commons"><a href="#cloud-api-commons" class="headerlink" title="cloud-api-commons"></a>cloud-api-commons</h4><p>此模块为公共模块</p><ul><li>pom.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;            &lt;!--            &lt;optional&gt;true&lt;/optional&gt;--&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;            &lt;version&gt;5.1.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><ul><li>结构如图</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220322111050141.png" alt="image-20220322111050141"></p><ul><li>CommonResult类：公共的json返回结果类</li></ul><pre><code class="java">import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt; &#123;    private Integer code;    private String message;    private T data;    public CommonResult(Integer code, String message) &#123;        this(code, message, null);    &#125;&#125;</code></pre><ul><li>payment类：支付类</li></ul><pre><code class="java">import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;/** * (Payment)实体类 */@Data@AllArgsConstructor@NoArgsConstructorpublic class Payment implements Serializable &#123;    private Long id;    private String serial;&#125;</code></pre><ul><li>Order类</li></ul><pre><code class="java">import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.math.BigDecimal;@Data@AllArgsConstructor@NoArgsConstructorpublic class Order implements Serializable &#123;    private Long id;    private Long userId;    private Long productId;    private Integer count;    private BigDecimal money;    private Integer status; //订单状态：0：创建中，1：已创建&#125;</code></pre><h4 id="cloud-provider-payment8001"><a href="#cloud-provider-payment8001" class="headerlink" title="cloud-provider-payment8001"></a>cloud-provider-payment8001</h4><p> 微服务提供者-支付模块</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220319161847316.png" alt="image-20220319161847316"></p><p>完整项目结构如下</p><p>​       <img src="/2022/03/27/1513842928408203264/images/image-20220322112053163.png" alt="image-20220322112053163"></p><p> 创建完成后回到父工程查看pom文件变化</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220319163010993.png" alt="image-20220319163010993"></p><ul><li>cloud-provider-payment8001 的pom文件</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;cloud-provider-payment8001&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--引入cloud-api-commons公共依赖模块--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--热部署--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><ul><li>cloud-provider-payment8001 的application.yml文件</li></ul><pre><code class="yml">server:  port: 8001spring:  application:    name: cloud-payment-service  datasource:    username: root    password: root    url: jdbc:mysql://localhost:3306/db2020_cloud    driver-class-name: com.mysql.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource    mybatis:  mapper-locations: classpath:mapper/*.xml  type-aliases-package: com.atguigu.springcloud.entities</code></pre><ul><li>cloud-provider-payment8001 的启动类：PaymentMain8001</li></ul><pre><code class="java">import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(&quot;com.atguigu.springcloud.dao&quot;)public class PaymentMain8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PaymentMain8001.class,args);    &#125;&#125;</code></pre><ul><li>cloud-provider-payment8001 的PaymentDao类</li></ul><pre><code class="java">import com.atguigu.springcloud.entities.Payment;import com.baomidou.mybatisplus.core.mapper.BaseMapper;public interface PaymentDao extends BaseMapper&lt;Payment&gt; &#123;&#125;</code></pre><ul><li>cloud-provider-payment8001 的PaymentServiceImpl</li></ul><pre><code class="java">import com.atguigu.springcloud.service.PaymentService;import com.atguigu.springcloud.entities.Payment;import com.atguigu.springcloud.dao.PaymentDao;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * (Payment)表服务实现类 */@Servicepublic class PaymentServiceImpl implements PaymentService &#123;    @Resource    private PaymentDao paymentDao;    /**     * 通过ID查询单条数据     *     * @param id 主键     * @return 实例对象     */    @Override    public Payment queryById(Long id) &#123;        return this.paymentDao.selectById(id);    &#125;    /**     * 新增数据     *     * @param payment 实例对象     * @return 实例对象     */    @Override    public Payment insert(Payment payment) &#123;        this.paymentDao.insert(payment);        return payment;    &#125;    /**     * 修改数据     *     * @param payment 实例对象     * @return 实例对象     */    @Override    public Payment update(Payment payment) &#123;        this.paymentDao.updateById(payment);        return payment;    &#125;    /**     * 通过主键删除数据     *     * @param id 主键     * @return 是否成功     */    @Override    public boolean deleteById(Long id) &#123;        return this.paymentDao.deleteById(id) &gt; 0;    &#125;&#125;</code></pre><ul><li>cloud-provider-payment8001 的PaymentController</li></ul><pre><code class="java">import com.atguigu.springcloud.service.PaymentService;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;/** * (Payment)表控制层 */@RestController@RequestMapping(&quot;payment&quot;)public class PaymentController &#123;    /**     * 服务对象     */    @Resource    private PaymentService paymentService;    /**     * 通过主键查询单条数据     *     * @param id 主键     * @return 单条数据     */    @GetMapping(&quot;get/&#123;id&#125;&quot;)    public CommonResult&lt;Payment&gt; selectOne(@PathVariable(&quot;id&quot;) Long id) &#123;        Payment payment = this.paymentService.queryById(id);        return new CommonResult&lt;Payment&gt;(200,&quot;select success 8001 hlf2!&quot;,payment);    &#125;    @PostMapping(&quot;create&quot;)    //注意：这里千万别忘了加@RequestBody,否则RestTemplate调用之后参数处理不了    public CommonResult create(@RequestBody Payment payment) &#123;        Payment insert = this.paymentService.insert(payment);        System.out.println(insert);        System.out.println(&quot;1234567890&quot;);        return new CommonResult(200,&quot;insert success&quot; ,insert);    &#125;&#125;</code></pre><h4 id="cloud-consumer-order80"><a href="#cloud-consumer-order80" class="headerlink" title="cloud-consumer-order80"></a>cloud-consumer-order80</h4><p>订单模块，此模块会通过RestTemplate调用payment(支付模块)。这个模块的结构和支付模块的结构类似</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220322113335114.png" alt="image-20220322113335114"></p><ul><li>pom.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;cloud-consumer-order80&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--引入公共模块--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--热部署--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><ul><li>ApplicationContextConfig：RestTemplate的配置类</li></ul><pre><code class="java">import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig &#123;    @Bean    public RestTemplate getRestTemplate()&#123;        return new RestTemplate();    &#125;&#125;</code></pre><ul><li>OrderController</li></ul><pre><code class="java">import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@RestControllerpublic class OrderController &#123;    @Resource    private RestTemplate restTemplate;    public static final String PAYMENT_URL=&quot;http://localhost:8001&quot;;    @RequestMapping(&quot;/consumer/payment/create&quot;)    public CommonResult&lt;Payment&gt; create(Payment payment)&#123;        return restTemplate.postForObject(PAYMENT_URL+&quot;/payment/create&quot;,payment,CommonResult.class);    &#125;    @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)    public CommonResult&lt;Payment&gt; selectOne(@PathVariable(&quot;id&quot;) Long id) &#123;        return restTemplate.getForObject(PAYMENT_URL+&quot;/payment/get/&quot;+id,CommonResult.class);    &#125;&#125;</code></pre><ul><li>主启动类:OrderMain80</li></ul><pre><code class="java">import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(&quot;com.atguigu.springcloud.dao&quot;)public class OrderMain80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderMain80.class,args);    &#125;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一部分周阳老师暂时还没有用到微服务springcloud的组件,只是方便大家熟悉代码,为后面的学习打基础用的。</p><h2 id="Eruka"><a href="#Eruka" class="headerlink" title="Eruka"></a>Eruka</h2><p>Eruka是一个注册中心组件</p><h3 id="Eruka的基础知识"><a href="#Eruka的基础知识" class="headerlink" title="Eruka的基础知识"></a>Eruka的基础知识</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220322114806433.png" alt="image-20220322114806433"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220322114833299.png" alt="image-20220322114833299"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220322114904872.png" alt="image-20220322114904872"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220322114935615.png" alt="image-20220322114935615"></p><h3 id="构建单机Eureka"><a href="#构建单机Eureka" class="headerlink" title="构建单机Eureka"></a>构建单机Eureka</h3><h4 id="cloud-eureka-server7001"><a href="#cloud-eureka-server7001" class="headerlink" title="cloud-eureka-server7001"></a>cloud-eureka-server7001</h4><p>这个7001模块为注册中心,属于eruka的服务端模块</p><ul><li>cloud-eureka-server7001的pom.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;cloud-eureka-server7001&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><ul><li>cloud-eureka-server7001的application.yml</li></ul><pre><code class="yml">server:  port: 7001spring:  application:    name: cloud-eureka-server7001eureka:  instance:    hostname: localhost  client:    fetch-registry: false  #不注册自己    register-with-eureka: false # 不检索自己    service-url:      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/  server:    #关闭自我保护机制，保证不可用服务立即被踢出 ,默认是true开启的    enable-self-preservation: true    eviction-interval-timer-in-ms: 2000</code></pre><ul><li>EurekaMain7001.java    注意要加上**@EnableEurekaServer** 这个注解</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServer  //EurekaServer的注解public class EurekaMain7001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaMain7001.class,args);    &#125;&#125;</code></pre><h4 id="cloud-provider-payment8001-1"><a href="#cloud-provider-payment8001-1" class="headerlink" title="cloud-provider-payment8001"></a>cloud-provider-payment8001</h4><p>这个模块是eruka的客户端模块</p><ul><li>cloud-provider-payment8001的pom.xml，需要加上eruka的客户端依赖</li></ul><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>cloud-provider-payment8001的application.yml，需要加上eruka的客户端配置</li></ul><pre><code class="yml">eureka:  client:    #表示将自己注册到eureka    register-with-eureka: true    # 是否从EurekaServer抓取已有的注册信息,单节点无所谓,集群必须设置为true    fetch-registry: true    # eureka服务端的地址    service-url:      defaultZone: http://localhost:7001/eureka</code></pre><ul><li>cloud-provider-payment8001的主启动类加上**@EnableEurekaClient**注解</li></ul><h4 id="cloud-consumer-order80-1"><a href="#cloud-consumer-order80-1" class="headerlink" title="cloud-consumer-order80"></a>cloud-consumer-order80</h4><p>这个模块同样是eureka的客户端模块</p><ul><li>cloud-consumer-order80的pom.xml增加eureka的依赖</li></ul><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>cloud-consumer-order80的application.yml增加eureka的配置</li></ul><pre><code class="yml">eureka:  client:    #表示将自己注册到eureka    register-with-eureka: true    # 是否从EurekaServer抓取已有的注册信息,单节点无所谓,集群必须设置为true    fetch-registry: true    # eureka服务端的地址    service-url:      defaultZone: http://localhost:7001/eureka</code></pre><ul><li>cloud-consumer-order80的主启动类加上**@EnableEurekaClient**注解</li></ul><p>先启动eureka的服务端,再启动两个客户端,访问7001服务端可以看到注册进去的两个服务的名称。</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324152456869.png" alt="image-20220324152456869"></p><h3 id="构建Eureka服务端集群"><a href="#构建Eureka服务端集群" class="headerlink" title="构建Eureka服务端集群"></a>构建Eureka服务端集群</h3><p>eureka集群原理如下</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324153046747.png" alt="image-20220324153046747"></p><h4 id="cloud-eureka-server7002"><a href="#cloud-eureka-server7002" class="headerlink" title="cloud-eureka-server7002"></a>cloud-eureka-server7002</h4><p>这个模块也是eureka服务端，类比cloud-eureka-server7001新建cloud-eureka-server7002。但是需要做一些修改。</p><ul><li>修改映射配置</li></ul><pre><code>1.找到C:\Windows\System32\drivers\etc路径下的hosts文件,末尾添加如下：127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com2.cmd命令行刷新hosts文件ipconfig /flushdns</code></pre><ul><li>修改7001的application.yml文件</li></ul><p>eureka服务端的集群配置特点：<strong>相互注册</strong>、<strong>相互守望</strong>。</p><pre><code class="yml">server:  port: 7001spring:  application:    name: cloud-eureka-service #修改1：7001和7002这里改成一致eureka:  instance:    # eureka服务端的实例名称    hostname: eureka7001.com #修改2  client:    # false表示不向注册中心注册自己    register-with-eureka: false    # false表示自己端就是注册中心,我的职责就是维护服务实例,并不需要检索服务    fetch-registry: false    service-url:      # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址      defaultZone: http://eureka7002.com:7002/eureka/ #修改3 相互注册，相互守望</code></pre><ul><li>修改7002的application.yml文件</li></ul><pre><code class="yml">server:  port: 7002spring:  application:    name: cloud-eureka-serviceeureka:  instance:    # eureka服务端的实例名称    hostname: eureka7002.com  client:    # false表示不向注册中心注册自己    register-with-eureka: false    # false表示自己端就是注册中心,我的职责就是维护服务实例,并不需要检索服务    fetch-registry: false    service-url:      # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址      defaultZone: http://eureka7001.com:7001/eureka/</code></pre><p>启动7001和7002两个eureka服务后发现：相互注册、相互守望</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324161530766.png" alt="image-20220324161530766"></p><h4 id="cloud-provider-payment8001-2"><a href="#cloud-provider-payment8001-2" class="headerlink" title="cloud-provider-payment8001"></a>cloud-provider-payment8001</h4><p>将这个服务注册到Eureka的集群，修改8001的<strong>application.yml</strong>文件</p><pre><code class="yml">eureka:  client:    #表示将自己注册到eureka    register-with-eureka: true    # 是否从EurekaServer抓取已有的注册信息,单节点无所谓,集群必须设置为true    fetch-registry: true    # eureka服务端的地址    service-url:      #defaultZone: http://localhost:7001/eureka # 单机版      #主要就是修改下面这行      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka </code></pre><blockquote><p>然后测试，就会发现8001同时注册到7001和7002两个eureka的服务端了。</p></blockquote><h4 id="cloud-consumer-order80-2"><a href="#cloud-consumer-order80-2" class="headerlink" title="cloud-consumer-order80"></a>cloud-consumer-order80</h4><p>将这个服务注册到Eureka的集群，修改80的<strong>application.yml</strong>文件，和上面的cloud-provider-payment8001做同样的修改</p><pre><code class="yml">#主要就是修改下面这行      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</code></pre><blockquote><p>然后测试，就会发现7001和7002这两个eureka的服务端中同时注册了80和8001两个服务</p></blockquote><h3 id="构建Eureka客户端集群"><a href="#构建Eureka客户端集群" class="headerlink" title="构建Eureka客户端集群"></a>构建Eureka客户端集群</h3><h4 id="cloud-provider-payment8002"><a href="#cloud-provider-payment8002" class="headerlink" title="cloud-provider-payment8002"></a>cloud-provider-payment8002</h4><p>参考cloud-provider-payment8001构建cloud-provider-payment8002</p><h4 id="修改8001和8002的controller"><a href="#修改8001和8002的controller" class="headerlink" title="修改8001和8002的controller"></a>修改8001和8002的controller</h4><p>目的是测试订单服务调用的到底是哪个端口的支付服务<img src="/2022/03/27/1513842928408203264/images/image-20220324165830811.png" alt="image-20220324165830811"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324165846068.png" alt="image-20220324165846068"></p><p>启动测试发现同一个服务名下注册了两个端口的支付服务</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324170940264.png" alt="image-20220324170940264"></p><blockquote><p>测试<a href="http://localhost/consumer/payment/get/31%E5%8F%91%E7%8E%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%B0%B8%E8%BF%9C%E6%98%AF8001%E7%9A%84%E9%82%A3%E4%B8%AA%E5%BE%AE%E6%9C%8D%E5%8A%A1,%E6%98%BE%E7%84%B6%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%82">http://localhost/consumer/payment/get/31发现调用的永远是8001的那个微服务,显然没有实现负载均衡。</a></p></blockquote><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>实现订单微服务均衡的调用支付的微服务。也就是8001和8002轮流调用</p><ul><li>订单controller中的地址不能写死</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220324172027959.png" alt="image-20220324172027959"></p><ul><li>ApplicationContextConfig中开启RestTemplate的负载均衡，**@LoadBalanced**注解</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220324172101334.png" alt="image-20220324172101334"></p><blockquote><p>测试结果：8001&#x2F;8002端口交替出现</p></blockquote><h3 id="actuator微服务信息完善"><a href="#actuator微服务信息完善" class="headerlink" title="actuator微服务信息完善"></a>actuator微服务信息完善</h3><p>非必须,只不过完善后看起来会更加的清晰。在eureka中做如下修改即可</p><pre><code class="yml">instance:    instance-id: payment8001 #修改名称    prefer-ip-address: true  #显示ip</code></pre><h4 id="主机名称-服务名称修改"><a href="#主机名称-服务名称修改" class="headerlink" title="主机名称:服务名称修改"></a>主机名称:服务名称修改</h4><p>当前问题</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324172830327.png" alt="image-20220324172830327"></p><p>修改application.yml即可</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324172856819.png" alt="image-20220324172856819"></p><p>修改之后的效果</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324173012503.png" alt="image-20220324173012503"></p><h4 id="访问信息有IP信息提示"><a href="#访问信息有IP信息提示" class="headerlink" title="访问信息有IP信息提示"></a>访问信息有IP信息提示</h4><p>当前问题：没有IP提示</p><p>修改application.yml即可</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324173146576.png" alt="image-20220324173146576"></p><p>修改后的效果</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324173215157.png" alt="image-20220324173215157"></p><h3 id="服务发现Discovery"><a href="#服务发现Discovery" class="headerlink" title="服务发现Discovery"></a>服务发现Discovery</h3><p>对于注册eureka里面的微服务,可以通过服务发现来获得该服务的信息</p><h4 id="cloud-provider-payment8001-3"><a href="#cloud-provider-payment8001-3" class="headerlink" title="cloud-provider-payment8001"></a>cloud-provider-payment8001</h4><ul><li>启动类加上注解：**@EnableDiscoveryClient**  (不加这个注解发现不了！！！)</li><li>修改PaymentController,加入下面的代码</li></ul><pre><code class="java">@Resourceprivate DiscoveryClient discoveryClient;//服务发现,获取服务信息@GetMapping(&quot;discovery&quot;)public Object discovery() &#123;    //获取所有微服务    List&lt;String&gt; services = discoveryClient.getServices();    services.forEach(service-&gt;&#123;        System.out.println(&quot;----service：&quot;+service);    &#125;);    //获取一个微服务下的全部实例    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);    for (ServiceInstance instance : instances) &#123;        System.out.println(instance.getServiceId()+&quot;\t&quot; + instance.getHost()+&quot;\t&quot;+ instance.getPort()+&quot;\t&quot;+instance.getUri());;    &#125;    return this.discoveryClient;&#125;</code></pre><p><img src="/2022/03/27/1513842928408203264/images/image-20220324211316405.png" alt="image-20220324211316405"></p><h3 id="eureka自我保护"><a href="#eureka自我保护" class="headerlink" title="eureka自我保护"></a>eureka自我保护</h3><ul><li>故障现象</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220324203712327.png" alt="image-20220324203712327"></p><ul><li>导致原因：某时刻 一个微服务不可用了,Eureka不会立刻清理,依旧会对该服务的信息进行保存。</li></ul><p>属于CAP里面的AP分支。</p><h4 id="禁用自我保护"><a href="#禁用自我保护" class="headerlink" title="禁用自我保护"></a>禁用自我保护</h4><p>在eurekaServer和eurekaClient分别进行配置</p><h5 id="注册中心eurekaServer端7001"><a href="#注册中心eurekaServer端7001" class="headerlink" title="注册中心eurekaServer端7001"></a>注册中心eurekaServer端7001</h5><p>出产默认,自我保护机制是开启的 ,可以在配置文件中关闭：</p><pre><code class="yml">eureka.server.enable-self-preservation: false</code></pre><p>关闭效果</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220324204326254.png" alt="image-20220324204326254"></p><h5 id="生产者客户端eurekaClient端8001"><a href="#生产者客户端eurekaClient端8001" class="headerlink" title="生产者客户端eurekaClient端8001"></a>生产者客户端eurekaClient端8001</h5><pre><code class="yml">#Eureka客户端向服务端发送心跳的时间间隔,单位为秒(默认是30秒)lease-renewal-interval-in-seconds: 30lease-expiration-duration-in-seconds: 90</code></pre><p><img src="/2022/03/27/1513842928408203264/images/image-20220324205202954.png" alt="image-20220324205202954"></p><h2 id="Zookeeper服务注册与发现"><a href="#Zookeeper服务注册与发现" class="headerlink" title="Zookeeper服务注册与发现"></a>Zookeeper服务注册与发现</h2><p>略(后面再补)</p><h2 id="Consul服务注册与发现"><a href="#Consul服务注册与发现" class="headerlink" title="Consul服务注册与发现"></a>Consul服务注册与发现</h2><p>官网：<a href="https://www.consul.io/intro/index.html">https://www.consul.io/intro/index.html</a></p><h3 id="consul简介"><a href="#consul简介" class="headerlink" title="consul简介"></a>consul简介</h3><p>是什么</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220325102353499.png" alt="image-20220325102353499"></p><p>能干嘛</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220325102501076.png" alt="image-20220325102501076"></p><h3 id="consul的安装"><a href="#consul的安装" class="headerlink" title="consul的安装"></a>consul的安装</h3><p>下载：<a href="https://www.consul.io/downloads.html">https://www.consul.io/downloads.html</a></p><p>中文文档：<a href="https://www.springcloud.cc/spring-cloud-consul.html">https://www.springcloud.cc/spring-cloud-consul.html</a></p><blockquote><p>ps：下载很慢，可以安装迅雷之后用迅雷加速下载</p></blockquote><ul><li><p>下载完毕之后的压缩包中有一个<code>consul.exe</code>文件</p></li><li><p>将<code>consul.exe</code>文件的路径配置到环境变量的<code>path</code>中即可,例如下面</p></li></ul><pre><code>D:\springcloud_soft\consul_1.11.4</code></pre><p><img src="/2022/03/27/1513842928408203264/images/image-20220325103604551.png" alt="image-20220325103604551"></p><ul><li>配好之后cmd窗口中输入下面的指令,看到consul的版本号，表示安装成功</li></ul><pre><code>consul --version</code></pre><h3 id="consul的启动和访问"><a href="#consul的启动和访问" class="headerlink" title="consul的启动和访问"></a>consul的启动和访问</h3><ul><li>在cmd窗口中运行启动命令 （使用开发模式启动）</li></ul><pre><code>consul agent -dev</code></pre><ul><li>浏览器中输入网址：<a href="http://localhost:8500/">http://localhost:8500/</a>  就可以进入到consul的界面了</li></ul><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>新建<code>cloud-providerconsul-payment8006</code>工程</p><ul><li>cloud-providerconsul-payment8006的pom.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;cloud-providerconsul-payment8006&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;!--SpringCloud consul-server--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--引入公共依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><ul><li>application.yml</li></ul><pre><code class="yml">server:  # consul服务端口  port: 8006spring:  application:    name: cloud-provider-payment  cloud:    consul:      # consul注册中心地址      host: localhost      port: 8500      discovery:        hostname: 127.0.0.1        service-name: $&#123;spring.application.name&#125;        prefer-ip-address: true</code></pre><ul><li>主启动类PaymentMain8006,主要添加<code>@EnableDiscoveryClient</code>注解</li></ul><pre><code class="java">@SpringBootApplication@EnableDiscoveryClientpublic class PaymentMain8006 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PaymentMain8006.class, args);    &#125;&#125;</code></pre><ul><li>controller</li></ul><pre><code class="java">@RestControllerpublic class PaymentController &#123;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    @RequestMapping(value = &quot;payment/consul&quot;)    public String paymentConsul() &#123;        return &quot;SpringCloud with consul:&quot; + serverPort + &quot;\t&quot; + UUID.randomUUID().toString();    &#125;&#125;</code></pre><h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p>新建cloud-consumerconsul-order80模块</p><ul><li>cloud-consumerconsul-order80的pom.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;cloud-consumerconsul-order80&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;!--SpringCloud consul-server--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--引入公共依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><ul><li>cloud-consumerconsul-order80的application.yml</li></ul><pre><code class="yml">server:  port: 80spring:  application:    name: cloud-consumer-order  cloud:    consul:      # consul注册中心地址      host: localhost      port: 8500      discovery:        hostname: 127.0.0.1        service-name: $&#123;spring.application.name&#125;        prefer-ip-address: true</code></pre><ul><li>ApplicationContextConfig,主要是为了RestTemplate的远程调用</li></ul><pre><code class="java">import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig &#123;    @Bean    @LoadBalanced //开启RestTemplate的负载均衡    public RestTemplate getRestTemplate()&#123;        return new RestTemplate();    &#125;&#125;</code></pre><ul><li>OrderController</li></ul><pre><code class="java">import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@RestControllerpublic class OrderController &#123;    @Resource    private RestTemplate restTemplate;    //注意下面这个地址的对应    public static final String PAYMENT_URL=&quot;http://cloud-provider-payment&quot;;    @GetMapping(&quot;/consumer/payment/consul&quot;)    public String consul() &#123;        return restTemplate.getForObject(PAYMENT_URL+&quot;/payment/consul&quot;,String.class);    &#125;&#125;</code></pre><ul><li>主启动类添加<code>@EnableDiscoveryClient</code>注解</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>测试consul注册中心中是否将服务提供者和消费者注册进去<img src="/2022/03/27/1513842928408203264/images/image-20220325160430199.png" alt="image-20220325160430199"></li><li>测试服务消费者能否成功调用服务提供者</li></ul><p>测试url：<a href="http://localhost/consumer/payment/consul">http://localhost/consumer/payment/consul</a></p><p>结果成功调用</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220325160529522.png" alt="image-20220325160529522"></p><h3 id="三个注册中心异同点"><a href="#三个注册中心异同点" class="headerlink" title="三个注册中心异同点"></a>三个注册中心异同点</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220325160638135.png" alt="image-20220325160638135"></p><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li>CAP概念</li></ul><pre><code>C: Consistency(强一致性)A: Availability(可用性)P: Parttition tolerance(分区容错性)</code></pre><ul><li><p>分区容错性要保证,所以要么是CP,要么是AP</p></li><li><p>CAP理论关注粒度是否是数据,而不是整体系统设计的策略</p></li><li><p>经典CAP图</p></li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220325160945521.png" alt="image-20220325160945521"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220325160653008.png" alt="image-20220325160653008"></p><h4 id="AP-eureka"><a href="#AP-eureka" class="headerlink" title="AP(eureka)"></a>AP(eureka)</h4><p><img src="/2022/03/27/1513842928408203264/images/image-20220325161050875.png" alt="image-20220325161050875"></p><h4 id="CP-Zookeeper-x2F-Consul"><a href="#CP-Zookeeper-x2F-Consul" class="headerlink" title="CP(Zookeeper&#x2F;Consul)"></a>CP(Zookeeper&#x2F;Consul)</h4><p>CP架构:当网络分区出现后,为了保证一致性,就必须拒绝请求,否则无法保证一致性<br>结论:违背了可用性A的要求,只满足一致性和分区容错,即CP</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220325161332377.png" alt="image-20220325161332377"></p><h2 id="Ribbon负载均衡服务调用"><a href="#Ribbon负载均衡服务调用" class="headerlink" title="Ribbon负载均衡服务调用"></a>Ribbon负载均衡服务调用</h2><blockquote><p>和feign的功能类似主要是用来<strong>负载均衡</strong>和<strong>远程调用</strong>,Ribbon目前也进入维护模式</p></blockquote><p><img src="/2022/03/27/1513842928408203264/images/image-20220403093022665.png" alt="image-20220403093022665"></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220403092611726.png" alt="image-20220403092611726"></p><p>官网资料: <a href="https://github.com/Netflix/ribbon/wiki/Getting-Started">https://github.com/Netflix/ribbon/wiki/Getting-Started</a></p><p>一句话：<strong>负载均衡+RestTemplate调用</strong>(前面我们讲解过了80通过轮询负载访问8001&#x2F;8002)</p><h3 id="Ribbon负载均衡演示"><a href="#Ribbon负载均衡演示" class="headerlink" title="Ribbon负载均衡演示"></a>Ribbon负载均衡演示</h3><p>架构说明</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403093511666.png" alt="image-20220403093511666"></p><p><strong>总结</strong>：</p><p>1.<strong>Ribbon</strong>其实就是一个<strong>软负载均衡</strong>的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。</p><p>2.之前没有引入Ribbon依赖也可以使用是因为,eureka的client中默认引入了Ribbon的依赖</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403093931357.png" alt="image-20220403093931357"></p><p>3.二说RestTemplate的使用</p><p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate官网</a></p><ul><li>getForObject方法&#x2F;getForEntity方法</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220403094225269.png" alt="image-20220403094225269"></p><ul><li>postForObject&#x2F;postForEntity</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220403094408540.png" alt="image-20220403094408540"></p><pre><code>RestTemplate的:    xxxForObject()方法,返回的是响应体中的数据    xxxForEntity()方法.返回的是entity对象,这个对象不仅仅包含响应体数据,还包含响应体信息(状态码等)        xxx 可以是get也可以使post</code></pre><h3 id="Ribbon核心组件IRule"><a href="#Ribbon核心组件IRule" class="headerlink" title="Ribbon核心组件IRule"></a>Ribbon核心组件IRule</h3><p><strong>IRule接口,Riboon使用该接口,根据特定算法从所有服务中,选择一个服务。Rule接口有7个实现类,每个实现类代表一个负载均衡算法</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403095315885.png" alt="image-20220403095315885"></p><h4 id="将轮询调用改为随机调用"><a href="#将轮询调用改为随机调用" class="headerlink" title="将轮询调用改为随机调用"></a>将轮询调用改为随机调用</h4><p>此处要注意一个细节：新建的rule配置类<strong>不能放在主启动类所在的包及子包下</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403095905874.png" alt="image-20220403095905874"></p><p>修改cloud-consumer-order80，具体步骤如下：</p><p>第一步：新建package以及新建MySelfRule规则类</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403100515702.png" alt="image-20220403100515702"></p><p>注意：新建的rule配置类<strong>不能放在主启动类所在的包及子包下</strong></p><p>MySelfRule内容如下</p><pre><code class="java">import com.netflix.loadbalancer.IRule;import com.netflix.loadbalancer.RandomRule;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MySelfRule &#123;    @Bean    public IRule myRule()&#123;        return new RandomRule();//定义为随机    &#125;&#125;</code></pre><p>第二步：主启动类添加**@RibbonClient**注解</p><pre><code class="java">@SpringBootApplication@MapperScan(&quot;com.atguigu.springcloud.dao&quot;)@EnableEurekaClient@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = MySelfRule.class)//表示,访问CLOUD_pAYMENT_SERVICE的服务时,使用我们自定义的负载均衡算法public class OrderMain80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderMain80.class,args);    &#125;&#125;</code></pre><p>第三步：测试  <a href="http://localhost/consumer/payment/get/31">http://localhost/consumer/payment/get/31</a></p><h3 id="Ribbon负载均衡算法"><a href="#Ribbon负载均衡算法" class="headerlink" title="Ribbon负载均衡算法"></a>Ribbon负载均衡算法</h3><p>略</p><h2 id="OpenFeign服务接口调用"><a href="#OpenFeign服务接口调用" class="headerlink" title="OpenFeign服务接口调用"></a>OpenFeign服务接口调用</h2><p>Feign是一个声明式的web服务客户端，让编写web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可（一个接口 + 一个注解）</p><p><a href="https://github.com/spring-cloud/spring-cloud-openfeign">GitHub</a></p><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220403102948332.png" alt="image-20220403102948332"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403103319851.png" alt="image-20220403103319851"></p><p>Feign和OpenFeign两者区别</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403103435984.png" alt="image-20220403103435984"></p><h3 id="OpenFeign使用步骤"><a href="#OpenFeign使用步骤" class="headerlink" title="OpenFeign使用步骤"></a>OpenFeign使用步骤</h3><p>1.主启动加<code>@EnableFeignClients</code> 注解</p><p>2.新建接口+接口上加<code>@FeignClient</code>注解</p><p>具体案例如下：</p><ul><li><p>新建cloud-consumer-feign-order80模块</p></li><li><p>cloud-consumer-feign-order80的pom.xml</p></li></ul><pre><code class="xml">&lt;!--openfeign--&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><ul><li>cloud-consumer-feign-order80的application.yml</li></ul><pre><code class="yml">server:  port: 80spring:  application:    name: cloud-order-serviceeureka:  client:    register-with-eureka: true    service-url:      defaultZone: http://eureka7001.com:7001/eureka</code></pre><ul><li>cloud-consumer-feign-order80的主启动</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClients  //表示开启Feignpublic class OrderFeignMain80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderFeignMain80.class,args);    &#125;&#125;</code></pre><ul><li>cloud-consumer-feign-order80的PaymentFeignService</li></ul><pre><code class="java">import com.atguigu.springcloud.entities.CommonResult;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@Component@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;) //表示Feign调用哪个微服务public interface PaymentFeignService &#123;    @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)    public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);&#125;</code></pre><ul><li>cloud-consumer-feign-order80的OrderFeignController</li></ul><pre><code class="java">@RestControllerpublic class OrderFeignController &#123;    @Resource    private PaymentFeignService paymentFeignService;    @GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123;        return paymentFeignService.getPaymentById(id);    &#125;&#125;</code></pre><ul><li>测试</li></ul><pre><code>先启动eureka7001再启动2个微服务8001/8002启动OpenFeign启动测试：http://localhost/consumer/payment/get/31测试发现：自带负载均衡(轮询)</code></pre><ul><li>小总结</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220403110312477.png" alt="image-20220403110312477"></p><h3 id="OpenFeign超时控制"><a href="#OpenFeign超时控制" class="headerlink" title="OpenFeign超时控制"></a>OpenFeign超时控制</h3><p>OpenFeign默认等待一秒钟，超过后报错.</p><p>OpenFeign默认支持Ribbon</p><p>因为OpenFeign的底层是ribbon进行负载均衡,所以它的超时时间是由ribbon控制。</p><p>YML文件里开启OpenFeign客户端的超时控制</p><pre><code class="yml">ribbon:  ReadTimeout:  5000  ConnectTimeout: 5000</code></pre><p>案例如下：超时设置，故意设置超时演示出错情况</p><ul><li>服务提供方8001故意写暂停程序</li></ul><pre><code class="java">@GetMapping(value = &quot;/payment/feign/timeout&quot;)public String paymentFeignTimeout()&#123;    try &#123; TimeUnit.SECONDS.sleep(3); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;    return serverPort;&#125;</code></pre><ul><li>服务消费方80添加超时方法PaymentFeignService</li></ul><pre><code class="java">@GetMapping(value = &quot;/payment/feign/timeout&quot;)public String paymentFeignTimeout();</code></pre><ul><li>服务消费方80添加超时方法OrderFeignController</li></ul><pre><code class="java">@GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;)public String paymentFeignTimeout()&#123;   return paymentFeignService.paymentFeignTimeout();&#125;</code></pre><ul><li>测试: <a href="http://localhost/consumer/payment/feign/timeout">http://localhost/consumer/payment/feign/timeout</a></li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220403114909935.png" alt="image-20220403114909935"></p><p>解决超时错误： YML文件里需要开启OpenFeign客户端超时控制</p><pre><code class="yml">ribbon:  ReadTimeout:  5000  ConnectTimeout: 5000</code></pre><h3 id="OpenFeign日志打印功能"><a href="#OpenFeign日志打印功能" class="headerlink" title="OpenFeign日志打印功能"></a>OpenFeign日志打印功能</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220403115138866.png" alt="image-20220403115138866"></p><p>Feign日志级别有如下</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403115159325.png" alt="image-20220403115159325"></p><p>配置步骤如下：</p><p>第一步：配置日志bean</p><pre><code class="java">package com.atguigu.springcloud.config;import feign.Logger;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FeignConfig &#123;    @Bean    Logger.Level feignLoggerLevel()&#123;        return Logger.Level.FULL;    &#125;&#125;</code></pre><p>第二步：YML文件里需要开启日志的Feign客户端</p><pre><code class="yml">logging:  level:    com.atguigu.springcloud.service.PaymentFeignService: debug</code></pre><p>第三步：控制台就可以看到日志了</p><h2 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220403163238944.png" alt="image-20220403163238944"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403163258545.png" alt="image-20220403163258545"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403163320203.png" alt="image-20220403163320203"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403163344596.png" alt="image-20220403163344596"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403163550382.png" alt="image-20220403163550382"></p><p><strong>Hystrix能干嘛</strong></p><pre><code>服务降级服务熔断接近实时的监控。。。</code></pre><p><a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">Hystrix官方文档</a></p><p><a href="https://github.com/Netflix/Hystrix">Hystrix官宣，停更进维</a></p><h3 id="Hystrix重要概念"><a href="#Hystrix重要概念" class="headerlink" title="Hystrix重要概念"></a>Hystrix重要概念</h3><p>a.服务降级: 服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示，fallback</p><p>哪些情况会触发降级?</p><pre><code>程序运行异常超时服务熔断触发服务降级线程池/信号量打满也会导致服务降级</code></pre><p>b.服务熔断: 类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示</p><pre><code>就是保险丝:      服务的降级-&gt;进而熔断-&gt;恢复调用链路</code></pre><p>c.服务限流: 秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p><p>降级和熔断的区别与联系：</p><pre><code>服务降级有很多种降级方式！如开关降级、限流降级、熔断降级!服务熔断属于降级方式的一种！</code></pre><h3 id="hystrix案例基础"><a href="#hystrix案例基础" class="headerlink" title="hystrix案例基础"></a>hystrix案例基础</h3><h4 id="构建基础模块"><a href="#构建基础模块" class="headerlink" title="构建基础模块"></a>构建基础模块</h4><ul><li><p>新建cloud-provider-hystrix-payment8001模块</p></li><li><p>cloud-provider-hystrix-payment8001的pom.xml</p></li></ul><pre><code class="xml">&lt;dependencies&gt;        &lt;!--新增hystrix--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;        &lt;/dependency&gt;            &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><ul><li>cloud-provider-hystrix-payment8001的application.yml</li></ul><pre><code class="yml">server:  port: 8001eureka:  client:    register-with-eureka: true        fetch-registry: true       service-url:      defaultZone: http://eureka7001.com:7001/eureka/spring:  application:    name: cloud-provider-hystrix-payment</code></pre><ul><li>cloud-provider-hystrix-payment8001的service</li></ul><pre><code class="java">import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;@Servicepublic class PaymentService &#123;    //成功    public String paymentInfo_OK(Integer id)&#123;        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_OK,id：  &quot;+id+&quot;\t&quot;+&quot;哈哈哈&quot;  ;    &#125;    //失败    public String paymentInfo_TimeOut(Integer id)&#123;        int timeNumber = 3;        try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_TimeOut,id：  &quot;+id+&quot;\t&quot;+&quot;呜呜呜&quot;+&quot; 耗时(秒)&quot;+timeNumber;    &#125;&#125;</code></pre><ul><li>cloud-provider-hystrix-payment8001的controller</li></ul><pre><code class="java">import com.atguigu.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController@Slf4jpublic class PaymentController &#123;    @Resource    private PaymentService paymentService;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    //ok    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;        String result = paymentService.paymentInfo_OK(id);        log.info(&quot;*******result:&quot;+result);        return result;    &#125;    //3秒    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;        String result = paymentService.paymentInfo_TimeOut(id);        log.info(&quot;*******result:&quot;+result);        return result;    &#125;&#125;</code></pre><p>测试基础模块</p><ul><li>正常访问： <a href="http://localhost:8001/payment/hystrix/ok/31">http://localhost:8001/payment/hystrix/ok/31</a></li><li>每次调用耗费3秒钟：<a href="http://localhost:8001/payment/hystrix/timeout/31">http://localhost:8001/payment/hystrix/timeout/31</a></li></ul><p>以上述为根基模块，从正确-&gt;错误-&gt;降级熔断-&gt;恢复</p><h4 id="高并发测试"><a href="#高并发测试" class="headerlink" title="高并发测试"></a>高并发测试</h4><p>下载压力测试工具<a href="https://jmeter.apache.org/download_jmeter.cgi">JMeter</a></p><blockquote><p>下载慢的话，可以用迅雷</p></blockquote><p>JMeter解压后运行bat文件即可</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403172357178.png" alt="image-20220403172357178"></p><p>运行之后默认是英文的,可以设置为中文</p><p>参考： <a href="https://jingyan.baidu.com/article/b0b63dbf25733b4a4830708f.html">设置JMeter界面为中文</a></p><p>第一步：右键测试，添加，线程，线程组</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403173607152.png" alt="image-20220403173607152"></p><p>第二步：填写好线程组相关信息，这里就2000吧怕电脑带不动，视频里是20000</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403173647183.png" alt="image-20220403173647183"></p><p>第三步：创建http请求</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403173747234.png" alt="image-20220403173747234"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403173814986.png" alt="image-20220403173814986"></p><p>然后启动就可以进行压力测试了</p><pre><code>此时使用压测工具,并发20000个请求,请求会延迟的那个方法,压测中,发现,另外一个方法并没有被压测,但是我们访问它时,却需要等待这就是因为被压测的方法它占用了服务器大部分资源,导致其他请求也变慢了tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。</code></pre><p>Jmeter压测结论: 上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖死</p><p>看热闹不嫌弃事大，80新建加入</p><ul><li>新建cloud-consumer-feign-hystrix-order80模块</li><li>cloud-consumer-feign-hystrix-order80的pom.xml</li></ul><pre><code class="xml"> &lt;dependencies&gt;        &lt;!--新增hystrix--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><ul><li>cloud-consumer-feign-hystrix-order80的application.yml</li></ul><pre><code class="yml">cloud-consumer-feign-hystrix-order80的application.ymlserver:  port: 80eureka:  client:    register-with-eureka: true        fetch-registry: true      service-url:      defaultZone: http://eureka7001.com:7001/eureka/spring:  application:    name: cloud-provider-hystrix-order</code></pre><ul><li>cloud-consumer-feign-hystrix-order80的主启动</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClientspublic class OrderHystrixMain80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderHystrixMain80.class,args);    &#125;&#125;</code></pre><ul><li>cloud-consumer-feign-hystrix-order80的service</li></ul><pre><code class="java">import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@Component@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)public interface PaymentHystrixService &#123;    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);&#125;</code></pre><ul><li>cloud-consumer-feign-hystrix-order80的controller</li></ul><pre><code class="java">import com.atguigu.springcloud.service.PaymentHystrixService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController@Slf4jpublic class OrderHystrixController &#123;    @Resource    private PaymentHystrixService paymentHystrixService;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;        String result = paymentHystrixService.paymentInfo_OK(id);        log.info(&quot;*******result:&quot;+result);        return result;    &#125;    //feigh默认是1s得做出响应,这个远程调用肯定会报超时错误    @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;        String result = paymentHystrixService.paymentInfo_TimeOut(id);        log.info(&quot;*******result:&quot;+result);        return result;    &#125;&#125;</code></pre><p>正常测试：<a href="http://localhost/consumer/payment/hystrix/ok/31">http://localhost/consumer/payment/hystrix/ok/31</a></p><p>高并发测试</p><pre><code>2W个线程压8001消费端80微服务再去访问正常的OK微服务8001地址http://localhost/consumer/payment/hystrix/timeout/31要么转圈圈等待要么消费端报超时错误</code></pre><h4 id="故障现象和导致原因"><a href="#故障现象和导致原因" class="headerlink" title="故障现象和导致原因"></a>故障现象和导致原因</h4><p>现象：80此时调用8001，客户端访问响应缓慢，转圈圈</p><p>原因：8001同一层次的其他接口服务被困死，因为tomcat线程里面的工作线程已经被挤占完毕</p><h4 id="上诉结论"><a href="#上诉结论" class="headerlink" title="上诉结论"></a>上诉结论</h4><p>正因为有上述故障或不佳表现，才有我们的降级&#x2F;容错&#x2F;限流等技术诞生</p><h4 id="如何解决？解决的要求"><a href="#如何解决？解决的要求" class="headerlink" title="如何解决？解决的要求"></a>如何解决？解决的要求</h4><p><img src="/2022/03/27/1513842928408203264/images/image-20220403181146372.png" alt="image-20220403181146372"></p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>&lt;1&gt; <strong>cloud-provider-hystrix-payment8001</strong> 的降级配置(生产者降级)</p><p>先从自身找问题设置<strong>自身</strong>调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback。</p><ul><li>主启动类激活：添加新注解**@EnableCircuitBreaker**</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClient@EnableCircuitBreaker  //激活hystrixpublic class PaymentHystrixMain8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PaymentHystrixMain8001.class,args);    &#125;&#125;</code></pre><ul><li>业务类配置：一旦调用服务方法失败并抛出了错误信息后，会自动调用**@HystrixCommand**标注好的fallbackMethod调用类中的指定方法</li></ul><p>注意：配置过的热部署方式对java代码的改动明显，但<strong>对@HystrixCommand内属性的修改建议重启微服务</strong></p><pre><code class="java">import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;@Servicepublic class PaymentService &#123;    //成功    public String paymentInfo_OK(Integer id)&#123;        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_OK,id：  &quot;+id+&quot;\t&quot;+&quot;哈哈哈&quot;  ;    &#125;    //失败    @HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;,commandProperties = &#123;            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;)  //3秒钟以内就是正常的业务逻辑    &#125;)    public String paymentInfo_TimeOut(Integer id)&#123;        //int age = 10/0;        try &#123; TimeUnit.SECONDS.sleep(id); &#125;catch (InterruptedException e) &#123;e.printStackTrace();&#125;        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_TimeOut,id：  &quot;+id+&quot;\t&quot;+&quot;呜呜呜&quot;+&quot; 耗时(秒)&quot;;    &#125;    //兜底方法    public String paymentInfo_TimeOutHandler(Integer id)&#123;        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   系统繁忙或报错, 请稍候再试  ,id：  &quot;+id+&quot;\t&quot;+&quot;哭了哇呜&quot;;    &#125;&#125;</code></pre><p>测试（注意：这里目前只是测试payment这个服务）</p><p>我这里是否超时，可以通过传参来控制更加方便！</p><pre><code>http://localhost:8001/payment/hystrix/timeout/2   //不报错 3秒以内http://localhost:8001/payment/hystrix/timeout/5   //报错   超过3秒</code></pre><p>&lt;2&gt; <strong>cloud-consumer-feign-hystrix-order80</strong>的降级配置（消费端降级）</p><p>一般服务降级,都是放在客户端&#x2F;消费端(order模块)</p><ul><li>cloud-consumer-feign-hystrix-order80的application.yml</li></ul><p>老师是配置下面的，但是有问题，会一直走fallback</p><pre><code class="yml">feign:  hystrix:    enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。</code></pre><p>还要增加ribbon的配置</p><pre><code class="yml">feign:  hystrix:    enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。## 巨坑只配上面的会一直走fallbackribbon:  ReadTimeout:  6000  ConnectTimeout: 6000hystrix:  command:    default:      execution:        isolation:          thread:            timeoutInMilliseconds: 3000</code></pre><ul><li>cloud-consumer-feign-hystrix-order80的主启动类添加**@EnableHystrix**注解</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.hystrix.EnableHystrix;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClients@EnableHystrix //消费端开启Hystrixpublic class OrderHystrixMain80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderHystrixMain80.class,args);    &#125;&#125;</code></pre><ul><li>cloud-consumer-feign-hystrix-order80的controller</li></ul><pre><code class="java">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)    @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1500&quot;)  //1.5秒钟以内就是正常的业务逻辑    &#125;)    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;        String result = paymentHystrixService.paymentInfo_TimeOut(id);        return result;    &#125;    //兜底方法    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123;        return &quot;我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)&quot;;    &#125;</code></pre><p>测试：</p><pre><code>http://localhost/consumer/payment/hystrix/timeout/1  正常，不走fallbackhttp://localhost/consumer/payment/hystrix/timeout/5  超时，走fallback</code></pre><h4 id="代码膨胀问题解决"><a href="#代码膨胀问题解决" class="headerlink" title="代码膨胀问题解决"></a>代码膨胀问题解决</h4><p>每个业务方法对应一个兜底的方法，代码膨胀。应该<strong>统一的和自定义的分开</strong></p><p>解决方案：  @DefaultProperties(defaultFallback&#x3D;””) 注解</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403230331413.png" alt="image-20220403230331413"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220403230236695.png" alt="image-20220403230236695"></p><p>修改cloud-consumer-feign-hystrix-order80的controller </p><pre><code class="java">package com.atguigu.springcloud.controller;import com.atguigu.springcloud.service.PaymentHystrixService;import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController@Slf4j@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)public class OrderHystrixController &#123;    @Resource    private PaymentHystrixService paymentHystrixService;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;        String result = paymentHystrixService.paymentInfo_OK(id);        log.info(&quot;*******result:&quot;+result);        return result;    &#125;    @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)    /*@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1500&quot;)  //1.5秒钟以内就是正常的业务逻辑    &#125;)*/    @HystrixCommand //这种没有指明的就会用全局fallback    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;        String result = paymentHystrixService.paymentInfo_TimeOut(id);        return result;    &#125;    //兜底方法    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123;        return &quot;我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)&quot;;    &#125;    /**     * 全局fallback     *     * @return     */    public String payment_Global_FallbackMethod() &#123;        return &quot;Global异常处理信息,请稍后重试.o(╥﹏╥)o&quot;;    &#125;&#125;</code></pre><p>测试</p><pre><code>http://localhost/consumer/payment/hystrix/timeout/1   正常http://localhost/consumer/payment/hystrix/timeout/3   超时，走全局fallback</code></pre><h4 id="代码耦合度的问题"><a href="#代码耦合度的问题" class="headerlink" title="代码耦合度的问题"></a>代码耦合度的问题</h4><p>服务降级,客户端去调用服务端,碰上服务端宕机或关闭</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220404160740103.png" alt="image-20220404160740103"></p><p>本次案例服务降级处理是在客户端80实现完成,与服务端8001没有关系  只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦。</p><blockquote><p> 也就是说只修改cloud-consumer-feign-hystrix-order80模块即可</p></blockquote><ul><li>PaymentHystrixService接口是远程调用pay模块的,我们这里创建一个类实现PaymentHystrixService接口,在实现类中统一处理异常</li></ul><pre><code class="java">package com.atguigu.springcloud.service;import org.springframework.stereotype.Service;@Servicepublic class PaymentFallbackService implements  PaymentHystrixService&#123;    //这个类来实现fallback    @Override    public String paymentInfo_OK(Integer id) &#123;        return &quot;实现类PaymentFallbackService  paymentInfo_OK&quot;;    &#125;    @Override    public String paymentInfo_TimeOut(Integer id) &#123;        return &quot;实现类PaymentFallbackService  paymentInfo_TimeOut&quot;;    &#125;&#125;</code></pre><ul><li>让PayService的实现类生效</li></ul><pre><code class="java">@Component@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = PaymentFallbackService.class) //就是在这里fallbackpublic interface PaymentHystrixService &#123;    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);&#125;</code></pre><p>测试</p><pre><code>http://localhost/consumer/payment/hystrix/timeout/3 走PaymentFallbackService里的fallbackhttp://localhost/consumer/payment/hystrix/timeout/1 正常返回</code></pre><p><strong>这样虽然解决了代码耦合度问题,但是又出现了过多重复代码的问题,每个方法都有一个降级方法</strong></p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>概念</p><ul><li>断路器：一句话就是家里的保险丝</li><li>熔断</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220404163210814.png" alt="image-20220404163210814"></p><p>修改cloud-provider-hystrix-payment8001</p><ul><li>cloud-provider-hystrix-payment8001的PaymentService新建下面方法</li></ul><pre><code class="java">//---服务的熔断    @HystrixCommand(            fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;), //是否开启断路器            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;), //请求次数            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), //时间窗口期            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),//失败率达到多少后跳闸    &#125;    )    //这里属性整体意思是:10秒之内(窗口,会移动),如果并发==超过==10个,或者10个并发中,失败了6个,就开启熔断器    public String paymentCircuitBreaker(Integer id) &#123;        if (id&lt;0) &#123;            throw new RuntimeException(&quot;******id不能为负数&quot;);        &#125;        //IdUtil是Hutool包下的类,这个Hutool就是整合了常用方法        String simpleUUID = IdUtil.simpleUUID();        return Thread.currentThread().getName()+&quot;\t&quot; + &quot;成功调用，流水号是：&quot; + simpleUUID;    &#125;    public String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) Integer id) &#123;        return &quot;id不能为负数，请稍后再试............&quot;+id;    &#125;</code></pre><ul><li>cloud-provider-hystrix-payment8001的PaymentController新建方法</li></ul><pre><code class="java"> //测试熔断    @GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)    public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id) &#123;        String result = paymentService.paymentCircuitBreaker(id);        log.info(&quot;*******result:&quot;+result);        return result;    &#125;</code></pre><p>测试</p><pre><code>http://localhost:8001/payment/circuit/31   正确http://localhost:8001/payment/circuit/-31  错误多次访问,并且错误率超过60%,此时服务熔断,此时即使访问正确的也会报错.但是,当过了几秒后,又恢复了.因为在10秒窗口期内,它自己会尝试接收部分请求,发现服务可以正常调用,慢慢的当错误率低于60%,取消熔断.</code></pre><p>》Hystrix所有可配置的属性</p><p>**全部在这个方法中记录,以成员变量的形式记录,**以后需要什么属性,查看这个类即可</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220404165558262.png" alt="image-20220404165558262"></p><h4 id="原理-x2F-总结"><a href="#原理-x2F-总结" class="headerlink" title="原理&#x2F;总结"></a>原理&#x2F;总结</h4><ul><li>大神结论</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220404165630986.png" alt="image-20220404165630986"></p><ul><li>熔断类型</li></ul><pre><code>熔断打开: 请求不再调用当前服务,内部设置一般为MTTR(平均故障处理时间),当打开长达导所设时钟则进入半熔断状态熔断关闭: 熔断关闭后不会对服务进行熔断熔断半开: 部分请求根据规则调用当前服务,如果请求成功且符合规则则认为当前服务恢复正常,关闭熔断</code></pre><ul><li>熔断流程(其实就是大神结论 的图)</li></ul><pre><code>断路器的打开和关闭,是按照一下5步决定的      1,并发此时是否达到我们指定的阈值      2,错误百分比,比如我们配置了60%,那么如果并发请求中,10次有6次是失败的,就开启断路器      3,上面的条件符合,断路器改变状态为open(开启)      4,这个服务的断路器开启,所有请求无法访问      5,在我们的时间窗口期,期间,尝试让一些请求通过(半开状态),如果请求还是失败,证明断路器还是开启状态,服务没有恢复,如果请求成功了,证明服务已经恢复,断路器状态变为close关闭状态</code></pre><ul><li>断路器开启或者关闭的条件</li></ul><pre><code>1.当满足一定的阈值的时候(默认10秒钟超过20个请求次数)2.当失败率达到一定的时候(默认10秒内超过50%的请求次数)3.到达以上阈值,断路器将会开启4.当开启的时候,所有请求都不会进行转发5.一段时间之后(默认5秒),这个时候断路器是半开状态,会让其他一个请求进行转发. 如果成功,断路器会关闭,若失败,继续开启.重复4和5</code></pre><ul><li>断路器打开之后</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220404170333355.png" alt="image-20220404170333355"></p><h3 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h3><p>后面高级篇讲解alibaba的Sentinel说明</p><h3 id="hystrix工作流程"><a href="#hystrix工作流程" class="headerlink" title="hystrix工作流程"></a>hystrix工作流程</h3><pre><code>1请求进来,首先查询缓存,如果缓存有,直接返回      如果缓存没有,---&gt;22,查看断路器是否开启,如果开启的,Hystrix直接将请求转发到降级返回,然后返回      如果断路器是关闭的,                判断线程池等资源是否已经满了,如果已经满了                      也会走降级方法              如果资源没有满,判断我们使用的什么类型的Hystrix,决定调用构造方法还是run方法        然后处理请求        然后Hystrix将本次请求的结果信息汇报给断路器,因为断路器此时可能是开启的                      (因为断路器开启也是可以接收请求的)                断路器收到信息,判断是否符合开启或关闭断路器的条件,                如果本次请求处理失败,又会进入降级方法        如果处理成功,判断处理是否超时,如果超时了,也进入降级方法        最后,没有超时,则本次请求处理成功,将结果返回给controller</code></pre><p><img src="/2022/03/27/1513842928408203264/images/image-20220404170605986.png" alt="image-20220404170605986"></p><h3 id="服务监控hystrixDashboard"><a href="#服务监控hystrixDashboard" class="headerlink" title="服务监控hystrixDashboard"></a>服务监控hystrixDashboard</h3><p>概述</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220404170708635.png" alt="image-20220404170708635"></p><p>第一步：新建cloud-consumer-hystrix-dashboard9001 监控服务</p><ul><li>cloud-consumer-hystrix-dashboard9001的pom.xml</li></ul><pre><code class="xml">&lt;dependencies&gt;        &lt;!--hystrix dashboard--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--监控--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--热部署--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><ul><li>cloud-consumer-hystrix-dashboard9001的application.yml</li></ul><pre><code class="yml">server:  port: 9001</code></pre><ul><li>cloud-consumer-hystrix-dashboard9001的主启动</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;@SpringBootApplication@EnableHystrixDashboard   //加上这个注解public class HystrixDashboardMain9001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(HystrixDashboardMain9001.class);    &#125;&#125;</code></pre><ul><li>所有Provider微服务提供类(8001&#x2F;8002&#x2F;8003)都需要监控依赖部署</li></ul><pre><code class="xml"> &lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>第二步：修改cloud-provider-hystrix-payment8001的主启动</p><pre><code class="java">import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.context.annotation.Bean;@SpringBootApplication@EnableEurekaClient@EnableCircuitBreaker  //激活hystrixpublic class PaymentHystrixMain8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PaymentHystrixMain8001.class,args);    &#125;    /**     * 此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑     * ServletRegistrationBean因为springboot的默认路径不是/hystrix.stream     * 只要在自己的项目里配置下面的Servlet就可以了     * @return     */    @Bean    public ServletRegistrationBean getServlet() &#123;        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);        registrationBean.setLoadOnStartup(1);        registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);        return registrationBean;    &#125;&#125;</code></pre><p>监控测试</p><pre><code>1.启动eureka2.启动cloud-provider-hystrix-payment80013.启动cloud-consumer-hystrix-dashboard9001访问地址：http://localhost:9001/hystrix填写地址：http://localhost:8001/hystrix.stream</code></pre><p>在web界面,指定9001要监控8001</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220404173133297.png" alt="image-20220404173133297"></p><p>就可以看到监控的信息了</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220404173209440.png" alt="image-20220404173209440"></p><p>监控说明：7色+1圈+1线</p><p>整图说明</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220404173414768.png" alt="image-20220404173414768"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220404173349194.png" alt="image-20220404173349194"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220404173440126.png" alt="image-20220404173440126"></p><h2 id="Gateway新一代网关"><a href="#Gateway新一代网关" class="headerlink" title="Gateway新一代网关"></a>Gateway新一代网关</h2><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">Gateway官网</a></p><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405102713103.png" alt="image-20220405102713103"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405103022721.png" alt="image-20220405103022721"></p><p><strong>gateway之所以性能好,因为底层使用WebFlux,而webFlux底层使用netty通信(NIO)</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405102822498.png" alt="image-20220405102822498"></p><h3 id="GateWay的特性"><a href="#GateWay的特性" class="headerlink" title="GateWay的特性"></a>GateWay的特性</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405103236241.png" alt="image-20220405103236241"></p><h3 id="GateWay与zuul的区别"><a href="#GateWay与zuul的区别" class="headerlink" title="GateWay与zuul的区别"></a>GateWay与zuul的区别</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405103409891.png" alt="image-20220405103409891"></p><h3 id="Zuul1-x模型"><a href="#Zuul1-x模型" class="headerlink" title="Zuul1.x模型"></a>Zuul1.x模型</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405103533745.png" alt="image-20220405103533745"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405103553800.png" alt="image-20220405103553800"></p><h3 id="GateWay三大核心概念"><a href="#GateWay三大核心概念" class="headerlink" title="GateWay三大核心概念"></a>GateWay三大核心概念</h3><ul><li><p>Route(路由) ：路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由（<strong>就是根据某些规则,将请求发送到指定服务上</strong>）</p></li><li><p>Predicate(断言)： 参考的是Java8的java.util.function.Predicate。开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由</p></li><li><p>Filter(过滤)： 指的是Spring框架中GatewayFilter的实例,使用<strong>过滤器</strong>,可以在请求被路由前或者之后对请求进行修改.</p></li></ul><h3 id="Gateway工作流程"><a href="#Gateway工作流程" class="headerlink" title="Gateway工作流程"></a>Gateway工作流程</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405104258807.png" alt="image-20220405104258807"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405104309788.png" alt="image-20220405104309788"></p><p>核心逻辑：<strong>路由转发+执行过滤器链</strong></p><h3 id="入门配置"><a href="#入门配置" class="headerlink" title="入门配置"></a>入门配置</h3><p>需求：目前不想暴露8001端口，希望在8001外面套一层9527，通过访问9527来间接的访问8001.</p><p>新建Module     cloud-gateway-gateway9527</p><ul><li>cloud-gateway-gateway9527的pom.xml</li></ul><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--引入公共依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><ul><li>cloud-gateway-gateway9527的application.yml</li></ul><pre><code class="yml">server:  port: 9527spring:  application:    name: cloud-gateway  cloud:    gateway:      routes:        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名          uri: http://localhost:8001   #匹配后提供服务的路由地址          predicates:            - Path=/payment/get/**   #断言,路径相匹配的进行路由        - id: payment_routh2          uri: http://localhost:8001          predicates:            - Path=/payment/lb/**   #断言,路径相匹配的进行路由eureka:  instance:    hostname: cloud-gateway-service  client:    service-url:      register-with-eureka: true      fetch-registry: true      defaultZone: http://eureka7001.com:7001/eureka</code></pre><ul><li>cloud-gateway-gateway9527的主启动类</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class GateWayMain9527 &#123;    public static void main(String[] args) &#123;        SpringApplication.run( GateWayMain9527.class,args);    &#125;&#125;</code></pre><p>测试:启动7001、8001、9527</p><p>访问<a href="http://localhost:9527/payment/get/31%E5%92%8C%E8%AE%BF%E9%97%AEhttp://localhost:8001/payment/get/31%E6%95%88%E6%9E%9C%E4%B8%80%E6%A0%B7">http://localhost:9527/payment/get/31和访问http://localhost:8001/payment/get/31效果一样</a></p><p>于是就可以验证网关的效果了</p><p>访问说明</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405110939286.png" alt="image-20220405110939286"></p><p>Gateway网关路由有两种配置方式</p><p>第一种：在配置文件yml中配置（上面的操作便是）</p><p>第二种：代码中注入RouteLocator的Bean(不推荐)</p><pre><code class="java">import org.springframework.cloud.gateway.route.RouteLocator;import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class GateWayConfig &#123;    @Bean    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) &#123;        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();        routes.route(&quot;path_rote_atguigu&quot;, r -&gt; r.path(&quot;/guonei&quot;).uri(&quot;http://news.baidu.com/guonei&quot;)).build();        return routes.build();    &#125;&#125;</code></pre><p><img src="/2022/03/27/1513842928408203264/images/image-20220405111446368.png" alt="image-20220405111446368"></p><h3 id="通过微服务名实现动态路由"><a href="#通过微服务名实现动态路由" class="headerlink" title="通过微服务名实现动态路由"></a>通过微服务名实现动态路由</h3><p>上面的配置虽然实现了网关,但是是在配置文件中写死了要路由的地址</p><p>现在需要修改,不指定地址,而是根据<strong>微服务名字进行路由</strong>,我们可以在注册中心获取某组微服务的地址</p><p>修改网关yml的两个地方即可</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405112636796.png" alt="image-20220405112636796"></p><p>完整网关yml配置</p><pre><code class="yml">server:  port: 9527spring:  application:    name: cloud-gateway  cloud:    gateway:      discovery:        locator:          enabled: true      routes:        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名          #uri: http://localhost:8001   #匹配后提供服务的路由地址          uri: lb://cloud-payment-service #需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。          predicates:            - Path=/payment/get/**   #断言,路径相匹配的进行路由        - id: payment_routh2          #uri: http://localhost:8001          uri: lb://cloud-payment-service          predicates:            - Path=/payment/lb/**   #断言,路径相匹配的进行路由eureka:  instance:    hostname: cloud-gateway-service  client:    service-url:      register-with-eureka: true      fetch-registry: true      defaultZone: http://eureka7001.com:7001/eureka</code></pre><blockquote><p>测试</p></blockquote><p>启动7001 、8001、8002、9527</p><p>测试地址：<a href="http://localhost:9527/payment/get/31">http://localhost:9527/payment/get/31</a>  发现8001和8002来回调用实现了负载和动态路由</p><h3 id="Predicate的使用"><a href="#Predicate的使用" class="headerlink" title="Predicate的使用"></a>Predicate的使用</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405115859709.png" alt="image-20220405115859709"></p><p>之前在配置文件中配置了断言</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405115941620.png" alt="image-20220405115941620"></p><p><strong>这个断言表示,如果外部访问路径是指定路径,就路由到指定微服务上</strong></p><p>启动9527可以看到,这里有一个<code>Path</code>,这个是断言的一种,<code>断言的类型</code></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405120021877.png" alt="image-20220405120021877"></p><ul><li>After:    可以指定,只有在指定时间后,才可以路由到指定微服务</li></ul><pre><code>before:  与after类似,他说在指定时间之前的才可以访问between: 需要指定两个时间,在他们之间的时间才可以访问（两个时间用逗号隔开）</code></pre><p>下面配置一个After作为例子</p><p>9527的yml新加After的配置</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405121529030.png" alt="image-20220405121529030"></p><p>那么这个时间怎么得出来呢,可以通过下面的代码</p><pre><code class="java">public class TestDate &#123;    public static void main(String[] args) &#123;        ZonedDateTime zonedDateTime = ZonedDateTime.now();        System.out.println(zonedDateTime);    &#125;&#125;</code></pre><p>这里表示,只有在<code>2022年的4月5的12点5分5秒之后</code>访问才可以路由,在此之前的访问,都会报404</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405121444653.png" alt="image-20220405121444653"></p><ul><li>Cookie:  只有包含某些指定Cookie(key,value),的请求才可以路由</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220405122108341.png" alt="image-20220405122108341"></p><ul><li>Header:  只有包含指定请求头的请求,才可以路由</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220405122216820.png" alt="image-20220405122216820"></p><p>测试</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405122236209.png" alt="image-20220405122236209"></p><ul><li><p>Host:只有指定主机的才可以访问,</p><p>比如我们当前的网站的域名是<a href="http://www.aa.com/">www.aa.com</a>  </p><p>那么这里就可以设置,只有用户是<a href="http://www.aa.com的请求,才进行路由/">www.aa.com的请求,才进行路由</a></p><p>在application.yml配置</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405122447170.png" alt="image-20220405122447170"></p></li><li><p>Method:  只有指定请求才可以路由,比如get请求…</p></li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220405122603016.png" alt="image-20220405122603016"></p><ul><li>Path: 只有访问指定路径,才进行路由。比如访问,&#x2F;abc才路由</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220405122659793.png" alt="image-20220405122659793"></p><ul><li>Query: 必须带有请求参数才可以访问</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220405122753973.png" alt="image-20220405122753973"></p><h3 id="Filter的使用"><a href="#Filter的使用" class="headerlink" title="Filter的使用"></a>Filter的使用</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405113408653.png" alt="image-20220405113408653"></p><h4 id="Spring-Cloud-Gateway的Filter"><a href="#Spring-Cloud-Gateway的Filter" class="headerlink" title="Spring Cloud Gateway的Filter"></a>Spring Cloud Gateway的Filter</h4><ul><li>生命周期(类比servlet的Filter)</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220405113529335.png" alt="image-20220405113529335"></p><ul><li>种类</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220405113611266.png" alt="image-20220405113611266"></p><p>GateWayFilter,单一的过滤器。<strong>与断言类似,比如闲置,请求头,只有特定的请求头才放行,反之就过滤</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405114055228.png" alt="image-20220405114055228"></p><ul><li>自定义全局GlobalFilter</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220405114732641.png" alt="image-20220405114732641"></p><p>在cloud-gateway-gateway9527模块中新建filter包，并且新建MyLogGateWayFilter类</p><pre><code class="java">package com.atguigu.springcloud.filter;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.Ordered;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;import java.util.Date;@Component@Slf4jpublic class MyLogGateWayFilter implements GlobalFilter,Ordered &#123;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        log.info(&quot;*********come in MyLogGateWayFilter: &quot;+new Date());        //获取到请求参数的uname        String uname = exchange.getRequest().getQueryParams().getFirst(&quot;uname&quot;);        //如果uname为空就直接过滤，不走路由        if(StringUtils.isEmpty(uname))&#123;            log.info(&quot;*****用户名为Null 非法用户,(┬＿┬)&quot;);            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);//给人家一个回应            return exchange.getResponse().setComplete();        &#125;        //uname不为空就走下一个路由        return chain.filter(exchange);    &#125;    @Override    public int getOrder() &#123;        return 0;    &#125;&#125;</code></pre><blockquote><p> 测试</p></blockquote><p>启动 7001 、8001、9527</p><pre><code>http://localhost:9527/payment/get/31?uname=1    带uname参数  访问正常http://localhost:9527/payment/get/31            不带uname参数 访问不了</code></pre><h2 id="Config分布式配置中心"><a href="#Config分布式配置中心" class="headerlink" title="Config分布式配置中心"></a>Config分布式配置中心</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>微服务面临的问题</p><pre><code>可以看到,每个微服务都需要一个配置文件,并且,如果有几个微服务都需要连接数据库那么就需要配4次数据库相关配置,并且当数据库发生改动,那么需要同时修改4个微服务的配置文件才可以</code></pre><p>所以有了springconfig配置中心</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405163736356.png" alt="image-20220405163736356"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405163800691.png" alt="image-20220405163800691"></p><blockquote><p>作用</p></blockquote><p><img src="/2022/03/27/1513842928408203264/images/image-20220405163917302.png" alt="image-20220405163917302"></p><h3 id="创建配置中心服务端"><a href="#创建配置中心服务端" class="headerlink" title="创建配置中心服务端"></a>创建配置中心服务端</h3><p>第一步：新建gitee仓库,提交相关文件</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405170143355.png" alt="image-20220405170143355"></p><p><code>config-dev.yml</code>内容(随便写点都行,主要用来区分)  prod和test的yml和下面的类似</p><pre><code class="yml">config:  info: I am test,version=1</code></pre><p>第二步：新建cloud-config-3344模块</p><ul><li>cloud-config-3344 的pom.xml</li></ul><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><ul><li>cloud-config-3344 的application.yml</li></ul><pre><code class="yml">server:  port: 3344spring:  application:    name: cloud-config-center  cloud:    config:      server:        git:          uri: https://gitee.com/heliufang/springcloud-config.git # git地址          search-paths:            - springcloud-config #git路径      label: master #git分支eureka:  client:    service-url:      defaultZone:  http://localhost:7001/eureka</code></pre><ul><li>cloud-config-3344 的主启动类</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;@SpringBootApplication@EnableConfigServer //开启配置中心服务public class ConfigCenterMain3344 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ConfigCenterMain3344 .class,args);    &#125;&#125;</code></pre><ul><li>配置windows的hosts</li></ul><pre><code>127.0.0.1 config-3344.com</code></pre><p><img src="/2022/03/27/1513842928408203264/images/image-20220405172153643.png" alt="image-20220405172153643"></p><ul><li>测试</li></ul><pre><code>启动7001启动3344访问：http://config-3344.com:3344/master/config-test.yml可以获取到git上的配置信息表示配置成功！</code></pre><h4 id="读取配置文件的规则"><a href="#读取配置文件的规则" class="headerlink" title="读取配置文件的规则"></a>读取配置文件的规则</h4><p>第一种（推荐这种）</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405172901762.png" alt="image-20220405172901762"></p><p>第二种</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405172954026.png" alt="image-20220405172954026"></p><p><strong>这里默认会读取master分支,因为我们配置文件中配置了</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405173027659.png" alt="image-20220405173027659"></p><p>第三种：注意这个方式读取到的配置是&#x3D;&#x3D;json格式&#x3D;&#x3D;的</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405173118387.png" alt="image-20220405173118387"></p><p>重要配置细节总结</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220405172656195.png" alt="image-20220405172656195"></p><h3 id="创建配置中心客户端"><a href="#创建配置中心客户端" class="headerlink" title="创建配置中心客户端"></a>创建配置中心客户端</h3><p>新建cloud-config-client-3355模块</p><ul><li>cloud-config-client-3355的pom.xml</li></ul><pre><code class="xml">&lt;dependencies&gt;        &lt;!-- 注意下面这个依赖,否则启动不了 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><ul><li>cloud-config-client-3355的   <code>bootstrap.yml</code></li></ul><pre><code class="yml">server:  port: 3355spring:  application:    name: config-client  cloud:    config:      label: master # 分支名称      name: config # 配置文件名称      profile: dev # 读取后缀名称    三个综合就会读取master分支上的config-dev.yml配置文件      uri: http://localhost:3344 # 配置中心地址 地址要写对否则启动不了eureka:  client:    service-url:      defaultZone: http://eureka7001.com:7001/eureka</code></pre><p><img src="/2022/03/27/1513842928408203264/images/image-20220406140617135.png" alt="image-20220406140617135"></p><ul><li>cloud-config-client-3355的  主启动类</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class ConfigClientMain3355 &#123;    public static void main(String[] args) &#123;        SpringApplication.run( ConfigClientMain3355.class,args);    &#125;&#125;</code></pre><ul><li>cloud-config-client-3355的  controller</li></ul><pre><code class="java">@RestControllerpublic class ConfigClientController &#123;    @Value(&quot;$&#123;config.info&#125;&quot;)    private String configInfo;    @GetMapping(&quot;/configInfo&quot;)    public String getConfigInfo()&#123;        return configInfo;    &#125;&#125;</code></pre><ul><li>测试</li></ul><pre><code>启动：7001、3344、3355直接通过配置中心访问git上面的信息：  http://config-3344.com:3344/master/config-test.yml3355来通过3344来访问git上面的信息： http://localhost:3355/configInfo</code></pre><p>测试结论：成功实现了客户端3355访问SpringCloud Config3344通过git获取配置信息</p><h3 id="Config客户端之动态刷新"><a href="#Config客户端之动态刷新" class="headerlink" title="Config客户端之动态刷新"></a>Config客户端之动态刷新</h3><p>Linux运维修改git上的配置文件内容做调整</p><p>刷新3344，发现ConfigServer配置中心立刻响应</p><p>刷新3355，发现ConfigServer客户端没有任何响应</p><p>3355没有变化除非自己重启或者重新加载</p><p>难道每次运维修改配置文件，客户端都需要重启？？噩梦</p><ul><li>cloud-config-client-3355的yml增加配置</li></ul><pre><code class="yml"># 配置动态刷新management:  endpoints:    web:      exposure:        include: &quot;*&quot;</code></pre><ul><li>cloud-config-client-3355的pom.xml中要加入下面依赖</li></ul><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>cloud-config-client-3355的<code>ConfigClientController</code>加上<code>@RefreshScope</code>注解</li></ul><pre><code class="java">import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RefreshScope //开启刷新public class ConfigClientController &#123;    @Value(&quot;$&#123;config.info&#125;&quot;)    private String configInfo;    @GetMapping(&quot;/configInfo&quot;)    public String getConfigInfo()&#123;        return configInfo;    &#125;&#125;</code></pre><p>测试</p><pre><code>启动7001、3344、3355http://config-3344.com:3344/master/config-dev.yml   okhttp://localhost:3355/configInfo  git上提交修改后还是没有刷新？？需要发送一个post请求： curl -X POST &quot;http://localhost:3355/actuator/refresh&quot;此时再测试  http://localhost:3355/configInfo 发现刷新成功了</code></pre><p>具体流程就是:</p><p>​            我们启动好服务后</p><p>​            运维人员,修改了配置文件,然后发送一个post请求通知3355</p><p>​            3355就可以获取最新配置文件</p><p><strong>问题:</strong></p><p>​        如果有多个客户端怎么办(3355,3356,3357…..)</p><p>​                        虽然可以使用shell脚本,循环刷新</p><p>​        但是,可不可以使用广播,一次通知??</p><p>​                    这些springconfig做不到,需要使用springcloud Bus消息总线</p><h2 id="Bus-消息总线"><a href="#Bus-消息总线" class="headerlink" title="Bus 消息总线"></a>Bus 消息总线</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220406162546409.png" alt="image-20220406162546409"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406162610509.png" alt="image-20220406162610509"></p><p>注意：上面的两图片,就代表两种广播方式（推荐第二种）</p><p>​            图1:        <strong>它是Bus直接通知给其中一个客户端,由这个客户端开始蔓延,传播给其他所有客户端</strong></p><p>​            图2:        它<strong>是通知给配置中心的服务端,有服务端广播给所有客户端</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406162646126.png" alt="image-20220406162646126"></p><h3 id="RabbitMQ环境配置"><a href="#RabbitMQ环境配置" class="headerlink" title="RabbitMQ环境配置"></a>RabbitMQ环境配置</h3><p>参考：<a href="https://www.cnblogs.com/y-web/p/13692626.html">RabbitMQ安装</a></p><p>访问：<a href="http://localhost:15672/">http://localhost:15672/</a></p><p>账号密码都是guest</p><h3 id="动态刷新之全局广播"><a href="#动态刷新之全局广播" class="headerlink" title="动态刷新之全局广播"></a>动态刷新之全局广播</h3><p>必须先具备良好的RabbitMQ环境</p><p>演示广播效果，增加复杂度，再以3355为模板再制作一个3366</p><p>&lt;1&gt;给cloud-config-center-3344配置中心服务端添加消息总线支持</p><ul><li>cloud-config-center-3344的pom增加下面 依赖 amqp</li></ul><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>cloud-config-center-3344的yml增加下面的配置</li></ul><pre><code class="yml">rabbitmq:    host: localhost    port: 5672    username: guest    password: guestmanagement:  endpoints:    web:      exposure:        include: &#39;bus-refresh&#39;</code></pre><p>&lt;2&gt;给cloud-config-client-3355客户端添加消息总线支持</p><ul><li>cloud-config-client-3355客户端的pom 增加amqp</li></ul><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>cloud-config-client-3355客户端的yml 添加rabbitmq的配置</li></ul><pre><code class="yml">rabbitmq:    host: localhost    port: 5672    username: guest    password: guest</code></pre><p>&lt;3&gt;给cloud-config-client-3366客户端添加消息总线支持  参考上面的3355</p><p><strong>测试</strong></p><p>启动7001,3344,3355,3366</p><p>此时修改git上的配置文件</p><p>此时只需要刷新3344,即可让3355,3366动态获取最新的配置文件</p><pre><code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh&quot;http://localhost:3355/configInfohttp://localhost:3366/configInfo</code></pre><p>其原理就是:<strong>所有客户端都监听了一个rabbitMq的topic,我们将信息放入这个topic,所有客户端都可以送到,从而实时更新</strong></p><h3 id="动态刷新之定点通知"><a href="#动态刷新之定点通知" class="headerlink" title="动态刷新之定点通知"></a>动态刷新之定点通知</h3><ol><li><p>就是只通知部分服务,比如只通知3355,不通知3366</p></li><li><p>公式：<a href="http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}">http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}</a></p></li><li><p>&#x2F;bus&#x2F;refresh请求不再发送到具体的服务实例上，而是发给config server并通过destination参数类指定需要更新配置的服务或实例</p></li></ol><p><img src="/2022/03/27/1513842928408203264/images/image-20220406172021082.png" alt="image-20220406172021082"></p><pre><code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh/config-client:3355&quot;</code></pre><h2 id="Stream消息驱动"><a href="#Stream消息驱动" class="headerlink" title="Stream消息驱动"></a>Stream消息驱动</h2><p>现在一个很项目可能分为三部分:<br>            前端—&gt;后端—-&gt;大数据<br>            而后端开发使用消息中间件,可能会使用RabbitMq<br>            而大数据开发,一般都是使用Kafka,<br>            那么一个项目中有多个消息中间件,对于程序员,因为人员都不友好</p><p>而Spring Cloud Stream就类似jpa,屏蔽底层消息中间件的差异,程序员主要操作Spring Cloud Stream即可</p><p>​            不需要管底层是kafka还是rabbitMq</p><h2 id="Sleuth分布式请求链路追踪"><a href="#Sleuth分布式请求链路追踪" class="headerlink" title="Sleuth分布式请求链路追踪"></a>Sleuth分布式请求链路追踪</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220406173528868.png" alt="image-20220406173528868"></p><p>Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406180455437.png" alt="image-20220406180455437"></p><p><strong>可以看到,类似链表的形式</strong></p><h3 id="搭建链路监控"><a href="#搭建链路监控" class="headerlink" title="搭建链路监控"></a>搭建链路监控</h3><h4 id="安装zipkin"><a href="#安装zipkin" class="headerlink" title="安装zipkin"></a>安装zipkin</h4><p>下载： <a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/</a></p><p><strong>运行jar包</strong></p><p>​            java -jar xxxx.jar</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406180253904.png" alt="image-20220406180253904"></p><p><strong>然后就可以访问web界面,  默认zipkin监听的端口是9411</strong></p><p>​            localhost:9411&#x2F;zipkin&#x2F;</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406180341322.png" alt="image-20220406180341322"></p><h4 id="使用sleuth"><a href="#使用sleuth" class="headerlink" title="使用sleuth"></a>使用sleuth</h4><p>不需要额外创建项目,使用之前的8001和order的80即可</p><p>&lt;1&gt;修改cloud-provider-payment8001模块</p><ul><li>cloud-provider-payment8001模块pom</li></ul><pre><code class="xml">&lt;!--包含了sleuth+zipkin--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><ul><li>cloud-provider-payment8001模块yml 添加下面的配置</li></ul><pre><code class="yml">zipkin:    base-url: http://localhost:9411 #指定zipkin地址  sleuth:    sampler:      probability: 1 # 采样率介于0-1之间，1表示全部采集</code></pre><p><img src="/2022/03/27/1513842928408203264/images/image-20220406182402336.png" alt="image-20220406182402336"></p><p>&lt;2&gt;修改cloud-consumer-order80模块</p><p>和上面的&lt;1&gt;一样</p><p>&lt;3&gt;测试</p><p>启动7001.8001,80,9411</p><p>先访问：<a href="http://localhost/consumer/payment/get/31">http://localhost/consumer/payment/get/31</a>  调用一次</p><p>然后在zipkin中就可以看到相关信息了</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406182618713.png" alt="image-20220406182618713"></p><h2 id="Spring-Cloud-Alibaba入门简介"><a href="#Spring-Cloud-Alibaba入门简介" class="headerlink" title="Spring Cloud Alibaba入门简介"></a>Spring Cloud Alibaba入门简介</h2><p>之所以有Spring Cloud Alibaba,是因为Spring Cloud Netflix项目进入维护模式</p><p>​        <strong>也就是,就不是不更新了,不会开发新组件了</strong></p><p>​        <strong>所以,某些组件都有代替版了,比如Ribbon由Loadbalancer代替,等等</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406205040717.png" alt="image-20220406205040717"></p><p><a href="https://spring.io/projects/spring-cloud-alibaba#overview">Spring Cloud Alibaba官网</a></p><p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">Spring Cloud Alibaba官网中文</a></p><p>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p><p>Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。</p><p>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p><p>Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</p><p>Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p><p>Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</p><p>Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</p><h2 id="Nacos服务注册和配置中心"><a href="#Nacos服务注册和配置中心" class="headerlink" title="Nacos服务注册和配置中心"></a>Nacos服务注册和配置中心</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&lt;1&gt;前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service</p><p>&lt;2&gt;一个更易于构建云原生应用的动态服务发现，配置管理和服务管理中心</p><p>&lt;3&gt;Nacos就是注册中心+配置中心的组合，  Nacos &#x3D; Eureka+Config+Bus</p><p>&lt;4&gt;替代Eureka做服务注册中心,替代Config做服务配置中心</p><p>下载nacos</p><p><a href="https://nacos.io/zh-cn/index.html">https://nacos.io/zh-cn/index.html</a></p><h3 id="安装运行Nacos"><a href="#安装运行Nacos" class="headerlink" title="安装运行Nacos"></a>安装运行Nacos</h3><p>本地Java8+Maven环境已经OK</p><p>先从官网下载Nacos：<a href="https://github.com/alibaba/nacos/releases/tag/1.1.4">https://github.com/alibaba/nacos/releases/tag/1.1.4</a></p><p>解压安装包，直接运行bin目录下的startup.cmd</p><p>命令运行成功后直接访问<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> （默认账号密码都是nacos）</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406211600106.png" alt="image-20220406211600106"></p><h3 id="Nacos作为注册中心"><a href="#Nacos作为注册中心" class="headerlink" title="Nacos作为注册中心"></a>Nacos作为注册中心</h3><p>​    <strong>现在不需要额外的服务注册模块了,Nacos单独启动了</strong></p><p>&lt;1&gt;新建cloudalibaba-provider-payment9001模块 (服务提供者)</p><ul><li>父工程的pom引入下面的依赖</li></ul><pre><code class="xml">&lt;!--  spring cloud alibaba 2.1.0.RELEASE    --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;    &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;    &lt;type&gt;pom&lt;/type&gt;    &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;</code></pre><ul><li>cloudalibaba-provider-payment9001模块的pom</li></ul><pre><code class="xml">&lt;dependencies&gt;         &lt;!--服务的注册与发现--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;&lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.62&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><ul><li>cloudalibaba-provider-payment9001模块的application.yml</li></ul><pre><code class="yml">server:  port: 9001spring:  application:    name: nacos-payment-provider  cloud:    nacos:      discovery:        server-addr: localhost:8848 #配置Nacos地址management:  endpoints:    web:      exposure:        include: &#39;*&#39;</code></pre><ul><li>cloudalibaba-provider-payment9001模块的主启动类</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class PaymentMain9001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PaymentMain9001.class,args);    &#125;&#125;</code></pre><ul><li>cloudalibaba-provider-payment9001模块的controller</li></ul><pre><code class="java">import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class PaymentController&#123;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    @GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)    public String getPayment(@PathVariable(&quot;id&quot;) Integer id)    &#123;        return &quot;nacos registry, serverPort: &quot;+ serverPort+&quot;\t id&quot;+id;    &#125;&#125;</code></pre><p><strong>测试</strong></p><p>启动9001,然后查看Nacos的web界面,可以看到9001已经注册成功</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406214745738.png" alt="image-20220406214745738">为了下面演示nacos的负载均衡，参考上面的9001模块,新建cloudalibaba-provider-payment9002模块</p><p>&lt;2&gt;新建cloudalibaba-consumer-nacos-order83模块 </p><ul><li>cloudalibaba-consumer-nacos-order83模块的 pom.xml</li></ul><pre><code class="xml">&lt;dependencies&gt;    &lt;!--SpringCloud ailibaba nacos --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;        &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li>cloudalibaba-consumer-nacos-order83模块的 application.yml</li></ul><pre><code class="yml">server:  port: 83spring:  application:    name: nacos-order-consumer  cloud:    nacos:      discovery:        server-addr: localhost:8848service-url:  nacos-user-service: http://nacos-payment-provider # 远程调用地址</code></pre><ul><li>cloudalibaba-consumer-nacos-order83模块的 主启动</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class OrderNacosMain83&#123;    public static void main(String[] args)    &#123;        SpringApplication.run(OrderNacosMain83.class,args);    &#125;&#125;</code></pre><ul><li>cloudalibaba-consumer-nacos-order83模块的 ApplicationContextConfig</li></ul><pre><code class="java">package com.atguigu.springcloud.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig&#123;    @Bean    @LoadBalanced //负载均衡    public RestTemplate getRestTemplate()    &#123;        return new RestTemplate();    &#125;&#125;</code></pre><ul><li>cloudalibaba-consumer-nacos-order83模块的 OrderNacosController</li></ul><pre><code class="java">import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@RestController@Slf4jpublic class OrderNacosController&#123;    @Resource    private RestTemplate restTemplate;//远程调用    @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)    private String serverURL;    @GetMapping(value = &quot;/consumer/payment/nacos/&#123;id&#125;&quot;)    public String paymentInfo(@PathVariable(&quot;id&quot;) Long id)    &#123;        return restTemplate.getForObject(serverURL+&quot;/payment/nacos/&quot;+id,String.class);    &#125;&#125;</code></pre><p><strong>测试</strong></p><p>启动83,访问9001,9002</p><p>访问：<a href="http://localhost:83/consumer/payment/nacos/13">http://localhost:83/consumer/payment/nacos/13</a></p><p>可以看到,实现了轮询负载均衡</p><p>&lt;3&gt;Nacos与其他服务注册的对比</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406221523144.png" alt="image-20220406221523144"></p><p>Nacos支持AP和CP模式的切换</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220406221624134.png" alt="image-20220406221624134"></p><p>上面这个curl命令,就是切换模式</p><h3 id="Nacos作为服务配置中心"><a href="#Nacos作为服务配置中心" class="headerlink" title="Nacos作为服务配置中心"></a>Nacos作为服务配置中心</h3><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p>新建cloudalibaba-config-nacos-client3377模块</p><ul><li>cloudalibaba-config-nacos-client3377模块的pom</li></ul><pre><code class="xml">&lt;dependencies&gt;    &lt;!--nacos-config--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--nacos-discovery--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--web + actuator--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--一般基础配置--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li>cloudalibaba-config-nacos-client3377模块的application.yml</li></ul><pre><code class="yml">spring:  profiles:    active: dev</code></pre><ul><li>cloudalibaba-config-nacos-client3377模块的bootstrap.yml</li></ul><pre><code class="yml">server:  port: 3377spring:  application:    name: nacos-config-client  cloud:    nacos:      discovery:        server-addr: localhost:8848 #服务注册中心地址      config:        server-addr: localhost:8848 #配置中心地址        file-extension: yaml #指定yaml格式的配置</code></pre><ul><li>cloudalibaba-config-nacos-client3377模块的主启动类</li></ul><pre><code class="java">@EnableDiscoveryClient@SpringBootApplicationpublic class NacosConfigClientMain3377 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(NacosConfigClientMain3377.class, args);    &#125;&#125;</code></pre><ul><li>cloudalibaba-config-nacos-client3377模块的controller</li></ul><pre><code class="java">import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RefreshScope //开启配置自动刷新public class ConfigClientController&#123;    @Value(&quot;$&#123;config.info&#125;&quot;)    private String configInfo;    @GetMapping(&quot;/config/info&quot;)    public String getConfigInfo() &#123;        return configInfo;    &#125;&#125;</code></pre><ul><li>在Nacos中添加配置信息</li></ul><p><strong>配置规则,就是我们在客户端如何指定读取配置文件,配置文件的命名的规则</strong></p><p>默认的命名方式:</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407105231059.png" alt="image-20220407105231059"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407105243474.png" alt="image-20220407105243474"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407105557290.png" alt="image-20220407105557290"></p><p>在nacos的web界面上创建配置文件</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407105727354.png" alt="image-20220407105727354"></p><p><strong>注意</strong>: DataId就是配置文件名字,名字一定要按照上面的规则命名,否则客户端会读取不到配置文件</p><p><strong>测试</strong>： 重启3377客户端</p><pre><code>测试一： 访问：http://localhost:3377/config/info 可以成功读取到nacos上面的配置信息测试二： 然后修改nacos上面的配置文件，发现客户端是可以立即更新的，这是因为Nacos支持Bus总线,会自动发送命令更新所有客户端</code></pre><h4 id="分类配置"><a href="#分类配置" class="headerlink" title="分类配置"></a>分类配置</h4><p><img src="/2022/03/27/1513842928408203264/images/image-20220407110953525.png" alt="image-20220407110953525"></p><p>Nacos的图形化管理界面</p><p>配置管理</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407111135409.png" alt="image-20220407111135409"></p><p>命名空间</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407111208957.png" alt="image-20220407111208957"></p><p>Namespace+Group+Data ID三者关系？为什么这么设计？</p><p>NameSpace默认有一个:  public名称空间</p><p>这三个类似java的: 包名 + 类名 + 方法名</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407111346267.png" alt="image-20220407111346267"></p><p>&lt;1&gt;DataID方案</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407210059609.png" alt="image-20220407210059609"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407210242676.png" alt="image-20220407210242676"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407210154361.png" alt="image-20220407210154361"></p><p>通过配置文件,实现多环境的读取</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407210312764.png" alt="image-20220407210312764"></p><p><strong>测试</strong>：<a href="http://localhost:3377/config/info">http://localhost:3377/config/info</a>  看能否成功获取到配置信息</p><blockquote><p>此时,改为dev,就会读取dev的配置文件,改为test,就会读取test的配置文件</p></blockquote><p>&lt;2&gt;Group方案</p><ul><li>通过Group实现环境区分,新建Group</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220407211618099.png" alt="image-20220407211618099"></p><ul><li>在nacos图形界面控制台上面新建配置文件DataID</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220407211717910.png" alt="image-20220407211717910"></p><ul><li>3377模块的bootstrap+application</li></ul><p>在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST_GROUP</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407211849932.png" alt="image-20220407211849932"></p><p><strong>测试</strong>：<a href="http://localhost:3377/config/info">http://localhost:3377/config/info</a>  看能否成功获取到配置信息</p><p>&lt;3&gt;Namespace方案</p><ul><li>新建dev&#x2F;test的Namespace</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220407213513504.png" alt="image-20220407213513504"></p><ul><li>回到服务管理-服务列表查看</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220407213536425.png" alt="image-20220407213536425"></p><ul><li>按照域名配置填写</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220407213604591.png" alt="image-20220407213604591"></p><ul><li>bootstrap.yml和application.yml   注意 application.yml填写好dev</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220407213837628.png" alt="image-20220407213837628"></p><p><strong>测试</strong>：<a href="http://localhost:3377/config/info">http://localhost:3377/config/info</a>  看能否成功获取到配置信息</p><h3 id="Nacos集群和持久化配置"><a href="#Nacos集群和持久化配置" class="headerlink" title="Nacos集群和持久化配置"></a>Nacos集群和持久化配置</h3><h4 id="切换mysql数据库"><a href="#切换mysql数据库" class="headerlink" title="切换mysql数据库"></a>切换mysql数据库</h4><p>Nacos默认自带的是嵌入式数据库derby</p><p>derby到我们自己的mysql切换配置步骤</p><p>第一步：mysql中新建nacos-config数据库，nacos-server-1.1.4\nacos\conf目录下找到sql脚本并执行</p><p>第二步：修改Nacos安装目录下的安排application.properties,添加</p><pre><code class="properties">##################################################spring.datasource.platform=mysql db.num=1db.url.0=jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=rootdb.password=root</code></pre><p>此时可以重启nacos,那么就会改为使用我们自己的mysql</p><p><strong>测试</strong>：在nacos上面新建一个yaml配置  发现我们自己mysql的config_info表中多了一条数据</p><h4 id="Linux版Nacos-MySQL生产环境配置"><a href="#Linux版Nacos-MySQL生产环境配置" class="headerlink" title="Linux版Nacos+MySQL生产环境配置"></a>Linux版Nacos+MySQL生产环境配置</h4><p>略</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>一句话解释，之前我们讲解过的Hystrix。<a href="https://github.com/alibaba/Sentinel">官网</a></p><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220407220639494.png" alt="image-20220407220639494"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407220520775.png" alt="image-20220407220520775"></p><h3 id="sentinel安装"><a href="#sentinel安装" class="headerlink" title="sentinel安装"></a>sentinel安装</h3><p>1&gt;下载sentinel的jar包 <a href="https://github.com/alibaba/Sentinel/releases">下载网址</a></p><p>2&gt;运行sentinel</p><p>​        由于是一个jar包,所以可以直接java -jar运行    </p><p>​        注意,默认sentinel占用8080端口</p><p>3&gt;访问sentinel      localhost:8080     登录的账号密码均为sentinel</p><h3 id="初始化演示工程"><a href="#初始化演示工程" class="headerlink" title="初始化演示工程"></a>初始化演示工程</h3><p>新建cloudalibaba-sentinel-service8401模块</p><ul><li>cloudalibaba-sentinel-service8401模块的pom</li></ul><pre><code class="xml">&lt;dependencies&gt;    &lt;!--引入公共依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;        &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--引入nacos依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--引入nacos-sentinel依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;        &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;    &lt;/dependency&gt;     &lt;!--引入sentinel依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;cn.hutool&lt;/groupId&gt;        &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;        &lt;version&gt;4.6.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li>cloudalibaba-sentinel-service8401模块的application.yml</li></ul><pre><code class="yml">server:  port: 8401spring:  application:    name: cloudalibaba-sentinel-service  cloud:    nacos:      discovery:        server-addr: localhost:8848    sentinel:      transport:        dashboard: localhost:8080        port: 8719  #默认8719，假如被占用了会自动从8719开始依次+1扫描。直至找到未被占用的端口management:  endpoints:    web:      exposure:        include: &#39;*&#39;</code></pre><ul><li>cloudalibaba-sentinel-service8401模块的主启动</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@EnableDiscoveryClient@SpringBootApplicationpublic class MainApp8401 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MainApp8401.class, args);    &#125;&#125;</code></pre><ul><li>cloudalibaba-sentinel-service8401模块的controller</li></ul><pre><code class="java">import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class FlowLimitController &#123;    @GetMapping(&quot;/testA&quot;)    public String testA() &#123;        return &quot;------testA&quot;;    &#125;    @GetMapping(&quot;/testB&quot;)    public String testB() &#123;        return &quot;------testB&quot;;    &#125;&#125;</code></pre><p><strong>测试</strong> </p><p>启动nacos、sentinel、以及8401</p><p>访问：<a href="http://localhost:8080/">http://localhost:8080/</a>    发现什么都没有，原因是sentinel是懒加载，需要调用一次才可以</p><p>于是访问：<a href="http://localhost:8401/testA">http://localhost:8401/testA</a>    <a href="http://localhost:8401/testB">http://localhost:8401/testB</a></p><p>此时再查看sentinel就有信息了,说明sentinel8080正在监控微服务8401</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220407223444396.png"></p><h3 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220408113311475.png" alt="image-20220408113311475"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408113536235.png" alt="image-20220408113536235"></p><p>&lt;1&gt;直接快速失败-<strong>QPS</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408172915366.png" alt="image-20220408172915366"></p><p>测试：1s发一个请求没事，快速的刷就被限流了</p><p>测试地址：<a href="http://localhost:8401/testA">http://localhost:8401/testA</a></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408173132950.png" alt="image-20220408173132950"></p><p>&lt;2&gt;直接-<strong>线程数</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408173442690.png" alt="image-20220408173442690"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408173558591.png" alt="image-20220408173558591"></p><p>修改8401的controller</p><pre><code class="java">@GetMapping(&quot;/testA&quot;)public String testA() &#123;    try &#123; TimeUnit.SECONDS.sleep(2); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;    return &quot;------testA&quot;;&#125;</code></pre><p><strong>测试</strong>：浏览器和postman各个发一个  <a href="http://localhost:8401/testA">http://localhost:8401/testA</a>  请求，就会出现限流了</p><pre><code>比如a请求过来,处理很慢,在一直处理,此时b请求又过来了        此时因为a占用一个线程,此时要处理b请求就只有额外开启一个线程        那么就会报错</code></pre><p>&lt;3&gt;关联-<strong>快速失败</strong></p><p>应用场景:  比如<strong>支付接口</strong>达到阈值,就要限流下<strong>订单的接口</strong>,防止一直有订单</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408174255511.png" alt="image-20220408174255511"></p><p><strong>当testB达到阈值,qps大于1,就让testA之后的请求直接失败</strong></p><p>可以使用postman压测</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408174520683.png" alt="image-20220408174520683"></p><p>&lt;4&gt;链路</p><p>多个请求调用了同一个微服务</p><p>&lt;5&gt;预热Warm up</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408180006425.png" alt="image-20220408180006425"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408180021903.png" alt="image-20220408180021903"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408180042637.png" alt="image-20220408180042637"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408180104783.png" alt="image-20220408180104783"></p><p>应用场景</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408180157218.png" alt="image-20220408180157218"></p><p><strong>测试</strong>:  前5s阈值是3，所以浏览器快速的刷  <a href="http://localhost:8401/testB">http://localhost:8401/testB</a> 被限流了，经过5s后阈值慢慢的加到10了就不报限流错误，除非阈值超过10.</p><p>&lt;6&gt;排队等待</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408181813746.png" alt="image-20220408181813746"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408181844849.png" alt="image-20220408181844849"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408181921992.png" alt="image-20220408181921992"></p><h3 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h3><p><strong>就是熔断降级</strong> </p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408183707198.png" alt="image-20220408183707198"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408183740371.png" alt="image-20220408183740371"></p><p>&lt;1&gt;RT配置（秒级）</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408184419499.png" alt="image-20220408184419499"></p><p>第一步：8401的controller新增一个请求方法用于测试</p><pre><code class="java">@GetMapping(&quot;/testD&quot;)public String testD() &#123;    try &#123; TimeUnit.SECONDS.sleep(1); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;    return &quot;------testD&quot;;&#125;</code></pre><p>第二步：配置的PT,默认是秒级的平均响应时间</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408185256797.png" alt="image-20220408185256797"></p><p>默认计算平均时间是: 1秒类进入5个请求,并且响应的平均值超过阈值(这里的200ms),就报错</p><p>1秒5请求是Sentinel默认设置的</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408185344799.png" alt="image-20220408185344799"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408185401867.png" alt="image-20220408185401867"></p><p>默认熔断后.就直接抛出异常</p><p>&lt;2&gt;异常比例(秒级)</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408205303408.png" alt="image-20220408205303408"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408205310655.png" alt="image-20220408205310655"></p><p>修改8401的controller方法</p><pre><code class="java">@GetMapping(&quot;/testD&quot;)public String testD() &#123;    //try &#123; TimeUnit.SECONDS.sleep(1); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;    int i = 1/0;//异常比例为100%    return &quot;------testD&quot;;&#125;</code></pre><p>配置sentinel</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408205555725.png" alt="image-20220408205555725"></p><p>配置jMeter</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408211201573.png" alt="image-20220408211201573"></p><p><strong>测试</strong></p><p>没触发熔断,正常抛出异常(先不开jmeter就是这样)</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408211259778.png" alt="image-20220408211259778"></p><p>触发熔断(开启jmeter)</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408211340920.png" alt="image-20220408211340920"></p><p>测试结论</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408211505660.png" alt="image-20220408211505660"></p><p>&lt;3&gt;异常数</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408211534177.png" alt="image-20220408211534177"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408211545405.png" alt="image-20220408211545405"></p><p>8401的controller添加一个方法</p><pre><code class="java">@GetMapping(&quot;/testE&quot;)public String testE()&#123;    int age = 10/0;    return &quot;------testE 测试异常数&quot;;&#125;</code></pre><p>配置sentinel</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408212008073.png" alt="image-20220408212008073"></p><h3 id="热点key限流"><a href="#热点key限流" class="headerlink" title="热点key限流"></a>热点key限流</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220408220159366.png" alt="image-20220408220159366"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408220233895.png" alt="image-20220408220233895"></p><p>比如:</p><p>​            localhost:8080&#x2F;aa?name&#x3D;aa</p><p>​            localhost:8080&#x2F;aa?name&#x3D;bb</p><p>​            加入两个请求中,带有参数aa的请求访问频次非常高,我们就现在name&#x3D;&#x3D;aa的请求,但是bb的不限制</p><p>如何自定义降级方法,而不是默认的抛出异常?</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408220334186.png" alt="image-20220408220334186"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408220403106.png" alt="image-20220408220403106"></p><pre><code class="java"> @GetMapping(&quot;/testHotKey&quot;)@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;deal_testHotKey&quot;)//@SentinelResource(value = &quot;testHotKey&quot;)public String testHotKey(@RequestParam(value = &quot;p1&quot;,required = false) String p1,                         @RequestParam(value = &quot;p2&quot;,required = false) String p2) &#123;    //int age = 10/0;//sentinel只对sentinel热点规则处理，不会对这个处理    return &quot;------testHotKey&quot;;&#125;//兜底方法public String deal_testHotKey (String p1, String p2, BlockException exception)&#123;    return &quot;------deal_testHotKey,o(╥﹏╥)o&quot;;&#125;</code></pre><p>定义热点规则</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408220538753.png" alt="image-20220408220538753"></p><p><strong>测试1.此时我们访问&#x2F;testHotkey并且带上p1参数</strong>，如果qps大于1,就会触发我们定义的降级方法</p><p><strong>测试2.此时我们访问&#x2F;testHotkey并且不带上p1参数</strong>，就没事</p><p>只有带了p1,才可能会触发热点限流</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408220834527.png" alt="image-20220408220834527"></p><p><strong>设置热点规则中的其他选项</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408221314106.png" alt="image-20220408221314106"></p><p>添加配置</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408221419827.png" alt="image-20220408221419827"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408221955917.png" alt="image-20220408221955917"></p><p><strong>注意:</strong> 参数类型只支持,8种基本类型+String类</p><p><strong>注意</strong>:</p><p>如果我们程序出现异常,是不会走blockHander的降级方法的,因为这个方法只配置了热点规则,没有配置限流规则</p><p>我们这里配置的降级方法是sentinel针对热点规则配置的</p><p>只有触发热点规则才会降级</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408222133092.png" alt="image-20220408222133092"></p><h3 id="系统规则-不推荐-太暴力了"><a href="#系统规则-不推荐-太暴力了" class="headerlink" title="系统规则(不推荐,太暴力了)"></a>系统规则(不推荐,太暴力了)</h3><p>系统自适应限流:<br>从整体维度对应用入口进行限流</p><p>对整体限流,比如设置qps到达100,这里限流会限制整个系统(<em>不友好，影响整体性能</em>)</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408222634882.png" alt="image-20220408222634882"></p><p>配置全局QPS</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408222722996.png" alt="image-20220408222722996"></p><p><strong>测试</strong>:  阈值超过一每个请求都被限流了</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408222938838.png" alt="image-20220408222938838"></p><h3 id="SentinelResource注解"><a href="#SentinelResource注解" class="headerlink" title="SentinelResource注解"></a>SentinelResource注解</h3><p>&lt;1&gt;按资源名称限流+后续处理</p><p>以前流控异常会抛出下面的异常，现在是想改成自定义的</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220408231120098.png" alt="image-20220408231120098"></p><ul><li>8401新增一个controller</li></ul><pre><code class="java">import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.atguigu.springcloud.entities.*;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RateLimitController &#123;    @GetMapping(&quot;/byResource&quot;)    @SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)    public CommonResult byResource() &#123;        return new CommonResult(200,&quot;按资源名称限流测试OK&quot;,new Payment(2020L,&quot;serial001&quot;));    &#125;    //自定义流控异常处理    public CommonResult handleException(BlockException exception) &#123;        return new CommonResult(444,exception.getClass().getCanonicalName()+&quot;\t 服务不可用&quot;);    &#125;&#125;</code></pre><ul><li>sentinel中添加流控配置</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220408231306581.png" alt="image-20220408231306581"></p><ul><li>测试： 可以看到已经进入自定义的降级方法了</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220408231410515.png" alt="image-20220408231410515"></p><p>此时关闭8401服务,这些定义的规则是临时的,关闭服务,规则就没有了</p><p>&lt;2&gt;按照Url地址限流+后续处理</p><ul><li>8401的RateLimitController新增方法</li></ul><pre><code class="java">@GetMapping(&quot;/rateLimit/byUrl&quot;)@SentinelResource(value = &quot;byUrl&quot;)public CommonResult byUrl()&#123;    return new CommonResult(200,&quot;按url限流测试OK&quot;,new Payment(2020L,&quot;serial002&quot;));&#125;</code></pre><ul><li>sentinel配置： 前面配置的是@SentinelResource的value值，而这里配置的是url，同样有效。</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220408233237294.png" alt="image-20220408233237294"></p><ul><li>测试： <a href="http://localhost:8401/rateLimit/byUrl">http://localhost:8401/rateLimit/byUrl</a></li></ul><p><strong>可以看到,上面两个配置的降级方法,又出现Hystrix遇到的问题了</strong></p><p>​            降级方法与业务方法耦合</p><p>​            每个业务方法都需要对应一个降级方法</p><p>&lt;3&gt;客户自定义限流处理逻辑</p><ul><li>8401的新增CustomerBlockHandler方法</li></ul><pre><code class="java">package com.atguigu.springcloud.myhandler;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.atguigu.springcloud.entities.*;public class CustomerBlockHandler &#123;    public static CommonResult handleException(BlockException exception) &#123;        return new CommonResult(2020, &quot;自定义限流处理信息....CustomerBlockHandler&quot;);    &#125;&#125;</code></pre><ul><li>8401的新增RateLimitController新建下面的方法</li></ul><pre><code class="java">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)@SentinelResource(value = &quot;customerBlockHandler&quot;,                  blockHandlerClass = CustomerBlockHandler.class,                  blockHandler = &quot;handleException&quot;)public CommonResult customerBlockHandler()&#123;    return new CommonResult(200,&quot;按客戶自定义&quot;,new Payment(2020L,&quot;serial003&quot;));&#125;</code></pre><ul><li>sentinel配置</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220409000306772.png" alt="image-20220409000306772"></p><p>测试： <a href="http://localhost:8401/rateLimit/customerBlockHandler">http://localhost:8401/rateLimit/customerBlockHandler</a></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220409000344210.png" alt="image-20220409000344210"></p><p>配置对应的图示</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220409000425790.png" alt="image-20220409000425790"></p><p>&lt;4&gt;SentinelResource注解的其他属性</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220409000554700.png" alt="image-20220409000554700"></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220409000626440.png" alt="image-20220409000626440"></p><h3 id="服务熔断功能"><a href="#服务熔断功能" class="headerlink" title="服务熔断功能"></a>服务熔断功能</h3><p>sentinel整合ribbon+openFeign+fallback</p><h4 id="Ribbon系列"><a href="#Ribbon系列" class="headerlink" title="Ribbon系列"></a>Ribbon系列</h4><p>&lt;1&gt;新建cloudalibaba-provider-payment9003模块</p><ul><li>cloudalibaba-provider-payment9003的pom</li></ul><pre><code class="xml">&lt;dependencies&gt;    &lt;!--SpringCloud ailibaba nacos --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;        &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- SpringBoot整合Web组件 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--日常通用jar包配置--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li>cloudalibaba-provider-payment9003的application.yml</li></ul><pre><code class="yml">server:  port: 9003spring:  application:    name: nacos-payment-provider  cloud:    nacos:      discovery:        server-addr: localhost:8848 #配置Nacos地址management:  endpoints:    web:      exposure:        include: &#39;*&#39;</code></pre><ul><li>cloudalibaba-provider-payment9003的controller</li></ul><pre><code class="java">import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;@RestControllerpublic class PaymentController &#123;    @Value(&quot;$&#123;server.port&#125;&quot;)    private String serverPort;    public static HashMap&lt;Long, Payment&gt; hashMap = new HashMap&lt;&gt;();    static&#123;        hashMap.put(1L,new Payment(1L,&quot;28a8c1e3bc2742d8848569891fb42181&quot;));        hashMap.put(2L,new Payment(2L,&quot;bba8c1e3bc2742d8848569891ac32182&quot;));        hashMap.put(3L,new Payment(3L,&quot;6ua8c1e3bc2742d8848569891xt92183&quot;));    &#125;    @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id)&#123;        Payment payment = hashMap.get(id);        CommonResult&lt;Payment&gt; result = new CommonResult(200,&quot;from mysql,serverPort:  &quot;+serverPort,payment);        return result;    &#125;&#125;</code></pre><ul><li>cloudalibaba-provider-payment9003的主启动</li></ul><pre><code class="java">import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class PaymentMain9003 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(PaymentMain9003.class, args);    &#125;&#125;</code></pre><p>同理，参考cloudalibaba-provider-payment9003，新建cloudalibaba-provider-payment9004</p><p>&lt;2&gt;新建cloudalibaba-consumer-nacos-order84模块</p><ul><li>cloudalibaba-consumer-nacos-order84模块的pom</li></ul><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><ul><li>cloudalibaba-consumer-nacos-order84模块的application.yml</li></ul><pre><code class="yml">server:  port: 84spring:  application:    name: nacos-order-consumer  cloud:    nacos:      discovery:        server-addr: localhost:8848    sentinel:      transport:        dashboard: localhost:8080        port: 8719service-url:  nacos-user-service: http://nacos-payment-provider</code></pre><ul><li>cloudalibaba-consumer-nacos-order84模块的config</li></ul><pre><code class="java">package com.atguigu.springcloud.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ApplicationContextConfig &#123;    @Bean    @LoadBalanced    public RestTemplate getRestTemplate() &#123;        return new RestTemplate();    &#125;&#125;</code></pre><ul><li>cloudalibaba-consumer-nacos-order84模块的controller</li></ul><pre><code class="java">import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@RestController@Slf4jpublic class CircleBreakerController &#123;    public static final String SERVICE_URL = &quot;http://nacos-payment-provider&quot;;    @Resource    private RestTemplate restTemplate;    @RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)    //@SentinelResource(value = &quot;fallback&quot;) //没有配置-抛出错误给用户,不友好    //@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback只负责业务异常    //@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler只负责sentinel控制台配置违规    @SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;,            exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;)    public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id) &#123;        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + &quot;/paymentSQL/&quot;+id, CommonResult.class,id);        if (id == 4) &#123;            throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;);        &#125;else if (result.getData() == null) &#123;            throw new NullPointerException (&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;);        &#125;        return result;    &#125;    //fallback 处理业务异常    public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) &#123;        Payment payment = new Payment(id,&quot;null&quot;);        return new CommonResult&lt;&gt;(444,&quot;兜底异常handlerFallback,exception内容  &quot;+e.getMessage(),payment);    &#125;    //blockHandler 处理sentinel控制台配置违规    public CommonResult blockHandler(@PathVariable  Long id,BlockException blockException) &#123;        Payment payment = new Payment(id,&quot;null&quot;);        return new CommonResult&lt;&gt;(445,&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;+blockException.getMessage(),payment);    &#125;&#125;</code></pre><ul><li>测试：启动9003,9004,84</li></ul><p>@SentinelResource的下面五种情况进行测试（修改controller中的fallback方法上面的注解注释即可）</p><p><img src="/2022/03/27/1513842928408203264/images/image-20220409110632070.png" alt="image-20220409110632070"></p><p>测试结论：</p><p>1&gt;fallback管运行异常</p><p>2&gt;blockHandler管sentinel配置违规异常</p><p>3&gt;<strong>两个都配置blockhandler优先生效</strong></p><p> 4&gt;exceptionsToIgnore指定一个异常类,<strong>表示如果当前方法抛出的是指定的异常,不降级,直接对用户抛出异常</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220409111028119.png" alt="image-20220409111028119"></p><h4 id="Feign系列"><a href="#Feign系列" class="headerlink" title="Feign系列"></a>Feign系列</h4><p>主要是修改cloudalibaba-consumer-nacos-order84模块</p><ul><li>cloudalibaba-consumer-nacos-order84的pom.xml</li></ul><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>cloudalibaba-consumer-nacos-order84的application.yml 开启feign</li></ul><pre><code class="yml">#对Feign的支持feign:  sentinel:    enabled: true</code></pre><ul><li>cloudalibaba-consumer-nacos-order84新建PaymentService接口</li></ul><pre><code class="java">import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)public interface PaymentService &#123;    @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id);&#125;</code></pre><ul><li>cloudalibaba-consumer-nacos-order84新建PaymentService接口实现类</li></ul><pre><code class="java">import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import org.springframework.stereotype.Component;@Component //注意要加上这个注解public class PaymentFallbackService implements PaymentService &#123;    @Override    public CommonResult&lt;Payment&gt; paymentSQL(Long id)&#123;        return new CommonResult&lt;&gt;(44444,&quot;服务降级返回,---PaymentFallbackService&quot;,new Payment(id,&quot;errorSerial&quot;));    &#125;&#125;</code></pre><ul><li>cloudalibaba-consumer-nacos-order84的controller添加下面方法</li></ul><pre><code class="java">// OpenFeign@Resourceprivate PaymentService paymentService;@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id) &#123;    return paymentService.paymentSQL(id);&#125;</code></pre><p>测试： 如果关闭9003.看看84会不会降级，<strong>可以看到,正常降级了</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220409112707584.png" alt="image-20220409112707584"></p><p><strong>熔断框架比较</strong></p><p><img src="/2022/03/27/1513842928408203264/images/image-20220409112740511.png" alt="image-20220409112740511"></p><h3 id="持久化规则"><a href="#持久化规则" class="headerlink" title="持久化规则"></a>持久化规则</h3><p><strong>问题：</strong>一旦我们重启应用，Sentinel规则将消失，生产环境需要将配置规则进行持久化</p><p><strong>解决</strong>：将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上Sentinel上的流控规则持续有效</p><p><strong>这里以之前的cloudalibaba-sentinel-service8401模块为案例进行修改:</strong></p><ul><li>cloudalibaba-sentinel-service8401的pom增加下面依赖</li></ul><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>cloudalibaba-sentinel-service8401的application.yml</li></ul><pre><code class="yml">datasource:        ds1:          nacos:            server-addr: localhost:8848            dataId: cloudalibaba-sentinel-service            groupId: DEFAULT_GROUP            data-type: json            rule-type: flow</code></pre><p><img src="/2022/03/27/1513842928408203264/images/image-20220409121742167.png" alt="image-20220409121742167"></p><p><strong>实际上就是指定,我们的规则要保证在哪个名称空间的哪个分组下</strong></p><p>这里没有指定namespace, 但是是可以指定的</p><p><strong>注意,这里的dataid要与8401的服务名一致</strong></p><ul><li>在nacos中创建一个配置文件,dataId就是上面配置文件中指定的</li></ul><p><img src="/2022/03/27/1513842928408203264/images/image-20220409115909698.png" alt="image-20220409115909698"></p><p>注意：下面这个resource后的url一定要填写正确，否则无效</p><pre><code class="json">[    &#123;         &quot;resource&quot;: &quot;/rateLimit/byUrl&quot;,         &quot;limitApp&quot;: &quot;default&quot;,         &quot;grade&quot;:   1,         &quot;count&quot;:   1,         &quot;strategy&quot;: 0,         &quot;controlBehavior&quot;: 0,         &quot;clusterMode&quot;: false        &#125;]</code></pre><p><img src="/2022/03/27/1513842928408203264/images/image-20220409115945717.png" alt="image-20220409115945717"></p><p><strong>测试</strong></p><p>启动8401,访问localhost:8401&#x2F;rateLimit&#x2F;byUrl</p><p>在sentinel中可以看到,直接读取到了规则</p><p>此时重启8401,如果sentinel又可以正常读取到规则,那么证明持久化成功</p>]]></content>
    
    
    <summary type="html">以前学过springcloud，现在利用这个教程过一遍springcloud，以及学习springcloudAibaba</summary>
    
    
    
    <category term="java" scheme="https://heliufang.github.io/categories/java/"/>
    
    
    <category term="springcloud" scheme="https://heliufang.github.io/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>java实现播放音乐-JLayer</title>
    <link href="https://heliufang.github.io/2021/08/27/1431195103640293376/images/"/>
    <id>https://heliufang.github.io/2021/08/27/1431195103640293376/images/</id>
    <published>2021-08-27T10:00:28.000Z</published>
    <updated>2021-08-27T10:00:57.732Z</updated>
    
    <content type="html"><![CDATA[<p>不久前，接了一个单子,用java的swing实现一个如下的功能</p><p><img src="/2021/08/27/1431195103640293376/images/image-20210827171756876.png" alt="image-20210827171756876"></p><p>其实增删改查都好实现,主要是java怎么播放MP3音乐。然后去百度,发现了一个人家造好的轮子—<code>JLayer</code>。导入jar包调用相关的api即可,下面记录一下使用方法。</p><h2 id="1-下载JLayer的jar包"><a href="#1-下载JLayer的jar包" class="headerlink" title="1 下载JLayer的jar包"></a>1 下载<code>JLayer</code>的jar包</h2><p><a href="https://sourceforge.net/projects/javalayer/">点击下载</a></p><h2 id="2-创建java项目"><a href="#2-创建java项目" class="headerlink" title="2 创建java项目"></a>2 创建java项目</h2><p>准备一个MP3文件放入src的文件夹下</p><p><img src="/2021/08/27/1431195103640293376/images/image-20210827173044986.png" alt="image-20210827173044986"></p><h2 id="3-编写测试代码"><a href="#3-编写测试代码" class="headerlink" title="3 编写测试代码"></a>3 编写测试代码</h2><p>【TestJlayer.java】</p><pre><code class="java">package com.qy.jlayer;import java.io.File;import java.io.FileInputStream;import javazoom.jl.player.Player;public class TestJlayer &#123;    public static void main(String[] args) throws Exception&#123;        File file = new File(&quot;src/1.mp3&quot;);        Player player = new Player(new FileInputStream(file));        player.play();//播放音乐        //player.close();//停止音乐    &#125;&#125;</code></pre><h2 id="4-常用api总结"><a href="#4-常用api总结" class="headerlink" title="4 常用api总结"></a>4 常用api总结</h2><p><img src="/2021/08/27/1431195103640293376/images/image-20210827173553935.png" alt="image-20210827173553935"></p><h2 id="5-注意"><a href="#5-注意" class="headerlink" title="5 注意"></a>5 注意</h2><p>可以看到这个工具包的使用很简单,但是play() 这个方法是阻塞式的,也就同步的,程序运行的时候，音乐不放完代码是不会往下走的，这在swing开发中就会存在一种问题，在播放音乐的时候如果想切换音乐或者停止音乐，按钮是点击不了的。我的解决方案是单独启动一个线程来播放音乐。</p><p>伪代码如下：</p><pre><code class="java">public class MusicIndexFrm extends JFrame &#123;    //第一步定义    private Player player ;//播放对象    private Music playMusic;//正在播放的音乐,如果没有则为null 这个Music类是自己封装的,里面定义了音乐相关信息，比如歌名，路径等        //第二步：核心在这里 自定义线程类,来播放音乐    private class MyRunnable implements Runnable&#123;//1.实现Runnable接口          public void run() &#123;//2.重写run方法             try &#123;                if(null != player)&#123;player.close();&#125;//如果有音乐在播放先关闭,一次只放一首歌                player = new Player(new FileInputStream(new File(playMusic.getPath())));                player.play();//播放            &#125; catch (FileNotFoundException e1) &#123;                e1.printStackTrace();            &#125; catch (JavaLayerException e1) &#123;                e1.printStackTrace();            &#125;         &#125;    &#125;        //第三步：通过线程去播放音乐而不是直接调用play()方法    Music music = new Music(id, name, formats, singer, path);    playMusic = music;//将正在播放的音乐保存    //播放音乐,此处要启动一个线程去播放,不然窗口动不了    new Thread(new MyRunnable()).start();&#125;</code></pre>]]></content>
    
    
    <summary type="html">java实现播放音乐-JLayer</summary>
    
    
    
    <category term="java" scheme="https://heliufang.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://heliufang.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发-Java版学习笔记</title>
    <link href="https://heliufang.github.io/2021/08/14/1426556608602836992/images/"/>
    <id>https://heliufang.github.io/2021/08/14/1426556608602836992/images/</id>
    <published>2021-08-14T14:26:28.000Z</published>
    <updated>2022-12-21T03:52:35.187Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于罗召勇老师的教程加上自己的理解整理</p><p>本文源码已上传至我的码云: <a href="https://gitee.com/heliufang/wx">https://gitee.com/heliufang/wx</a></p><p>微信公众号开发整体不难,主要是熟悉微信公众号常用的一些接口文档,然后会一门后端语言(比如java)即可。</p><p>罗召勇老师教程：<a href="https://www.bilibili.com/video/BV1nb411P76t?from=search&seid=14211630633615797421">微信公众号开发-Java版（蓝桥罗召勇）</a></p><p>微信公众号文档：<a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html">微信公众号官方文档</a></p><h2 id="1-微信公众号介绍"><a href="#1-微信公众号介绍" class="headerlink" title="1 微信公众号介绍"></a>1 微信公众号介绍</h2><p>账号分为<code>服务号</code>、<code>订阅号</code>、小程序</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808110213141.png" alt="image-20210808110213141"></p><p>服务号和订阅号开发类似,但是申请服务号必须是企业,所以学习的话申请一个订阅号+测试账号即可。为啥要申请测试账号呢？因为订阅号的接口功能有限,为了学习开发以及熟悉更多的接口,所以还需要申请一个测试号。</p><h2 id="2-注册订阅号"><a href="#2-注册订阅号" class="headerlink" title="2 注册订阅号"></a>2 注册订阅号</h2><p>第一步：访问：<a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a>  点击<code>立即注册</code>按钮</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808110839008.png" alt="image-20210808110839008"></p><p>第二步：注册类型页面选择<code>订阅号</code></p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808110933591.png" alt="image-20210808110933591"></p><p>第三步：填写相关信息，点击注册即可</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808111031011.png" alt="image-20210808111031011"></p><h2 id="3-注册测试号"><a href="#3-注册测试号" class="headerlink" title="3 注册测试号"></a>3 注册测试号</h2><p>因为订阅号的接口权限是有限的,为了熟悉更多的微信公众号接口,所以需要申请一个测试号。</p><p>第一步：用注册的订阅号登录</p><p>第二步：在目录中【设置与开发】—&gt;【开发者工具】下选择公众平台测试账号,点击进入后申请即可。</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808112917414.png" alt="image-20210808112917414"></p><p>申请成功之后,就可以配置相关信息进行开发了,具体怎么配置后面再解释</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808113103181.png" alt="image-20210808113103181"></p><h2 id="4-程序运行流程"><a href="#4-程序运行流程" class="headerlink" title="4 程序运行流程"></a>4 程序运行流程</h2><p>用户在公众号发送请求到<code>微信服务器</code></p><p><code>微信服务器</code>将请求转发到<code>我们自己的服务器</code></p><p><code>我们自己的服务器</code>处理完之后再把结果发送到<code>微信服务器</code></p><p>最后<code>微信服务器</code>再把结果响应给客户</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808114624893.png" alt="image-20210808114624893"></p><h2 id="5-搭建开发环境"><a href="#5-搭建开发环境" class="headerlink" title="5 搭建开发环境"></a>5 搭建开发环境</h2><p>罗老师用的是eclipse并且没有用maven环境,我用的是eclipse+maven+jdk7+tomcat8.0。maven的话可以兼容idea，而且下载依赖方便。</p><p>新建一个名为<code>wx</code>的maven项目(这个项目名字任意都行),<code>pom.xml</code>的依赖如下：</p><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- 阿里云小蜜-自动回复机器人 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;            &lt;artifactId&gt;aliyun-java-sdk-chatbot&lt;/artifactId&gt;            &lt;version&gt;1.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;            &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;            &lt;version&gt;4.5.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- xml操作相关依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt;            &lt;artifactId&gt;xstream&lt;/artifactId&gt;            &lt;version&gt;1.4.11.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.dom4j&lt;/groupId&gt;            &lt;artifactId&gt;dom4j&lt;/artifactId&gt;            &lt;version&gt;2.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 阿里json解析 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.28&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 这个是编码解码的 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;commons-codec&lt;/groupId&gt;            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;            &lt;version&gt;1.10&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>编写一个测试的servlet</p><pre><code class="java">import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(&quot;/test&quot;) public class TestServlet extends HttpServlet&#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;请求到达了&quot;);        resp.getWriter().write(&quot;hello weixin&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            &#125;&#125;</code></pre><p>启动项目访问：<a href="http://localhost:8080/wx/test">http://localhost:8080/wx/test</a></p><p>浏览器看到如下效果说明搭建成功</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808120644851.png" alt="image-20210808120644851"></p><h2 id="6-内外网穿透"><a href="#6-内外网穿透" class="headerlink" title="6 内外网穿透"></a>6 内外网穿透</h2><p>外网默认是访问不到自己电脑上的项目的,为了让外网能够访问,所以需要做内外网穿透.这个不需要自己实现,可以借助一些工具,如花生壳、ngrok.这里用的是ngrok.</p><p><a href="https://www.ngrok.cc/_book/start/ngrok_linux.html">ngrok文档</a></p><p>第一步：访问<a href="https://www.ngrok.cc/">ngrok官网</a>,注册ngrok账号。</p><p>第二步：使用注册的账号登录</p><p>第三步：【隧道管理—&gt;开通隧道】立即购买,可以购买最后那个免费的，也可以花10块钱买一个。免费的有时候不稳定,可以买一个10块。</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808195028874.png" alt="image-20210808195028874"></p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808195438170.png" alt="image-20210808195438170"></p><p>开通之后在隧道管理下就可以看到刚刚开通的隧道</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808195618721.png" alt="image-20210808195618721"></p><p>第四步：下载客户端工具,我电脑是windows的所以下载windows版</p><p>各版本工具下载地址：<a href="https://www.ngrok.cc/download.html">https://www.ngrok.cc/download.html</a></p><p>第五步：启动ngrok客户端工具,运行bat,输入隧道id，回车</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808195948516.png" alt="image-20210808195948516"></p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808200101402.png" alt="image-20210808200101402"></p><p>看到下面这个状态为【online】表示启动成功<br><img src="/2021/08/14/1426556608602836992/images/image-20210808200116096.png" alt="image-20210808200116096"></p><p>然后就可以通过<a href="http://heliufang.vipgz4.idcfengye.com这个域名访问本地8080端口上的项目了,比如访问之前搭建的wx项目/">http://heliufang.vipgz4.idcfengye.com这个域名访问本地8080端口上的项目了,比如访问之前搭建的wx项目</a></p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808200322739.png" alt="image-20210808200322739"></p><h2 id="7-开发接入"><a href="#7-开发接入" class="headerlink" title="7 开发接入"></a>7 开发接入</h2><p>接入之后微信服务器和我们自己的项目就接通了。那么如何接入呢?</p><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Access_Overview.html">接入的官方文档</a></p><ul><li>第一步：登录<a href="http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login">微信公众测试号</a>的管理界面,填写好相关信息</li></ul><p><img src="/2021/08/14/1426556608602836992/images/image-20210808213637686.png" alt="image-20210808213637686"></p><p>上图中的url就是自己电脑的项目</p><p>点击上图的提交按钮之后,微信会向上图中的url发送一个get请求,请求参数如下：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">signature</td><td align="left">微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</td></tr><tr><td align="left">timestamp</td><td align="left">时间戳</td></tr><tr><td align="left">nonce</td><td align="left">随机数</td></tr><tr><td align="left">echostr</td><td align="left">随机字符串</td></tr></tbody></table><ul><li>第二步：编写代码校验,用代码实现下面的逻辑</li></ul><p> 1）将token、timestamp、nonce三个参数进行字典序排序</p><p> 2）将三个参数字符串拼接成一个字符串进行sha1加密 </p><p> 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信,如果比对成功,请原样返回echostr参数内容</p><p>在之前搭建的名为<code>wx</code>的项目中新建一个【WxServlet.java】</p><pre><code class="java">import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.qy.service.WxService;@WebServlet(&quot;/api&quot;)public class WxServlet extends HttpServlet&#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;请求到达了&quot;);        //取出微信服务器传过来的参数        String signature = req.getParameter(&quot;signature&quot;);        String timestamp = req.getParameter(&quot;timestamp&quot;);        String nonce = req.getParameter(&quot;nonce&quot;);        String echostr = req.getParameter(&quot;echostr&quot;);        //自定义一个check方法用来校验接入        boolean success = WxService.check(timestamp, nonce, signature);        if(success)&#123;            System.out.println(&quot;接入成功&quot;);            PrintWriter writer = resp.getWriter();            writer.write(echostr);//接入成功需要原样返回echostr        &#125;else&#123;            System.out.println(&quot;接入失败&quot;);        &#125;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;            &#125;&#125;</code></pre><p>新建一个【WxService.java】并添加一个check工具方法</p><pre><code class="java">import java.util.Arrays;import org.apache.commons.codec.digest.DigestUtils;public class WxService &#123;        public static final String TOKEN = &quot;hlf&quot;;//在微信配置界面自定义的token        /**     * 接入校验     * @param timestamp     * @param nonce     * @param signature     * @return     */    public static boolean check(String timestamp, String nonce, String signature) &#123;        //1.将token、timestamp、nonce三个参数进行字典序排序        String[] arr = new String[]&#123;TOKEN,timestamp,nonce&#125;;        Arrays.sort(arr);        //2.将三个参数字符串拼接成一个字符串进行sha1加密  https://www.cnblogs.com/2333/p/6405386.html        String str = arr[0]+arr[1]+arr[2];        str = DigestUtils.sha1Hex(str);//sha1加密,这里没有像罗老师那样手写,直接用的commons-codec包的工具类        System.out.println(&quot;str:&quot;+str);        //3.将加密后的字符串和signature比较        System.out.println(signature);        return str.equalsIgnoreCase(signature);    &#125;&#125;</code></pre><p>启动项目,点击提交按钮,出现下面这个代表接入成功。</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210808220055857.png" alt="image-20210808220055857"></p><h2 id="8-接收用户消息"><a href="#8-接收用户消息" class="headerlink" title="8 接收用户消息"></a>8 接收用户消息</h2><p>官方文档：<a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html">接受普通消息</a></p><blockquote><p>当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上。</p></blockquote><p>也就是说用户发消息给微信服务器,微信服务器会发送<code>post请求</code>到我们自己的服务器,并且传送一个xml的数据给我们自己的服务器。</p><p>例如文本消息是这样的</p><pre><code class="xml">&lt;xml&gt;  &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;  &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;  &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;  &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;  &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;  &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ToUserName</td><td align="left">开发者微信号</td></tr><tr><td align="left">FromUserName</td><td align="left">发送方帐号（一个OpenID）</td></tr><tr><td align="left">CreateTime</td><td align="left">消息创建时间 （整型）</td></tr><tr><td align="left">MsgType</td><td align="left">消息类型，文本为text</td></tr><tr><td align="left">Content</td><td align="left">文本消息内容</td></tr><tr><td align="left">MsgId</td><td align="left">消息id，64位整型</td></tr></tbody></table><p>java中这样的数据读取并不方便。可以转换一下,先通过dom4j这个包转成dom对象,再把标签名和对应的标签的值保存到HashMap集合中,这样后面处理数据就很方便了,具体代码实现如下：</p><p>在【WxServlet】中编写<code>doPost</code>方法,在<a href="http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&t=sandbox/index">测试号管理界面</a>,扫码关注测试公众号</p><pre><code class="java">@Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        Map&lt;String,String&gt; map = WxService.parseRequest(req.getInputStream());        System.out.println(map);//关注测试号,给测试公众号发消息,就可以看到打印结果了    &#125;</code></pre><p>在【WxService】中添加<code>parseRequest</code>方法</p><pre><code class="java">/**     * 将接受到的消息转化成map     * @param req     * @return     */    public static  Map&lt;String, String&gt; parseRequest(InputStream is) &#123;        Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();        //1.通过io流得到文档对象        SAXReader saxReader = new SAXReader();        Document document = null;        try &#123;            document = saxReader.read(is);        &#125; catch (DocumentException e) &#123;            e.printStackTrace();        &#125;        //2.通过文档对象得到根节点对象        Element root = document.getRootElement();        //3.通过根节点对象获取所有子节点对象        List&lt;Element&gt; elements = root.elements();        //4.将所有节点放入map        for (Element element : elements) &#123;            map.put(element.getName(), element.getStringValue());        &#125;        return map;    &#125;</code></pre><h2 id="9-回复用户消息封装"><a href="#9-回复用户消息封装" class="headerlink" title="9 回复用户消息封装"></a>9 回复用户消息封装</h2><p>官方文档：<a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message.html">被动回复用户消息</a></p><blockquote><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。</p><p><strong>一旦遇到以下情况，微信都会在公众号会话中，向用户下发系统提示“该公众号暂时无法提供服务，请稍后再试”：</strong></p><p>1、开发者在5秒内未回复任何内容 2、开发者回复了异常数据，比如JSON数据等</p></blockquote><p>上面这段文字来自官方,可以看出</p><ul><li><p>回复必须是xml的类型</p></li><li><p>可以回复多种类型的xml(文本、图片、图文、语音、视频、音乐)</p></li><li><p>接收到消息没有做出响应就会抛出：<code>该公众号暂时无法提供服务，请稍后再试</code></p></li></ul><h3 id="9-1-回复消息入门demo"><a href="#9-1-回复消息入门demo" class="headerlink" title="9.1  回复消息入门demo"></a>9.1  回复消息入门demo</h3><p>这个demo就是给用户回复一个文本消息</p><p>回复的xml格式如下：</p><pre><code class="xml">&lt;xml&gt;  &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;  &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;  &lt;CreateTime&gt;12345678&lt;/CreateTime&gt;  &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;  &lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;&lt;/xml&gt;</code></pre><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ToUserName</td><td align="left">是</td><td align="left">接收方帐号（收到的OpenID）</td></tr><tr><td align="left">FromUserName</td><td align="left">是</td><td align="left">开发者微信号</td></tr><tr><td align="left">CreateTime</td><td align="left">是</td><td align="left">消息创建时间 （整型）</td></tr><tr><td align="left">MsgType</td><td align="left">是</td><td align="left">消息类型，文本为text</td></tr><tr><td align="left">Content</td><td align="left">是</td><td align="left">回复的消息内容（换行：在content中能够换行，微信客户端就支持换行显示）</td></tr></tbody></table><p>在wxservlet中doPost编写如下代码</p><pre><code class="java">@Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //设置编码格式,不然中文会乱码        req.setCharacterEncoding(&quot;UTF-8&quot;);        resp.setCharacterEncoding(&quot;UTF-8&quot;);        //将请求中的xml参数转成map        Map&lt;String,String&gt; map = WxService.parseRequest(req.getInputStream());        System.out.println(map);        //回复消息        String textMsg = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&quot;+map.get(&quot;FromUserName&quot;)+&quot;]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[&quot;+map.get(&quot;ToUserName&quot;)+&quot;]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;12345678&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;&lt;/xml&gt;&quot;;        resp.getWriter().print(textMsg);    &#125;</code></pre><p>然后用测试号发消息,公众号都会回复一个  【你好】</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210810221633028.png" alt="image-20210810221633028"></p><p>这样写代码功能是可以实现,但是这样拼接字符串,再回复消息很不方便.然后自然就想到可以用java类来封装消息,响应的时候将java类转成xml(通过<code>xstream</code>这个工具包实现)。下面就以文本消息和图文消息为例进行封装,其它消息类似。</p><h3 id="9-2-基础消息类的封装"><a href="#9-2-基础消息类的封装" class="headerlink" title="9.2 基础消息类的封装"></a>9.2 基础消息类的封装</h3><p>把公共的属性放到基础消息类中,然后其它消息类继承即可。</p><p><code>@XStreamAlias</code> 这个注解配置的就是转成xml时对应的节点名字</p><pre><code class="java">public class BaseMsg &#123;    @XStreamAlias(&quot;ToUserName&quot;)    private String toUserName;//接收方的账号(收到的openid)    @XStreamAlias(&quot;FromUserName&quot;)    private String fromUserName;//开发者的微信号    @XStreamAlias(&quot;CreateTime&quot;)    private String createTime;//消息创建时间    @XStreamAlias(&quot;MsgType&quot;)    private String msgType;//消息类型    public BaseMsg(Map&lt;String,String&gt; requestMap) &#123;        super();        this.toUserName = requestMap.get(&quot;FromUserName&quot;);        this.fromUserName = requestMap.get(&quot;ToUserName&quot;);        this.createTime = requestMap.get(&quot;CreateTime&quot;);    &#125;        //get and set ...&#125;</code></pre><h3 id="9-3-文本消息类封装"><a href="#9-3-文本消息类封装" class="headerlink" title="9.3 文本消息类封装"></a>9.3 文本消息类封装</h3><p>回复的xml的格式说明可以参考9.1入门demo.回复文本的封装类如下：</p><pre><code class="java">@XStreamAlias(&quot;xml&quot;) //xml指的就是xml这个根节点名称public class TextMsg extends BaseMsg &#123;    @XStreamAlias(&quot;Content&quot;)    private String content;//回复的文本内容        public TextMsg(Map&lt;String,String&gt; requestMap,String content) &#123;        super(requestMap);        this.setMsgType(&quot;text&quot;);        this.content = content;    &#125;        //get and set ...&#125;</code></pre><h3 id="9-4-图文消息封装"><a href="#9-4-图文消息封装" class="headerlink" title="9.4 图文消息封装"></a>9.4 图文消息封装</h3><p>图文消息格式说明</p><pre><code class="xml">&lt;xml&gt;  &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;  &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;  &lt;CreateTime&gt;12345678&lt;/CreateTime&gt;  &lt;MsgType&gt;&lt;![CDATA[news]]&gt;&lt;/MsgType&gt;  &lt;ArticleCount&gt;1&lt;/ArticleCount&gt;  &lt;Articles&gt;    &lt;item&gt;      &lt;Title&gt;&lt;![CDATA[title1]]&gt;&lt;/Title&gt;      &lt;Description&gt;&lt;![CDATA[description1]]&gt;&lt;/Description&gt;      &lt;PicUrl&gt;&lt;![CDATA[picurl]]&gt;&lt;/PicUrl&gt;      &lt;Url&gt;&lt;![CDATA[url]]&gt;&lt;/Url&gt;    &lt;/item&gt;  &lt;/Articles&gt;&lt;/xml&gt;</code></pre><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ToUserName</td><td align="left">是</td><td align="left">接收方帐号（收到的OpenID）</td></tr><tr><td align="left">FromUserName</td><td align="left">是</td><td align="left">开发者微信号</td></tr><tr><td align="left">CreateTime</td><td align="left">是</td><td align="left">消息创建时间 （整型）</td></tr><tr><td align="left">MsgType</td><td align="left">是</td><td align="left">消息类型，图文为news</td></tr><tr><td align="left">ArticleCount</td><td align="left">是</td><td align="left">图文消息个数；当用户发送文本、图片、语音、视频、图文、地理位置这六种消息时，开发者只能回复1条图文消息；其余场景最多可回复8条图文消息</td></tr><tr><td align="left">Articles</td><td align="left">是</td><td align="left">图文消息信息，注意，如果图文数超过限制，则将只发限制内的条数</td></tr><tr><td align="left">Title</td><td align="left">是</td><td align="left">图文消息标题</td></tr><tr><td align="left">Description</td><td align="left">是</td><td align="left">图文消息描述</td></tr><tr><td align="left">PicUrl</td><td align="left">是</td><td align="left">图片链接，支持JPG、PNG格式，较好的效果为大图360<em>200，小图200</em>200</td></tr><tr><td align="left">Url</td><td align="left">是</td><td align="left">点击图文消息跳转链接</td></tr></tbody></table><p>首先封装一个article类,对应就是xml中的item这个节点</p><pre><code class="java">@XStreamAlias(&quot;item&quot;)//映射到xml中的item这个节点public class Article &#123;    @XStreamAlias(&quot;Title&quot;)    private String title;//图文消息标题    @XStreamAlias(&quot;Description&quot;)    private String description;//图文消息描述    @XStreamAlias(&quot;PicUrl&quot;)    private String picUrl;//图片链接    @XStreamAlias(&quot;Url&quot;)    private String url;//点击图文消息跳转链接        //get and set ...&#125;</code></pre><p>然后再封装一个图文消息类</p><pre><code class="java">@XStreamAlias(&quot;xml&quot;)public class NewsMsg extends BaseMsg &#123;        @XStreamAlias(&quot;ArticleCount&quot;)    private String articleCount;//图文消息个数    @XStreamAlias(&quot;Articles&quot;)    private List&lt;Article&gt; articles;    public NewsMsg(Map&lt;String, String&gt; requestMap,List&lt;Article&gt; articles) &#123;        super(requestMap);        this.setMsgType(&quot;news&quot;);        this.articles = articles;        this.setArticleCount(this.articles.size()+&quot;&quot;);    &#125;    //get and set ...&#125;</code></pre><h3 id="9-5-测试"><a href="#9-5-测试" class="headerlink" title="9.5 测试"></a>9.5 测试</h3><p>前面已经将基础消息和图文消息封装好了,现在用封装好的消息类来回复</p><p>第一步：将<code>wxservlet</code>的<code>doPost</code>方法改成如下</p><pre><code class="java">@Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //设置编码格式,不然中文会乱码        req.setCharacterEncoding(&quot;UTF-8&quot;);        resp.setCharacterEncoding(&quot;UTF-8&quot;);        //将请求中的xml参数转成map        Map&lt;String,String&gt; map = WxService.parseRequest(req.getInputStream());        System.out.println(map);        //处理完将响应一个xml给微信        String respXml = WxService.getRespose(map);        System.out.println(respXml);        resp.getWriter().print(respXml);    &#125;</code></pre><p>第二步：WxService添加如下方法：</p><pre><code class="java">/**     * 事件消息回复     */    public static String getRespose(Map&lt;String, String&gt; requestMap) &#123;        BaseMsg msg = null;        // 根据用户发送消息的类型,做不同的处理        String msgType = requestMap.get(&quot;MsgType&quot;);        switch (msgType) &#123;        case &quot;text&quot;:            msg = dealTextMsg(requestMap);            break;        case &quot;news&quot;:            break;        default:            break;        &#125;        // System.out.println(msg);        // 将处理结果转化成xml的字符串返回        if (null != msg) &#123;            return beanToXml(msg);        &#125;        return null;    &#125;    /**     * 将回复的消息类转成xml字符串     *      * @param msg     * @return     */    public static String beanToXml(BaseMsg msg) &#123;        XStream stream = new XStream();        stream.processAnnotations(TextMsg.class);        stream.processAnnotations(NewsMsg.class);        String xml = stream.toXML(msg);        return xml;    &#125;    /**     * 当用户发送是文本消息的处理逻辑     *      * @param map     * @return     */    private static BaseMsg dealTextMsg(Map&lt;String, String&gt; requestMap) &#123;        // 获取用户发送的消息内容        String msg = requestMap.get(&quot;Content&quot;);        // 如果是图文回复一个图文消息        if (msg.equals(&quot;图文&quot;)) &#123;            List&lt;Article&gt; articles = new ArrayList&lt;Article&gt;();            articles.add(new Article(&quot;码云博客&quot;, &quot;这个是我个人的码云博客,基于hexo搭建,里面的文章都是使用markdown编写&quot;,                    &quot;https://heliufang.gitee.io/uploads/banner.jpg&quot;, &quot;https://heliufang.gitee.io/&quot;));            return new NewsMsg(requestMap, articles);        &#125;        //否则回复一个文本消息,文本内容为&#39;当前时间+你好&#39;        //当然这个内容可以自定义,在这里也可以接入自动回复机器人        TextMsg textMsg = new TextMsg(requestMap, new Date(System.currentTimeMillis()).toLocaleString() + &quot;你好&quot;);        return textMsg;    &#125;</code></pre><p>然后分别给公众号发一个1和图文</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210810231459572.png" alt="image-20210810231459572"></p><h3 id="9-6-自动回复机器人"><a href="#9-6-自动回复机器人" class="headerlink" title="9.6 自动回复机器人"></a>9.6 自动回复机器人</h3><p>罗老师教程中的图灵机器人已经要收费.我使用的是阿里云的<code>阿里云小蜜</code>这个机器人来做的回复.</p><p>阿里云小蜜机器人可以免费体验三个月。</p><p>具体代码可以查看阿里云小蜜的文档：<a href="https://help.aliyun.com/document_detail/60221.html">阿里云产品服务协议(云小蜜)</a></p><h2 id="10-★access-token的获取"><a href="#10-★access-token的获取" class="headerlink" title="10 ★access token的获取"></a>10 ★access token的获取</h2><p>access_token是公众号的全局唯一接口调用凭据，<strong>公众号调用各接口时都需使用access_token</strong>。开发者需要进行妥善保存.access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效</p><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html">access token文档</a></p><p>目前access_token的有效期通过返回的<code>expire_in</code>来传达，目前是7200秒之内的值。中控服务器需要根据这个有效时间提前去刷新新access_token</p><p>总结：调用很多接口需要access_token，获取access_token之后需要保存起来,过期了再重新获取,而不是每次都重新获取。</p><p><strong>接口调用请求说明</strong></p><blockquote><p>https请求方式: GET <a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</a></p></blockquote><p><strong>参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">grant_type</td><td align="left">是</td><td align="left">获取access_token填写client_credential</td></tr><tr><td align="left">appid</td><td align="left">是</td><td align="left">第三方用户唯一凭证</td></tr><tr><td align="left">secret</td><td align="left">是</td><td align="left">第三方用户唯一凭证密钥，即appsecret</td></tr></tbody></table><p><strong>返回说明</strong></p><p>正常情况下，微信会返回下述JSON数据包给公众号：</p><pre><code class="json">&#123;&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200&#125;</code></pre><p><strong>参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">获取到的凭证</td></tr><tr><td align="left">expires_in</td><td align="left">凭证有效时间，单位：秒</td></tr></tbody></table><h3 id="10-1-★封装请求工具类"><a href="#10-1-★封装请求工具类" class="headerlink" title="10.1 ★封装请求工具类"></a>10.1 ★封装请求工具类</h3><p>因为需要发送请求给微信服务器,所以需要有请求的工具类。罗老师用的是java自带的请求类，相对来说比较繁琐。所以我这里采用的是Apache HttpClient,这个用起来更加的简单。</p><p>第一步：pom.xml中导入依赖</p><pre><code class="xml">&lt;!--httpClient需要的依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;    &lt;version&gt;4.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--//httpclient缓存--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpclient-cache&lt;/artifactId&gt;    &lt;version&gt;4.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--//http的mime类型都在这里面--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpmime&lt;/artifactId&gt;    &lt;version&gt;4.3.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>第二步：基于<code>Apache HttpClient</code>封装<code>HttpUtils</code>工具类,我封装了4个方法,可以支持get请求和post请求。后面很多需要用的地方直接调用即可。</p><p>可以参考这个博客：<a href="https://www.cnblogs.com/shan-kylin/p/9453514.html">HttpClient发送get&#x2F;post请求</a></p><pre><code class="java">public class HttpUtils &#123;    public static void main(String[] args) &#123;        // 1.测试get请求        /*         String getUrl = &quot;http://localhost:8080/user/searchPage?pageNum=1&amp;pageSize=2&quot;;         System.out.println(sendGet(getUrl));         */                // 2.测试post请求 携带x-www-form-urlencoded数据格式        /*String postUrlForm = &quot;http://localhost:8080/user&quot;;        Map paramMap = new HashMap();        paramMap.put(&quot;name&quot;, &quot;杰克&quot;);        paramMap.put(&quot;age&quot;, &quot;20&quot;);        paramMap.put(&quot;gender&quot;, &quot;1&quot;);        System.out.println(sendPost(postUrlForm, paramMap));*/                //3.测试post请求 携带json数据格式        /*String postUrlJson = &quot;http://localhost:8080/user&quot;;        String jsonParam = &quot;&#123;\&quot;name\&quot;:\&quot;jack\&quot;,\&quot;age\&quot;:\&quot;18\&quot;,\&quot;gender\&quot;:\&quot;2\&quot;&#125;&quot;;        System.out.println(sendPost(postUrlJson,jsonParam));*/                //4 测试post 携带文件        String postUrlFile = &quot;http://localhost:8080/user/upload&quot;;        Map paramMap = new HashMap();        paramMap.put(&quot;name&quot;, &quot;tom&quot;);        String localFile = &quot;d:\\logo.png&quot;;        String fileParamName = &quot;file&quot;;        System.out.println(sendPost(postUrlFile, paramMap,localFile,fileParamName));    &#125;    // 1.httpClient发送get请求    public static String sendGet(String url) &#123;        String result = &quot;&quot;;        CloseableHttpResponse response = null;        try &#123;            // 根据地址获取请求            HttpGet request = new HttpGet(url);// 这里发送get请求            // 获取当前客户端对象            CloseableHttpClient httpClient = HttpClients.createDefault();            // 通过请求对象获取响应对象            response = httpClient.execute(request);            // 判断网络连接状态码是否正常(0--200都数正常)            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123;                result = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (null != response) &#123;                try &#123;                    response.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return result;    &#125;    // 2.httpClient发送post请求 携带x-www-form-urlencoded数据格式    public static String sendPost(String url, Map&lt;String, String&gt; map) &#123;        CloseableHttpResponse httpResponse = null;        String result = &quot;&quot;;        try &#123;            // 1、创建一个httpClient客户端对象            CloseableHttpClient httpClient = HttpClients.createDefault();            // 2、创建一个HttpPost请求            HttpPost httpPost = new HttpPost(url);            // 设置请求头            httpPost.setHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); // 设置传输的数据格式            // 携带普通的参数params的方式            List&lt;BasicNameValuePair&gt; params = new ArrayList&lt;BasicNameValuePair&gt;();            Set&lt;String&gt; keys = map.keySet();            for (String key : keys) &#123;                params.add(new BasicNameValuePair(key, map.get(key)));            &#125;            String str = EntityUtils.toString(new UrlEncodedFormEntity(params, Consts.UTF_8));            // 这里就是：username=kylin&amp;password=123456            System.out.println(str);            // 放参数进post请求里面 从名字可以知道 这个类是专门处理x-www-form-urlencoded 添加参数的            httpPost.setEntity(new UrlEncodedFormEntity(params, &quot;UTF-8&quot;));            // 7、执行post请求操作，并拿到结果            httpResponse = httpClient.execute(httpPost);            // 获取结果实体            HttpEntity entity = httpResponse.getEntity();            if (entity != null) &#123;                result = EntityUtils.toString(entity, &quot;UTF-8&quot;);            &#125; else &#123;                EntityUtils.consume(entity);//// 如果entity为空，那么直接消化掉即可            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (null != httpResponse) &#123;                try &#123;                    httpResponse.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return result;    &#125;    // 3.httpClient发送post请求 携带json数据格式    public static String sendPost(String url, String jsonStr) &#123;        CloseableHttpResponse httpResponse = null;        String result = &quot;&quot;;        try &#123;            // 1.创建httpClient            CloseableHttpClient httpClient = HttpClients.createDefault();            // 2.创建post请求方式实例            HttpPost httpPost = new HttpPost(url);            // 2.1设置请求头 发送的是json数据格式            httpPost.setHeader(&quot;Content-type&quot;, &quot;application/json;charset=utf-8&quot;);            httpPost.setHeader(&quot;Connection&quot;, &quot;Close&quot;);            // 3.设置参数---设置消息实体 也就是携带的数据            /*             * 比如传递： &#123; &quot;username&quot;: &quot;aries&quot;, &quot;password&quot;: &quot;666666&quot; &#125;             */            //String jsonStr = &quot; &#123;\&quot;username\&quot;:\&quot;aries\&quot;,\&quot;password\&quot;:\&quot;666666\&quot;&#125;&quot;;            StringEntity entity = new StringEntity(jsonStr.toString(), Charset.forName(&quot;UTF-8&quot;));            entity.setContentEncoding(&quot;UTF-8&quot;); // 设置编码格式            // 发送Json格式的数据请求            entity.setContentType(&quot;application/json&quot;);            // 把请求消息实体塞进去            httpPost.setEntity(entity);            // 4.执行http的post请求            // 4.执行post请求操作，并拿到结果            httpResponse = httpClient.execute(httpPost);            // 获取结果实体            HttpEntity httpEntity = httpResponse.getEntity();            if (httpEntity != null) &#123;                result = EntityUtils.toString(httpEntity, &quot;UTF-8&quot;);            &#125; else &#123;                EntityUtils.consume(httpEntity);//// 如果httpEntity为空，那么直接消化掉即可            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (null != httpResponse) &#123;                try &#123;                    httpResponse.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return result;    &#125;    // 4.httpClient发送post请求 携带文件    public static String sendPost(String url, Map&lt;String, String&gt; map,String localFile, String fileParamName) &#123;        HttpPost httpPost = new HttpPost(url);        CloseableHttpClient httpClient = HttpClients.createDefault();        String resultString = &quot;&quot;;        CloseableHttpResponse response = null;        try &#123;            // 把文件转换成流对象FileBody            FileBody bin = new FileBody(new File(localFile));            MultipartEntityBuilder builder = MultipartEntityBuilder.create();            // 相当于&lt;input type=&quot;file&quot; name=&quot;fileParamName&quot;/&gt; 其中fileParamName以传进来的为准            builder.addPart(fileParamName, bin);            // 相当于&lt;input type=&quot;text&quot; name=&quot;userName&quot; value=userName&gt;            /*builder.addPart(&quot;filesFileName&quot;,                    new StringBody(fileParamName, ContentType.create(&quot;text/plain&quot;, Consts.UTF_8)));*/            if (map != null) &#123;                for (String key : map.keySet()) &#123;                    builder.addPart(key,                            new StringBody(map.get(key), ContentType.create(&quot;text/plain&quot;, Consts.UTF_8)));                &#125;            &#125;            HttpEntity reqEntity = builder.build();            httpPost.setEntity(reqEntity);            // 发起请求 并返回请求的响应            response = httpClient.execute(httpPost, HttpClientContext.create());            resultString = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;);        &#125;  catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if (response != null)                    response.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        return resultString;    &#125;&#125;</code></pre><h3 id="10-2-创建AccessToken类"><a href="#10-2-创建AccessToken类" class="headerlink" title="10.2 创建AccessToken类"></a>10.2 创建AccessToken类</h3><pre><code class="java">public class AccessToken &#123;    private String token;    private long expiresTime;//过期时间        public AccessToken(String token, String expiresIn) &#123;        super();        this.token = token;        //当前时间+有效期 = 过期时间        this.expiresTime = System.currentTimeMillis()+Integer.parseInt(expiresIn);    &#125;        /**     * 判断token是否过期     * @return     */    public boolean isExpire() &#123;        return System.currentTimeMillis() &gt; expiresTime;    &#125;    //get and set ...&#125;</code></pre><h3 id="10-3-WxService中添加获取AccessToken的方法"><a href="#10-3-WxService中添加获取AccessToken的方法" class="headerlink" title="10.3 WxService中添加获取AccessToken的方法"></a>10.3 WxService中添加获取AccessToken的方法</h3><pre><code class="java">private static AccessToken at;//token获取的次数有限,有效期也有限,所以需要保存起来private static String GET_TOKEN_URL = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET&quot;;        //登录测试号管理界面-测试号信息下面可以得到你的APPID和APPSECRET    private static String APPID = &quot;wx7bf783afc5150a5a&quot;;    private static String APPSECRET = &quot;8d9930d60717c7aaa0620ad993d984d8&quot;;/**     * 发送get请求获取AccessToken     */    private static void getToken() &#123;        String url = GET_TOKEN_URL.replace(&quot;APPID&quot;, APPID).replace(&quot;APPSECRET&quot;, APPSECRET);        String tokenStr = HttpUtils.sendGet(url);//调用工具类发get请求        System.out.println(tokenStr);        JSONObject jsonObject = JSONObject.parseObject(tokenStr);        String token = jsonObject.getString(&quot;access_token&quot;);        String expiresIn = jsonObject.getString(&quot;expires_in&quot;);        at = new AccessToken(token, expiresIn);    &#125;        /**     * 获取AccessToken  向外提供     */    public static String getAccessToken() &#123;        //过期了或者没有值再去发送请求获取        if(at == null || at.isExpire()) &#123;            getToken();        &#125;        return at.getToken();    &#125;</code></pre><p>编写一个测试类获取AccessToken</p><pre><code class="java">import org.junit.Test;import com.qy.service.WxService;public class TestToken &#123;    @Test    public void getAccessToken() &#123;        //可以看到下面两次获取的值一致        System.out.println(WxService.getAccessToken());        System.out.println(WxService.getAccessToken());    &#125;&#125;</code></pre><h2 id="11-自定义菜单"><a href="#11-自定义菜单" class="headerlink" title="11 自定义菜单"></a>11 自定义菜单</h2><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Custom_Menus/Creating_Custom-Defined_Menu.html">自定义菜单文档</a></p><p>请注意：</p><ol><li>自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。</li><li>一级菜单最多4个汉字，二级菜单最多8个汉字，多出来的部分将会以“…”代替。</li><li>创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果。</li></ol><p>自定义菜单接口可实现多种类型按钮，如下：</p><ol><li>click：点击推事件用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互；</li><li>view：跳转URL用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。</li><li>scancode_push：扫码推事件用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。</li><li>scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。</li><li>pic_sysphoto：弹出系统拍照发图用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。</li><li>pic_photo_or_album：弹出拍照或者相册发图用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。</li><li>pic_weixin：弹出微信相册发图器用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。</li><li>location_select：弹出地理位置选择器用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。</li><li>media_id：下发消息（除文本消息）用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频、图文消息。请注意：永久素材id必须是在“素材管理&#x2F;新增永久素材”接口上传后获得的合法id。</li><li>view_limited：跳转图文消息URL用户点击view_limited类型按钮后，微信客户端将打开开发者在按钮中填写的永久素材id对应的图文消息URL，永久素材类型只支持图文消息。请注意：永久素材id必须是在“素材管理&#x2F;新增永久素材”接口上传后获得的合法id。</li></ol><p><strong>接口调用请求说明</strong></p><p>http请求方式：POST（请使用https协议） <a href="https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN</a></p><p>url中的ACCESS_TOKEN就是之前获取的,调用这个接口需要带上</p><p>请求需携带json参数</p><pre><code class="json">&#123; &quot;button&quot;:[     &#123;           &quot;type&quot;:&quot;click&quot;,          &quot;name&quot;:&quot;一级点击&quot;,          &quot;key&quot;:&quot;1&quot;     &#125;,     &#123;           &quot;type&quot;:&quot;view&quot;,          &quot;name&quot;:&quot;个人博客&quot;,          &quot;url&quot;:&quot;https://heliufang.gitee.io/&quot;     &#125;,     &#123;          &quot;name&quot;:&quot;有子菜单&quot;,          &quot;sub_button&quot;:[              &#123;                  &quot;type&quot;:&quot;click&quot;,                  &quot;name&quot;:&quot;三一点击&quot;,                  &quot;key&quot;:&quot;31&quot;            &#125;,            &#123;                  &quot;type&quot;:&quot;view&quot;,                  &quot;name&quot;:&quot;码云博客&quot;,                  &quot;url&quot;:&quot;https://heliufang.gitee.io/&quot;            &#125;,            &#123;                &quot;type&quot;:&quot;pic_photo_or_album&quot;,                &quot;name&quot;:&quot;拍照或发图&quot;,                &quot;key&quot;:&quot;33&quot;            &#125;          ]     &#125; ]&#125;</code></pre><p><strong>参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">button</td><td align="left">是</td><td align="left">一级菜单数组，个数应为1~3个</td></tr><tr><td align="left">sub_button</td><td align="left">否</td><td align="left">二级菜单数组，个数应为1~5个</td></tr><tr><td align="left">type</td><td align="left">是</td><td align="left">菜单的响应动作类型，view表示网页类型，click表示点击类型，miniprogram表示小程序类型</td></tr><tr><td align="left">name</td><td align="left">是</td><td align="left">菜单标题，不超过16个字节，子菜单不超过60个字节</td></tr><tr><td align="left">key</td><td align="left">click等点击类型必须</td><td align="left">菜单KEY值，用于消息接口推送，不超过128字节</td></tr><tr><td align="left">url</td><td align="left">view、miniprogram类型必须</td><td align="left">网页 链接，用户点击菜单可打开链接，不超过1024字节。 type为miniprogram时，不支持小程序的老版本客户端将打开本url。</td></tr><tr><td align="left">media_id</td><td align="left">media_id类型和view_limited类型必须</td><td align="left">调用新增永久素材接口返回的合法media_id</td></tr><tr><td align="left">appid</td><td align="left">miniprogram类型必须</td><td align="left">小程序的appid（仅认证公众号可配置）</td></tr><tr><td align="left">pagepath</td><td align="left">miniprogram类型必须</td><td align="left">小程序的页面路径</td></tr></tbody></table><p><strong>返回结果</strong></p><p>正确时的返回JSON数据包如下：</p><pre><code class="json">&#123;&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;&#125;</code></pre><p>错误时的返回JSON数据包如下（示例为无效菜单名长度）：</p><pre><code class="json">&#123;&quot;errcode&quot;:40018,&quot;errmsg&quot;:&quot;invalid button name size&quot;&#125;</code></pre><p>和前面xml的类似,我们需要对着请求的json数据封装按钮类,这样后面操作起来就比较方便,而且也方便维护。</p><h3 id="11-1-封装菜单类"><a href="#11-1-封装菜单类" class="headerlink" title="11.1 封装菜单类"></a>11.1 封装菜单类</h3><p>&lt;1&gt;AbstractButton类</p><pre><code class="java">//所有菜单(按钮)的父类public abstract class AbstractButton &#123;    private String name;//按钮标题    public String getName() &#123;        return this.name;    &#125;    public void setName(final String name) &#123;        this.name = name;    &#125;    public AbstractButton(final String name) &#123;        this.name = name;    &#125;&#125;</code></pre><p>&lt;2&gt;Button类</p><pre><code class="java">//一级菜单对象public class Button &#123;    private List&lt;AbstractButton&gt; button;    public Button() &#123;        this.button = new ArrayList&lt;AbstractButton&gt;();    &#125;    public List&lt;AbstractButton&gt; getButton() &#123;        return this.button;    &#125;    public void setButton(final List&lt;AbstractButton&gt; button) &#123;        this.button = button;    &#125;&#125;</code></pre><p>&lt;3&gt;ClickButton类</p><pre><code class="java">//点击类型的菜单public class ClickButton extends AbstractButton &#123;    private String type;    private String key;    public String getType() &#123;        return this.type;    &#125;    public void setType(final String type) &#123;        this.type = type;    &#125;    public String getKey() &#123;        return this.key;    &#125;    public void setKey(final String key) &#123;        this.key = key;    &#125;    public ClickButton(final String name, final String key) &#123;        super(name);        this.type = &quot;click&quot;;//点击类型        this.key = key;    &#125;&#125;</code></pre><p>&lt;4&gt;ViewButton类</p><pre><code class="java">//网页类型的菜单public class ViewButton extends AbstractButton &#123;    private String type;    private String url;    public String getType() &#123;        return this.type;    &#125;    public void setType(final String type) &#123;        this.type = type;    &#125;    public String getUrl() &#123;        return this.url;    &#125;    public void setUrl(final String url) &#123;        this.url = url;    &#125;    public ViewButton(final String name, final String url) &#123;        super(name);        this.type = &quot;view&quot;;//网页类型        this.url = url;    &#125;&#125;</code></pre><p>&lt;5&gt; PhotoOrAlbumButton</p><pre><code class="java">//拍照或传图菜单public class PhotoOrAlbumButton extends AbstractButton&#123;    private String type;    private String key;    public PhotoOrAlbumButton(String name,String key) &#123;        super(name);        this.type = &quot;pic_photo_or_album&quot;;//拍照获取传图        this.key = key;    &#125;    public String getType() &#123;        return type;    &#125;    public void setType(String type) &#123;        this.type = type;    &#125;    public String getKey() &#123;        return key;    &#125;    public void setKey(String key) &#123;        this.key = key;    &#125;&#125;</code></pre><p>&lt;6&gt;SubButton</p><pre><code class="java">import java.util.ArrayList;import java.util.List;//二级菜单对象public class SubButton extends AbstractButton &#123;    private List&lt;AbstractButton&gt; sub_button;    public List&lt;AbstractButton&gt; getSub_button() &#123;        return this.sub_button;    &#125;    public void setSub_button(final List&lt;AbstractButton&gt; sub_button) &#123;        this.sub_button = sub_button;    &#125;    public SubButton(final String name) &#123;        super(name);        this.sub_button = new ArrayList&lt;AbstractButton&gt;();    &#125;&#125;</code></pre><h3 id="11-2-测试"><a href="#11-2-测试" class="headerlink" title="11.2 测试"></a>11.2 测试</h3><p>新增一个Test方法</p><pre><code class="java">package com.qy.test;import java.util.ArrayList;import java.util.List;import org.junit.Test;import com.alibaba.fastjson.JSONObject;import com.qy.entity.button.AbstractButton;import com.qy.entity.button.Button;import com.qy.entity.button.ClickButton;import com.qy.entity.button.PhotoOrAlbumButton;import com.qy.entity.button.SubButton;import com.qy.entity.button.ViewButton;import com.qy.service.WxService;import com.qy.utils.HttpUtils;public class TestButton &#123;    @Test    public void setButton() &#123;        //创建一级菜单        Button button = new Button();        //在第三个菜单中创建二级菜单        SubButton subButton = new SubButton(&quot;有子菜单&quot;);        List&lt;AbstractButton&gt; list2 = new ArrayList();        list2.add(new ClickButton(&quot;三一点击&quot;, &quot;31&quot;));        list2.add(new ViewButton(&quot;码云博客&quot;, &quot;https://heliufang.gitee.io/&quot;));        list2.add(new PhotoOrAlbumButton(&quot;拍照或发图&quot;,&quot;33&quot;));        subButton.setSub_button(list2);        //在一级菜单中添加三个按钮,        List&lt;AbstractButton&gt; list = new ArrayList();        list.add(new ClickButton(&quot;一级点击&quot;, &quot;1&quot;));        list.add(new ViewButton(&quot;个人博客&quot;, &quot;https://heliufang.gitee.io/&quot;));        list.add(subButton);        button.setButton(list);        //转成json格式字符串        String jsonString = JSONObject.toJSONString(button);        //System.out.println(jsonString);        //发送请求        String url = &quot;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN&quot;;        url = url.replace(&quot;ACCESS_TOKEN&quot;, WxService.getAccessToken());//把token带上        String result = HttpUtils.sendPost(url, jsonString);        System.out.println(result);    &#125;&#125;</code></pre><p>运行效果如下：</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210813000312449.png" alt="image-20210813000312449"></p><h2 id="12-设置和获取行业信息"><a href="#12-设置和获取行业信息" class="headerlink" title="12 设置和获取行业信息"></a>12 设置和获取行业信息</h2><h3 id="12-1-设置行业信息"><a href="#12-1-设置行业信息" class="headerlink" title="12.1 设置行业信息"></a>12.1 设置行业信息</h3><p>如果要发送模板消息,那么首先就得设置行业信息,如何设置和获取可以看下面接口。</p><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Interface.html">模板消息文档</a></p><p>设置行业可在微信公众平台后台完成，每月可修改行业1次，帐号仅可使用所属行业中相关的模板，为方便第三方开发者，提供通过接口调用的方式来修改账号所属行业，具体如下：</p><p><strong>接口调用请求说明</strong></p><blockquote><p>http请求方式: POST <a href="https://api.weixin.qq.com/cgi-bin/template/api_set_industry?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/template/api_set_industry?access_token=ACCESS_TOKEN</a></p></blockquote><p><strong>POST数据说明</strong></p><p>POST数据示例如下：</p><pre><code class="json">&#123;    &quot;industry_id1&quot;:&quot;1&quot;,    &quot;industry_id2&quot;:&quot;4&quot;&#125;</code></pre><p>参数说明</p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">是</td><td align="left">接口调用凭证</td></tr><tr><td align="left">industry_id1</td><td align="left">是</td><td align="left">公众号模板消息所属行业编号-主行业</td></tr><tr><td align="left">industry_id2</td><td align="left">是</td><td align="left">公众号模板消息所属行业编号-副行业</td></tr></tbody></table><p><strong>行业代码查询</strong>,更多代码可以查询文档</p><table><thead><tr><th align="left">主行业</th><th align="left">副行业</th><th align="left">代码</th></tr></thead><tbody><tr><td align="left">IT科技</td><td align="left">互联网&#x2F;电子商务</td><td align="left">1</td></tr><tr><td align="left">IT科技</td><td align="left">IT软件与服务</td><td align="left">2</td></tr><tr><td align="left">IT科技</td><td align="left">IT硬件与设备</td><td align="left">3</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>编写测试代码</p><pre><code class="java">@Test    public void setIndustry() &#123;        String url = &quot;https://api.weixin.qq.com/cgi-bin/template/api_set_industry?access_token=ACCESS_TOKEN&quot;;        url = url.replace(&quot;ACCESS_TOKEN&quot;, WxService.getAccessToken());        String jsonStr = &quot;&#123;\&quot;industry_id1\&quot;:\&quot;1\&quot;,\&quot;industry_id2\&quot;:\&quot;4\&quot;&#125;&quot;;        String rString = HttpUtils.sendPost(url, jsonStr);        System.out.println(rString);    &#125;</code></pre><h3 id="12-2-获取行业信息"><a href="#12-2-获取行业信息" class="headerlink" title="12.2 获取行业信息"></a>12.2 获取行业信息</h3><p>获取帐号设置的行业信息。可登录微信公众平台，在公众号后台中查看行业信息。为方便第三方开发者，提供通过接口调用的方式来获取帐号所设置的行业信息，具体如下:</p><p><strong>接口调用请求说明</strong></p><blockquote><p>http请求方式：GET <a href="https://api.weixin.qq.com/cgi-bin/template/get_industry?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/template/get_industry?access_token=ACCESS_TOKEN</a></p></blockquote><p><strong>参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">是</td><td align="left">接口调用凭证</td></tr></tbody></table><p><strong>返回说明</strong></p><p>正确调用后的返回示例：</p><pre><code class="json">&#123;    &quot;primary_industry&quot;:&#123;&quot;first_class&quot;:&quot;运输与仓储&quot;,&quot;second_class&quot;:&quot;快递&quot;&#125;,    &quot;secondary_industry&quot;:&#123;&quot;first_class&quot;:&quot;IT科技&quot;,&quot;second_class&quot;:&quot;互联网|电子商务&quot;&#125;&#125;</code></pre><p>返回参数说明</p><table><thead><tr><th align="left">参数</th><th align="left">是否必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">是</td><td align="left">接口调用凭证</td></tr><tr><td align="left">primary_industry</td><td align="left">是</td><td align="left">帐号设置的主营行业</td></tr><tr><td align="left">secondary_industry</td><td align="left">是</td><td align="left">帐号设置的副营行业</td></tr></tbody></table><p>编写测试代码</p><pre><code class="java">@Test    public void getIndustry() &#123;        String url = &quot;https://api.weixin.qq.com/cgi-bin/template/get_industry?access_token=ACCESS_TOKEN&quot;;        url = url.replace(&quot;ACCESS_TOKEN&quot;, WxService.getAccessToken());        String string = HttpUtils.sendGet(url);        System.out.println(string);    &#125;</code></pre><h2 id="13-发送模板消息"><a href="#13-发送模板消息" class="headerlink" title="13 发送模板消息"></a>13 发送模板消息</h2><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Interface.html">模板消息接口</a></p><p>就是微信主动给用户推送消息,不需要像之前那样被动(用户发送之后再回复).</p><p><strong>接口调用请求说明</strong></p><blockquote><p>http请求方式: POST <a href="https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKEN">https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKEN</a></p></blockquote><p>POST数据如下：</p><pre><code class="json">&#123;    &quot;touser&quot;: &quot;oQxvI51GI5t9wBaBjmBXgJZZVM3A&quot;,    &quot;template_id&quot;: &quot;tQ0G9Pmd_n_ylmplYsEnexgabkJXH1S3J7BXahK454g&quot;,    &quot;url&quot;: &quot;https://heliufang.gitee.io/&quot;,    &quot;data&quot;: &#123;        &quot;first&quot;: &#123;            &quot;value&quot;: &quot;您好!您投递的简历有新的反馈&quot;,            &quot;color&quot;: &quot;#173177&quot;        &#125;,        &quot;company&quot;: &#123;            &quot;value&quot;: &quot;广州壹新网络科技有限公司&quot;,            &quot;color&quot;: &quot;#173177&quot;        &#125;,        &quot;time&quot;: &#123;            &quot;value&quot;: &quot;2021-8-5 23:31:23&quot;,            &quot;color&quot;: &quot;#173177&quot;        &#125;,        &quot;result&quot;: &#123;            &quot;value&quot;: &quot;已通过&quot;,            &quot;color&quot;: &quot;#ff0000&quot;        &#125;,        &quot;remark&quot;: &#123;            &quot;value&quot;: &quot;带身份证&quot;,            &quot;color&quot;: &quot;#173177&quot;        &#125;    &#125;&#125;</code></pre><p>参数说明</p><table><thead><tr><th align="left">参数</th><th align="left">是否必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">touser</td><td align="left">是</td><td align="left">接收者openid</td></tr><tr><td align="left">template_id</td><td align="left">是</td><td align="left">模板ID,这个需要在管理界面配置</td></tr><tr><td align="left">url</td><td align="left">否</td><td align="left">模板跳转链接（海外帐号没有跳转能力）</td></tr><tr><td align="left">data</td><td align="left">是</td><td align="left">模板数据</td></tr><tr><td align="left">color</td><td align="left">否</td><td align="left">模板内容字体颜色，不填默认为黑色</td></tr></tbody></table><p><strong>返回码说明</strong></p><p>在调用模板消息接口后，会返回JSON数据包。正常时的返回JSON数据包示例：</p><pre><code class="json">&#123;&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;,&quot;msgid&quot;:200228332&#125;</code></pre><p>★第一步：在微信测试号管理后台配置模板：</p><ul><li><p>模板标题: 简历反馈提醒</p></li><li><p>模板内容：</p></li></ul><pre><code>&#123;&#123;first.DATA&#125;&#125; 公司名：&#123;&#123;company.DATA&#125;&#125; 投递时间：&#123;&#123;time.DATA&#125;&#125; 反馈结果：&#123;&#123;result.DATA&#125;&#125; &#123;&#123;remark.DATA&#125;&#125;</code></pre><p>创建好之后是下面这个样子</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210814170124702.png" alt="image-20210814170124702"></p><p>第二步：编写代码</p><pre><code class="java">@Test    public void sendTemplateMsg() &#123;        String url = &quot;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=ACCESS_TOKEN&quot;;        url = url.replace(&quot;ACCESS_TOKEN&quot;, WxService.getAccessToken());        //实际开发中应封装成java类,再把java对象转成类似下面的jsonstr        String jsonStr = &quot;&#123;\r\n&quot; +                 &quot;    \&quot;touser\&quot;: \&quot;oQxvI51GI5t9wBaBjmBXgJZZVM3A\&quot;,\r\n&quot; +                 &quot;    \&quot;template_id\&quot;: \&quot;tQ0G9Pmd_n_ylmplYsEnexgabkJXH1S3J7BXahK454g\&quot;,\r\n&quot; +                 &quot;    \&quot;url\&quot;: \&quot;https://heliufang.gitee.io/\&quot;,\r\n&quot; +                 &quot;    \&quot;data\&quot;: &#123;\r\n&quot; +                 &quot;        \&quot;first\&quot;: &#123;\r\n&quot; +                 &quot;            \&quot;value\&quot;: \&quot;您好!您投递的简历有新的反馈\&quot;,\r\n&quot; +                 &quot;            \&quot;color\&quot;: \&quot;#173177\&quot;\r\n&quot; +                 &quot;        &#125;,\r\n&quot; +                 &quot;        \&quot;company\&quot;: &#123;\r\n&quot; +                 &quot;            \&quot;value\&quot;: \&quot;广州壹新网络科技有限公司\&quot;,\r\n&quot; +                 &quot;            \&quot;color\&quot;: \&quot;#173177\&quot;\r\n&quot; +                 &quot;        &#125;,\r\n&quot; +                 &quot;        \&quot;time\&quot;: &#123;\r\n&quot; +                 &quot;            \&quot;value\&quot;: \&quot;2021-8-5 23:31:23\&quot;,\r\n&quot; +                 &quot;            \&quot;color\&quot;: \&quot;#173177\&quot;\r\n&quot; +                 &quot;        &#125;,\r\n&quot; +                 &quot;        \&quot;result\&quot;: &#123;\r\n&quot; +                 &quot;            \&quot;value\&quot;: \&quot;已通过\&quot;,\r\n&quot; +                 &quot;            \&quot;color\&quot;: \&quot;#ff0000\&quot;\r\n&quot; +                 &quot;        &#125;,\r\n&quot; +                 &quot;        \&quot;remark\&quot;: &#123;\r\n&quot; +                 &quot;            \&quot;value\&quot;: \&quot;带身份证\&quot;,\r\n&quot; +                 &quot;            \&quot;color\&quot;: \&quot;#173177\&quot;\r\n&quot; +                 &quot;        &#125;\r\n&quot; +                 &quot;    &#125;\r\n&quot; +                 &quot;&#125;&quot;;        String rString = HttpUtils.sendPost(url, jsonStr);        System.out.println(rString);    &#125;</code></pre><p>测试结果如下</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210814171316722.png" alt="image-20210814171316722"></p><h2 id="14-新增和获取临时素材"><a href="#14-新增和获取临时素材" class="headerlink" title="14 新增和获取临时素材"></a>14 新增和获取临时素材</h2><p>公众号经常有需要用到一些临时性的多媒体素材的场景，例如在使用接口特别是发送消息时，对多媒体文件、多媒体消息的获取和调用等操作，是通过media_id来进行的。素材管理接口对所有认证的订阅号和服务号开放。</p><p>注意点：</p><p>1、临时素材media_id是可复用的。</p><p>2、<strong>媒体文件在微信后台保存时间为3天，即3天后media_id失效。</strong></p><p>3、上传临时素材的格式、大小限制与公众平台官网一致。</p><p>图片（image）: 10M，支持PNG\JPEG\JPG\GIF格式</p><p>语音（voice）：2M，播放长度不超过60s，支持AMR\MP3格式</p><p>视频（video）：10MB，支持MP4格式</p><p>缩略图（thumb）：64KB，支持JPG格式</p><h3 id="14-1-新增临时素材"><a href="#14-1-新增临时素材" class="headerlink" title="14.1 新增临时素材"></a>14.1 新增临时素材</h3><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Asset_Management/New_temporary_materials.html">新增临时素材文档</a></p><p>罗老师用的是java自带的文件类上传,代码比较繁琐。而我使用HttpClient封装的HttpUtils上传就很简单了。</p><p><strong>接口调用请求说明</strong></p><blockquote><p>http请求方式: POST <a href="https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&amp;type=TYPE">https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&amp;type=TYPE</a></p></blockquote><p><strong>参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">是</td><td align="left">调用接口凭证</td></tr><tr><td align="left">type</td><td align="left">是</td><td align="left">媒体文件类型，分别有图片（image）、语音（voice）、视频（video）和缩略图（thumb）</td></tr><tr><td align="left">media</td><td align="left">是</td><td align="left">form-data中媒体文件标识，有filename、filelength、content-type等信息</td></tr></tbody></table><p><strong>返回说明</strong></p><p>正确情况下的返回JSON数据包结果如下：</p><pre><code class="json">&#123;&quot;type&quot;:&quot;image&quot;,&quot;media_id&quot;:&quot;atL80WWRNpMWhivoIGf9KTUUUO5pm6RxML8OPEUd7cbfb1Rs0kl2Yv0319KMQI-0&quot;,&quot;created_at&quot;:1628933345,&quot;item&quot;:[]&#125;</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">媒体文件类型，分别有图片（image）、语音（voice）、视频（video）和缩略图（thumb，主要用于视频与音乐格式的缩略图）</td></tr><tr><td align="left">media_id</td><td align="left">媒体文件上传后，获取标识</td></tr><tr><td align="left">created_at</td><td align="left">媒体文件上传时间戳</td></tr></tbody></table><p>编写测试代码</p><pre><code class="java">//上传图片    @Test    public void uploadMedia() &#123;        String url = &quot;https://api.weixin.qq.com/cgi-bin/media/upload?access_token=ACCESS_TOKEN&amp;type=TYPE&quot;;        url = url.replace(&quot;ACCESS_TOKEN&quot;, WxService.getAccessToken());        url = url.replace(&quot;TYPE&quot;, &quot;image&quot;);        String string = HttpUtils.sendPost(url, null, &quot;C:\\Users\\Administrator\\Desktop\\2.jpg&quot;, &quot;&quot;);        System.out.println(string);    &#125;</code></pre><h3 id="14-2-获取临时素材"><a href="#14-2-获取临时素材" class="headerlink" title="14.2 获取临时素材"></a>14.2 获取临时素材</h3><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Asset_Management/Get_temporary_materials.html">获取临时素材文档</a></p><p><strong>接口调用请求说明</strong></p><blockquote><p>http请求方式: GET,https调用 <a href="https://api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID">https://api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID</a> 请求示例（示例为通过curl命令获取多媒体文件） curl -I -G “<a href="https://api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID&quot;">https://api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID&quot;</a></p></blockquote><p>把ACCESS_TOKEN和MEDIA_ID替换到url的位置,然后浏览器打开就可以下载了</p><p><strong>参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">是</td><td align="left">调用接口凭证</td></tr><tr><td align="left">media_id</td><td align="left">是</td><td align="left">媒体文件ID</td></tr></tbody></table><p><strong>返回说明</strong></p><p>正确情况下的返回HTTP头如下：</p><pre><code class="text">HTTP/1.1 200 OKConnection: closeContent-Type: image/jpegContent-disposition: attachment; filename=&quot;MEDIA_ID.jpg&quot;Date: Sun, 06 Jan 2013 10:20:18 GMTCache-Control: no-cache, must-revalidateContent-Length: 339721curl -G &quot;https://api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&amp;media_id=MEDIA_ID&quot;</code></pre><h2 id="15-二维码生成和扫描"><a href="#15-二维码生成和扫描" class="headerlink" title="15 二维码生成和扫描"></a>15 二维码生成和扫描</h2><h3 id="15-1-生成带参数的临时二维码"><a href="#15-1-生成带参数的临时二维码" class="headerlink" title="15.1 生成带参数的临时二维码"></a>15.1 生成带参数的临时二维码</h3><p>为了满足用户渠道推广分析和用户帐号绑定等场景的需要，公众平台提供了生成带参数二维码的接口。使用该接口可以获得多个带不同场景值的二维码，用户扫描后，公众号可以接收到事件推送。</p><p>目前有2种类型的二维码：</p><p>1、<code>临时二维码</code>，是有过期时间的，最长可以设置为在二维码生成后的30天（即2592000秒）后过期，但能够生成较多数量。临时二维码主要用于帐号绑定等不要求二维码永久保存的业务场景 2、<code>永久二维码</code>，是无过期时间的，但数量较少（目前为最多10万个）。永久二维码主要用于适用于帐号绑定、用户来源统计等场景。</p><p><strong>获取带参数的二维码的过程包括两步，首先创建二维码ticket，然后凭借ticket到指定URL换取二维码。</strong></p><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Account_Management/Generating_a_Parametric_QR_Code.html">生成带参数的二维码文档</a></p><p>测试代码将实现下面这样一个功能,点击页面上的生成按钮,在页面展示生成好的二维码</p><p>【index.jsp】</p><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;二维码测试页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;   &lt;button type=&quot;button&quot;&gt;生成二维码&lt;/button&gt;&lt;br&gt;   &lt;img alt=&quot;暂无图片&quot; src=&quot;&quot;&gt;&lt;/body&gt;&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt;   $(&quot;button&quot;).click(function()&#123;       $.ajax(&#123;           url: &quot;/wx/getQrCode&quot;,           type: &quot;get&quot;,           dataType: &quot;json&quot;,           success: function(resp)&#123;               console.log(resp);               //通过ticket获取图片               var src = &quot;https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=&quot;+resp.ticket;               $(&quot;img&quot;).attr(&quot;src&quot;,src)           &#125;       &#125;)   &#125;)&lt;/script&gt;&lt;/html&gt;</code></pre><p>【后端servlet】</p><pre><code class="java">@WebServlet(&quot;/getQrCode&quot;)public class QrCodeServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //设置编码格式,不然中文会乱码        req.setCharacterEncoding(&quot;UTF-8&quot;);        resp.setCharacterEncoding(&quot;UTF-8&quot;);        //发送post请求获取ticket,页面通过ticket就可以展示二维码图片了        String url = &quot;https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=TOKEN&quot;;        url = url.replace(&quot;TOKEN&quot;, WxService.getAccessToken());        /*600表示10分钟有效  scene_str是一个唯一标识,类似点击事件的key, QR_STR_SCENE表示临时二维码         * &#123;                &quot;expire_seconds&quot;: 600,                 &quot;action_name&quot;: &quot;QR_STR_SCENE&quot;,                 &quot;action_info&quot;: &#123;                    &quot;scene&quot;: &#123;                        &quot;scene_str&quot;: &quot;test&quot;                                            &#125;                &#125;            &#125;         */        String jsonStr = &quot;&#123;\r\n&quot; +                 &quot;    \&quot;expire_seconds\&quot;: 600, \r\n&quot; +                 &quot;    \&quot;action_name\&quot;: \&quot;QR_STR_SCENE\&quot;, \r\n&quot; +                 &quot;    \&quot;action_info\&quot;: &#123;\r\n&quot; +                 &quot;        \&quot;scene\&quot;: &#123;\r\n&quot; +                 &quot;            \&quot;scene_str\&quot;: \&quot;test\&quot;\r\n&quot; +                 &quot;            \r\n&quot; +                 &quot;        &#125;\r\n&quot; +                 &quot;    &#125;\r\n&quot; +                 &quot;&#125;&quot;;        String string = HttpUtils.sendPost(url, jsonStr);        JSONObject object = JSONObject.parseObject(string);        //将响应结果返回页面,用于显示二维码        resp.getWriter().write(string);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    &#125;&#125;</code></pre><p>访问页面,点击按钮就可以看到如下效果</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210814182247464.png" alt="image-20210814182247464"></p><h3 id="15-2-扫描二维码"><a href="#15-2-扫描二维码" class="headerlink" title="15.2 扫描二维码"></a>15.2 扫描二维码</h3><p>用户扫描带场景值二维码时，可能推送以下两种事件：</p><p>如果用户还未关注公众号，则用户可以关注公众号，关注后微信会将带场景值关注事件推送给开发者。</p><p>如果用户已经关注公众号，在用户扫描后会自动进入会话，微信也会将带场景值扫描事件推送给开发者</p><p>扫描临时二维码之后,会向服务器推送一个xml数据包,解析之后打印效果如下：</p><pre><code>&#123;Ticket=gQFr8DwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAya1JKeDQ2M3JmOEQxOGlybk54Y08AAgS6mBdhAwRYAgAA, FromUserName=oQxvI51GI5t9wBaBjmBXgJZZVM3A,EventKey=test, Event=SCAN, CreateTime=1628936703, ToUserName=gh_c8af0521f09a, MsgType=event&#125;</code></pre><p>实现扫码之后给用户回复一个[你扫码了]</p><p>修改【WxService】的代码，修改getRespose方法,新增dealEvent和dealScanEvent方法</p><pre><code class="java">/**     * 事件消息回复     */    public static String getRespose(Map&lt;String, String&gt; requestMap) &#123;        BaseMsg msg = null;        // 根据用户发送消息的类型,做不同的处理        String msgType = requestMap.get(&quot;MsgType&quot;);        switch (msgType) &#123;        case &quot;text&quot;:            msg = dealTextMsg(requestMap);            break;        case &quot;news&quot;:            break;        case &quot;event&quot;:            //新增处理事件的方法            msg = dealEvent(requestMap);            break;        default:            break;        &#125;        // System.out.println(msg);        // 将处理结果转化成xml的字符串返回        if (null != msg) &#123;            return beanToXml(msg);        &#125;        return null;    &#125;    //处理事件    private static BaseMsg dealEvent(Map&lt;String, String&gt; requestMap) &#123;        String event = requestMap.get(&quot;Event&quot;);        BaseMsg msg = null;        //switch分发到具体事件        switch (event) &#123;            case &quot;SCAN&quot;:                msg = dealScanEvent(requestMap);                break;            default:                break;        &#125;        return msg;    &#125;    //处理SCAN事件    private static BaseMsg dealScanEvent(Map&lt;String, String&gt; requestMap) &#123;        String eventKey = requestMap.get(&quot;EventKey&quot;);        if(&quot;test&quot;.equals(eventKey)) &#123;            return new TextMsg(requestMap, &quot;你扫码了&quot;);        &#125;        return new TextMsg(requestMap, requestMap.toString());    &#125;</code></pre><p>扫码之后效果如下：</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210814184046627.png" alt="image-20210814184046627"></p><h2 id="16-获取用户信息"><a href="#16-获取用户信息" class="headerlink" title="16 获取用户信息"></a>16 获取用户信息</h2><p>一般在做网页授权的时候,会用到这个功能。</p><h3 id="16-1-获取已关注的用户信息"><a href="#16-1-获取已关注的用户信息" class="headerlink" title="16.1 获取已关注的用户信息"></a>16.1 获取已关注的用户信息</h3><p><a href="https://developers.weixin.qq.com/doc/offiaccount/User_Management/Get_users_basic_information_UnionID.html#UinonId">获取用户基本信息(UnionID机制)</a></p><p>在关注者与公众号产生消息交互后，公众号可获得关注者的OpenID（加密后的微信号，每个用户对每个公众号的OpenID是唯一的。对于不同公众号，同一用户的openid不同）。公众号可通过本接口来根据OpenID获取用户基本信息，包括昵称、头像、性别、所在城市、语言和关注时间。</p><p><strong>获取用户基本信息（包括UnionID机制）</strong></p><p>开发者可通过OpenID来获取用户基本信息。请使用https协议。</p><blockquote><p>接口调用请求说明 http请求方式: GET <a href="https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN">https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</a></p></blockquote><p>参数说明</p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">是</td><td align="left">调用接口凭证</td></tr><tr><td align="left">openid</td><td align="left">是</td><td align="left">普通用户的标识，对当前公众号唯一</td></tr><tr><td align="left">lang</td><td align="left">否</td><td align="left">返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语</td></tr></tbody></table><p>openid可以登录测试号管理界面获取,对应关注者的微信号</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210814185850181.png" alt="image-20210814185850181"></p><p>测试代码</p><pre><code class="java">@Test    public void getUserInfo() &#123;        String url = &quot;https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN&quot;;        url = url.replace(&quot;ACCESS_TOKEN&quot;, WxService.getAccessToken());        url = url.replace(&quot;OPENID&quot;, &quot;oQxvI51GI5t9wBaBjmBXgJZZVM3A&quot;);        String string = HttpUtils.sendGet(url);        System.out.println(string);//这里就可以看到打印的用户信息了    &#125;</code></pre><h3 id="16-2-网页授权"><a href="#16-2-网页授权" class="headerlink" title="16.2 网页授权"></a>16.2 网页授权</h3><p>可以获取未关注的用户信息,这部分需要有域名才能测试。</p><p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html">网页授权</a></p><p>因为ngrok默认域名已经被微信封了,所以需要申请一个域名来测试</p><p>第一步：在ngrok中使用自定义域名。</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210815145833067.png" alt="image-20210815145833067"></p><p>第二步：微信测试号管理界面修改成自定义的域名</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210815145936625.png" alt="image-20210815145936625"></p><p>第三步：测试号接口权限中配置网页授权的域名</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210815150238632.png" alt="image-20210815150238632"></p><p>第四步：阿里云域名解析到ngrok的域名</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210815150319450.png" alt="image-20210815150319450"></p><p>测试代码：</p><p>【WxService】修改dealTextMsg方法</p><p><img src="/2021/08/14/1426556608602836992/images/image-20210815150631184.png" alt="image-20210815150631184"></p><p>新增一个【getUserInfo】的servlet,这个就是用户点击之后重定向的servlet</p><pre><code class="java">@WebServlet(&quot;/getUserInfo&quot;)public class GetUserInfoServlet extends HttpServlet &#123;    private static final long serialVersionUID = 1L;           protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        //1.用户同意授权，获取code        String code = request.getParameter(&quot;code&quot;);        //2.通过code获取网页授权的access_token        String url = &quot; https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code&quot;;        url = url.replace(&quot;APPID&quot;, WxService.APPID).replace(&quot;CODE&quot;, code).replace(&quot;SECRET&quot;, WxService.APPSECRET);        String string = HttpUtils.sendGet(url);        JSONObject jsonObject = JSONObject.parseObject(string);        String accessToken = jsonObject.getString(&quot;access_token&quot;);        String openid = jsonObject.getString(&quot;openid&quot;);        //3.刷新access_token（如果需要）        //4.通过token获取用户信息        String getUserInfoUrl = &quot;https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN&quot;;        getUserInfoUrl = getUserInfoUrl.replace(&quot;ACCESS_TOKEN&quot;, accessToken).replace(&quot;OPENID&quot;, openid);        String userInfoJsonStr = HttpUtils.sendGet(getUserInfoUrl);        System.out.println(userInfoJsonStr);    &#125;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        doGet(request, response);    &#125;&#125;</code></pre><h2 id="17-微信公众号开发框架"><a href="#17-微信公众号开发框架" class="headerlink" title="17 微信公众号开发框架"></a>17 微信公众号开发框架</h2><p>前面的开发都是原生的写法,github上有很多现成的公众号开发框架。</p><p>比如这个基于springboot的公众号开发框架：</p><p>仓库：<a href="https://github.com/binarywang/weixin-java-mp-demo">https://github.com/binarywang/weixin-java-mp-demo</a></p><p>文档：<a href="https://github.com/Wechat-Group/WxJava/wiki/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3">https://github.com/Wechat-Group/WxJava/wiki/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3</a></p><p>最后多说一句只有把原生的基础打好了,才能更好的理解和使用框架,所以建议先学原生的公众号开发,再上手框架。</p>]]></content>
    
    
    <summary type="html">微信公众号开发学习笔记,后端使用java+maven</summary>
    
    
    
    <category term="公众号和小程序" scheme="https://heliufang.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="java" scheme="https://heliufang.github.io/tags/java/"/>
    
    <category term="微信公众号" scheme="https://heliufang.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>java生成pdf并加水印(通过wkhtmltopdf实现)</title>
    <link href="https://heliufang.github.io/2021/08/03/1426392656254210048/images/"/>
    <id>https://heliufang.github.io/2021/08/03/1426392656254210048/images/</id>
    <published>2021-08-03T15:47:28.000Z</published>
    <updated>2021-08-03T15:47:55.735Z</updated>
    
    <content type="html"><![CDATA[<p>公司项目有个需求就是根据模板动态的生成pdf文件,在网上看过很多方式生成的效果都不是很好。要么样式不支持，要么字体不支持。我这边项目的需求是这样：</p><pre><code>1.根据模板生成纸张方向为横向的pdf2.给pdf的每一页中间的位置都加上文字水印</code></pre><p>研究了很久终于实现了效果，效果如下图所示：</p><p><img src="/2021/08/03/1426392656254210048/images/image-20210801204853727.png" alt="image-20210801204853727"></p><h2 id="总体实现方案"><a href="#总体实现方案" class="headerlink" title="总体实现方案"></a>总体实现方案</h2><ul><li><p>准备好html模板 —&gt;就是写html,注意：样式少用css3的，并且不要使用外部样式.可以把样式写在style标签内部,也就是保证样式和html标签在同一个html文件中。</p></li><li><p>通过模板引擎将html模板生成含数据的html —&gt; 使用<code>beetl</code>模板引擎实现,当然你也可以用<code>freemarker</code>等模板引擎实现</p></li><li><p>把生成的html转成pdf—&gt;通过<code>wkhtmltopdf</code>这个程序实现</p></li><li><p>最后把生成的pdf文件加上水印—&gt;通过<code>itex</code>t实现</p></li></ul><h2 id="1-编写模板"><a href="#1-编写模板" class="headerlink" title="1 编写模板"></a>1 编写模板</h2><p>模板如下,其实就是写html文件，可以看到<code>$&#123;xxx&#125;</code>这种占位符,这些数据都是动态的，用来给模板引擎识别的。</p><p><img src="/2021/08/03/1426392656254210048/images/image-20210801205236360.png" alt="image-20210801205236360"></p><h2 id="2-模板引擎生成带数据的html文件"><a href="#2-模板引擎生成带数据的html文件" class="headerlink" title="2 模板引擎生成带数据的html文件"></a>2 模板引擎生成带数据的html文件</h2><p>因为公司项目用的是<code>beetl</code>模板引擎所以我这里也就用beetl生成html文件.你也可以用其它的模板引擎生成,比如<code>freemarker</code>。如果这两个都不会，那就先去学习一下吧，O(∩_∩)O哈哈~,其实不难，这两个模板引擎的语法和jsp的语法很像。</p><p>beetl官网：<a href="https://www.kancloud.cn/xiandafu/beetl3_guide/2138944">https://www.kancloud.cn/xiandafu/beetl3_guide/2138944</a></p><p>freemarker官网：<a href="http://freemarker.foofun.cn/">http://freemarker.foofun.cn/</a></p><p>beetl的maven依赖如下：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.ibeetl&lt;/groupId&gt;    &lt;artifactId&gt;beetl&lt;/artifactId&gt;    &lt;version&gt;3.1.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>大致代码如下：这里需要根据你自己的模板进行修改</p><pre><code class="java">public static void fileResourceLoaderTest() throws Exception&#123;        String root = System.getProperty(&quot;user.dir&quot;)+File.separator+&quot;template&quot;;        //System.out.println(root);        FileResourceLoader resourceLoader = new FileResourceLoader(root,&quot;utf-8&quot;);        Configuration cfg = Configuration.defaultConfiguration();        GroupTemplate gt = new GroupTemplate(resourceLoader, cfg);        //准备模板需要的动态数据        Map map = new HashMap();//给模板的数据        map.put(&quot;address&quot;, &quot;清远市清城区横荷清远大道55号&quot;);        //通过模板位置构建模板对象        Template t = gt.getTemplate(&quot;/s01/order.html&quot;);        //将数据和模板绑定,        t.binding(map);        String str = t.render();        System.out.println(str);        //生成html文件        FileWriter writer = new FileWriter(&quot;C:\\Users\\Administrator\\Desktop\\a\\1.html&quot;);        writer.write(str);    &#125;</code></pre><h2 id="3-通过wkhtmltopdf将生成的html文件转成pdf文件"><a href="#3-通过wkhtmltopdf将生成的html文件转成pdf文件" class="headerlink" title="3 通过wkhtmltopdf将生成的html文件转成pdf文件"></a>3 通过wkhtmltopdf将生成的html文件转成pdf文件</h2><p><code>wkhtmltopdf</code>是一个程序,具体来说就是一个软件,也是生成pdf的关键技术。可以在java程序中调用这个软件来把html文件转成pdf文件。我对比了很多方案,我认为<code>wkhtmltopdf</code>是目前来说比较好的一种方案。</p><h3 id="3-1-下载wkhtmltopdf"><a href="#3-1-下载wkhtmltopdf" class="headerlink" title="3.1 下载wkhtmltopdf"></a>3.1 下载wkhtmltopdf</h3><p>官网下载地址：<a href="https://wkhtmltopdf.org/downloads.html">https://wkhtmltopdf.org/downloads.html</a></p><p>根据自己的需要下载相应的版本即可</p><p><img src="/2021/08/03/1426392656254210048/images/image-20210802230511892.png" alt="image-20210802230511892"></p><h3 id="3-2-安装wkhtmltopdf"><a href="#3-2-安装wkhtmltopdf" class="headerlink" title="3.2 安装wkhtmltopdf"></a>3.2 安装wkhtmltopdf</h3><p>下载下来的安装包如下：</p><p><img src="/2021/08/03/1426392656254210048/images/image-20210802230435552.png" alt="image-20210802230435552"></p><h4 id="3-2-1-windows安装"><a href="#3-2-1-windows安装" class="headerlink" title="3.2.1 windows安装"></a>3.2.1 windows安装</h4><p>windows安装比较简单,一直点击下一步即可</p><p>装好之后可以使用cmd命令行来运行</p><p>在装好的路径下右键—&gt;打开命令窗口：</p><p><img src="/2021/08/03/1426392656254210048/images/image-20210802232012602.png" alt="image-20210802232012602"></p><p>命令格式：</p><pre><code>wkhtmltopdf.exe https://wkhtmltopdf.org/downloads.html c:\1.pdf</code></pre><p><img src="/2021/08/03/1426392656254210048/images/image-20210802232308095.png" alt="image-20210802232308095"></p><p>可以看到其实就是把<a href="https://wkhtmltopdf.org/downloads.html%E8%BF%99%E4%B8%AA%E7%BD%91%E9%A1%B5%E5%9C%A8c%E7%9B%98%E4%B8%8B%E7%94%9F%E6%88%901.pdf">https://wkhtmltopdf.org/downloads.html这个网页在c盘下生成1.pdf</a></p><p><img src="/2021/08/03/1426392656254210048/images/image-20210802232335699.png" alt="image-20210802232335699"></p><p>当然也可以把本地的html文件转成pdf,比如：</p><pre><code>wkhtmltopdf.exe c:\1.html c:\1.pdf</code></pre><p>这样生成的pdf默认是竖向的,但是公司项目需求是横向的所以要加上参数 <code>-O landscape</code></p><pre><code>wkhtmltopdf -O landscape c:\1.html c:\1.pdf</code></pre><p>其它参数配置可以看看这个博客：<a href="https://www.cnblogs.com/chenjunwu/p/12792708.html">wkhtmltopdf 参数 详解</a></p><h4 id="3-2-2-centos7-linux安装"><a href="#3-2-2-centos7-linux安装" class="headerlink" title="3.2.2 centos7-linux安装"></a>3.2.2 centos7-linux安装</h4><ul><li>首先需要安装以下依赖：</li></ul><pre><code class="shell">yum install libX11yum install libXextyum install libXrenderyum install libjpegyum install xorg-x11-fonts-75dpiyum install xorg-x11-fonts-Type1</code></pre><ul><li>然后执行安装命令</li></ul><pre><code class="shell">rpm -ivh wkhtmltox-0.12.6-1.centos7.x86_64.rpm</code></pre><p>至此linux上就安装好了,linux的运行wkhtmltopdf和windows类似</p><p>比如将当前目录下的<code>1.html</code>转成<code>1.pdf</code></p><pre><code class="sh">/opt/wkhtmltopdf/bin/wkhtmltopdf -O landscape .\1.html .\1.pdf</code></pre><p><code>/opt/wkhtmltopdf/bin/wkhtmltopdf</code>其实就是装好之后的路径,可以通过find命令查出来.每台linux的服务器可能不一样,所以要查一下。</p><pre><code class="shell">find / -name &#39;wkhtmltopdf&#39;</code></pre><p>比如我查出来的结果如下：</p><p><img src="/2021/08/03/1426392656254210048/images/image-20210802234806791.png" alt="image-20210802234806791"></p><h3 id="3-3-封装一个html转pdf的工具类"><a href="#3-3-封装一个html转pdf的工具类" class="headerlink" title="3.3 封装一个html转pdf的工具类"></a>3.3 封装一个html转pdf的工具类</h3><pre><code class="java">public class WKHtmlToPdfUtil &#123;        /**     *       测试     * @param args     * @throws Exception     */    public static void main(String[] args) throws Exception&#123;        htmlToPdf(&quot;https://www.baidu.com&quot;,&quot;d:\\1.pdf&quot;);    &#125;    /**     * 获取windows和linux调用wkhtmltopdf程序的命令     * @param sourceFilePath     * @param targetFilePath     * @return     */    public static String getCommand(String sourceFilePath, String targetFilePath) &#123;        String system = System.getProperty(&quot;os.name&quot;);        if(system.contains(&quot;Windows&quot;)) &#123;            System.out.println(&quot;windows&quot;);            //-O landscape 表示纸张方向为横向  默认为纵向  如果要生成横向那么去掉-O landscape即可            return &quot;C:\\Program Files\\wkhtmltopdf\\bin\\wkhtmltopdf.exe -O landscape &quot; + sourceFilePath + &quot; &quot; + targetFilePath;        &#125;else if(system.contains(&quot;Linux&quot;)) &#123;            System.out.println(&quot;linux&quot;);            return &quot;/usr/local/bin/wkhtmltopdf -O landscape &quot; + sourceFilePath + &quot; &quot; + targetFilePath;        &#125;        return &quot;&quot;;    &#125;        /**     * html转pdf     * @param sourceFilePath     * @param targetFilePath     * @return     */    public static boolean htmlToPdf(String sourceFilePath, String targetFilePath) &#123;        try &#123;            System.out.println(&quot;转化开始&quot;);            String command = WKHtmlToPdfUtil.getCommand(sourceFilePath, targetFilePath);            System.out.println(&quot;command:&quot;+command);            Process process = Runtime.getRuntime().exec(command);            process.waitFor();  //这个调用比较关键，就是等当前命令执行完成后再往下执行            System.out.println(&quot;html--&gt;pdf:success&quot;);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            System.out.println(&quot;html--&gt;pdf:error&quot;);            return false;        &#125;    &#125;&#125;</code></pre><h3 id="3-4-wkhtmltopdf的一些问题总结"><a href="#3-4-wkhtmltopdf的一些问题总结" class="headerlink" title="3.4 wkhtmltopdf的一些问题总结"></a>3.4 wkhtmltopdf的一些问题总结</h3><h4 id="3-4-1-强制分页问题"><a href="#3-4-1-强制分页问题" class="headerlink" title="3.4.1 强制分页问题"></a>3.4.1 强制分页问题</h4><p>添加样式，使用样式的容器将会独占一页，如果分页最后一页也会独占一页,给div容器加上以下样式即可。</p><pre><code class="css">page-break-after: always !important;</code></pre><h4 id="3-4-2-每页显示表头"><a href="#3-4-2-每页显示表头" class="headerlink" title="3.4.2 每页显示表头"></a>3.4.2 每页显示表头</h4><pre><code class="css">thead &#123;     display:table-header-group;/* 给thead加上这行保证每页都会带上表头 */&#125;</code></pre><p>给thead加上这行保证每页都会带上表头，同时也会解决表头与内容重叠问题.</p><p>如果仍然存在表头和内容重叠问题,一般是因为表格的一行的内容超过一页。我就遇到过这种问题，我的解决方案是用js缩放页面。</p><pre><code class="js">document.getElementsByTagName(&#39;body&#39;)[0].style.zoom=0.6;//0.6为缩放的比例</code></pre><h4 id="3-4-3-表格分页时行内容被截断问题"><a href="#3-4-3-表格分页时行内容被截断问题" class="headerlink" title="3.4.3 表格分页时行内容被截断问题"></a>3.4.3 表格分页时行内容被截断问题</h4><p>给表格tbody的tr标签加上这个样式</p><pre><code class="css">tbody tr&#123;    page-break-inside: avoid !important;&#125;</code></pre><h2 id="4-给pdf的每一页都加上文字水印和页码"><a href="#4-给pdf的每一页都加上文字水印和页码" class="headerlink" title="4 给pdf的每一页都加上文字水印和页码"></a>4 给pdf的每一页都加上文字水印和页码</h2><p>如果你的项目没有这个需求可以不看这部分</p><p>maven坐标如下：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.lowagie&lt;/groupId&gt;    &lt;artifactId&gt;itextasian&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.lowagie&lt;/groupId&gt;    &lt;artifactId&gt;itext&lt;/artifactId&gt;    &lt;version&gt;2.1.7&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>其中<code>itextasian</code>这个maven仓库默认是没有的,需要手动添加到自己的maven仓库</p><p>我上传到百度云了：</p><p>链接：<a href="https://pan.baidu.com/s/1bN3MTRjzlQaqzF5FpfpySg">https://pan.baidu.com/s/1bN3MTRjzlQaqzF5FpfpySg</a><br>提取码：ijgf </p><p>下载下来后将<code>lowagie.rar</code> 中的 <code>lowagie</code> 文件夹 直接拷贝到本地仓库的com文件夹下面即可</p><p><img src="/2021/08/03/1426392656254210048/images/image-20210803232811879.png" alt="image-20210803232811879"></p><p>demo代码如下</p><pre><code class="java">import java.awt.Color;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Calendar;import org.junit.Test;import com.lowagie.text.DocumentException;import com.lowagie.text.Element;import com.lowagie.text.Image;import com.lowagie.text.pdf.BaseFont;import com.lowagie.text.pdf.PdfContentByte;import com.lowagie.text.pdf.PdfGState;import com.lowagie.text.pdf.PdfReader;import com.lowagie.text.pdf.PdfStamper;public class PDFAddWaterMart&#123;        @Test    public void addTextMart() throws Exception&#123;        // 要输出的pdf文件        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(new File(&quot;C:\\result1.pdf&quot;)));        // 将pdf文件先加水印然后输出        setWatermarkText(bos, &quot;C:\\input.pdf&quot;,&quot;壹新设计报价云平台&quot;);    &#125;        //@Test    public void addImageMart() throws Exception&#123;        // 要输出的pdf文件        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(new File(&quot;C:\\result2.pdf&quot;)));        Calendar cal = Calendar.getInstance();        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);        // 将pdf文件先加水印然后输出        setWatermarkImage(bos, &quot;C:\\input.pdf&quot;, format.format(cal.getTime()) + &quot;  下载使用人：&quot; + &quot;测试user&quot;, 16);    &#125;            /**     * 设置文字水印     * @param bos     * @param input     * @param text     * @throws DocumentException     * @throws IOException     */    public static void setWatermarkText(BufferedOutputStream bos, String input,String text)            throws DocumentException, IOException &#123;        PdfReader reader = new PdfReader(input);        PdfStamper stamper = new PdfStamper(reader, bos);        int total = reader.getNumberOfPages()+1;        PdfContentByte content;        BaseFont base = BaseFont.createFont(&quot;STSong-Light&quot;, &quot;UniGB-UCS2-H&quot;, BaseFont.EMBEDDED);        PdfGState gs1 = new PdfGState();        gs1.setFillOpacity(0.2f);//设置透明度        PdfGState gs2 = new PdfGState();        gs2.setFillOpacity(1f);        for (int i = 1; i &lt; total; i++) &#123;            content = stamper.getOverContent(i);// 在内容上方加水印            //content = stamper.getUnderContent(i);//在内容下方加水印            //水印内容            content.setGState(gs1);            content.beginText();            content.setColorFill(Color.GRAY);            content.setFontAndSize(base, 50);            content.setTextMatrix(70, 200);            //350为x坐标 350y坐标  45为旋转45度            content.showTextAligned(Element.ALIGN_CENTER, text, 350, 350, 45);            content.endText();//结束文字            //页脚内容            content.setGState(gs2);            content.beginText();            content.setColorFill(Color.BLACK);            content.setFontAndSize(base, 8);            content.setTextMatrix(70, 200);            content.showTextAligned(Element.ALIGN_CENTER, &quot;壹新设计报价云平台 www.newbeall.com 第&quot;+i+ &quot;页,共&quot;+(total-1)+&quot;页&quot;, 370, 10, 0);            content.endText();        &#125;        stamper.close();    &#125;        /**     * 设置图片水印     * @param bos输出文件的位置     * @param input     *            原PDF位置     * @param waterMarkName     *            页脚添加水印     * @param permission     *            权限码     * @throws DocumentException     * @throws IOException     */    public static void setWatermarkImage(BufferedOutputStream bos, String input, String waterMarkName, int permission)            throws DocumentException, IOException &#123;                        PdfReader reader = new PdfReader(input);        PdfStamper stamper = new PdfStamper(reader, bos);                int total = reader.getNumberOfPages() + 1;        PdfContentByte content;        BaseFont base = BaseFont.createFont(&quot;STSong-Light&quot;, &quot;UniGB-UCS2-H&quot;, BaseFont.EMBEDDED);        PdfGState gs = new PdfGState();        for (int i = 1; i &lt; total; i++) &#123;            content = stamper.getOverContent(i);// 在内容上方加水印            // content = stamper.getUnderContent(i);//在内容下方加水印            gs.setFillOpacity(0.2f);            // content.setGState(gs);            content.beginText();            content.setColorFill(Color.LIGHT_GRAY);            content.setFontAndSize(base, 50);            content.setTextMatrix(70, 200);            //这里的水印图片换成你自己的            Image image = Image.getInstance(&quot;C:\\Users\\Administrator\\Desktop\\quotation12.png&quot;);            /*              img.setAlignment(Image.LEFT | Image.TEXTWRAP);              img.setBorder(Image.BOX); img.setBorderWidth(10);              img.setBorderColor(BaseColor.WHITE); img.scaleToFit(100072);//大小              img.setRotationDegrees(-30);//旋转             */            image.setAbsolutePosition(200, 206); // set the first background            image.scaleToFit(200, 200);// image of the absolute            image.setRotationDegrees(45);//旋转45度            content.addImage(image);            content.setColorFill(Color.BLACK);            content.setFontAndSize(base, 8);            content.showTextAligned(Element.ALIGN_CENTER, &quot;下载时间：&quot; + waterMarkName + &quot;&quot;, 300, 10, 0);            content.endText();        &#125;        stamper.close();    &#125;&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wangsen/p/9329687.html">java生成pdf</a></p><p><a href="https://www.cnblogs.com/chenjunwu/p/12792708.html">wkhtmltopdf 参数 详解</a></p><p><a href="https://www.cnblogs.com/qlqwjy/p/9326468.html">Java给图片和PDF文件添加水印(图片水印和文字水印)</a></p><p><a href="https://blog.csdn.net/qq_33745005/article/details/89970979">maven项目中使用itextasian</a></p><p><a href="https://www.cnblogs.com/daxiongblog/p/12963501.html">使用 wkhtmltopdf 导出时遇到的问题</a></p>]]></content>
    
    
    <summary type="html">java生成pdf并加水印(通过wkhtmltopdf实现)。</summary>
    
    
    
    <category term="java" scheme="https://heliufang.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://heliufang.github.io/tags/java/"/>
    
    <category term="pdf" scheme="https://heliufang.github.io/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>bootstrap-table插件笔记</title>
    <link href="https://heliufang.github.io/2021/08/01/1426392655180468224/images/"/>
    <id>https://heliufang.github.io/2021/08/01/1426392655180468224/images/</id>
    <published>2021-08-01T08:11:28.000Z</published>
    <updated>2022-03-31T02:10:33.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-bootstrap-table插件介绍"><a href="#1-bootstrap-table插件介绍" class="headerlink" title="1 bootstrap-table插件介绍"></a>1 bootstrap-table插件介绍</h2><p>一个基于bootstrap的表格渲染插件,可以极大的简化表格的渲染操作</p><h2 id="2-下载"><a href="#2-下载" class="headerlink" title="2 下载"></a>2 下载</h2><p>github：<a href="https://github.com/wenzhixin/bootstrap-table">https://github.com/wenzhixin/bootstrap-table</a></p><p>中文官网：<a href="https://www.bootstrap-table.com.cn/">https://www.bootstrap-table.com.cn/</a></p><p>英文官网：<a href="https://bootstrap-table.com/">https://bootstrap-table.com/</a></p><p>下载后相关的依赖都在dist文件夹下</p><p><img src="/2021/08/01/1426392655180468224/images/image-20210801161820257.png" alt="image-20210801161820257"></p><h2 id="3-入门案例"><a href="#3-入门案例" class="headerlink" title="3 入门案例"></a>3 入门案例</h2><p>请求json数据渲染表格</p><h3 id="3-1-搭建工程"><a href="#3-1-搭建工程" class="headerlink" title="3.1 搭建工程"></a>3.1 搭建工程</h3><p><img src="/2021/08/01/1426392655180468224/images/image-20210801002706695.png" alt="image-20210801002706695"></p><p>其中<code>data.json</code>的数据文件内容如下：</p><pre><code class="json">[    &#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;tom&quot;,&quot;sal&quot;:&quot;4000&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;18&quot;&#125;,    &#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;jerry&quot;,&quot;sal&quot;:&quot;2000&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:&quot;26&quot;&#125;,    &#123;&quot;id&quot;:&quot;3&quot;,&quot;name&quot;:&quot;heliufang&quot;,&quot;sal&quot;:&quot;8000&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;25&quot;&#125;,    &#123;&quot;id&quot;:&quot;4&quot;,&quot;name&quot;:&quot;lucy&quot;,&quot;sal&quot;:&quot;2500&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:&quot;28&quot;&#125;,    &#123;&quot;id&quot;:&quot;5&quot;,&quot;name&quot;:&quot;linda&quot;,&quot;sal&quot;:&quot;1000&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:&quot;16&quot;&#125;,    &#123;&quot;id&quot;:&quot;6&quot;,&quot;name&quot;:&quot;jack&quot;,&quot;sal&quot;:&quot;2500&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;28&quot;&#125;]</code></pre><p>这个data.json只是在做前端分页的时候使用</p><h3 id="3-2-编写测试代码"><a href="#3-2-编写测试代码" class="headerlink" title="3.2 编写测试代码"></a>3.2 编写测试代码</h3><p>【1.入门案例.html】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;!-- 引入相关样式表 --&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap3/css/bootstrap.min.css&quot;/&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap3/css/bootstrap-theme.min.css&quot;/&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap-table/bootstrap-table.min.css&quot;/&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 创建表格容器 --&gt;        &lt;table id=&quot;table&quot;&gt;&lt;/table&gt;        &lt;!-- 引入相关js --&gt;        &lt;script src=&quot;js/jquery-1.11.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;bootstrap3/js/bootstrap.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;bootstrap-table/bootstrap-table.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;bootstrap-table/bootstrap-table-zh-CN.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            //通过bootrap-table插件渲染表格            $(&#39;#table&#39;).bootstrapTable(&#123;                url: &#39;json/data.json&#39;,//请求的url                columns: [&#123;                    field: &#39;id&#39;,                    title: &#39;序号&#39;                &#125;, &#123;                    field: &#39;name&#39;,                    title: &#39;姓名&#39;                &#125;, &#123;                    field: &#39;sal&#39;,                    title: &#39;薪水&#39;                &#125;, &#123;                    field: &#39;sex&#39;,                    title: &#39;性别&#39;                &#125;,&#123;                    field: &#39;age&#39;,                    title: &#39;年龄&#39;                &#125;]            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>测试结果如下：</p><p><img src="/2021/08/01/1426392655180468224/images/image-20210801004401622.png" alt="image-20210801004401622"></p><p>可以看到插件自动帮我们把数据渲染好了,是不是很方便！！！</p><h2 id="4-前端分页实现"><a href="#4-前端分页实现" class="headerlink" title="4 前端分页实现"></a>4 前端分页实现</h2><p>【2.前端分页.html】将【1.入门案例.html】中的渲染的js代码改成如下：</p><pre><code class="js">//通过bootrap-table插件渲染表格$(&#39;#table&#39;).bootstrapTable(&#123;    url: &#39;json/data.json&#39;,    columns: [&#123;        field: &#39;id&#39;,        title: &#39;序号&#39;    &#125;, &#123;        field: &#39;name&#39;,        title: &#39;姓名&#39;    &#125;, &#123;        field: &#39;sal&#39;,        title: &#39;薪水&#39;    &#125;, &#123;        field: &#39;sex&#39;,        title: &#39;性别&#39;    &#125;,&#123;        field: &#39;age&#39;,        title: &#39;年龄&#39;    &#125;],    striped: false,    //是否显示行间隔色    cache: false,     //是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*）    pagination: true, //是否显示分页（*）    sortable: true,   //是否启用排序    sortOrder: &quot;asc&quot;, //排序方式    sidePagination: &quot;client&quot;,//分页方式：client客户端分页，server服务端分页（*）    pageNumber: 1,//初始化加载第一页，默认第一页,并记录    pageSize: 2,//每页的记录行数（*）    pageList: [2, 5, 10, 20], //可供选择的每页的行数（*）    search: true,//是否显示表格搜索    strictSearch: false,//是否使用严格搜索模式    showColumns: true, //是否显示所有的列（选择显示的列）    showRefresh: true,//是否显示刷新按钮    minimumCountColumns: 2,//最少允许的列数    clickToSelect: true,//是否启用点击选中行    //height: 500,//行高，如果没有设置height属性，表格自动根据记录条数设置表格高度    uniqueId: &quot;id&quot;,//每一行的唯一标识，一般为主键列    showToggle: true,//是否显示详细视图和列表视图的切换按钮    cardView: false,//是否显示详细视图    detailView: false,//是否显示父子表&#125;);</code></pre><p>效果如下：</p><p><img src="/2021/08/01/1426392655180468224/images/image-20210801010453656.png" alt="image-20210801010453656"></p><h2 id="5-工具栏"><a href="#5-工具栏" class="headerlink" title="5 工具栏"></a>5 工具栏</h2><p>工具栏实现分为两步</p><ul><li><p>准备工具按钮容器</p></li><li><p>bootstrap-table中引用插件</p></li></ul><p>​       加上这个配置即可：toolbar: ‘#toolbar’, &#x2F;&#x2F;工具按钮用哪个容器</p><p>案例【3.工具栏.html】 </p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;!-- 引入相关样式表 --&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap3/css/bootstrap.min.css&quot;/&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap3/css/bootstrap-theme.min.css&quot;/&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap-table/bootstrap-table.min.css&quot;/&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 工具栏容器 --&gt;        &lt;div id=&quot;toolbar&quot; class=&quot;row&quot; style=&quot;margin-left: 5px;&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-default col-md-4&quot;&gt;新增&lt;/button&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-info col-md-4&quot;&gt;修改&lt;/button&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-danger col-md-4&quot;&gt;删除&lt;/button&gt;        &lt;/div&gt;        &lt;!-- 创建表格容器 --&gt;        &lt;table id=&quot;table&quot;&gt;&lt;/table&gt;        &lt;!-- 引入相关js --&gt;        &lt;script src=&quot;js/jquery-1.11.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;bootstrap3/js/bootstrap.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;bootstrap-table/bootstrap-table.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;bootstrap-table/bootstrap-table-zh-CN.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            //通过bootrap-table插件渲染表格            $(&#39;#table&#39;).bootstrapTable(&#123;                url: &#39;json/data.json&#39;,                columns: [&#123;                    field: &#39;id&#39;,                    title: &#39;序号&#39;                &#125;, &#123;                    field: &#39;name&#39;,                    title: &#39;姓名&#39;                &#125;, &#123;                    field: &#39;sal&#39;,                    title: &#39;薪水&#39;                &#125;, &#123;                    field: &#39;sex&#39;,                    title: &#39;性别&#39;                &#125;,&#123;                    field: &#39;age&#39;,                    title: &#39;年龄&#39;                &#125;],                toolbar: &#39;#toolbar&#39;,              //工具按钮用哪个容器                striped: true,                      //是否显示行间隔色                cache: false,                       //是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*）                pagination: true,                   //是否显示分页（*）                sortable: true,                     //是否启用排序                sortOrder: &quot;asc&quot;,                   //排序方式                sidePagination: &quot;client&quot;,           //分页方式：client客户端分页，server服务端分页（*）                pageNumber: 1,                      //初始化加载第一页，默认第一页,并记录                pageSize: 2,                     //每页的记录行数（*）                pageList: [2, 5, 10, 20],        //可供选择的每页的行数（*）                search: true,                      //是否显示表格搜索                strictSearch: false,                showColumns: true,                  //是否显示所有的列（选择显示的列）                showRefresh: true,                  //是否显示刷新按钮                minimumCountColumns: 2,             //最少允许的列数                clickToSelect: true,                //是否启用点击选中行                //height: 500,                      //行高，如果没有设置height属性，表格自动根据记录条数设置表格高度                uniqueId: &quot;id&quot;,                     //每一行的唯一标识，一般为主键列                showToggle: false,                   //是否显示详细视图和列表视图的切换按钮                cardView: false,                    //是否显示详细视图                detailView: false,                  //是否显示父子表            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>效果如下：</p><p><img src="/2021/08/01/1426392655180468224/images/image-20210801102854453.png" alt="image-20210801102854453"></p><h2 id="6-后端分页"><a href="#6-后端分页" class="headerlink" title="6 后端分页"></a>6 后端分页</h2><p>后端接口,我后端是java写的具体分页代码就不上了,这里把接口文档写出来</p><ul><li><p>请求方式：GET</p></li><li><p>URL:  <a href="http://localhost:8080/user/searchPage">http://localhost:8080/user/searchPage</a></p></li><li><p>请求参数</p></li></ul><pre><code>pageNum:查询的是哪一页pageSize：每页显示的条数name：姓名age：年龄比如：http://localhost:8080/user/searchPage?name=tom&amp;age=&amp;pageSize=2&amp;pageNum=1</code></pre><ul><li>响应(json)</li></ul><p>注意：这里必须是返回{“total”:””,”rows”,[]}这种格式的数据</p><p><code>total</code>是总共的记录数量</p><p><code>rows</code>是当前页查出来的记录对象数组</p><pre><code class="json">&#123;  &quot;total&quot;: 1,  &quot;rows&quot;: [    &#123;      &quot;id&quot;: 1,      &quot;name&quot;: &quot;tom&quot;,      &quot;age&quot;: 18,      &quot;gender&quot;: &quot;1&quot;,      &quot;createTime&quot;: &quot;2021-02-22 09:53:24&quot;    &#125;  ]&#125;</code></pre><p>【4.后端分页.html】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;!-- 引入相关样式表 --&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap3/css/bootstrap.min.css&quot;/&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap3/css/bootstrap-theme.min.css&quot;/&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;bootstrap-table/bootstrap-table.min.css&quot;/&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;container&quot;&gt;            &lt;!-- 工具栏 --&gt;            &lt;div id=&quot;toolbar&quot; class=&quot;row&quot; style=&quot;margin-left: 5px;&quot;&gt;                &lt;form class=&quot;form-inline&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot;&gt;新增&lt;/button&gt;                     &lt;div class=&quot;form-group&quot;&gt;                        &lt;label&gt;姓名&lt;/label&gt;&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;nameTxt&quot;/&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label&gt;年龄&lt;/label&gt;&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;ageTxt&quot;/&gt;                    &lt;/div&gt;                    &lt;button onclick=&quot;search()&quot; type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;查询&lt;/button&gt;                &lt;/form&gt;            &lt;/div&gt;            &lt;!-- 创建表格容器 --&gt;            &lt;table id=&quot;myTable&quot;&gt;&lt;/table&gt;        &lt;/div&gt;        &lt;!-- 引入相关js --&gt;        &lt;script src=&quot;js/jquery-1.11.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;bootstrap3/js/bootstrap.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;bootstrap-table/bootstrap-table.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;bootstrap-table/bootstrap-table-zh-CN.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot;&gt;             //封装一个初始化表格的方法            function initTable(tableId,url,columns,query)&#123;                //将原有的表格销毁                $(&quot;#&quot;+tableId).bootstrapTable(&#39;destroy&#39;);                //通过bootrap-table插件渲染表格                var myTable = $(&#39;#&#39;+tableId).bootstrapTable(&#123;                    method: &#39;GET&#39;,  //请求方式（*）                    url: url,                    columns: columns,                    toolbar: &#39;#toolbar&#39;, //工具按钮用哪个容器                    striped: true, //是否显示行间隔色                    cache: false,//是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*）                    pagination: true,//是否显示分页（*）                    sortable: false,//是否启用排序                    sortOrder: &quot;asc&quot;, //排序方式                    sidePagination: &quot;server&quot;, //分页方式：client客户端分页，server服务端分页                    pageNumber: 1, //初始化加载第一页，默认第一页,并记录                    pageSize: 2, //每页的记录行数（*）                    pageList: [2, 5, 10, 20],//可供选择的每页的行数（*）                    search: false,//是否显示表格搜索                    strictSearch: false,                    showColumns: true,//是否显示所有的列（选择显示的列）                    showRefresh: true,//是否显示刷新按钮                    minimumCountColumns: 2,//最少允许的列数                    clickToSelect: true,//是否启用点击选中行                    //height: 500,//行高，如果没有设置height属性，表格自动根据记录条数设置表格高度                    uniqueId: &quot;id&quot;,//每一行的唯一标识，一般为主键列                    showToggle: false,//是否显示详细视图和列表视图的切换按钮                    cardView: false,//是否显示详细视图                    detailView: false,//是否显示父子表                    //得到查询的参数                    queryParams : function (params) &#123;                        //这里的键的名字和控制器的变量名必须一致，这边改动，控制器也需要改成一样的                        /* var temp = &#123;                            pageSize: params.limit,                         //页面大小                            pageNum: (params.offset / params.limit) + 1,   //页码                            //sort: params.sort,      //排序列名                            //sortOrder: params.order //排位命令（desc，asc）                            //自定义的参数                            name:params.name, //姓名                            age:params.age //年龄                        &#125;; */                        if(null == query || undefined == query)&#123;                            query = &#123;&#125;;                        &#125;                        query.pageSize = params.limit; //页面大小                        query.pageNum = (params.offset / params.limit) + 1;  //页码                        console.log(query);                        return query;                    &#125;                &#125;);            &#125;            //初始化列信息            var columns =  [                &#123;                    field: &#39;id&#39;,                    title: &#39;序号&#39;                &#125;,                 &#123;                    field: &#39;name&#39;,                    title: &#39;姓名&#39;                &#125;,                 &#123;                    field: &#39;gender&#39;,                    title: &#39;性别&#39;,                    //formatter 为格式化函数,后端返回的性别类型: 1男2女 所以这里要处理一下再显示                    formatter: function(value, row, index)&#123;                        //console.log(value);//当前列数据                        //console.log(row);//当前行json数据                        if(value == 1)&#123;                            return &quot;男&quot;;                        &#125;                        return &quot;女&quot;;                    &#125;                &#125;,                &#123;                    field: &#39;age&#39;,                    title: &#39;年龄&#39;                &#125;,                &#123;                        field: &#39;&#39;,                        title: &#39;操作&#39;,                        //如果需要对列处理可以写在formatter函数中                        formatter: function(value,row,index)&#123;                            return &#39;&lt;button onclick=&quot;updateFun(&#39;+row.id+&#39;)&quot; type=&quot;button&quot; class=&quot;btn btn-warning btn-xs&quot;&gt;修改&lt;/button&gt;&amp;nbsp;&#39;                                   + &#39;&lt;button onclick=&quot;deleteFun(&#39;+row.id+&#39;)&quot; type=&quot;button&quot; class=&quot;btn btn-danger btn-xs&quot;&gt;删除&lt;/button&gt;&#39;                        &#125;                &#125;             ];            //点击修改按钮            function updateFun(data)&#123;                alert(&quot;修改：&quot;+data)                console.log(data)            &#125;            //点击删除按钮            function deleteFun(data)&#123;                alert(&quot;删除：&quot;+data)                console.log(data)            &#125;                        //点击查询按钮            function search()&#123;                var name = $(&quot;#nameTxt&quot;).val();                var age = $(&quot;#ageTxt&quot;).val();                var queryParams = &#123;name,age&#125;;initTable(&quot;myTable&quot;,&#39;http://localhost:8080/user/searchPage&#39;,columns,queryParams);            &#125;            //第一次进入页面加载表格            initTable(&quot;myTable&quot;,&#39;http://localhost:8080/user/searchPage&#39;,columns,null);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>运行效果如下：</p><p><img src="/2021/08/01/1426392655180468224/images/image-20210801160235625.png" alt="image-20210801160235625"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/laowangc/p/8875526.html">Bootstrap-table 使用总结</a></p><p><a href="https://www.cnblogs.com/web-panpan/p/7278367.html">BOOTSTRAP TABLE表格前台分页，点击TAB选项，重新刷新表格</a></p><p><a href="https://www.cnblogs.com/benmumu/p/9594019.html">Bootstrap Table 中文文档（完整翻译版）</a></p>]]></content>
    
    
    <summary type="html">bootstrap-table插件笔记</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="bootstrap-table" scheme="https://heliufang.github.io/tags/bootstrap-table/"/>
    
    <category term="bootstrap" scheme="https://heliufang.github.io/tags/bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>art-template笔记</title>
    <link href="https://heliufang.github.io/2021/07/31/1426392654899449856/images/"/>
    <id>https://heliufang.github.io/2021/07/31/1426392654899449856/images/</id>
    <published>2021-07-31T03:19:50.000Z</published>
    <updated>2022-09-24T06:20:18.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-art-template是什么"><a href="#1-art-template是什么" class="headerlink" title="1 art-template是什么"></a>1 art-template是什么</h2><p>一个前端js模板引擎。语法分为简洁语法和原始语法,推荐使用简洁语法兼容性更好！</p><h2 id="2-下载"><a href="#2-下载" class="headerlink" title="2 下载"></a>2 下载</h2><p>码云下载：<a href="https://gitee.com/mirrors/art-template.git">https://gitee.com/mirrors/art-template.git</a></p><p>github下载：<a href="https://github.com/aui/art-template">https://github.com/aui/art-template</a></p><p>有git用git拉取下载，没git可以直接下载zip包</p><h2 id="3-构造项目测试"><a href="#3-构造项目测试" class="headerlink" title="3 构造项目测试"></a>3 构造项目测试</h2><h3 id="3-1-搭建项目"><a href="#3-1-搭建项目" class="headerlink" title="3.1 搭建项目"></a>3.1 搭建项目</h3><ul><li>下载后的zip包中是这样</li></ul><p><img src="/2021/07/31/1426392654899449856/images/image-20210731100754067.png" alt="image-20210731100754067"></p><ul><li>创建一个html项目,将下载下来的<code>art-template-master\lib\template-web.js</code>拷贝到项目中</li></ul><p><img src="/2021/07/31/1426392654899449856/images/image-20210731100651714.png" alt="image-20210731100651714"></p><h3 id="3-2-编写代码"><a href="#3-2-编写代码" class="headerlink" title="3.2 编写代码"></a>3.2 编写代码</h3><p>test.html</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;测试art-template模板引擎&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;        &lt;!-- 1.引入art-template依赖 --&gt;        &lt;script src=&quot;js/template-web.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;                &lt;!-- 2.定义html模板             id:定义模板的id            type:定义模板类型        --&gt;        &lt;script id=&quot;templateId&quot; type=&quot;text/html&quot;&gt;            &lt;h5&gt;1.渲染普通数据&lt;/h5&gt;            你好：&lt;span id=&quot;username&quot;&gt;&#123;&#123; username &#125;&#125;&lt;/span&gt;            &lt;hr&gt;            &lt;h5&gt;2.渲染对象数据&lt;/h5&gt;            姓名：&lt;span id=&quot;name&quot;&gt;&#123;&#123; user.name &#125;&#125;&lt;/span&gt;            性别：&lt;span id=&quot;sex&quot;&gt;&#123;&#123; user.sex &#125;&#125;&lt;/span&gt;            年龄：&lt;span id=&quot;age&quot;&gt;&#123;&#123; user.age &#125;&#125;&lt;/span&gt;            &lt;hr&gt;            &lt;h5&gt;3.渲染列表数据&lt;/h5&gt;            &lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;1px&quot;&gt;                &lt;thead&gt;                    &lt;tr&gt;                        &lt;th&gt;序号&lt;/th&gt;                        &lt;th&gt;姓名&lt;/th&gt;                        &lt;th&gt;性别&lt;/th&gt;                        &lt;th&gt;年龄&lt;/th&gt;                        &lt;th&gt;个人介绍&lt;/th&gt;                    &lt;/tr&gt;                &lt;/thead&gt;                &lt;tbody&gt;                &#123;&#123;each list&#125;&#125;                    &lt;tr&gt;                        &lt;td&gt;&#123;&#123;$index + 1&#125;&#125;&lt;/td&gt;                        &lt;td&gt;&#123;&#123;$value.name&#125;&#125;&lt;/td&gt;                        &lt;td&gt;&#123;&#123;$value.sex&#125;&#125;&lt;/td&gt;                        &lt;td&gt;&#123;&#123;$value.age&#125;&#125;&lt;/td&gt;                        &lt;td&gt;&#123;&#123;$value.introduction&#125;&#125;&lt;/td&gt;                    &lt;/tr&gt;                &#123;&#123;/each&#125;&#125;                &lt;/tbody&gt;            &lt;/table&gt;        &lt;/script&gt;        &lt;!-- 3.渲染模板 --&gt;        &lt;script&gt;            /*注意： 页面加载完毕后调用,否则可能会报错 ！！！*/            window.onload = function()&#123;                //a.定义数据                var data = &#123;                    &quot;username&quot;: &quot;管理员&quot;,                    &quot;user&quot;: &#123;                        &quot;name&quot;: &quot;小贺&quot;,                        &quot;sex&quot;: &quot;男&quot;,                        &quot;age&quot;: 18                    &#125;,                    &quot;list&quot;: [                        &#123;                            &quot;name&quot;: &quot;小贺&quot;,                            &quot;sex&quot;: &quot;男&quot;,                            &quot;age&quot;: 18,                            &quot;introduction&quot;: &quot;我很帅&quot;                        &#125;,                        &#123;                            &quot;name&quot;: &quot;小花&quot;,                            &quot;sex&quot;: &quot;女&quot;,                            &quot;age&quot;: 16,                            &quot;introduction&quot;: &quot;我很美&quot;                        &#125;,                        &#123;                            &quot;name&quot;: &quot;小李&quot;,                            &quot;sex&quot;: &quot;女&quot;,                            &quot;age&quot;: 20,                            &quot;introduction&quot;: &quot;我很强&quot;                        &#125;                    ]                &#125;                //b.数据和模板进行渲染,得到渲染后的html字符串                var rsHtml = template(&quot;templateId&quot;,data);                //c.将html渲染到标签中                document.getElementById(&quot;app&quot;).innerHTML = rsHtml;            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>运行结果</p><p><img src="/2021/07/31/1426392654899449856/images/image-20210731105808540.png" alt="image-20210731105808540"></p><p>其它详细语法请参考：<a href="https://www.jianshu.com/p/d8d8e19157e0">https://www.jianshu.com/p/d8d8e19157e0</a></p>]]></content>
    
    
    <summary type="html">art-template入门笔记。</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="art-template" scheme="https://heliufang.github.io/tags/art-template/"/>
    
    <category term="js模板引擎" scheme="https://heliufang.github.io/tags/js%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>swing的JTable表格列中插入图片</title>
    <link href="https://heliufang.github.io/2021/07/25/1426392656442953728/images/"/>
    <id>https://heliufang.github.io/2021/07/25/1426392656442953728/images/</id>
    <published>2021-07-25T15:49:28.000Z</published>
    <updated>2021-07-25T15:49:43.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-实现效果"><a href="#1-实现效果" class="headerlink" title="1.实现效果"></a>1.实现效果</h2><p>给swing的JTable实现如下效果，JTable的列表中插入图片</p><p><img src="/2021/07/25/1426392656442953728/images/image-20210725233436734.png" alt="image-20210725233436734"></p><h2 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2.实现步骤"></a>2.实现步骤</h2><p>这里准备了三张方式的图片：网络图片、工程类目录图片、本地磁盘图片</p><p>工程目录如下：</p><p><img src="/2021/07/25/1426392656442953728/images/image-20210725233944024.png" alt="image-20210725233944024"></p><p>关键步骤有两个：</p><ul><li>创建Icon对象</li><li>重写DefaultTableModel类的getColumnClass方法</li></ul><h2 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3.完整代码"></a>3.完整代码</h2><pre><code class="java">package com.qy;import java.awt.BorderLayout;import java.net.MalformedURLException;import java.net.URL;import java.util.Enumeration;import javax.swing.Icon;import javax.swing.ImageIcon;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.border.EmptyBorder;import javax.swing.JTable;import javax.swing.table.DefaultTableModel;import javax.swing.table.JTableHeader;import javax.swing.table.TableColumn;/** * @Author 贺刘芳* @Time 2021年7月25日 下午11:21:33 * @Version 1.0* &lt;p&gt;Description:&lt;/p&gt;*/public class JTableImg extends JFrame &#123;    private JPanel contentPane;    private JTable table;    public static void main(String[] args) &#123;        JTableImg frame = new JTableImg();        frame.setVisible(true);    &#125;    public JTableImg() &#123;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭程序退出        setSize(566, 429);//设置窗口大小        setLocationRelativeTo(null);//设置窗口居中        contentPane = new JPanel();        contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));        setContentPane(contentPane);        contentPane.setLayout(null);//设置布局方式为绝对布局                JPanel panel = new JPanel();        panel.setBounds(10, 10, 530, 349);        contentPane.add(panel);        panel.setLayout(new BorderLayout(0, 0));        //核心步骤1：创建Icon对象        //相对于类路径读取图片        Icon icon1 = new ImageIcon(this.getClass().getResource(&quot;/images/33.jpg&quot;));        //绝对路径读取图片        Icon icon2 = new ImageIcon(&quot;D:/images/22.jpg&quot;);        //网络路径读取图片        Icon icon3 = null;        try &#123;            icon3 = new ImageIcon(new URL(&quot;https://avatar.csdnimg.cn/3/F/F/3_toto1297488504_1548903051.jpg&quot;));        &#125; catch (MalformedURLException e) &#123;            e.printStackTrace();        &#125;        table = new JTable();        String[] columnNames = new String[] &#123;&quot;头像&quot;, &quot;姓名&quot;&#125;;        //将图片Icon对象放入表格数据数组        Object[][] data = new Object[][] &#123;             &#123;icon1, &quot;Text 1&quot;&#125;,             &#123;icon2, &quot;Text 2&quot;&#125;,             &#123;icon3, &quot;Text 3&quot;&#125;        &#125;;        //将表格数据数组放入表格模型,并重写getColumnClass方法        table.setModel(new DefaultTableModel(data,columnNames)&#123;            @Override   //核心步骤2：重写getColumnClass方法            public Class&lt;?&gt; getColumnClass(int columnIndex) &#123;                return getValueAt(0, columnIndex).getClass();            &#125;        &#125;);        //设置每一列的列宽        //table.getColumn(columnNames[0]).setPreferredWidth(59);        table.setRowHeight(0, 80);        table.setRowHeight(1, 80);        table.setRowHeight(2, 80);        table.setRowHeight(3, 80);        //fitTableColumns(table); //非必须，设置列宽随表格内容自动调整        JScrollPane  jsp = new JScrollPane(table);        jsp.setSize(530, 349);        panel.add(jsp);    &#125;        //设置列宽随表格内容自动调整   参考博客：https://blog.csdn.net/tototuzuoquan/article/details/8982618    public void fitTableColumns(JTable myTable) &#123; // 設置table的列寬隨內容調整        JTableHeader header = myTable.getTableHeader();        int rowCount = myTable.getRowCount();        Enumeration columns = myTable.getColumnModel().getColumns();        while (columns.hasMoreElements()) &#123;            TableColumn column = (TableColumn) columns.nextElement();            int col = header.getColumnModel().getColumnIndex(column.getIdentifier());            int width = (int) myTable.getTableHeader().getDefaultRenderer()                    .getTableCellRendererComponent(myTable,column.getIdentifier(), false, false, -1, col)                    .getPreferredSize().getWidth();            for (int row = 0; row &lt; rowCount; row++) &#123;                int preferedWidth = (int) myTable.getCellRenderer(row, col)                        .getTableCellRendererComponent(myTable,myTable.getValueAt(row, col), false, false,row, col)                        .getPreferredSize().getWidth();                width = Math.max(width, preferedWidth);            &#125;            header.setResizingColumn(column);            column.setWidth(width + myTable.getIntercellSpacing().width);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">swing的JTable表格列中插入图片</summary>
    
    
    
    <category term="java" scheme="https://heliufang.github.io/categories/java/"/>
    
    
    <category term="swing" scheme="https://heliufang.github.io/tags/swing/"/>
    
    <category term="JTable" scheme="https://heliufang.github.io/tags/JTable/"/>
    
  </entry>
  
  <entry>
    <title>css笔记</title>
    <link href="https://heliufang.github.io/2021/05/08/1541065649298739200/images/"/>
    <id>https://heliufang.github.io/2021/05/08/1541065649298739200/images/</id>
    <published>2021-05-08T13:20:28.000Z</published>
    <updated>2022-06-26T14:18:13.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS初体验"><a href="#CSS初体验" class="headerlink" title="CSS初体验"></a>CSS初体验</h1><blockquote><p>css的作用是给页面中的元素（标签）设置样式（颜色、大小、字体、位置等等）</p></blockquote><h5 id="ヾ-๑╹◡╹-ﾉ”咱们首先给P标签一点颜色看看"><a href="#ヾ-๑╹◡╹-ﾉ”咱们首先给P标签一点颜色看看" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”咱们首先给P标签一点颜色看看~"></a>ヾ(๑╹◡╹)ﾉ”咱们首先给P标签一点颜色看看~</h5><p><strong>特点：</strong>css的相关设置都放在 style 标签中，style是一个双标签，它放在head里面，title下面</p><p><strong>结构：</strong></p><pre><code class="html">&lt;style&gt;    选择器 &#123;        属性名1: 属性值1;        属性名2: 属性值2;        ...    &#125;&lt;/style&gt;</code></pre><p>示例:</p><pre><code class="html">&lt;style&gt;    p &#123;        color: red;        font-size: 30px;    &#125;&lt;/style&gt;</code></pre><p><strong>总结：</strong>css 是用来给页面上的结构添加样式的 (尺寸、颜色、位置等等)</p><h2 id="CSS的相关属性"><a href="#CSS的相关属性" class="headerlink" title="CSS的相关属性"></a>CSS的相关属性</h2><pre><code class="html">color：设置字体的颜色font-size：设置字体的大小background-color：设置背景(颜色)width：设置宽度height：设置高度</code></pre><h2 id="CSS概念"><a href="#CSS概念" class="headerlink" title="CSS概念"></a>CSS概念</h2><blockquote><p>层叠样式表（Cascading style sheets）</p></blockquote><p><strong>作用：</strong> 给html标签设置样式 ( 给人穿衣服、化妆)</p><p><strong>注意：</strong></p><ul><li>符号必须是英文状态下的</li><li>每一句样式键值对写完之后，必须记得加一个分号。</li></ul><h1 id="字体属性（font-）"><a href="#字体属性（font-）" class="headerlink" title="字体属性（font-）"></a>字体属性（font-）</h1><h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h2><p><strong>font-size：</strong>设置字体大小</p><pre><code>font-size  设置字体的大小   取值如：font-size: 12px;  注意：在css大多数数值都需要添加单位</code></pre><h2 id="字体粗细"><a href="#字体粗细" class="headerlink" title="字体粗细"></a>字体粗细</h2><p><strong>font-weight：</strong>字体的<strong>粗细</strong></p><p><strong>取值：</strong></p><ul><li>数字 :  正常(400)、粗(700)<strong>（没有单位）</strong></li><li>关键字 : 正常(normal)、粗( bold )</li></ul><h2 id="字体风格"><a href="#字体风格" class="headerlink" title="字体风格"></a>字体风格</h2><p><strong>font-style：</strong>字体的样式 </p><pre><code class="html">font-style 设置字体的风格(样式)取值：    normal 显示标准的字体样式（默认）    italic 字体倾斜</code></pre><h2 id="字体类型"><a href="#字体类型" class="headerlink" title="字体类型"></a>字体类型</h2><p><strong>font-family：</strong>字体类型</p><p><strong>注意：</strong></p><ul><li>一些冷门字体很多电脑里面默认没有安装，此时会显示不出来。实际工作中，默认都是一些主流字体如宋体、微软雅黑等等……</li><li>字体可以写多组，中间用<strong>逗号隔开</strong>（第一个不兼容会使用第二个，第二个不行会使用第三个）可以同时设置几个字体类型隶书，楷体（UI给咱们什么，就写什么~）</li><li>你们写字体的时候，都要加上引号</li></ul><p><strong>代码：</strong></p><pre><code class="css">p &#123;    /* 样式: 斜体   默认:正常  斜体*/    font-style: italic;    /* 粗细  默认 : 正常  粗体 */    font-weight: bold;    /*  字体大小  默认: 16px ; */    font-size: 116px;    /* 类型  默认: 微软雅黑; */    font-family: &#39;隶书&#39;;&#125; </code></pre><p><strong>层叠性问题~</strong></p><h2 id="连写形式"><a href="#连写形式" class="headerlink" title="连写形式"></a>连写形式</h2><pre><code class="html">font: 样式 粗细 大小 类型 font: font-style font-weight font-size  font-familyfont: italic bold 100px 宋体;</code></pre><p><strong>记忆 :</strong></p><ul><li>【样式、粗细、大小、家庭】 记住这八个字就行</li></ul><ul><li>稍微舒服&#x3D;&#x3D;swsf</li><li>或者直接记 : <code> font: italic bold 40px &#39;宋体&#39;;</code></li></ul><p><strong>省略：</strong></p><ul><li>可以省略前两个</li></ul><pre><code class="js">font:  40px &#39;微软雅黑&#39;;</code></pre><p><strong>注意点：</strong> </p><ul><li>连写是注意是swsf这个顺序</li><li>【连写只能省略前两个】</li><li>给同一标签设置的相同的属性，写在下面的样式会覆盖上面的样式！！</li><li>推荐样式单独设置使用！！！（一般用的最多的是font-size）</li></ul><h1 id="开发人员调试"><a href="#开发人员调试" class="headerlink" title="开发人员调试"></a>开发人员调试</h1><blockquote><p>开发者调试工具：调试、查错、找BUG。程序员的必备装备~</p></blockquote><p><strong>打开方式：</strong></p><ul><li><p>右键 –&gt; 查看网页源代码：”查看源码”</p></li><li><p>右键–&gt;检查：”检查元素&#x2F;打开控制台”</p></li></ul><p><strong>调试的作用：</strong></p><ul><li>修改属性值（点击属性值）<ul><li>直接修改</li><li>鼠标滚轮</li><li>键盘的上下键</li></ul></li><li>添加属性<ul><li>在上一个属性值的分号之后点击一下，就可以添加样式</li></ul></li><li>控制样式生效<ul><li>点击每个属性前的小框，可以控制。</li><li>如果样式中有一个删除线，表示该样式不生效（失效）</li></ul></li><li>查看是否生效<ul><li>样式是否有删除线（一般都是被覆盖）</li></ul></li><li>查看报错（原因）<ul><li>属性值之后没有分号（没有分号会认为这一行没结束）</li><li>格式写的有问题（中文的标点）</li><li>属性名或属性值有错误</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>在基础班只关注elements这个面板，右侧的style就是当前标签对应的css样式</li><li>在调试工具中修改，仅仅是改变了当前页面的样式效果，刷新之后就没有了，需要添加到代码中才行</li></ul><h1 id="简单（基本）选择器"><a href="#简单（基本）选择器" class="headerlink" title="简单（基本）选择器"></a>简单（基本）选择器</h1><blockquote><p>标签选择器、类选择器、ID选择器</p><p>选择器就是用来选中对应的标签的，然后给选中的标签加上对应的样式</p></blockquote><h2 id="标签选择器（标签名）"><a href="#标签选择器（标签名）" class="headerlink" title="标签选择器（标签名）"></a>标签选择器（标签名）</h2><blockquote><p>要求：四个标签都设置为红色</p></blockquote><pre><code class="html">&lt;p&gt;我是p标签&lt;/p&gt;&lt;p&gt;我也是p标签&lt;/p&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;div&gt;我也是div&lt;/div&gt;</code></pre><p><strong>作用：</strong>根据指定的标签名，来设置指定的标签的样式 </p><p><strong>结构：</strong></p><pre><code class="html"> &lt;style&gt;    标签名(选择器) &#123;        属性名1: 属性值1;        属性名2: 属性值2;        ....    &#125;&lt;/style&gt;</code></pre><p><strong>特点：</strong></p><ul><li>标签选择器会选中页面中所有符合标签名的标签</li><li>标签选择器不管嵌套关系多深，都能选择到</li><li>标签选择器不能只选择一个，而是会选中所有这一类标签</li></ul><h2 id="类选择器（-）"><a href="#类选择器（-）" class="headerlink" title="类选择器（.）"></a>类选择器（.）</h2><blockquote><p>要求：满足下面的要求（做衣服）</p></blockquote><pre><code class="css">/*没穿衣服的样子*/&lt;p&gt;小红&lt;/p&gt;&lt;p&gt;小黄&lt;/p&gt;&lt;p&gt;小粉&lt;/p&gt;&lt;div&gt;我是一个想红的div&lt;/div&gt;/*穿好衣服的样子*/&lt;p class=&quot;red&quot;&gt;小红&lt;/p&gt;&lt;p class=&quot;yellow&quot;&gt;小黄&lt;/p&gt;&lt;p class=&quot;pink&quot;&gt;小粉&lt;/p&gt;&lt;div class=&quot;red&quot;&gt;我是一个想红的div&lt;/div&gt;</code></pre><p><strong>作用：</strong>根据指定的类名，来设置指定的标签的样式（穿衣服）</p><p><strong>结构：</strong></p><pre><code>&lt;style&gt;    .类名(选择器) &#123;        属性名1: 属性值1;        属性名2: 属性值2;        ....    &#125;&lt;/style&gt;</code></pre><p><strong>步骤：</strong></p><ol><li>声明自定义类名<code>.自定义类名 &#123;属性1:值1;属性2: 值2;&#125; </code>（先做一件衣服）</li><li>给对应的元素添加class类名属性 class&#x3D;”自定义的类名”  （把衣服给标签穿上）</li></ol><p><strong>效果：</strong> </p><ul><li>所有拥有这个类名的这些标签都加上对应样式</li><li>可以给相同标签名的标签定义不同的样式（用的最多）</li></ul><p><strong>注意：</strong></p><ol><li>类名的命名方式：数字  字母  下划线   <strong>不能以数字开头！！</strong></li><li>一个标签可以使用多个类选择器，每个类名之间以空格隔开 （覆盖问题-》层叠样式表）</li><li>一个类选择器，可以用在多个标签上（一种衣服可以很多人穿-》撞衫）</li></ol><h2 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器(#)"></a>ID选择器(#)</h2><blockquote><p>要求：都设置不同的颜色，不用类选择器</p></blockquote><pre><code class="html">&lt;p id=&quot;red&quot;&gt;天选之人-红果果&lt;/p&gt;&lt;p id=&quot;green&quot;&gt;天选之人-绿泡泡&lt;/p&gt;&lt;div id=&quot;lowred&quot;&gt;我也想变红&lt;/div&gt;</code></pre><p><strong>作用：</strong>根据指定的id，来设置指定的标签的样式（专属装备）</p><p><strong>结构：</strong></p><pre><code>&lt;style&gt;    #id名(选择器) &#123;        属性名1: 属性值1;        属性名2: 属性值2;        ....    &#125;&lt;/style&gt;</code></pre><p><strong>步骤：</strong></p><ol><li>声明id <code>#自定义id名字 &#123;属性1:值1;属性2:值2;&#125;</code>（做一件专属装备）</li><li>给对应的元素添加属性 id&#x3D;”自定义id”  （调用id选择器，找到天选之人，给他穿上这件专属装备）</li></ol><p><strong>效果:</strong> </p><ul><li><p>会将拥有这个id名的标签加上对应的属性</p><p><strong>特点 :一对一</strong></p><p>（一个标签只能用一个id选择器 ,一个页面上也只能用唯一的id）</p></li></ul><p><strong>注意点：</strong></p><ul><li>id属性相当于标签的身份证号码<ul><li>一个页面中的标签不能有相同的id，每一个标签的id都是唯一的！</li></ul></li><li>一个标签上只能有一个id属性，并且唯一</li><li>一个id选择器只能选中一个标签</li><li>id的命名规则和类名一样（规范）</li></ul><blockquote><p>id 主要不是为了设置css样式，而且为了后面的js使用</p></blockquote><h3 id="特别注解："><a href="#特别注解：" class="headerlink" title="特别注解："></a>特别注解：</h3><h4 id="id和class的区别"><a href="#id和class的区别" class="headerlink" title="id和class的区别"></a>id和class的区别</h4><ul><li><p>id相当于身份证，不可重复，一个HTML标签只能绑定一个id属性</p></li><li><p>class相当于姓名，可以重复，一个HTML标签可以绑定多个class属性</p></li></ul><h4 id="id选择器和class选择器的区别？"><a href="#id选择器和class选择器的区别？" class="headerlink" title="id选择器和class选择器的区别？"></a>id选择器和class选择器的区别？</h4><ul><li>id选择器以#开头</li><li>class选择器以.开头</li></ul><h4 id="实际开发情况"><a href="#实际开发情况" class="headerlink" title="实际开发情况"></a>实际开发情况</h4><ul><li>使用最多的是class选择器</li><li>id一般情况下是给js使用的，所以除非特殊情况，否则不要用id去设置样式。</li><li>实际公司开发要注意代码的<strong>冗余代码的抽取</strong>，可以将一些公共的代码抽取到一个类选择器中</li></ul><h5 id="ヾ-๑╹◡╹-ﾉ”课堂练习小练习"><a href="#ヾ-๑╹◡╹-ﾉ”课堂练习小练习" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”课堂练习小练习:"></a>ヾ(๑╹◡╹)ﾉ”课堂练习小练习:</h5><p><img src="/2021/05/08/1541065649298739200/images/1605666253972.png" alt="1605666253972"></p><h5 id="ヾ-๑╹◡╹-ﾉ”课堂练习小练习-1"><a href="#ヾ-๑╹◡╹-ﾉ”课堂练习小练习-1" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”课堂练习小练习:"></a>ヾ(๑╹◡╹)ﾉ”课堂练习小练习:</h5><pre><code>  &lt;p&gt;我是p标签,我想变大，不想变红&lt;/p&gt;  &lt;p&gt;我是p标签，我想变红，不想变大！！&lt;/p&gt;  &lt;div&gt;我是div，我想变红，我想变大&lt;/div&gt;</code></pre><h1 id="复杂（复合）选择器"><a href="#复杂（复合）选择器" class="headerlink" title="复杂（复合）选择器"></a>复杂（复合）选择器</h1><h2 id="通配符选择器（-）"><a href="#通配符选择器（-）" class="headerlink" title="通配符选择器（*）"></a>通配符选择器（*）</h2><blockquote><p>需求 :把页面内所有的元素都设置一个颜色为red</p></blockquote><pre><code class="html">&lt;h1&gt;标题&lt;/h1&gt;&lt;div&gt;小姐姐&lt;/div&gt;&lt;p&gt;小帅哥&lt;/p&gt;&lt;h2&gt;我是h2&lt;/h2&gt;&lt;p&gt;小可爱&lt;/p&gt;&lt;span&gt;大可爱&lt;/span&gt;</code></pre><p><strong>作用：</strong> 会将页面上所有的标签都设置这个样式</p><p><strong>代码：</strong></p><pre><code class="html">&lt;style&gt;    * &#123;        属性名: 属性值;    &#125;&lt;/style&gt;</code></pre><p><strong>注意:</strong> </p><ul><li>通配符会去页面上一个个的遍历页面所有的标签，然后给他们进行设置样式（效率低，不要滥用）</li></ul><h2 id="并集选择器（，）"><a href="#并集选择器（，）" class="headerlink" title="并集选择器（，）"></a>并集选择器（，）</h2><blockquote><p>需求：把div和p的设置红色（节省代码的方式）</p></blockquote><pre><code class="html">&lt;!-- 给div 和p标签设置red色 节省代码的方式  --&gt;&lt;div class=&quot;red&quot;&gt;小帅哥&lt;/div&gt;&lt;p&gt;小姐姐&lt;/p&gt;&lt;p&gt;小可爱&lt;/p&gt;&lt;span id=&quot;biglovely&quot;&gt;大可爱&lt;/span&gt;</code></pre><p><strong>作用 :</strong> 将满足多个选择器类型的标签全部选择出来</p><p><strong>代码 :</strong> </p><pre><code class="html">&lt;style&gt;    选择器,选择器 &#123;        属性名1: 属性值1;    &#125;&lt;/style&gt;</code></pre><p><strong>注意 :</strong></p><ul><li>并集选择器可以同时写很多的选择器 ，只要每个选择器之间以<strong>逗号隔开</strong> </li><li>并集选择器中的选择器，可以是标签选择器、类选择器、id选择器、等等……</li></ul><h2 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h2><blockquote><p>需求：只让小可爱变红</p></blockquote><pre><code class="html">&lt;!-- 只让小可爱变红  其他的是默认的颜色  不能改变html中的代码 --&gt;&lt;div class=&quot;red&quot;&gt;小姐姐&lt;/div&gt;&lt;p&gt;小帅哥&lt;/p&gt;&lt;p class =&quot;red&quot;&gt;小可爱&lt;/p&gt;</code></pre><p><strong>作用：</strong> 从两个集合中选择他们相同的部分</p><pre><code>既又原则 例如：p.box &#123;&#125;  既是p标签 又有box类名</code></pre><p><strong>代码：</strong> </p><pre><code class="js">选择器1选择器2 &#123;    属性名1: 属性值1;&#125;该标签既能被选择器1选中，又能被选择器2选中</code></pre><p><strong>注意：</strong></p><ul><li>两个选择器是紧密挨着的，中间不能有其他任何东西</li><li>如果交集选择器中标签选择器，标签选择器写在最开头</li><li>交集选择器可以同时写多个选择器</li></ul><h2 id="后代选择器（空格）"><a href="#后代选择器（空格）" class="headerlink" title="后代选择器（空格）"></a>后代选择器（空格）</h2><blockquote><p>需求：完成下面的要求</p></blockquote><pre><code class="html">&lt;!-- 不准改下面的html结构 只让小姐姐变红--&gt;&lt;div class=&quot;father&quot;&gt;     &lt;p&gt;小姐姐&lt;/p&gt;&lt;/div&gt;&lt;p&gt;小可爱&lt;/p&gt;</code></pre><p>这个选择器开发挺常用的</p><p><strong>作用 :</strong>  选中满足条件的后代元素（后代 : 儿子、孙子、重孙子……）</p><p><strong>代码 :</strong> </p><pre><code class="html">&lt;style&gt;    .father p &#123;        color: red;    &#125;&lt;/style&gt;选择器1 选择器2 &#123;    属性名1: 属性值1;    ....&#125;</code></pre><p><strong>步骤：</strong></p><ol><li>通过选择器1找到一堆标签</li><li>找到这一对标签的所有的后代标签</li><li>在这些后代标签中，找到满足选择器2的标签，给这些标签加上样式</li></ol><h2 id="子代选择器（-gt-）"><a href="#子代选择器（-gt-）" class="headerlink" title="子代选择器（&gt;）"></a>子代选择器（&gt;）</h2><blockquote><p>需求：完成下面的要求</p></blockquote><pre><code class="html">&lt;!-- 只让小可爱变红  其他的不变颜色  不准更改html的结构 --&gt;&lt;div class=&quot;father&quot;&gt;    &lt;p&gt;小可爱&lt;/p&gt;    &lt;div&gt;        &lt;p&gt;小姐姐&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;&lt;p&gt;大可爱&lt;/p&gt;</code></pre><p><strong>作用 ：</strong>选中满足条件的直接子代元素 （子代 : 儿子）</p><p><strong>代码 :</strong> </p><pre><code class="css">&lt;style&gt;    .father &gt; p &#123;        color: red;    &#125;&lt;/style&gt;选择器1 &gt; 选择器2 &#123;    属性名1: 属性值1;    ....&#125;</code></pre><p><strong>注意：</strong></p><ul><li>只找的是自己的儿子辈</li></ul><h5 id="ヾ-๑╹◡╹-ﾉ”项目中的情况（时间不够留给作业）"><a href="#ヾ-๑╹◡╹-ﾉ”项目中的情况（时间不够留给作业）" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”项目中的情况（时间不够留给作业）"></a>ヾ(๑╹◡╹)ﾉ”项目中的情况（时间不够留给作业）</h5><pre><code class="html">&lt;!-- 主导航栏 --&gt;&lt;div class=&quot;nav&quot;&gt;      &lt;ul&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司首页&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司简介&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司产品&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;         &lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;         &lt;ul&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司邮箱&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司电话&lt;/a&gt;&lt;/li&gt;         &lt;/ul&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;!-- 侧导航栏 --&gt;&lt;div class=&quot;sitenav&quot;&gt;      &lt;div class=&quot;left&quot;&gt;左侧侧导航栏&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>在不修改以上代码的前提下，完成以下任务：</p><ol><li>链接登录的颜色为红色，同时主导航栏里面的所有的链接改为粉色（简单）</li><li>主导航栏和侧导航栏里面文字都是14像素并且是微软雅黑（中等）</li><li>主导航栏里面的一级菜单链接文字颜色为绿色（难）</li></ol><p><strong>答案：</strong></p><pre><code class="html">.right a &#123;    color: red;&#125;.nav a &#123;    color: pink;&#125;.nav,.sitenav &#123;    font-size: 14px;    font-family: &#39;微软雅黑&#39;;&#125;.nav&gt;ul&gt;li&gt;a &#123;    color: green;&#125;</code></pre><p><strong>小注意：</strong></p><ul><li>基本选择器是必须熟练使用的</li><li>复合选择器需要配合项目多次使用才能熟练使用，第一次很难确定什么时候使用这是很正常的，之后的项目中跟着老师一起练即可</li></ul><h1 id="拓展的小细节"><a href="#拓展的小细节" class="headerlink" title="拓展的小细节"></a>拓展的小细节</h1><h2 id="颜色的属性（知道即可）"><a href="#颜色的属性（知道即可）" class="headerlink" title="颜色的属性（知道即可）"></a>颜色的属性（知道即可）</h2><p><strong>颜色的取值可以是：</strong></p><ul><li><p><strong>具体的颜色的英文单词：</strong> </p><p>yellow，pink，red，purple（常用的颜色单词要记住，案例中会经常使用）</p></li><li><p><strong>rgb 表示法</strong>（三种颜色的比例）</p><p>r：red     g：green   b：blue  </p><p><img src="/2021/05/08/1541065649298739200/images/1605666286319.png" alt="1605666286319"></p><p>rgb（0,0,0）分别表示red、green、blue的比重，数值范围0~55</p><p>白？黑？红？绿？蓝？</p></li><li><p><strong>rgba 表示法</strong>， 最后一个表示<strong>透明度</strong> （0~1）</p><p>省略写法：rgba( 0, 0, 0, 0.5 ) —》 rgba( 0, 0, 0, .5 )</p></li><li><p><strong>十六进制表示法</strong>  #CFCFCF</p><p><strong>特点：</strong></p><ol><li>以#开头的十六进制</li><li>前两位代表红色，中间代表绿色，最后代表蓝色</li><li>不区分大小写</li><li>如果三组都是重复的，可以简写  #aabbcc&#x3D;》#abc</li></ol></li><li><p><strong>之后会量颜色或者UI给你，不是自己肉眼看，所以直接拿来用就行。</strong></p></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>作用：</strong>可以让页面上的一段代码让他们失去作用，浏览器不解析他们（和html的注释差不多，就是格式不一样）</p><pre><code class="html">&lt;!-- --&gt;: html 中的注释, 不能嵌套/*    */: css 中的注释, 不能嵌套</code></pre><p>注释快捷键：Ctrl + &#x2F;</p><h1 id="CSS的三种书写位置"><a href="#CSS的三种书写位置" class="headerlink" title="CSS的三种书写位置"></a>CSS的三种书写位置</h1><blockquote><p>内嵌（嵌入）样式表、行内样式表、外联（外部）样式表</p></blockquote><h3 id="内嵌样式"><a href="#内嵌样式" class="headerlink" title="内嵌样式"></a>内嵌样式</h3><blockquote><p>将css语句都写在style标签里面（写了很久了）</p></blockquote><p><strong>位置：</strong></p><ul><li>head标签里面，title标签下面，style标签里面</li></ul><p><strong>作用范围：</strong></p><ul><li>当前页面</li></ul><pre><code class="html">&lt;style&gt;    div &#123;        color: red；        font-size：100px；    &#125;&lt;/style&gt;</code></pre><p><strong>作用：</strong></p><ul><li>一般用在小demo或者小案例的时候用到，用的稍多</li></ul><h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><blockquote><p>将CSS样式直接写在标签本身上，以属性的形式存在 </p></blockquote><p><strong>位置：</strong></p><ul><li>标签里面（双标签——》开始标签）</li></ul><p><strong>作用范围：</strong></p><ul><li>当前标签</li></ul><pre><code class="html">&lt;div style=&quot;color: red; font-size: 100px;&quot;&gt;小可爱&lt;/div&gt;</code></pre><p><strong>作用：</strong></p><ul><li>之后的学习的js操作的都是行内样式，用的较少，基础班最好别用</li></ul><h3 id="外联样式"><a href="#外联样式" class="headerlink" title="外联样式"></a>外联样式</h3><blockquote><p>单独创建一个后缀名为.css的文件，在html文件里面通过link标签引入css文件</p></blockquote><p><strong>步骤：</strong></p><ul><li>新建一个文件, 后缀叫 .css</li><li>在这个文件中直接通过 link 引入</li></ul><p><strong>位置：</strong></p><ul><li>新建一个新的css文件</li><li>在title下面引用</li></ul><p><strong>作用范围：</strong></p><ul><li>哪个页面引入，那个页面有效果</li></ul><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;路径&quot; &gt;</code></pre><p><strong>作用：</strong></p><ul><li>用的最多的一种，一般在项目中会用到。推荐使用</li></ul><h3 id="三种样式表总结"><a href="#三种样式表总结" class="headerlink" title="三种样式表总结"></a>三种样式表总结</h3><table><thead><tr><th align="center">样式表</th><th align="center">作用范围</th><th align="center">存放位置</th><th align="center">应用</th></tr></thead><tbody><tr><td align="center">内嵌样式</td><td align="center">当前页面</td><td align="center">head里的title下面的style</td><td align="center">存放当前页面的样式</td></tr><tr><td align="center">行内样式</td><td align="center">只作用于当前标签</td><td align="center">通过标签的style属性设置</td><td align="center">只给一个标签使用（js）</td></tr><tr><td align="center">外联样式</td><td align="center">所有页面都可以使用</td><td align="center">在html文件中通过link引入</td><td align="center">存放很多页面的公共样式</td></tr></tbody></table><h1 id="text-文本相关属性"><a href="#text-文本相关属性" class="headerlink" title="text- 文本相关属性"></a>text- 文本相关属性</h1><h3 id="text-indent：文本的缩进"><a href="#text-indent：文本的缩进" class="headerlink" title="(*)text-indent：文本的缩进"></a>(*)text-indent：文本的缩进</h3><blockquote><p>设置文字的缩进,类似word中首行缩进</p></blockquote><p><strong>取值：</strong></p><ul><li>px（像素）</li><li>em（一个文字的大小）</li></ul><p><strong>注意：</strong></p><ul><li>单位是 em，1em代表一个文字的宽度 ，2em标签首行缩进两个字符。</li></ul><h3 id="text-align：文本的对齐方式"><a href="#text-align：文本的对齐方式" class="headerlink" title="text-align：文本的对齐方式"></a>text-align：文本的对齐方式</h3><blockquote><p>设置文字的对齐方式（水平居中）</p></blockquote><p><strong>取值：</strong></p><ul><li><p>left：设置<code>内容</code>在盒子中 <strong>靠左</strong></p></li><li><p>center：设置<code>内容</code>在盒子中 <strong>水平居中</strong></p></li><li><p>right：设置<code>内容</code>在盒子中 <strong>靠右</strong></p></li></ul><p><strong>注意：</strong></p><ul><li><p>能让哪些元素位置居中???</p><p>【文本、图片（行内块），span（行内）】</p></li></ul><h3 id="text-decoration：文本的修饰"><a href="#text-decoration：文本的修饰" class="headerlink" title="text-decoration：文本的修饰"></a>text-decoration：文本的修饰</h3><blockquote><p>设置文字的修饰（下划线、删除线等）</p></blockquote><p><strong>取值：</strong></p><ul><li>none：没有任何装饰（去掉多余的样式）</li><li>underline：下划线</li><li>line-through：删除线</li></ul><p><strong>注意：</strong></p><ul><li>一般用的最多的是用text-decoration：none，取消a标签的默认下划线。</li></ul><p><strong>总结：</strong>strong、ins、em、del已经全部都css替换掉了</p><ul><li>strong——–》font的bold：加粗</li><li>ins———》underline：下划线</li><li>em——–》font的italic：斜体</li><li>del——–》line-through：删除线</li></ul><h1 id="让盒子水平居中"><a href="#让盒子水平居中" class="headerlink" title="(*)让盒子水平居中"></a>(*)让盒子水平居中</h1><blockquote><p>项目中会经常用到让盒子（div、p、h）水平居中</p></blockquote><pre><code>margin: 0 auto;</code></pre><p><strong>作用：</strong> 可以让<code>盒子</code>水平居中</p><p><strong>条件：</strong></p><ul><li>有<strong>宽度</strong>的<strong>盒子</strong>（div、p、h），独占一行是div的效果，但是总体上来说不算居中。</li></ul><p><strong>区别：</strong></p><p><code>margin:0 auto;</code> 和<code>text-align</code> 的区别</p><ul><li>一个是盒子本身居中</li><li>一个是盒子里的内容居中</li></ul><h5 id="ヾ-๑╹◡╹-ﾉ”改写昨天的新闻案例"><a href="#ヾ-๑╹◡╹-ﾉ”改写昨天的新闻案例" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”改写昨天的新闻案例"></a>ヾ(๑╹◡╹)ﾉ”改写昨天的新闻案例</h5><h1 id="CSS的三大特性"><a href="#CSS的三大特性" class="headerlink" title="CSS的三大特性"></a>CSS的三大特性</h1><blockquote><p>解释css的一些效果~</p></blockquote><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><blockquote><p>后代元素会继承祖先元素的一些样式（子承父业）</p></blockquote><pre><code class="html">&lt;div class=&quot;father&quot;&gt;父亲    &lt;div class=&quot;son&quot;&gt;儿子&lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>开发者调试工具的使用！</strong></p><p><strong>有哪些样式属性可以继承（没说就是不能继承）：</strong></p><ul><li>color：颜色</li><li>font- 开头的：字体相关属性</li><li>text- 开头的：文本相关属性</li><li>line- 开头的：line-height<ul><li>开发者调试工具中的<strong>computed</strong></li></ul></li></ul><p><strong>应用：</strong>可以省略自己的代码。比如 <code>list-style：none；</code>  一般给ul设置，此时可以利用继承性</p><p><strong>注意（继承的失效）：</strong></p><ul><li>a链接颜色不能通过继承设置，需要单独设置（a标签有本身的样式）<ul><li>a标签有默认的样式，要给a标签设置样式，需要单独选中后设置！</li></ul></li><li>h系列标签字体大小不能通过继承设置，需要单独设置（有本身的样式）</li><li>div的高度不能继承，宽度默认有继承父元素的效果</li><li>元素如果自身有CSS样式，那么该样式不予继承（独立）</li></ul><blockquote><p>以后敲代码别想着用继承就少写代码，该设置的代码一个别省（<strong>不要用css的继承性偷懒</strong>）</p></blockquote><h2 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h2><blockquote><p>浏览器解决样式冲突的特性</p></blockquote><p><strong>特点：</strong>后渲染的css样式会覆盖掉先渲染的css样式 （优先级相同的情况下） </p><pre><code>层叠的属性不一样------》叠加层叠的属性一样-------》覆盖（下面的生效）</code></pre><p><strong>例子：</strong></p><pre><code class="html">&lt;style&gt;    .red &#123;        color: green;        color: red;    &#125;    /* 最终绿色起效果,因为.green后渲染 */    .green &#123;        color:green;    &#125;&lt;/style&gt;&lt;div class=&quot;green red&quot;&gt;小姐姐&lt;/div&gt;</code></pre><h2 id="优先级（重要）"><a href="#优先级（重要）" class="headerlink" title="优先级（重要）"></a>优先级（重要）</h2><blockquote><p>给页面中的一个标签设置样式，可以通过多种方法~</p><p>当设置的样式层叠的时候，需要考虑优先级（权重）</p></blockquote><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><blockquote><p>不同的基础选择器有不同的优先级</p></blockquote><pre><code>继承 &lt; 通配符 &lt; 标签选择器 &lt; 类选择器 &lt; ID选择器 &lt; 行内样式 &lt;　!important</code></pre><p><strong>！important：</strong>无法提高继承的优先级（继承还是继承，优先级还是最低的），并且注意格式的问题</p><p>【案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        *&#123;            color: blue;        &#125;        #box&#123;            /* color: blueviolet; */        &#125;        .box&#123;            /* color: green; */            /* color: yellow !important; */        &#125;        div&#123;            /* color: antiquewhite; */        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- &lt;div class=&quot;box&quot; id=&quot;box&quot; style=&quot;color:red&quot;&gt;优先级&lt;/div&gt; --&gt;    &lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;优先级&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><blockquote><p>当面对复合选择器的时候，需要考虑权重的计算</p></blockquote><p><strong>计算公式：</strong></p><p>公式算法：（0,0,0,0）</p><p><img src="/2021/05/08/1541065649298739200/images/1605665353039.png" alt="1605665353039"></p><ul><li>第一个数字：行内样式的个数</li><li>第二个数字：ID选择器的个数</li><li>第三个数字：类选择器的个数</li><li>第四个数字：标签选择器的个数</li></ul><p><strong>注意：</strong></p><ul><li><p>从第一级开始比较，如果第一级大,，那么就大； 如果第一级一样， 那么就比第二级……</p></li><li><p><strong>!important</strong>如果能选中对应的标签，则权重最高，天下第一！！</p></li><li><p>权重其实就是计算优先级的算法！！</p></li><li><p>计算的步骤</p><pre><code>第一步 : 是不是能选择到该标签（继承------》pass掉）第二步 : 使用公式（0,0,0,0） </code></pre></li></ul><p><strong>补充一点：</strong>浏览器解析选择器的时候，实际是用右往左解析的，所以<strong>尽量少使用层级关系</strong>（涉及到算法的遍历）</p><p><strong>例子：</strong></p><blockquote><p>不同的选择器选中同一个标签，选择器设置相同的样式，此时听谁的？</p></blockquote><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        /*根据权重公式-显示红色*/        .father .son .grandson&#123;            color: red;        &#125;        .son .grandson&#123;            color: green;        &#125;        .grandson&#123;            color: blue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;father&quot;&gt;        父亲        &lt;div class=&quot;son&quot;&gt;            儿子            &lt;div class=&quot;grandson&quot;&gt;                孙子            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="背景相关的属性（background）"><a href="#背景相关的属性（background）" class="headerlink" title="(*)背景相关的属性（background）"></a>(*)背景相关的属性（background）</h1><h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2><blockquote><p>设置标签的背景颜色</p></blockquote><p><strong>代码：</strong><code>background-color: red;</code></p><p><strong>取值：</strong></p><ul><li>可以是之前介绍的几种~（前端只需要会写就行了，具体的值是UI设计好的）</li></ul><h2 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h2><blockquote><p>设置标签的背景为图片</p></blockquote><p><strong>代码：</strong><code>background-image: url(图片路径);</code></p><p><strong>注意：</strong></p><ul><li>背景图片默认平铺</li></ul><h2 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h2><blockquote><p>设置标签的背景图片是否平铺</p></blockquote><p><strong>代码：</strong><code>background-repeat: no-repeat；</code></p><p><strong>取值：</strong></p><ul><li>repeat：平铺 （默认值）</li><li>no-repeat：不平铺</li><li>repeat-x：水平平铺</li><li>repeat-y：垂直平铺</li></ul><h2 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h2><blockquote><p>设置背景图片的位置</p></blockquote><p><strong>代码：</strong><code>background-position: 水平方向的位置（x） 垂直方向的位置（y）；</code></p><p><strong>取值：</strong></p><ul><li><p>关键字</p><ul><li>水平方向：left、center、right</li><li>垂直方向：top、center、bottom</li></ul></li><li><p>像素：当前盒子的左上角为（0,0）原点，构建一个坐标系。第一值是X轴的位置，第二个值是Y轴的位置 交互的点就是图片左上角顶点开始显示的起始位置。<br>注意：<br>1、浏览器里面的坐标系X轴水平向右  Y轴垂直向下<br>2、注意顺序</p></li></ul><h2 id="背景的连写"><a href="#背景的连写" class="headerlink" title="背景的连写"></a>背景的连写</h2><blockquote><p>背景属性相关的连写形式</p></blockquote><p><strong>代码：</strong><code>background: #fff url() no-repeat  center center;</code> （记住这个顺序）</p><p><strong>注意：</strong></p><ul><li><p>background：背景<code>颜色</code> 背景<code>图片</code>地址 背景<code>平铺</code>  背景<code>位置</code>;（推荐使用这个顺序！）</p></li><li><p>省略：</p><pre><code class="css">background: color image repeat position;省略 :  color /  image repeat position;（相当于background-color）省略的特殊情况    当div（盒子）的大小和背景图片的尺寸一样的时候    当div（盒子）大小=背景图片的大小    可以只写  background:url(200.jpg);  相当于只写background-image</code></pre></li><li><p>注意写省略时候有覆盖的问题（省略写法，没写就是默认值，默认值也会覆盖！）</p></li></ul><p>【案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box&#123;            width: 300px;            height: 300px;            border: 1px solid;            margin: 0 auto;            /* background-color: darkblue; */            /* background-image: url(./img/head.jpg); */            /* background-repeat: no-repeat; */            /* background-position: 10px 10px; */            /* background-position: center center; */            /* 连写 */            background: blueviolet url(./img/head.jpg) no-repeat center center;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="标签的三种显示方式（重要，必会！！）"><a href="#标签的三种显示方式（重要，必会！！）" class="headerlink" title="*标签的三种显示方式（重要，必会！！）"></a>*标签的三种显示方式（重要，必会！！）</h1><blockquote><p>看看div、p、span、a的效果~</p><p>div独占一行、宽度默认继承父盒子、高度由内容撑开</p><p>span一行显示一个、宽度和高度都是由内容撑开</p></blockquote><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><blockquote><p>查看div的computed搜索：display</p></blockquote><p><strong>属性：</strong>display : block  ; </p><p><strong>特点：</strong></p><ul><li>独占一行一行、只能显示一个  （有时候就需要这种的，不算缺点）</li><li>默认宽度是父级标签的宽度</li><li>可设置宽和高（优点）</li></ul><p><strong>代表：</strong></p><ul><li><p>div、p、h系列（记住）</p><pre><code>div,p,ol,li,ul,dt,dd,dl,header,footer,aside,nav,article,section</code></pre></li></ul><p><strong>注意：p这种段落标签不要嵌套块级元素</strong>（<strong>惊天BUG</strong>）</p><h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><p><strong>属性：</strong>display : inline；</p><p><strong>特点：</strong></p><ul><li>一行可以显示多个 (优点)、不独占一行</li><li>宽度由内容决定，盒子大小完全是被内容撑开</li><li>无法设置宽高   (缺点)</li></ul><p><strong>代表：</strong>  </p><ul><li><p>span、a</p><pre><code>a,span,b,u,s,i,strong,ins,del,em</code></pre></li></ul><h2 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h2><blockquote><p>行内元素演变成现在的行内块元素的</p></blockquote><p><strong>属性：</strong> display: inline-block ; </p><p><strong>特点：</strong></p><ul><li>一行可以显示多个 (像是行内)</li><li>可以设置宽高  (像是块级)</li></ul><p><strong>代表：</strong>  input、img、textarea、select、button</p><h2 id="三种显示方式的转换"><a href="#三种显示方式的转换" class="headerlink" title="三种显示方式的转换"></a>三种显示方式的转换</h2><ul><li><code>display: block;</code> 转成块级</li><li><code>display: inline;</code> 转成行内</li><li><code>display: inline-block;</code> 转成行内块</li></ul><h5 id="ヾ-๑╹◡╹-ﾉ”low导航（都是a标签-60-40）字体大小12px"><a href="#ヾ-๑╹◡╹-ﾉ”low导航（都是a标签-60-40）字体大小12px" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”low导航（都是a标签 60*40）字体大小12px"></a>ヾ(๑╹◡╹)ﾉ”low导航（都是a标签 60*40）字体大小12px</h5><p><img src="/2021/05/08/1541065649298739200/images/1605664358957.png" alt="1605664358957"></p><h1 id="链接伪类选择器-了解"><a href="#链接伪类选择器-了解" class="headerlink" title="链接伪类选择器(了解)"></a>链接伪类选择器(了解)</h1><blockquote><p>选择的元素的一种状态，并只是找到元素就没了</p></blockquote><h2 id="链接伪类选择器介绍"><a href="#链接伪类选择器介绍" class="headerlink" title="链接伪类选择器介绍"></a>链接伪类选择器介绍</h2><blockquote><p>回顾a链接的特性</p></blockquote><pre><code class="js">(1) a:link &#123;        color: red;        font-size: 18px;    &#125;    作用: 给a标签设置`没有被访问过`的样式(2) a:visited &#123;        color: blue;    &#125;    作用: 给a标签设置`访问过`的样式    一般这个只设置 color, 其他属性会无效(3) a:hover &#123;        color: pink;        font-size: 20px;    &#125;    作用: 给a标签设置 `鼠标悬停`的样式(4) a:active &#123;        color: green;        font-size: 30px;           // 背景颜色不能设     &#125;    作用: 给a标签设置 ` 激活(点击中) `的状态</code></pre><h2 id="链接伪类选择器注意点"><a href="#链接伪类选择器注意点" class="headerlink" title="链接伪类选择器注意点"></a>链接伪类选择器注意点</h2><ul><li><p>一般一起使用设置某个属性，都设置某一个属性</p></li><li><p>顺序固定</p><pre><code>link visited hover activelvha =&gt; 看见lv包就ha</code></pre></li><li><p>hover必须记住（可以加给其他元素），其他的几乎不用</p></li></ul><h1 id="居中方法小总结"><a href="#居中方法小总结" class="headerlink" title="居中方法小总结"></a>居中方法小总结</h1><h2 id="让标签中的内容（文本、图片、span）水平居中"><a href="#让标签中的内容（文本、图片、span）水平居中" class="headerlink" title="让标签中的内容（文本、图片、span）水平居中"></a>让标签中的内容（文本、图片、span）水平居中</h2><pre><code>text-align:center1.文本2.行内块元素（input/img）3.行内元素（span/a）</code></pre><h2 id="让标签中的内容（文本、图片、span）垂直居中"><a href="#让标签中的内容（文本、图片、span）垂直居中" class="headerlink" title="让标签中的内容（文本、图片、span）垂直居中"></a>让标签中的内容（文本、图片、span）垂直居中</h2><pre><code>line-height：标签的高度；1.文本2.行内块元素（input/img）注意：`img需要加 vertical-align : middle（垂直对齐方式居中）`3.行内元素（span/a）</code></pre><p>【案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box&#123;            width: 300px;            height: 300px;            border: 1px solid;            text-align: center;            line-height: 300px;            margin: 0 auto;        &#125;        .box img&#123;            /*图片居中要加上这个*/            vertical-align: middle;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;!-- heh --&gt;        &lt;!-- &lt;input type=&quot;text&quot;&gt; --&gt;        &lt;!-- &lt;span&gt;111&lt;/span&gt; --&gt;        &lt;img src=&quot;./img/head.jpg&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="让盒子自身水平居中"><a href="#让盒子自身水平居中" class="headerlink" title="让盒子自身水平居中"></a>让盒子自身水平居中</h2><pre><code>盒子自身设置 margin:0 auto;</code></pre><h2 id="让盒子自身垂直居中"><a href="#让盒子自身垂直居中" class="headerlink" title="让盒子自身垂直居中"></a>让盒子自身垂直居中</h2><pre><code>之后学习的定位</code></pre><h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><blockquote><p>一种思维方式（万物皆盒子）</p></blockquote><p><img src="/2021/05/08/1541065649298739200/images/1605663475449.png" alt="1605663475449"></p><h2 id="盒子模型的组成"><a href="#盒子模型的组成" class="headerlink" title="盒子模型的组成"></a>盒子模型的组成</h2><blockquote><p>盒子模型的四个组成部分</p></blockquote><p><img src="/2021/05/08/1541065649298739200/images/1605663499790.png" alt="1605663499790"></p><ul><li>content（内容&#x2F;电脑）+padding（内边距&#x2F;海绵）+border（边框&#x2F;白色纸壳）+margin（外边距&#x2F;盒子与盒子间的距离）</li></ul><h2 id="边框（border-边框-盒子的外纸壳）"><a href="#边框（border-边框-盒子的外纸壳）" class="headerlink" title="边框（border-边框-盒子的外纸壳）"></a>边框（border-边框-盒子的外纸壳）</h2><p><strong>属性：</strong></p><ul><li>border-width: 边框的宽度（10px）；</li><li>border-style: 边框的样式；<ul><li>solid : 实线 （用的最多）</li><li>dashed : 虚线</li><li>dotted : 点线</li></ul></li><li>border-color: 边框的颜色；<ul><li>有颜色：red、#fff、rgb()等等</li><li>透明：transparent</li></ul></li></ul><p><strong>连写：</strong></p><pre><code class="js">border: 边框大小  边框样式 边框颜色;border: 1px solid blue;  // 不要记上面那个，就记这个即可 （用的最多）快捷方式：bd+ + tab  以后使用，都用连写，基本不会单独写</code></pre><p><strong>方向：</strong></p><blockquote><p>单独设置盒子的一条边框</p></blockquote><pre><code>border-方位名词:边框大小 边框样式 边框颜色;比如：    border-left 左边框    border-right 右边框    border-top 上边框    border-bottom 下边框</code></pre><p><strong>补充：</strong></p><ul><li><p>细线表格 <code>border-collapse:collapse；</code>这样就不用写cellpadding和cellspacing了</p><p><img src="/2021/05/08/1541065649298739200/images/1605663546486.png" alt="1605663546486"></p></li><li><p>使用开发者工具查看盒子模型（计算盒子的大小，<strong>初级计算公式</strong>）</p><pre><code class="html">&lt;!-- 需求 :     盒子尺寸 400*400 , 背景绿色, 边框: 10px 实线 黑色 --&gt;注意：    1.css设置的height和width设置的是内容的宽高    2.添加边框会让盒子变大解决：    在设置边框之后根据初级公式，把height和width手动减去多出的部分    （手动内减）解决方案：盒子内容 380*380 , 背景绿色, 边框：10px 实线 黑色</code></pre></li></ul><h5 id="ヾ-๑╹◡╹-ﾉ”写一个小盒子（由内容和边框组成）"><a href="#ヾ-๑╹◡╹-ﾉ”写一个小盒子（由内容和边框组成）" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”写一个小盒子（由内容和边框组成）"></a>ヾ(๑╹◡╹)ﾉ”写一个小盒子（由内容和边框组成）</h5><p><img src="/2021/05/08/1541065649298739200/images/1605663571427.png" alt="1605663571427"></p><h5 id="——————————"><a href="#——————————" class="headerlink" title="——————————-"></a>——————————-</h5><h5 id="ヾ-๑╹◡╹-ﾉ”不low导航"><a href="#ヾ-๑╹◡╹-ﾉ”不low导航" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”不low导航~"></a>ヾ(๑╹◡╹)ﾉ”不low导航~</h5><p><img src="/2021/05/08/1541065649298739200/images/1605663587535.png" alt="1605663587535"></p><h2 id="内边距（padding-内边距-盒子的泡沫）"><a href="#内边距（padding-内边距-盒子的泡沫）" class="headerlink" title="内边距（padding-内边距-盒子的泡沫）"></a>内边距（padding-内边距-盒子的泡沫）</h2><blockquote><p>盒子边框与内容之间的距离</p></blockquote><p><strong>取值：</strong></p><ul><li><p><strong>一个值：</strong>控制整个上下左右 <code>padding : 40px；</code></p><p>上、右、下、左 的内边距都设置了 40 px的距离;</p></li><li><p><strong>两个值：</strong>第一个控制上下 第二个控制左右  <code>padding : 40px 80px</code></p><p>上下 &#x3D;&gt; 40px   ,   左右 &#x3D;&gt; 80px </p></li><li><p><strong>三个值：</strong>第一个控制的上 第二个控制的左右 第三个控制的下 <code>padding : 40px 60px 80px;</code></p><p>上 &#x3D;&gt; 40px , 左右 &#x3D;&gt; 60px , 下 &#x3D;&gt; 80px </p></li><li><p><strong>四个值：</strong>分别控制：上右下左 <code>padding : 40px 60px 80px 100px;</code></p><p>上 &#x3D;&gt; 40px , 右 &#x3D;&gt; 60px , 下 &#x3D;&gt; 80px , 左 &#x3D;&gt; 100px</p></li><li><p><strong>记忆：</strong>顺时针，上右下左，没有找对面</p></li></ul><p><strong>单独设置（方向）：</strong></p><pre><code>padding-toppadding-rightpadding-bottompadding-left</code></pre><h2 id="计算盒子的大小"><a href="#计算盒子的大小" class="headerlink" title="*计算盒子的大小"></a>*计算盒子的大小</h2><blockquote><p>盒子大小与内容大小的区别</p></blockquote><ul><li>盒子大小公式 :</li></ul><pre><code class="html">&lt;!-- 需求 :     盒子尺寸 300*300 , 背景粉色, 上下左右20px的padding(此时盒子大小是多少？？) 边框: 10px 实线 黑色 --&gt;// 左右相等 盒子宽度 =  内容宽度 + 2*padding + 2*border  // 左右不等盒子宽度 =  内容宽度 + padding-left+padding-right + border-left            + border-right ;</code></pre><blockquote><p>那盒子高度是多少？</p></blockquote><ul><li><strong>盒子大小：</strong>边框、内边距、内容决定的</li><li>我们之前设置的width 和 height 都只是设置<strong>内容的大小</strong></li></ul><p><strong>注意（不会撑大盒子的特殊情况）：</strong></p><ul><li>当一个<strong>大盒子包含一个小盒子，并且两个盒子都是块级元素，小盒子宽度继承父盒子</strong>，这时候给小盒子加padding-left，是不会改变小盒子大小的 （下面的都可以）<ul><li>padding-left（用的最多）</li><li>padding-right</li><li>border-left</li><li>border-right</li></ul></li></ul><p>【案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box1&#123;            width: 300px;            height: 300px;            background: deeppink;        &#125;        .box2&#123;            height: 200px;            background: deepskyblue;            /*此时小盒子不会被撑大,会自动内减*/            padding-left: 20px;            border-left: 10px solid;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box1&quot;&gt;        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="ヾ-๑╹◡╹-ﾉ”新浪导航（不low导航升级版）"><a href="#ヾ-๑╹◡╹-ﾉ”新浪导航（不low导航升级版）" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”新浪导航（不low导航升级版）~"></a>ヾ(๑╹◡╹)ﾉ”新浪导航（不low导航升级版）~</h5><blockquote><p>用之前的方法，当a标签的文字数量不确定时，页面会有问题。</p><p>普遍的方法应该使用padding</p></blockquote><h5 id="——————————-1"><a href="#——————————-1" class="headerlink" title="——————————"></a>——————————</h5><p><strong>让浏览器自动内减（拓展css3）~</strong> </p><pre><code class="html">&lt;!-- 需求 :     盒子尺寸 400*400 , 背景绿色, 边框: 10px 实线 黑色  padding:20px--&gt;box-sizing：border-box；（自动内减，此时width和height就是当前盒子的实际大小）</code></pre><h5 id="ヾ-๑╹◡╹-ﾉ”新闻列表案例"><a href="#ヾ-๑╹◡╹-ﾉ”新闻列表案例" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”新闻列表案例~"></a>ヾ(๑╹◡╹)ﾉ”新闻列表案例~</h5><h2 id="外边距（margin-外边距-盒子与盒子之间的距离）"><a href="#外边距（margin-外边距-盒子与盒子之间的距离）" class="headerlink" title="外边距（margin-外边距-盒子与盒子之间的距离）"></a>外边距（margin-外边距-盒子与盒子之间的距离）</h2><blockquote><p>盒子与盒子之间的距离（控制盒子的位置）</p></blockquote><p><strong>取值：</strong></p><ul><li><p><strong>一个值</strong>：控制整个上下左右 <code>margin : 40px；</code></p><p>上、右、下、左 的内边距都设置了 40 px的距离;</p></li><li><p><strong>两个值：</strong>第一个控制上下  第二个控制左右  <code>margin : 40px 80px</code></p><p>上下 &#x3D;&gt; 40px   ,   左右 &#x3D;&gt; 80px </p></li><li><p><strong>三个值：</strong>第一个控制的上 第二个控制的左右 第三个控制的下 <code>margin : 40px 60px 80px;</code></p><p>上 &#x3D;&gt; 40px , 左右 &#x3D;&gt; 60px , 下 &#x3D;&gt; 80px </p></li><li><p><strong>四个值：</strong>分别控制：上右下左 <code>margin : 40px 60px 80px 100px;</code></p><p>上 &#x3D;&gt; 40px , 右 &#x3D;&gt; 60px , 下 &#x3D;&gt; 80px , 左 &#x3D;&gt; 100px</p></li></ul><p><strong>单独设置（方向）：</strong></p><pre><code>margin-topmargin-rightmargin-bottommargin-left</code></pre><p><strong>针对margin单方向的应用：</strong></p><ul><li><p>上下应用</p><ul><li>margin-top：能让盒子下移</li><li>margin-bottom：能让下面的盒子往下移</li></ul></li><li><p>左右应用（先转换成行内块）</p><ul><li>margin-left：能让盒子右移</li><li>margin-right：能让右边的盒子往右移动</li></ul></li></ul><h2 id="清除默认内外边距"><a href="#清除默认内外边距" class="headerlink" title="清除默认内外边距"></a>清除默认内外边距</h2><blockquote><p>很多标签默认带有margin和padding，在布局之前需要清除这些标签默认的margin和padding，留给自己设置。</p></blockquote><p>比如：</p><pre><code>(1) body 标签: 自带 margin: 8px; 的属性(2) p 标签: 默认带有 margin: font-size 的值(3) h 标签: 也默认带有 margin-top 和 margin-bottom(4) ul标签: ul 标签默认带有上下的 margin, 和 padding-left...</code></pre><p><strong>方法（清除页面中标签的默认padding和margin）：</strong></p><pre><code>* &#123;     padding: 0;    margin: 0; &#125;</code></pre><h5 id="——————————-2"><a href="#——————————-2" class="headerlink" title="——————————"></a>——————————</h5><h5 id="ヾ-๑╹◡╹-ﾉ”爱宠知识案例"><a href="#ヾ-๑╹◡╹-ﾉ”爱宠知识案例" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”爱宠知识案例~"></a>ヾ(๑╹◡╹)ﾉ”爱宠知识案例~</h5><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ul><li>之后工作中，用什么软件测量都可以，顺手就行</li><li>box-sizing：border-box；（自动内减，此时width和height就是当前盒子的实际大小）</li></ul><h1 id="行高（line-height）"><a href="#行高（line-height）" class="headerlink" title="*行高（line-height）"></a>*行高（line-height）</h1><p><strong>定义：</strong> 两行文本基线的距离，默认值为normal，可以撑起高度</p><p><img src="/2021/05/08/1541065649298739200/images/1605606292395.png" alt="1605606292395"></p><p><strong>应用：</strong>将<strong>行高设置等于容器的高度</strong>，可以<strong>让文本垂直居中</strong></p><pre><code class="css">line-height:20px; /*控制的是文字与文字之间的上下距离*/</code></pre><p><strong>注意：</strong></p><ul><li>小技巧：如果将标签的高度和行高设置成一样，那么这个标签里面的文字可以在这个标签里面垂直居中</li><li>与text-align结合使用可以让单行文字在标签内部水平垂直居中</li><li>行高是可以继承的</li></ul><h2 id="行高的单位"><a href="#行高的单位" class="headerlink" title="行高的单位"></a>行高的单位</h2><p><strong>取值：</strong></p><ul><li><p>具体的像素</p></li><li><p>em </p><p>根据当前标签的<strong>字体大小（font-size）</strong>为基数计算（没有手动设置，浏览器默认设置16px）</p><blockquote><p>如果当前字体大小为16px，那么 2em&#x3D;32px</p></blockquote></li><li><p>百分号（%）</p><p>根据当前标签的<strong>字体大小（font-size）</strong>为基数计算</p><blockquote><p>如果当前字体大小为16px，那么 200% &#x3D; 32px</p></blockquote></li><li><p>不带单位的数字（倍数）</p><p>根据当前标签的<strong>字体大小（font-size）</strong>为基数计算</p><blockquote><p>如果当前字体大小为16px，那么 2 &#x3D; 32px</p></blockquote></li></ul><p><strong>补充：</strong> 谷歌浏览器默认字体大小 16px;</p><h2 id="行高与font的连写"><a href="#行高与font的连写" class="headerlink" title="*行高与font的连写"></a>*行高与font的连写</h2><p>字体连写里面还有行高（默认值：<strong>normal</strong>）</p><blockquote><p>默认值为：normal，不同的文字效果不同，</p></blockquote><p><strong>完整版的font连写形式：</strong></p><p><code>font: font-style font-weight font-size/line-height font-family</code></p><p><strong>line-height 如果写在 font 连写前面，会被层叠掉</strong> （连写的层叠现象）</p><pre><code class="css">/*line-height书写位置：*//*1. 写在font里 没毛病 */font: italic bold 20px/200px &#39;微软雅黑&#39;;/*2. 写在font后面  没毛病*/font: italic bold 20px &#39;微软雅黑&#39;;line-height: 200px;/* 3. 写在font前面 会覆盖  */line-height: 200px;font: italic bold 20px &#39;微软雅黑&#39;;/*此时line-height为normal值*/</code></pre><p><strong>注意（项目中用到了line-height和font的连写）：</strong></p><ul><li>把line-height写在font连写的下面</li><li>把line-height写进font的连写里面！</li></ul><p>【案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        li&#123;            height: 32px;            background: cornsilk;            border: 1px solid;            /* line-height: 200%; */            /* line-height: 32px; */            /* line-height: 2; */            /* line-height: 32px; */                                    /* font: italic bold 16px/32px &#39;微软雅黑&#39;; */                        /* font: italic bold 16px &#39;微软雅黑&#39;;            line-height: 32px; */            /* 这种情况会失效 */            /* line-height: 32px;            font: italic bold 16px &#39;微软雅黑&#39;; */                    &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;     &lt;ul&gt;        &lt;li&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="margin的两种特殊现象"><a href="#margin的两种特殊现象" class="headerlink" title="margin的两种特殊现象"></a>margin的两种特殊现象</h1><h2 id="marign的合并现象"><a href="#marign的合并现象" class="headerlink" title="*marign的合并现象"></a>*marign的合并现象</h2><blockquote><p>当两个盒子<strong>水平</strong>布局时，左右的margin会叠加；</p><p>当两个盒子<strong>垂直</strong>布局时，上下的marign会合并-》合并之后取两者的最大值为两个盒子之间的距离</p></blockquote><pre><code class="js">// 盒子左右排序  没毛病 margin-left 和 margin-right 叠加// 【盒子上下排序  有问题】margin-top 和 margin-bottom 合并// 总结 : 两个div上下排序, 在进行设置 margin-top 和 margin-bottom 的时候,两个margin会产生一个合并的现象, 合并的值以大的为准</code></pre><p><strong>解决方案：</strong>   避免就好了</p><p>记忆：margin   水平—&gt;叠加   上下—&gt;取大</p><h2 id="margin的塌陷现象（面试常考！）"><a href="#margin的塌陷现象（面试常考！）" class="headerlink" title="*margin的塌陷现象（面试常考！）"></a>*margin的塌陷现象（面试常考！）</h2><blockquote><p><strong>嵌套</strong> <strong>块元素</strong>垂直外边距的塌陷（父元素一起往下移动）</p><p>两个盒子为父子关系时候，父元素的marign和子元素的margin会合并，并且父元素会往下移动</p></blockquote><pre><code>如果一个大盒子中包含一个小盒子, 给小盒子设置 margin-top 大盒子会一起向下平移</code></pre><p><strong>解决方案：</strong></p><ul><li>给父盒子加一个边框</li><li>给父盒子加 padding-top </li><li>给父盒子设置属性 overflow: hidden &#x3D;&gt; BFC;</li><li>给父盒子设置浮动</li><li>给父盒子设置为行内块</li></ul><p>【案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        *&#123;            margin: 0;            padding: 0;        &#125;        .box&#123;            width: 200px;            height: 200px;        &#125;        .box1&#123;            background: deeppink;            display: inline-block;            margin-right: 10px;        &#125;        .box2&#123;            background: deepskyblue;            display: inline-block;            margin-left: 10px;        &#125;        .box3&#123;            background: green;            margin-bottom: 20px;        &#125;        .box4&#123;            background: yellow;            margin-top: 10px;        &#125;        .box5&#123;            background: blueviolet;            /* 塌陷的解决方案，下面选一种就行 */            /* border: 1px solid; */            /* padding-top: 1px; */            /* display: inline-block; */            /* overflow: hidden; */            /* float: left; */        &#125;        .box6&#123;            width: 100px;            height: 100px;            background: yellowgreen;            margin-top: 10px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 合并1.水平maring会叠加 --&gt;    &lt;div class=&quot;box1 box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2 box&quot;&gt;&lt;/div&gt;    &lt;hr&gt;    &lt;!-- 合并2.上下maring会去最大的 --&gt;    &lt;div class=&quot;box3 box&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;box4 box&quot;&gt;&lt;/div&gt;    &lt;hr&gt;    &lt;!-- 塌陷现象 --&gt;    &lt;div class=&quot;box5 box&quot;&gt;        &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><h2 id="浮动初体验"><a href="#浮动初体验" class="headerlink" title="浮动初体验"></a>浮动初体验</h2><blockquote><p>解决上下盒子 可以水平布局的问题</p></blockquote><p><strong>需求：</strong>在页面上有两个盒子，一个盒子靠着左边显示，一个盒子靠着右边显示</p><p>可以使用marign，但是浏览器宽度变化时，不能完成效果~</p><p><strong>浮动的代码：</strong></p><pre><code class="css">float: left;float: right; </code></pre><h2 id="浮动的特点（了解）"><a href="#浮动的特点（了解）" class="headerlink" title="浮动的特点（了解）"></a>浮动的特点（了解）</h2><blockquote><p>重点在于使用</p></blockquote><p><strong>标准流：</strong>就是浏览器默认摆放盒子的顺序（从上往下、从左往右）</p><p><strong>注意：</strong></p><ul><li><p>浮动的元素会脱离<strong>标准流（脱标）</strong></p><ul><li>飘起来了</li><li>在标准流中不占位置</li></ul><pre><code>如果一个元素按照正常的标准流来显示, 会在 html 中所属的位置占位, 后面的元素会紧跟着它, 但是浮动脱离了标准流, 将来在看到浮动的元素以后,就不能以正常的标准流来判断了 (浮动的元素在标准流中不占位置了)</code></pre></li><li><p>浮动以后的元素，会覆盖在标准流的<strong>元素之上</strong></p><ul><li>比标准流高出半个级别</li></ul></li><li><p>浮动的规则：浮动找浮动，不浮动找不浮动 </p></li><li><p>浮动的重点：浮动的元素只会影响下面的元素  </p><ul><li>本质：浮动的元素受到盒子边界的限制（块级元素独占一行）</li></ul></li><li><p>浮动的元素会改变显示方式效果</p><pre><code>浮动以后的元素当做是一种特殊的显示效果：1、一行可以显示多个2、并且可以设置宽高总结: 浮动以后的元素的显示方式与行内块级元素类似，但是不能使用text-align：center居中（浮动本身就是让盒子左右排布的）</code></pre></li></ul><p><strong>记忆 :</strong> </p><pre><code class="js">1. 浮动的元素会脱标 ==&gt; 飘起来了（不占位置） ==&gt; 比标准流高半个级别  ==&gt; 类似行内块的特点2. 浮动的元素会被盒子的边界限制住</code></pre><h2 id="浮动的案例"><a href="#浮动的案例" class="headerlink" title="浮动的案例"></a>浮动的案例</h2><ul><li>使用浮动完成页面的布局</li></ul><p><img src="/2021/05/08/1541065649298739200/images/1605606556196.png" alt="1605606556196"></p><p>【案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        *&#123;            margin: 0;            padding: 0;        &#125;        .head&#123;            height: 50px;            background: pink;        &#125;        .container&#123;            width: 500px;            margin: 0 auto;        &#125;        .container .top&#123;            height: 50px;            background: yellow;        &#125;        .container .aside&#123;            width: 20%;            height: 200px;            background: #000;            float: left;        &#125;        .container .section&#123;            width: 80%;            height: 200px;            background: blue;            float: left;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;head&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;section&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li><p>制作导航</p><p>注意：之前直接使用 a 标签 display：inline-block 制作导航是有问题的</p><ul><li>导航与导航之间应该是列表关系，如果想要将这些关系通过 html 语义化表示出来，必须要用到 ul 标签</li><li>如果这些 a 标签不用其他的标签包裹起来，那么将来浏览器会将这些 a 标签中的文字，当做普通文本一起显示，SEO 在查看页面时，认为该页面在作弊，就是在进行关键字堆砌</li></ul><p>所以, 导航必须要用 ul 和 li 将 a 标签包裹起来</p></li></ul><p><img src="/2021/05/08/1541065649298739200/images/1605606581772.png" alt="1605606581772"></p><pre><code>*：项目开始前先初始化样式ul:用于清除小圆点：list-styleli:用于浮动在水平方向布局：float：lefta：用于设置宽高（把li的大小撑起来）    注意a标签是行内元素，需要通过        1.转换显示方式（块级元素和行内块都行，但是不推荐使用行内块）；        2.float：left 也能起效果（浮动之后的元素可以设置宽高）</code></pre><h2 id="清除浮动（清除浮动的影响）"><a href="#清除浮动（清除浮动的影响）" class="headerlink" title="清除浮动（清除浮动的影响）"></a>清除浮动（清除浮动的影响）</h2><blockquote><p>浮动带来的问题：浮动元素撑不开父级容器</p></blockquote><p>如果一个父盒子中有一个子盒子，并且父盒子没有设置高，子盒子在父盒子中进行了浮动，那么将来父盒子的高度为0，由于父盒子的高度为 0，下面的元素会自动补位，所以这个时候要进行浮动的清除</p><pre><code>浮动: float: left; float: right;清除浮动: clear: both;</code></pre><h4 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h4><blockquote><p>不推荐，会产生一个多余的盒子</p></blockquote><p>在浮动的盒子内部<strong>最后</strong>，再放一个<strong>块级标签</strong>，在这个标签内使用 <code>clear：both；</code>来清除浮动对页面的影响</p><p><strong>注意：</strong> 一般情况不使用这种方式清除浮动，因为这种方式会在页面中添加额外的标签</p><h4 id="使用-overflow-清除浮动"><a href="#使用-overflow-清除浮动" class="headerlink" title="使用 overflow 清除浮动"></a>使用 overflow 清除浮动</h4><blockquote><p>在某些特定场景下使用不了</p></blockquote><p>找到浮动盒子的父元素, 再在父元素中添加一个属性 <code>overflow: hidden; </code> 清除父元素中子元素浮动对页面的影响</p><p><strong>注意：</strong> 一般情况也不用这种方式，因为 <code>overflow: hidden;</code> 有一个特点，离开了这个元素所在的区域以后会被隐藏 （后面讲这个方法就懂了）</p><h4 id="使用伪元素清除浮动"><a href="#使用伪元素清除浮动" class="headerlink" title="使用伪元素清除浮动"></a>使用伪元素清除浮动</h4><blockquote><p>通过css实现，推荐！</p></blockquote><p><strong>伪元素：</strong> 在页面上不存在的元素，但是可以通过  css 添加上去（默认是行内元素）</p><p><strong>种类：</strong>常见的就2种</p><pre><code>::after(在...之后)::before(在...之前)为了和伪类的一个冒号区别，css3的时候推荐使用两个冒号（兼容还是要使用一个冒号）</code></pre><p><strong>注意：</strong>  </p><ul><li>伪元素由css渲染，不会增加html结构</li><li>每个元素都可以添加自己的伪元素</li><li>默认伪元素是行内元素，可以通过 display 修改</li></ul><p>伪元素清除浮动完整代码：</p><pre><code class="css">.clearfix::after &#123;    content: &quot;&quot;;     //伪元素必须给这个content=&#39;&#39;    display: block;   // 必须块级才能清除     clear: both;      // 核心代码        /*保证伪元素在页面中看不到*/    height:0;    line-height:0;    visibility:hidden;&#125;</code></pre><h4 id="设置高度"><a href="#设置高度" class="headerlink" title="设置高度"></a>设置高度</h4><blockquote><p>简单粗暴，但是不推荐，不利于后期维护</p></blockquote><p><strong>注意：</strong>问题? 给谁设置，浮动的父盒子 (height&#x3D;0 的)</p><h5 id="—————————"><a href="#—————————" class="headerlink" title="—————————-"></a>—————————-</h5><h2 id="浮动的意义"><a href="#浮动的意义" class="headerlink" title="浮动的意义"></a>浮动的意义</h2><ul><li>浮动最开始是做图文环绕（报纸的效果）</li><li>浮动的布局应用场景：让元素直接<strong>排成一排</strong>，或者<strong>一个靠左一个靠右</strong></li></ul><h5 id="ヾ-๑╹◡╹-ﾉ”网页头部案例"><a href="#ヾ-๑╹◡╹-ﾉ”网页头部案例" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”网页头部案例~"></a>ヾ(๑╹◡╹)ﾉ”网页头部案例~</h5><h1 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h1><h2 id="关于行内的padding和margin使用"><a href="#关于行内的padding和margin使用" class="headerlink" title="*关于行内的padding和margin使用"></a>*关于行内的padding和margin使用</h2><p>什么时候设置margin? 什么时候设置padding?</p><pre><code class="js">需要在`边框内部`留有空隙 =&gt; padding需要在`边框外部`留有空隙 =&gt; margin</code></pre><h5 id="ヾ-๑╹◡╹-ﾉ”上面两个div，下面有个p标签"><a href="#ヾ-๑╹◡╹-ﾉ”上面两个div，下面有个p标签" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”上面两个div，下面有个p标签~"></a>ヾ(๑╹◡╹)ﾉ”上面两个div，下面有个p标签~</h5><p><strong>块</strong>级元素和<strong>行内块</strong>元素使用 margin 和 padding-》没毛病，但是：</p><ul><li><strong>行内</strong>元素使用<strong>margin</strong>的left 和 right可以，top和bottom无效</li><li><strong>行内</strong>元素使用<strong>padding</strong>的left和right可以，top和bottom无效</li></ul><p><strong>注意：</strong></p><ul><li>块级元素和行内块元素的margin和padding随便使用！没问题</li><li>【行内元素的上下margin和上下padding会失效！！开发中不要使用！！】</li></ul><h1 id="浮动元素显示效果的注意点"><a href="#浮动元素显示效果的注意点" class="headerlink" title="*浮动元素显示效果的注意点"></a>*浮动元素显示效果的注意点</h1><blockquote><p>浮动元素的特点之一为：浮动之后的元素有类似<code>行内块</code>的显示效果</p></blockquote><p>所以浮动元素不管前生是什么，浮动之后就变成了一个类似行内块的效果！不再有块级的特点：</p><p>以div为例：</p><ul><li>块级元素特点1：水平居中使用margin:0 auto;<ul><li>前生：块级元素：margin：0  auto；</li><li>浮动之后：<strong>margin：0 auto；不能居中</strong>（浮动本身就是到页面的一侧，并且浮动之后有行内块的效果）也<strong>不能使用text-align：center；居中</strong></li></ul></li><li>块级元素特点2：宽度继承<ul><li>前生：块级元素：有继承父元素宽度的效果</li><li>浮动之后：<strong>不能继承父元素的宽度</strong></li></ul></li></ul><blockquote><p>记忆：浮动之后元素当做一个特殊的显示方式！</p><p>不能使用text-align；或者margin：0 auto；居中</p><p>宽度不能继承父元素</p><p>（一行显示多个，并且可以设置宽高）</p><p>不要乱用浮动，只有当遇到让盒子水平布局时才使用！！！</p></blockquote><blockquote><p>浮动的元素相当于父元素的内容，仍然在盒子的content部分中！</p></blockquote><h1 id="版心"><a href="#版心" class="headerlink" title="版心"></a>版心</h1><blockquote><p>宽度固定且水平居中的盒子</p></blockquote><p>为什么要有版心?</p><blockquote><p>因为电脑的屏幕不一样大，为了在不同的电脑上视觉效果一致，我们需要版心作为约束</p></blockquote><p>版心的公共类的设定：</p><pre><code class="css">.w &#123;    width: 1200px；    margin：0 auto；&#125;&lt;div class=&quot;w&quot;&gt;&lt;/div&gt;</code></pre><p>特殊情况：</p><pre><code>设计师会给你一张很大的图片 1920 * 1000  (是为了适应不同的屏幕) 但是版心只有1280 问：图片怎么处理答：这个盒子不做约束 width:100%;  这个图片作为背景图片放到这个盒子里面 同时background-position:center 0;</code></pre><p>综合项目：尚合</p><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><blockquote><p>整个项目应该就是一个文件夹，文件夹中放项目中的所有资源（图片、html、css）</p><p>css在开始的时候可以把项目中常见的样式先写好，这个叫做样式的初始化！！！</p></blockquote><pre><code class="css">/*-----------------------------项目样式的初始化--------------------------------------------*//*清除默认的marign和padding*/* &#123;  margin: 0;  padding: 0;&#125;/*消除页面中li的小点*/ul &#123;  list-style: none;&#125;/*消除a标签默认的下划线*/a &#123;  text-decoration: none;&#125;/*版心的样式*//*版心就是宽度固定水平居中的盒子*/.w &#123;  width: 980px;  margin: 0 auto;&#125;/*左浮动的类*/.fl &#123;  float: left;  &#125;/*右浮动的类*/.fr &#123;  float: right;&#125;/*清除浮动的代码*/.clearfix::after &#123;  content: &#39;&#39;;  display: block;  clear: both;  height: 0;  line-height: 0;  visibility: hidden;&#125;/*为了在上面看到下面的标签 最后删掉*//*body &#123;  height: 2000px;&#125;*/</code></pre><h2 id="尚合总结"><a href="#尚合总结" class="headerlink" title="尚合总结"></a>尚合总结</h2><ul><li>给div设置宽高来简化间距的设置</li></ul><p><img src="/2021/05/08/1541065649298739200/images/1605764242660.png" alt="1605764242660"></p><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p><strong>作用:</strong>   解决盒子与盒子之间的层叠问题</p><p><strong>问题：</strong>现在在页面上有两个盒子，其中第二个盒子将第一个盒子压住了一半，怎么完成？？？</p><p><img src="/2021/05/08/1541065649298739200/images/1605260484649.png" alt="1605260484649"></p><p>使用margin可以实现效果，但是并不好，定位可以专门解决这样的层叠问题</p><p><strong>初体验：</strong></p><p><code>position：absolute；</code> 设置定位</p><pre><code class="css">div&#123;    width: 200px;    height: 200px;  &#125;.red&#123;    background-color: red;&#125;.blue&#123;    background-color: blue;    position: absolute;    top: 100px;    left:100px;&#125;</code></pre><p><strong>方位属性：</strong></p><blockquote><p>水平和垂直方向各选一个使用即可，一般选取的原则是离那边近用哪个</p></blockquote><ul><li>水平方向：<ul><li>left：相对于左边框的距离</li><li>right：相对于右边框的距离</li></ul></li><li>垂直方向：<ul><li>top：相对于上边框的距离</li><li>bottom：相对于下边框的距离</li></ul></li></ul><h2 id="static：静态定位（默认型）（有争议的）"><a href="#static：静态定位（默认型）（有争议的）" class="headerlink" title="static：静态定位（默认型）（有争议的）"></a>static：静态定位（默认型）（有争议的）</h2><blockquote><p>标准流中的元素默认都是静态定位</p></blockquote><p><strong>代码：</strong> <code>position: static;</code> （默认值）静态定位</p><blockquote><p>静态定位是有一定争议的（有些人认为静态定位不算定位）</p></blockquote><p><strong>面试时候回答：</strong>三种定位方式，优先回答其他三个（相对、绝对、固定），如果四种再写静态定位</p><h2 id="relative：相对定位（自恋型）"><a href="#relative：相对定位（自恋型）" class="headerlink" title="relative：相对定位（自恋型）"></a>relative：相对定位（自恋型）</h2><blockquote><p>盒子相对于自己之前的位置定位移动（红绿蓝）</p></blockquote><p><strong>代码：</strong><code>position: relative；</code> 相对定位</p><pre><code class="css">div&#123;    width: 200px;    height: 200px;&#125;.red&#123;    background-color: red;&#125;.blue&#123;    background-color: blue;    position: relative;    top:100px;    left:100px;&#125;</code></pre><p><strong>特点：</strong></p><ul><li><p>要配合方位属性使用，不然无法移动</p></li><li><p>相对于自己原来的位置进行偏移</p></li><li><p>设置了相对定位的元素在页面上占据了位置-》<strong>没有脱标</strong></p></li></ul><p><strong>应用场景：</strong></p><ul><li>配合绝对定位组CP（子绝父相），用的最多</li><li>用于小范围的移动（比如让某个标签稍微往下移动几个像素）</li></ul><h2 id="absolute：绝对定位（拼爹型）"><a href="#absolute：绝对定位（拼爹型）" class="headerlink" title="absolute：绝对定位（拼爹型）"></a>absolute：绝对定位（拼爹型）</h2><blockquote><p>绝对定位相对于非静态定位的父元素进行定位移动</p></blockquote><p><strong>代码：</strong><code>position: absolute; </code> 绝对定位</p><p><strong>特点：</strong></p><h5 id="—————————–"><a href="#—————————–" class="headerlink" title="—————————–"></a>—————————–</h5><ul><li><p>需要配合方位属性移动使用</p></li><li><p><strong>绝对定位相对谁移动</strong>？？</p><blockquote><p>默认相对于浏览器进行移动，但是如果有父元素，则相对于有定位的父元素进行移动</p><p>判断方法：</p></blockquote><ul><li>没有父元素-》相对于浏览器进行移动</li><li>有父元素（判断父元素有没有定位（三种，非static））<ul><li>父元素没有定位-》相对于浏览器进行移动</li><li>父元素有定位-》相对于有定位的父元素进行移动</li></ul></li></ul></li><li><p>绝对定位的元素在页面中不占位置-》<strong>脱标</strong></p></li></ul><p><strong>应用场景：</strong></p><ul><li><p>子绝父相（子元素绝对定位、父元素相对定位），把子元素定位到父元素中的某个位置，用的最多！！！</p><blockquote><p>子绝父相这个CP不会影响页面的布局-》举例说明</p></blockquote></li></ul><h5 id="ヾ-๑╹◡╹-ﾉ”子绝父相定位居中案例"><a href="#ヾ-๑╹◡╹-ﾉ”子绝父相定位居中案例" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”子绝父相定位居中案例"></a>ヾ(๑╹◡╹)ﾉ”子绝父相定位居中案例</h5><p><strong>代码:</strong></p><pre><code class="css">.father&#123;    width: 400px;    height: 400px;    background-color: red;    margin-left: 100px;    margin-top: 100px;    position: relative;&#125;.son&#123;    width: 100px;    height: 100px;    background-color: blue;    position: absolute;    left:50%;    top:50%;    /* transform: translateX(-50%); */    transform:translate(-50%,-50%); &#125;</code></pre><blockquote><p>如果小盒子在大盒子（1）水平居中（2）水平垂直都居中</p><p>.father:600*400</p><p>.son:200*100</p></blockquote><ul><li><p>先 left：50%， 将子盒子在父盒子向右平移父盒子的一半</p></li><li><p>再设置 margin-left：-（子盒子自身宽高的一半）</p><p>注意：此时取值一定是负数-》 那么将来子盒子就可以水平居中了</p></li><li><p><strong>优化：</strong>但是此时子盒子大小变化时就不再居中了，margin-left：-50%也是相对父元素的不行；</p><p>此时可以使用css3的新属性：<code>transform：translateX（-50%）沿着x轴的负方向移动自己的一半</code> 也能居中！如果x周和y周都沿轴的负方向移动自己的一半要设置：<code>transform:translate(-50%,-50%); </code></p></li></ul><h5 id="ヾ-๑╹◡╹-ﾉ”课堂练习：网站头部hot图标"><a href="#ヾ-๑╹◡╹-ﾉ”课堂练习：网站头部hot图标" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”课堂练习：网站头部hot图标"></a>ヾ(๑╹◡╹)ﾉ”课堂练习：网站头部hot图标</h5><h5 id="ヾ-๑╹◡╹-ﾉ”课堂练习：小米商品页半透明效果"><a href="#ヾ-๑╹◡╹-ﾉ”课堂练习：小米商品页半透明效果" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”课堂练习：小米商品页半透明效果"></a>ヾ(๑╹◡╹)ﾉ”课堂练习：小米商品页半透明效果</h5><h5 id="—————————–-1"><a href="#—————————–-1" class="headerlink" title="—————————–"></a>—————————–</h5><h2 id="fixed：固定定位-（死心眼型）"><a href="#fixed：固定定位-（死心眼型）" class="headerlink" title="fixed：固定定位 （死心眼型）"></a>fixed：固定定位 （死心眼型）</h2><blockquote><p>盒子相对于浏览器进行定位移动</p></blockquote><p><strong>代码：</strong><code>position: fixed; </code>  固定定位</p><p><strong>特点：</strong></p><ul><li><p>配合方位属性一起使用</p></li><li><p>永远相对于浏览器进行移动</p></li><li><p>固定定位的元素也不在页面中占据位置-》<strong>脱标</strong></p></li></ul><blockquote><p>注意的是：脱标后的元素和浮动脱标了一样，有类似于行内块元素的显示方式（宽度默认由内容撑开）</p></blockquote><h5 id="ヾ-๑╹◡╹-ﾉ”课堂练习：新浪网页"><a href="#ヾ-๑╹◡╹-ﾉ”课堂练习：新浪网页" class="headerlink" title="ヾ(๑╹◡╹)ﾉ”课堂练习：新浪网页"></a>ヾ(๑╹◡╹)ﾉ”课堂练习：新浪网页</h5><h2 id="四种定位总结"><a href="#四种定位总结" class="headerlink" title="四种定位总结"></a>四种定位总结</h2><table><thead><tr><th align="center">是否脱标占有位置</th><th align="center">定位模式</th><th align="center">是否移动</th><th align="center">移动位置基准</th></tr></thead><tbody><tr><td align="center">不脱标，正常模式</td><td align="center">静态static</td><td align="center">不可以</td><td align="center">正常模式</td></tr><tr><td align="center">不脱标，占有位置</td><td align="center">相对定位relative</td><td align="center">可以</td><td align="center">相对自身位置移动</td></tr><tr><td align="center">完全脱标，不占有位置</td><td align="center">绝对定位absolute</td><td align="center">可以</td><td align="center">相对于定位的父级移动位置</td></tr><tr><td align="center">完全脱标，不占有位置</td><td align="center">固定定位fixed</td><td align="center">可以</td><td align="center">相对于浏览器移动位置</td></tr></tbody></table><h1 id="元素的层级问题（z-index）"><a href="#元素的层级问题（z-index）" class="headerlink" title="元素的层级问题（z-index）"></a>元素的层级问题（z-index）</h1><blockquote><p>可以通过z-index设置页面中<code>定位元素</code>的层级关系，数值越大，层级越高</p></blockquote><p><strong>取值：</strong>整数</p><p><strong>注意：</strong></p><ul><li><p>标准流、浮动、定位之间的层级关系</p><blockquote><p>两个盒子之间的比较</p></blockquote><pre><code>三种层叠关系：标准流 &lt; 浮动 &lt; 定位（相对、绝对、固定）</code></pre></li><li><p>定位之间的层叠问题：</p><ul><li><p>三者的层叠关系相同，写在下面元素的覆盖上面的</p></li><li><p>可以手动设置定位元素的层级关系</p><pre><code>如果需要手动设置定位的层级关系，可以通过z-index属性设置层级z-index：数值;  数值越大  层级越高</code></pre></li></ul></li></ul><h1 id="vertical-align（垂直对齐方式）"><a href="#vertical-align（垂直对齐方式）" class="headerlink" title="vertical-align（垂直对齐方式）"></a>vertical-align（垂直对齐方式）</h1><blockquote><p>让图片（行内块元素）和文字对齐，需要优先给行内块元素设置垂直对齐方式</p></blockquote><p><strong>问题：</strong> 图片和文字在一行中显示的问题（bottom）</p><pre><code>如果文本与图片在同一行中显示，其实默认的效果是图片的底部和文字基线对齐的，此时就可能会影响页面的布局。此时可以通过：vertical-align: 可以设置文本与行内块（图片）的垂直对齐方式</code></pre><p><strong>取值：</strong></p><ul><li>baseline：基线对齐(默认)</li><li>top：顶部对齐</li><li>middle：中线对齐</li><li>bottom：底部对齐</li></ul><p><strong>使用行内块元素可能会出现的bug：</strong></p><ul><li>场景1 :  文本框（text）和表单按钮（button）无法对齐问题；（vertical-align: middle）</li><li>场景2 :  input 和 img无法对齐的问题；(vertical-align: bottom)</li><li>场景3 : div里放一个文本框 ，此时文本框无法靠顶；(vertical-align: top)</li><li>场景4：div有img标签撑开，此时img标签下方有间隙（给img标签设置vertical-align即可）；</li><li>场景5 : 使用line-height让img标签垂直居中，需要给img标签单独设置vertical-align：middle</li></ul><p><strong>如果要让垂直布局的盒子变成水平布局，不推荐使用转换成行内块元素，推荐使用浮动完成效果。</strong></p><p>【案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box&#123;            border: 1px solid #000;         &#125;        .box1 button&#123;            border: 1px solid #000;            vertical-align: middle;        &#125;         .box2 img&#123;            vertical-align: bottom;        &#125;        .box3&#123;            height: 30px;        &#125;        .box3 input&#123;            vertical-align: top;        &#125;        .box4 img&#123;            vertical-align: bottom;        &#125;        .box5&#123;            padding: 20px;            text-align: center;        &#125;        .box5 img&#123;            width: 30px;            height: 30px;            vertical-align: middle;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box box1&quot;&gt;        石室诗士施氏，嗜狮&lt;button&gt;login&lt;/button&gt;    &lt;/div&gt;    &lt;div class=&quot;box box2&quot;&gt;        &lt;input type=&quot;text&quot;&gt; &lt;img src=&quot;./img/head.jpg&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;box box3&quot;&gt;        &lt;input type=&quot;text&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;box box4&quot;&gt;        &lt;img src=&quot;./img/head.jpg&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;box box5&quot;&gt;        &lt;img src=&quot;./img/head.jpg&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="overflow：溢出"><a href="#overflow：溢出" class="headerlink" title="overflow：溢出"></a>overflow：溢出</h1><blockquote><p>设置盒子内容超出盒子大小时的展示效果</p></blockquote><p><strong>取值：</strong></p><pre><code>visible  超出不裁剪（默认值）hidden   如果盒子中的内容超出盒子范围，就隐藏scroll   显示滚动条auto     根据具体的情况，判断是否要添加滚动条（不超出没有，超出有）</code></pre><h1 id="元素的隐藏区别"><a href="#元素的隐藏区别" class="headerlink" title="*元素的隐藏区别"></a>*元素的隐藏区别</h1><blockquote><p>隐藏元素的几种方式的区别（大小盒子嵌套）</p></blockquote><h2 id="overflow-hidden；（超出隐藏）"><a href="#overflow-hidden；（超出隐藏）" class="headerlink" title="overflow:hidden；（超出隐藏）"></a>overflow:hidden；（超出隐藏）</h2><blockquote><p>隐藏超出部分</p></blockquote><h2 id="visibility：hidden；（元素看不见）"><a href="#visibility：hidden；（元素看不见）" class="headerlink" title="visibility：hidden；（元素看不见）"></a>visibility：hidden；（元素看不见）</h2><blockquote><p>隐藏元素，将元素看不见，但是在页面中还是占位置！！</p></blockquote><h2 id="display：none；（元素不存在）"><a href="#display：none；（元素不存在）" class="headerlink" title="display：none；（元素不存在）"></a>display：none；（元素不存在）</h2><blockquote><p>隐藏元素，将元素看不见，但是在页面中不占位置！！</p></blockquote><pre><code class="html">&lt;div class=&quot;one&quot;&gt;测试隐藏&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</code></pre><h1 id="html-标签的嵌套规范（了解）"><a href="#html-标签的嵌套规范（了解）" class="headerlink" title="html 标签的嵌套规范（了解）"></a>html 标签的嵌套规范（了解）</h1><blockquote><p>块级元素一般用于布局：比如div在页面的布局用的最多；</p><p>行内元素一般用于放文字：比如span、a标签里面一般放文字</p><p>标签之间是不能随意嵌套的，书写的时候应该有对应的规范：</p></blockquote><p><strong>注意点：</strong></p><ul><li>行内元素一般放文字或者行内元素，但是<strong>a标签之间不能互相嵌套</strong>（会被浏览器解析成两个a标签）；</li><li>块级元素相当于一个容器，里面可以放文字、行内元素、块级元素，但是<strong>p标签不能包含div标签</strong>（p标签会被拆分成两个p标签）</li><li>p标签作为一个段落标签，只有文字才会组成段落，所以p标签里面一般只放文字，不要放块级元素！！！</li></ul><h1 id="拓展-2"><a href="#拓展-2" class="headerlink" title="拓展"></a>拓展</h1><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><blockquote><p>通过标签的属性，找到对应的标签</p><p>用的最多的情况是找到input标签的不同形态</p></blockquote><pre><code class="css">/* 找到页面中的文本框 */input[ type = &#39;text&#39; ] &#123;    css样式;&#125;/* 找到页面中的普通按钮 */input[ type = &#39;button&#39; ] &#123;    css样式;&#125;</code></pre><h2 id="结构伪类选择器-child系列"><a href="#结构伪类选择器-child系列" class="headerlink" title="结构伪类选择器( -child系列)"></a>结构伪类选择器( -child系列)</h2><blockquote><p>如果现在想找到ul标签下面的第几个li标签的时候，除了使用class大法之外，还可以使用结构伪类选择器完成效果</p></blockquote><ul><li><p>E:first-child          匹配父元素的第一个子元素E</p><pre><code>比如：li：first-child &#123;css样式&#125;查找过程如下：1、首先找到li 2、找li标签的父元素3、找父元素第一个子元素4、看这个子元素是不是li    1、是-》加样式    2、不是-》不加样式</code></pre></li><li><p>E:last-child           匹配父元素的最后一个子元素E</p></li><li><p>E:nth-child(n)        匹配父元素的第n个子元素E</p><pre><code>针对于nth-child括号中可以写一个带n的式子，n的取值范围是0~正无穷的整数所以：1、找到所有的偶数：2n2、找到所有的奇数：2n-1 / 2n+13、找到前12个：-n+12(12-n却不行？？？)</code></pre></li></ul><p>【案例】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        ul li:first-child&#123;            color: red;        &#125;        ul li:nth-child(3)&#123;            color: blue;        &#125;        ul li:nth-child(2n)&#123;            color: yellow;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;!-- &lt;div&gt;奸细如果是第一个，不会变红&lt;/div&gt; --&gt;        &lt;li&gt;我是第个1li&lt;/li&gt;        &lt;li&gt;我是第个2li&lt;/li&gt;        &lt;li&gt;我是第个3li&lt;/li&gt;        &lt;li&gt;我是第个4li&lt;/li&gt;        &lt;li&gt;我是第个5li&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">css基础笔记整理</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="css" scheme="https://heliufang.github.io/tags/css/"/>
    
  </entry>
  
</feed>
