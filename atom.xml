<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老C的搬砖日记</title>
  
  <subtitle>每天多学一点知识,就少写一行代码</subtitle>
  <link href="https://heliufang.github.io/atom.xml" rel="self"/>
  
  <link href="https://heliufang.github.io/"/>
  <updated>2024-01-12T13:46:14.036Z</updated>
  <id>https://heliufang.github.io/</id>
  
  <author>
    <name>老C</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nuxt2笔记整理</title>
    <link href="https://heliufang.github.io/posts/8088d2b5/"/>
    <id>https://heliufang.github.io/posts/8088d2b5/</id>
    <published>2023-12-12T09:44:28.000Z</published>
    <updated>2024-01-12T13:46:14.036Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://v2.nuxt.com/docs/get-started/installation">Nuxt2官网</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>nuxt是基于vue语法来实现SSR(服务器渲染)的框架，解决单页应用不利于SEO的问题</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>由于国内网络问题经常下载失败，推荐采用沙盒下载环境项目模板</p><p><a href="https://stackblitz.com/github/nuxt/starter/tree/v2-stackblitz?file=README.md">https://stackblitz.com/github/nuxt/starter/tree/v2-stackblitz?file=README.md</a></p><p><img src="/posts/8088d2b5/1702344800164.png" alt="1702344800164"></p><p>新建一个nuxt2-study文件夹，将下载后的文件解压到这个文件夹中</p><p><img src="/posts/8088d2b5/1702345551102.png" alt="1702345551102"></p><p>然后安装依赖</p><pre><code class="shell">npm i</code></pre><p>启动</p><pre><code class="shell">npm run dev</code></pre><p>访问：localhost:3000</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>每个页面组件都是一个Vue组件 ，pages目录中的每个文件都是一个页面。</p><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>假设文件结构如下</p><pre><code>pages/--| user/-----| index.vue-----| one.vue--| index.vue</code></pre><p>那么生成的路由如下</p><pre><code class="js">router: &#123;  routes: [    &#123;      name: &#39;index&#39;,      path: &#39;/&#39;,      component: &#39;pages/index.vue&#39;    &#125;,    &#123;      name: &#39;user&#39;,      path: &#39;/user&#39;,      component: &#39;pages/user/index.vue&#39;    &#125;,    &#123;      name: &#39;user-one&#39;,      path: &#39;/user/one&#39;,      component: &#39;pages/user/one.vue&#39;    &#125;  ]&#125;</code></pre><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>假设文件结构如下</p><pre><code>pages/--| _slug/-----| comments.vue-----| index.vue--| users/-----| _id.vue--| index.vue</code></pre><p>那么生成的路由如下</p><pre><code class="js">router: &#123;  routes: [    &#123;      name: &#39;index&#39;,      path: &#39;/&#39;,      component: &#39;pages/index.vue&#39;    &#125;,    &#123;      name: &#39;users-id&#39;,      path: &#39;/users/:id?&#39;,      component: &#39;pages/users/_id.vue&#39;    &#125;,    &#123;      name: &#39;slug&#39;,      path: &#39;/:slug&#39;,      component: &#39;pages/_slug/index.vue&#39;    &#125;,    &#123;      name: &#39;slug-comments&#39;,      path: &#39;/:slug/comments&#39;,      component: &#39;pages/_slug/comments.vue&#39;    &#125;  ]&#125;</code></pre><p>动态路由参数的获取和<code>vue-router</code>一致：<code>this.$route.params.xxx</code></p><h3 id="NuxtLink组件"><a href="#NuxtLink组件" class="headerlink" title="NuxtLink组件"></a>NuxtLink组件</h3><p>和router-link类似，用于跳转页面。 对于指向站点内页面的所有链接，请使用&lt; NuxtLink &gt;。如果有其他网站的链接，应该使用&lt; a &gt;标签</p><pre><code class="html">&lt;NuxtLink to=&quot;/book/10001&quot;&gt;查看详情&lt;/NuxtLink&gt;</code></pre><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>功能类似vue中的router-view组件，一个项目可以有多个布局。默认使用的布局是 layouts&#x2F;default.vue </p><ul><li>定义新布局  layouts&#x2F;myLayout.vue</li></ul><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;h1&gt;自定义页面头部&lt;/h1&gt;        &lt;!-- Nuxt功能类似router-view组件 --&gt;        &lt;Nuxt /&gt;        &lt;h1&gt;自定义页面底部&lt;/h1&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>组件中使用布局</li></ul><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;NuxtLink to=&quot;/book/10001&quot;&gt;查看详情&lt;/NuxtLink&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;Nuxt2StudyIndex&#39;,    layout: &#39;myLayout&#39;,//使用自定义的布局    //...&#125;;&lt;/script&gt;</code></pre><h2 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h2><p>当404和500的时候显示一个错误页面</p><p>layouts&#x2F;error.vue</p><pre><code class="html">&lt;template&gt;    &lt;!-- 自定义错误页面 --&gt;    &lt;div class=&quot;error-container&quot;&gt;        &lt;div class=&quot;info&quot;&gt;            &lt;div class=&quot;code&quot;&gt;&#123;&#123; error.statusCode &#125;&#125;&lt;/div&gt;            &lt;div v-if=&quot;error.statusCode == 404&quot; class=&quot;desc&quot;&gt;抱歉！页面走丢了&lt;/div&gt;            &lt;div v-else class=&quot;desc&quot;&gt;抱歉！服务器繁忙&lt;/div&gt;            &lt;el-button @click=&quot;$router.replace(&#39;/home&#39;)&quot;&gt;返回首页&lt;/el-button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;  &lt;script&gt;export default &#123;    props: [&#39;error&#39;]&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.error-container &#123;    background-color: #55aafe;    height: 100vh;    display: flex;    .info &#123;        margin: auto;        color: #fff;        text-align: center;        .code &#123;            font-size: 200px;            font-weight: bold;        &#125;        .desc&#123;            font-size: 30px;            margin: 20px 0;        &#125;    &#125;&#125;&lt;/style&gt;</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期如下: 重点掌握asyncData() 和 mouted()</p><p><img src="/posts/8088d2b5/lifecycle.png" alt="lifecycle"></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>在请求到达之前做一些处理、比如重定向、鉴权等操作</p><h3 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h3><p>新建 middleware&#x2F;middleware.js</p><pre><code class="js">export default function (&#123;app,redirect,route &#125;) &#123;    console.log(&#39;这个会在服务器的控制台打印&#39;)    //默认跳转到 home    if(&quot;/&quot; == route.fullPath || &quot;/zh&quot; == route.fullPath)&#123;        redirect(&#39;/home&#39;)    &#125;&#125;</code></pre><p>nuxt.config.js 配置中间件</p><pre><code class="js">export default &#123;    router: &#123;        middleware: &quot;middleware&quot;, //middleware对应middleware.js的文件名    &#125;    //...&#125;</code></pre><h3 id="命名中间件"><a href="#命名中间件" class="headerlink" title="命名中间件"></a>命名中间件</h3><p>新建middleware&#x2F;auth.js</p><pre><code class="js">//鉴权中间件export default function (&#123; app,store, redirect, route &#125;) &#123;  console.log(&quot;auth middleware&quot;, store.getters.token, &quot;auth url&quot;, route.path);  //白名单  let whiteList = [    &quot;/sign-in&quot;,     &#39;/register&#39;,    &#39;/home&#39;  ];  //let whiteListZh = whiteList.map(m =&gt; app.localePath(m))  //whiteList = [...whiteList,...whiteListZh] //生成中英  if (process.client &amp;&amp; !store.getters.token) &#123;//客户端渲染的页面 没有token    if (!(whiteList.includes(route.path) || whiteList.some(s =&gt; route.path.startsWith(s)))) &#123;//不在白名单       return redirect(&quot;/sign-in&quot;);//跳转登录      //return redirect(app.localePath(&quot;/sign-in&quot;));//跳转登录    &#125;  &#125;&#125;</code></pre><p>在页面组件或者布局组件中</p><pre><code class="html">&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;MyLayout&#39;,  middleware: [&#39;auth&#39;] //当前组件将要受到auth中间件控制&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</code></pre><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><h3 id="asyncData"><a href="#asyncData" class="headerlink" title="asyncData"></a>asyncData</h3><p>asyncData只能用于页面级组件，asyncData不能访问组件实例(this)。它接收上下文作为其参数。Nuxt会自动将返回的对象与组件数据进行浅层合并。 </p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for=&quot;car in carList&quot;&gt;&#123;&#123; car.id + '-' + car.name &#125;&#125;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;Nuxt2StudyIndex&#39;,    data() &#123;        return &#123;            carList: []        &#125;;    &#125;,    //服务端渲染：服务器请求并渲染数据 这个钩子内部不能使用this    async asyncData(ctx) &#123;         //query 等价于 this.$route.query  params 等价于 this.$route.params        console.log(&#39;ctx&#39;, ctx.query,ctx.params)        //模拟发送请求        let carList = await new Promise((resolve, reject) =&gt; &#123;            setTimeout(() =&gt; &#123;                resolve([                    &#123; id: 1, name: &#39;宝马&#39; &#125;,                    &#123; id: 2, name: &#39;奔驰&#39; &#125;,                    &#123; id: 3, name: &#39;五菱&#39; &#125;,                ])            &#125;, 1000);        &#125;)        return &#123; carList &#125; //这个数据将自动合并到组件data()    &#125;&#125;;&lt;/script&gt;</code></pre><h3 id="mouted"><a href="#mouted" class="headerlink" title="mouted"></a>mouted</h3><p>用于客户端渲染,和vue中的一致</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for=&quot;car in carList&quot;&gt;&#123;&#123; car.id + '-' + car.name &#125;&#125;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;Nuxt2StudyIndex&#39;,    data() &#123;        return &#123;            carList: []        &#125;;    &#125;,    //客户端渲染    mounted() &#123;        let cartList = [            &#123;id: 1,name: &#39;宝马&#39;&#125;,            &#123;id: 2,name: &#39;奔驰&#39;&#125;,            &#123;id: 3,name: &#39;五菱&#39;&#125;,        ]         this.carList = cartList    &#125;&#125;;&lt;/script&gt;</code></pre><h2 id="集成sass"><a href="#集成sass" class="headerlink" title="集成sass"></a>集成sass</h2><p>安装</p><pre><code class="shell">npm i sass@1.32.13npm i sass-loader@10.1.1</code></pre><p>页面使用</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;h1&gt;hello nuxt2&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.container&#123;  h1&#123;    color: red;  &#125;&#125;&lt;/style&gt;</code></pre><h2 id="集成elementui"><a href="#集成elementui" class="headerlink" title="集成elementui"></a>集成elementui</h2><p>安装</p><pre><code class="shell">npm i element-ui -S</code></pre><p>新建plugins&#x2F;elementui.js</p><pre><code class="js">import Vue from &#39;vue&#39;;import ElementUI from &#39;element-ui&#39;;Vue.use(ElementUI);</code></pre><p>nuxt.config.js引入elementui.js插件和样式</p><pre><code class="js">export default &#123;    css: [        &quot;element-ui/lib/theme-chalk/index.css&quot;,        &#39;element-ui/lib/theme-chalk/display.css&#39;      ],    plugins: [        &quot;~/plugins/elementui.js&quot;,    ],    //...&#125;</code></pre><p>页面使用</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;el-button type=&quot;primary&quot;&gt;test&lt;/el-button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装</p><pre><code class="shell">npm i @nuxtjs/i18n@7.3.1</code></pre><p>项目根目录新建lang&#x2F;zh.js</p><pre><code class="js">export default &#123;    name: &#39;姓名&#39;,    age: &#39;年龄&#39;&#125;</code></pre><p>项目根目录新建lang&#x2F;en.js</p><pre><code class="js">export default &#123;    name: &#39;name&#39;,    age: &#39;age&#39;&#125;</code></pre><p>项目根目录新建i18n.js</p><pre><code class="js">import en from &quot;./lang/en.js&quot;;import zh from &quot;./lang/zh.js&quot;;import Vue from &quot;vue&quot;;import VueI18n from &quot;vue-i18n&quot;;Vue.use(VueI18n);const i18n = &#123;  locales: [&quot;en&quot;, &quot;zh&quot;], //有多少地区的语言就添加多少种  defaultLocale: &quot;en&quot;, //默认的地区语言  vueI18n: &#123;    fallbackLocale: &quot;en&quot;, //回退策略，指定的locale中没有找到对应资源的情况下使用的locale    messages: &#123;      //要渲染的信息，有多少语言就添加多少种      en,      zh,    &#125;  &#125;,&#125;</code></pre><p>nuxt.config.js</p><pre><code class="js">import i18n from &quot;./i18n.js&quot;; //导入上面的i18n配置文件export default &#123;    //模块  modules: [[&quot;@nuxtjs/i18n&quot;, i18n]],    //...&#125;</code></pre><p>页面中使用</p><p>this.$t(‘key’)  获取当前语言下对应的value值</p><p>this.localePath(url)  根据语言处理路径</p><p>this.$i18n.locale 获取当前语言</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;el-tag type=&quot;primary&quot;&gt;&#123;&#123; $t('name') &#125;&#125;&lt;/el-tag&gt;    &lt;el-tag type=&quot;success&quot;&gt;&#123;&#123; $t('age') &#125;&#125;&lt;/el-tag&gt;    &lt;nuxt-link :to=&quot;url&quot;&gt;本地化路径&lt;/nuxt-link&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Nuxt2StudyIndex&#39;,  data() &#123;    return &#123;      url: &#39;&#39;    &#125;;  &#125;,  mounted() &#123;    //localePath方法可根据语言处理路径 英文：/book/1001 中文：/zh/book/1001    this.url = this.localePath(&#39;/book/1001&#39;)  &#125;&#125;;&lt;/script&gt;</code></pre><p>访问</p><pre><code>英文：http://localhost:3000/中文：http://localhost:3000/zh</code></pre><h3 id="语言切换组件"><a href="#语言切换组件" class="headerlink" title="语言切换组件"></a>语言切换组件</h3><p>components&#x2F;Language.vue</p><pre><code class="html">&lt;template&gt;    &lt;a :href=&quot;webUrl&quot;&gt;        &lt;img :src=&quot;require(&#39;@/assets/images/zh.svg&#39;)&quot; v-if=&quot;$i18n.locale == &#39;en&#39;&quot; @click.prevent=&quot;changeLang(&#39;zh&#39;)&quot;            style=&quot;cursor: pointer&quot; /&gt;        &lt;img :src=&quot;require(&#39;@/assets/images/en.svg&#39;)&quot; v-if=&quot;$i18n.locale == &#39;zh&#39;&quot; @click.prevent=&quot;changeLang(&#39;en&#39;)&quot;            style=&quot;cursor: pointer&quot; /&gt;    &lt;/a&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;Language&#39;,    data() &#123;        return &#123;        &#125;    &#125;,    computed: &#123;        webUrl() &#123;            return this.$i18n.locale == &#39;en&#39; ? &quot;/zh&quot; + this.$route.fullPath : this.$route.fullPath        &#125;    &#125;,    methods: &#123;        // 切换语言        changeLang(lang) &#123;            let url = this.$route.fullPath            url = url.includes(&#39;/zh&#39;) ? url.replace(&#39;/zh&#39;, &#39;&#39;) : &#39;/zh&#39; + url            url = url.replace(&#39;null&#39;, &#39;&#39;)            // location.href = url            this.$router.replace(url)        &#125;    &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;a:hover&#123;    background: #f2f4f7;&#125;a&#123;    padding: 8px!important;&#125;img &#123;    vertical-align: middle;&#125;&lt;/style&gt;</code></pre><h3 id="element-ui-国际化"><a href="#element-ui-国际化" class="headerlink" title="element ui 国际化"></a>element ui 国际化</h3><p>layouts&#x2F;default.vue</p><pre><code class="html">&lt;template&gt;  &lt;!-- 默认布局组件 --&gt;  &lt;div&gt;    &lt;!-- 渲染内容 --&gt;    &lt;Nuxt /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import en from &#39;element-ui/lib/locale/lang/en&#39;import zh from &#39;element-ui/lib/locale/lang/zh-CN&#39;import locale from &#39;element-ui/lib/locale&#39;export default &#123;  name: &#39;Default&#39;,  mounted() &#123;    //elementui国际化    let lang = this.$i18n.locale == &#39;en&#39;? en :zh    locale.use(lang)  &#125;&#125;;&lt;/script&gt;</code></pre><h2 id="SEO的处理"><a href="#SEO的处理" class="headerlink" title="SEO的处理"></a>SEO的处理</h2><h3 id="全局处理"><a href="#全局处理" class="headerlink" title="全局处理"></a>全局处理</h3><p>在nuxt.config.js 中可以给所有页面配置</p><pre><code class="js">export default &#123;  //全局SEO设置  head: &#123;    title: &quot;Tranalysis system&quot;,    htmlAttrs: &#123;      lang: &quot;en&quot;,    &#125;,    meta: [      &#123; charset: &quot;utf-8&quot; &#125;,      &#123; name: &quot;viewport&quot;, content: &quot;width=device-width, initial-scale=1&quot; &#125;,      &#123; hid: &quot;description&quot;, name: &quot;description&quot;, content: &quot;Tranalysis system&quot; &#125;,    ],    link: [&#123; rel: &quot;icon&quot;, type: &quot;image/x-icon&quot;, href: &quot;/favicon.ico&quot; &#125;],  &#125;,&#125;</code></pre><h3 id="单个页面或者布局组件中配置"><a href="#单个页面或者布局组件中配置" class="headerlink" title="单个页面或者布局组件中配置"></a>单个页面或者布局组件中配置</h3><p>这种方式更好，可以支持国际化</p><pre><code class="html">&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    head() &#123;        let title = &#39;标题111&#39;        let description = &#39;描述2222&#39;        return &#123;          title,//网页标题          meta: [            &#123;              hid: &#39;keywords&#39;,              name: &#39;keywords&#39;, //网页关键字              content: title            &#125;,            &#123;              hid: &#39;description&#39;,              name: &#39;description&#39;,//网页描述              content: description            &#125;,          ]        &#125;    &#125;,&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</code></pre><h2 id="vuex的使用"><a href="#vuex的使用" class="headerlink" title="vuex的使用"></a>vuex的使用</h2><p>和原来的用法一致，nuxt中已经内置vuex，所以不需要安装vuex，只需要安装vuex持久化插件即可</p><p>安装vuex持久化插件</p><pre><code class="shell">npm i vuex-persistedstate@4.1.0</code></pre><p>新建 plugins&#x2F;vuex-persistedstate.js</p><pre><code class="js">import createPersistedState from &#39;vuex-persistedstate&#39;//vuex持久化export default (&#123; store &#125;) =&gt; &#123;    createPersistedState(&#123;        storage: localStorage    &#125;)(store)&#125;</code></pre><p>nuxt.config.js</p><pre><code class="js">export default &#123;  plugins: [    //...    &#123; src: &#39;~/plugins/vuex-persistedstate.js&#39;, ssr: false &#125; //引入vuex-persistedstate插件  ],&#125;</code></pre><p>store&#x2F;modules&#x2F;user.js</p><pre><code class="js">const user = &#123;    state: &#123;        count: 0    &#125;,    mutations: &#123;        SET_COUNT: (state, data) =&gt; &#123;          state.count = data        &#125;,    &#125;,    actions: &#123;&#125;&#125;export default user;</code></pre><p>store&#x2F;getters.js</p><pre><code class="js">const getters = &#123;    count: state =&gt; state.user.count&#125;export default getters</code></pre><p>store&#x2F;index.js</p><pre><code class="js">import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;import user from &quot;./modules/user&quot;;import getters from &quot;./getters&quot;;Vue.use(Vuex);//主要这里要用箭头函数的形式导出，否则会报错export default () =&gt; new Vuex.Store(&#123;  getters,  modules: &#123;    user  &#125;,&#125;);</code></pre><p>组件中使用vuex</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;el-button @click=&quot;add&quot; type=&quot;primary&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/el-button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapGetters,mapMutations&#125; from &#39;vuex&#39;export default &#123;    name: &#39;Nuxt2StudyIndex&#39;,    computed:&#123;        ...mapGetters([&#39;count&#39;])    &#125;,    methods: &#123;        ...mapMutations([&#39;SET_COUNT&#39;]),        add()&#123;            this.SET_COUNT(this.count+1)        &#125;    &#125;,&#125;&lt;/script&gt;</code></pre><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>安装</p><pre><code class="shell">npm i cross-env@7.0.3 -D</code></pre><p>项目根目录新建env.js</p><pre><code class="js">export default &#123;    //开发环境    dev:&#123;      NODE_ENV: &#39;dev&#39;,      PROJECT_TITLE: &#39;NUXT-DEV&#39;,      ENV_API:&#39;http://dev.com/api&#39;,//API地址    &#125;,    //测试环境    stage:&#123;      NODE_ENV: &#39;test&#39;,      PROJECT_TITLE: &#39;NUXT-TEST&#39;,      ENV_API:&#39;http://test.com/api&#39;,//API地址    &#125;,    //正式环境    prod:&#123;      NODE_ENV: &#39;prod&#39;,      PROJECT_TITLE: &#39;NUXT-PRODUCTION&#39;,      ENV_API:&#39;http://prod.com/api&#39;,//API地址    &#125;&#125;</code></pre><p>nuxt.config.js</p><pre><code class="js">import env from &quot;./env.js&quot;; //导入上面的环境变量export default &#123;    env: env[process.env.NODE_ENV] //配置环境变量    //...&#125;</code></pre><p>package.json 配置</p><pre><code class="js">&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;cross-env NODE_ENV=dev nuxt dev&quot;,    &quot;build:stage&quot;: &quot;cross-env NODE_ENV=stage nuxt build&quot;,    &quot;start:stage&quot;: &quot;cross-env NODE_ENV=stage nuxt start&quot;,    &quot;build:prod&quot;: &quot;cross-env NODE_ENV=prod nuxt build&quot;,    &quot;start:prod&quot;: &quot;cross-env NODE_ENV=prod nuxt start&quot;,    &quot;generate:prod&quot;: &quot;cross-env NODE_ENV=prod nuxt generate&quot;,    &quot;generate:stage&quot;: &quot;cross-env NODE_ENV=stage nuxt generate&quot;  &#125;,&#125;</code></pre><p>页面中使用</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &#123;&#123; title &#125;&#125;-&#123;&#123; baseAPI &#125;&#125;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;Nuxt2StudyIndex&#39;,    data() &#123;        return &#123;            title: process.env.PROJECT_TITLE,            baseAPI: process.env.ENV_API        &#125;    &#125;&#125;</code></pre><h2 id="集成axios"><a href="#集成axios" class="headerlink" title="集成axios"></a>集成axios</h2><p>安装</p><pre><code class="shell">npm i @nuxtjs/axios@5.13.6</code></pre><p>plugins&#x2F;axios.js  参考下面按需修改即可</p><pre><code class="js">import &#123; Message &#125; from &quot;element-ui&quot;;import &#123; getToken &#125; from &quot;@/utils/auth&quot;;//get请求参数处理function tansParams(params) &#123;  let result = &quot;&quot;;  for (const propName of Object.keys(params)) &#123;    const value = params[propName];    var part = encodeURIComponent(propName) + &quot;=&quot;;    if (value !== null &amp;&amp; value !== &quot;&quot; &amp;&amp; typeof value !== &quot;undefined&quot;) &#123;      if (typeof value === &quot;object&quot;) &#123;        for (const key of Object.keys(value)) &#123;          if (            value[key] !== null &amp;&amp;            value[key] !== &quot;&quot; &amp;&amp;            typeof value[key] !== &quot;undefined&quot;          ) &#123;            let params = propName + &quot;[&quot; + key + &quot;]&quot;;            var subPart = encodeURIComponent(params) + &quot;=&quot;;            result += subPart + encodeURIComponent(value[key]) + &quot;&amp;&quot;;          &#125;        &#125;      &#125; else &#123;        result += part + encodeURIComponent(value) + &quot;&amp;&quot;;      &#125;    &#125;  &#125;  return result;&#125;export default function (&#123; $axios, redirect, app, store, $router, $route &#125;) &#123;  //如果需要国际化可以：app.i18n.t(&quot;key&quot;)  //请求拦截  $axios.interceptors.request.use(    (config) =&gt; &#123;      const isToken = (config.headers || &#123;&#125;).isToken === false;      if (getToken() &amp;&amp; !isToken) &#123;        config.headers[&quot;Authorization&quot;] = &quot;Bearer &quot; + getToken(); // 让每个请求携带自定义token 请根据实际情况自行修改      &#125;      // get请求映射params参数      if (config.method === &quot;get&quot; &amp;&amp; config.params) &#123;        let url = config.url + &quot;?&quot; + tansParams(config.params);        url = url.slice(0, -1);        config.params = &#123;&#125;;        config.url = url;      &#125;      return config;    &#125;,    (error) =&gt; &#123;      console.log(&quot;axios request error&quot;, error);      return Promise.reject(error);    &#125;  );  //响应拦截  $axios.interceptors.response.use(    (response) =&gt; &#123;      const code = response.data.code || 200;      console.log(&quot;code&quot;, code, &quot;axios response:&quot; + response);      const res = response.data;      //文件下载      if (&quot;business/product/downloadProductData&quot; == response.config.url) &#123;        return res;      &#125;      if (code === 401) &#123;        //登录过期        // if(app.i18n.t(res.msg)) Message(&#123;type: &#39;error&#39;, message: app.i18n.t(res.msg)&#125;)        // store.dispatch(&quot;LogOut&quot;).then(() =&gt; &#123;        //   app.router.push(app.localePath(&quot;/&quot;));        // &#125;);        Message(&#123; type: &quot;error&quot;, message: &quot;登录已过期，请重新登录！&quot; &#125;);        app.router.push(app.localePath(&quot;/&quot;));      &#125; else if (code === 200) &#123;        //普通请求        return res;      &#125; else if (code === 500) &#123;        Message(&#123; type: &quot;error&quot;, message: app.i18n.t(res?.msg) &#125;);        return Promise.reject(new Error(res?.msg || &quot;Error&quot;));      &#125; else &#123;        return res;      &#125;    &#125;,    (error) =&gt; &#123;      console.log(&quot;err&quot; + error);      let &#123; message &#125; = error;      Message(&#123; message, type: &quot;error&quot;, duration: 5 * 1000 &#125;);      return Promise.reject(error);    &#125;  );&#125;</code></pre><p>plugins&#x2F;api.js</p><pre><code class="js">import login from &#39;@/api/login&#39;import menu from &#39;@/api/menu&#39;export default function(&#123; $axios &#125;,inject) &#123;    inject(&#39;loginAPI&#39;,login($axios)) //组件中使用this.$loginAPI.xxx方法名调用    inject(&#39;menuAPI&#39;,menu($axios)) //组件中使用this.$menuAPI.xxx方法名调用&#125;</code></pre><p>api&#x2F;menu.js</p><pre><code class="js">export default function menu(request) &#123;  /**   * 获取菜单   */  const getRouters = (lang,menuSuit=1) =&gt; &#123;    return request(&#123;      url: `/system/menu/getRouters/$&#123;lang&#125;/$&#123;menuSuit&#125;`,      method: &quot;get&quot;,    &#125;);  &#125;;  return &#123;    getRouters,  &#125;;&#125;</code></pre><p>api&#x2F;login.js</p><pre><code class="js">export default function login(request) &#123;    // 注册方法      function register(data) &#123;        return request(&#123;          url: &quot;/auth/register&quot;,          headers: &#123;            isToken: false, //无需携带token          &#125;,          method: &quot;post&quot;,          data: data,        &#125;);      &#125;        // 获取用户详细信息      function getInfo() &#123;        return request(&#123;          url: &quot;/system/user/getInfo&quot;,          method: &quot;get&quot;,        &#125;);      &#125;    return &#123;        register,        getInfo      &#125;;&#125;</code></pre><p>nuxt.config.js 中配置</p><pre><code class="js">export default &#123;    //第一步：配置axios请求前缀    axios: &#123;        // proxyHeaders: false        baseURL: env[process.env.NODE_ENV].ENV_API         //...    &#125;    //第二步：增加axios相关的两个配置    plugins: [        &quot;~/plugins/axios.js&quot;,        &quot;~/plugins/api.js&quot;,         //...    ],    //第三步：模块中增加axios    modules: [&quot;@nuxtjs/axios&quot;, [&quot;@nuxtjs/i18n&quot;, i18n]],    //...&#125;</code></pre><p>页面中使用</p><pre><code class="js">export default &#123;    methods: &#123;        async test()&#123;          //调用方法：plugins/api.js中的 inject(&#39;loginAPI&#39;,login($axios)) 第一个参数前面+$调用          const res = await this.$loginAPI.register(&#123;username: &#39;tom&#39;,password: 123456&#125;)          //await this.$loginAPI.getInfo()          //this.$menuAPI.getRouters()        &#125;    &#125;&#125;</code></pre><h2 id="配置组件自动导入"><a href="#配置组件自动导入" class="headerlink" title="配置组件自动导入"></a>配置组件自动导入</h2><p>nuxt.config.js</p><pre><code class="js">export default &#123;    components: true    //...&#125;</code></pre><h2 id="配置ip和端口"><a href="#配置ip和端口" class="headerlink" title="配置ip和端口"></a>配置ip和端口</h2><p>nuxt.config.js</p><pre><code class="js">export default &#123;    server: &#123;        port: 81, // default: 3000        host: &quot;0.0.0.0&quot;, // default: localhost    &#125;    //...&#125;</code></pre><h2 id="配置src目录"><a href="#配置src目录" class="headerlink" title="配置src目录"></a>配置src目录</h2><p>默认不使用src目录，如果需要配置像下面这样</p><pre><code class="bash">---| node_modules/---| nuxt.config.js---| package.json---| src/------| assets/------| components/------| layouts/------| middleware/------| pages/------| plugins/------| static/------| store/</code></pre><p>则需要在nuxt.config.js中配置</p><pre><code class="js">export default &#123;    srcDir: &quot;./src&quot;    //...&#125;</code></pre><h2 id="svg组件封装"><a href="#svg组件封装" class="headerlink" title="svg组件封装"></a>svg组件封装</h2><p>封装svg组件，方便后续svg图片的使用</p><p>首先安装</p><pre><code class="shell">npm i svg-sprite-loader@6.0.11 -D</code></pre><p>在nuxt.config.js中配置</p><pre><code class="js">const path = require(&#39;path&#39;); //导入path模块export default &#123;    build: &#123;        vendor: [&quot;element-ui&quot;],        extend(config, ctx) &#123;          // ...          const svgRule = config.module.rules.find((rule) =&gt;            rule.test.test(&quot;.svg&quot;)          );          //这里将svg图片拷贝到 》 根目录/static/svg文件夹中          svgRule.exclude = [path.resolve(__dirname, &quot;./static/svg&quot;)];          config.module.rules.push(&#123;            test: /\.svg$/,            include: [path.resolve(__dirname, &quot;./static/svg&quot;)],            loader: &quot;svg-sprite-loader&quot;,            options: &#123;              symbolId: &quot;icon-[name]&quot;,            &#125;,          &#125;);        &#125;,    &#125;,    //...&#125;</code></pre><p>新建 components&#x2F;SvgIcon.vue 组件</p><pre><code class="html">&lt;!-- nuxt中使用svg https://blog.csdn.net/qq_26373925/article/details/108405038 --&gt;&lt;template&gt;    &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;        &lt;use :xlink:href=&quot;iconName&quot; /&gt;    &lt;/svg&gt;&lt;/template&gt;  &lt;script&gt;export default &#123;    name: &#39;SvgIcon&#39;,    props: &#123;        iconClass: &#123;            type: String,            required: true        &#125;,        className: &#123;            type: String,            default: &#39;&#39;        &#125;    &#125;,    computed: &#123;        iconName() &#123;            console.log(&#39;iconClass&#39;, this.iconClass)            return `#icon-$&#123;this.iconClass&#125;`        &#125;,        svgClass() &#123;            return this.className ? &#39;svg-icon &#39; + this.className : &#39;svg-icon&#39;        &#125;    &#125;&#125;&lt;/script&gt;  &lt;style scoped&gt;.svg-icon &#123;    width: 1em;    height: 1em;    font-size: 1.2em;    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;&#125;&lt;/style&gt;</code></pre><p>页面中使用</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;        &lt;!--dashboard 对应 static/svg/dashboard.svg--&gt;        &lt;svg-icon icon-class=&quot;dashboard&quot; /&gt; &lt;span slot=&quot;title&quot;&gt;首页&lt;/span&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h2 id="静态资源引入"><a href="#静态资源引入" class="headerlink" title="静态资源引入"></a>静态资源引入</h2><p>static目录和assets目录，都是用来存储静态文件的</p><pre><code>assets中的资源会被webpack处理，打包后会在dist中合并成一个文件；static中的资源不会被webpack处理，打包后直接复制到dist（默认是dist/static）下推荐assets中存放自己的资源（css、images、utils等），static中放第三方资源（pdf.js、iconfont等）动态绑定中，assets的图片会加载失败，因为webpack使用commonJS规范，需要使用require引入图片（可以通过import的方式引入）</code></pre><p>assets 需要 require引入</p><pre><code class="html">&lt;!--assets/images/zh.svg--&gt;&lt;img :src=&quot;require(&#39;@/assets/images/zh.svg&#39;)&quot; /&gt;</code></pre><p>static直接映射到服务器根目录，可以通过项目根URL访问</p><pre><code class="html">&lt;!--static/images/pay/ali.png--&gt;&lt;img src=&quot;/images/pay/ali.png&quot; width=&quot;40&quot;&gt;</code></pre><h2 id="集成tailwindcss"><a href="#集成tailwindcss" class="headerlink" title="集成tailwindcss"></a>集成tailwindcss</h2><p>安装</p><pre><code class="shell">npm i @nuxtjs/tailwindcss@6.10.1</code></pre><p>项目根目录 创建 tailwind.config.js</p><pre><code class="js">/** @type &#123;import(&#39;tailwindcss&#39;).Config&#125; */module.exports = &#123;  content: [],  theme: &#123;    extend: &#123;&#125;,  &#125;,  plugins: [],&#125;</code></pre><p>项目根目录 创建 assets&#x2F;css&#x2F;tailwind.css</p><pre><code class="css">@tailwind base;@tailwind components;@tailwind utilities;</code></pre><p>在nuxt.config.js中配置</p><pre><code class="js">export default &#123;    buildModules: [&#39;@nuxtjs/tailwindcss&#39;],    tailwindcss: &#123;        cssPath: &#39;~/assets/css/tailwind.css&#39;,        configPath: &#39;tailwind.config.js&#39;,        exposeConfig: false,        config: &#123;&#125;    &#125;,    //...&#125;</code></pre><h2 id="nuxt2项目模板"><a href="#nuxt2项目模板" class="headerlink" title="nuxt2项目模板"></a>nuxt2项目模板</h2><p>自建nuxt2项目模板 <a href="https://gitee.com/heliufang/nuxt2-template">nuxt2-template</a></p>]]></content>
    
    
    <summary type="html">nuxt2基础、以及整合elementui、tailwindcss、axios、i18n国际化等等</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="nuxt" scheme="https://heliufang.github.io/tags/nuxt/"/>
    
  </entry>
  
  <entry>
    <title>js格式化时间间隔</title>
    <link href="https://heliufang.github.io/posts/31559881/"/>
    <id>https://heliufang.github.io/posts/31559881/</id>
    <published>2023-12-11T08:50:28.000Z</published>
    <updated>2024-01-12T13:46:14.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>js计算时间间隔要求如下：</p><pre><code>小于1分钟：刚刚        60小于1小时：几分钟前    60*60小于1天：几小时前      60*60*24小于1周：几天前        60*60*24*7小于1月：几周前        60*60*24*30小于1年：几个月前      60*60*24*365大于1年：几年前        60*60*24*365</code></pre><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>formatTimeFromNowZh-中文方法<br>formatTimeFromNowEn-英文方法</p><pre><code class="js">//1.中文方法function formatTimeFromNowZh(time) &#123;  // if ((&quot;&quot; + time).length === 10) &#123;  //   time = parseInt(time) * 1000;  // &#125; else &#123;  //   time = +time;  // &#125;  const d = new Date(time);  const now = Date.now();  const diff = (now - d) / 1000;  // console.log(&#39;formatTimeFromNowZh time&#39;, time,&#39;diff&#39;,diff)  if(diff &lt; 0)&#123;//未来时间    return time  &#125;  if (diff &lt; 60) &#123;    return &quot;刚刚&quot;;  &#125; else if (diff &lt; 3600) &#123;    return Math.floor(diff / 60) + &quot;分钟前&quot;;  &#125; else if (diff &lt; 3600 * 24) &#123;    return Math.floor(diff / 3600) + &quot;小时前&quot;;  &#125; else if (diff &lt; 3600 * 24 * 7) &#123;    return Math.floor(diff / (3600 * 24))+&quot;天前&quot;;  &#125;else if (diff &lt; 3600 * 24 * 30) &#123;    return Math.floor(diff / (3600 * 24 * 7))+&quot;周前&quot;;  &#125;else if (diff &lt; 3600 * 24 * 365) &#123;    let m = Math.floor(diff / (3600 * 24 * 30))    m = m==12?11:m    return m+&quot;月前&quot;;  &#125;else if (diff &gt;= 3600 * 24 * 365) &#123;    return Math.floor(diff / (3600 * 24 * 365))+&quot;年前&quot;;  &#125;else&#123;    return time  &#125;&#125;//2.英文方法function formatTimeFromNowEn(time) &#123;  // if ((&quot;&quot; + time).length === 10) &#123;  //   time = parseInt(time) * 1000;  // &#125; else &#123;  //   time = +time;  // &#125;  const d = new Date(time);  const now = Date.now();  const diff = (now - d) / 1000;  if(diff &lt; 0)&#123;//未来时间    return time  &#125;  if (diff &lt; 60) &#123;    return &quot;Just now&quot;;  &#125; else if (diff &lt; 3600) &#123;    let suffix = Math.floor(diff / 60) &gt; 1?&quot;minutes ago&quot;:&quot;minute ago&quot;    return Math.floor(diff / 60) +&quot; &quot;+suffix;  &#125; else if (diff &lt; 3600 * 24) &#123;    let suffix = Math.floor(diff / 3600) &gt; 1?&quot;hours ago&quot;:&quot;hour ago&quot;    return Math.floor(diff / 3600)+&quot; &quot; + suffix;  &#125; else if (diff &lt; 3600 * 24 * 7) &#123;    let suffix = Math.floor(diff / (3600 * 24)) &gt; 1?&quot;days ago&quot;:&quot;day ago&quot;    return Math.floor(diff / (3600 * 24))+&quot; &quot;+suffix;  &#125;else if (diff &lt; 3600 * 24 * 30) &#123;    let suffix =Math.floor(diff / (3600 * 24 * 7)) &gt; 1?&quot;weeks ago&quot;:&quot;week ago&quot;    return Math.floor(diff / (3600 * 24 * 7))+&quot; &quot;+suffix;  &#125;else if (diff &lt; 3600 * 24 * 365) &#123;    let m = Math.floor(diff / (3600 * 24 * 30))    m = m==12?11:m    let suffix = m &gt; 1?&quot;months ago&quot;:&quot;month ago&quot;    return m+&quot; &quot;+suffix;  &#125;else if (diff &gt;= 3600 * 24 * 365) &#123;    let suffix = Math.floor(diff / (3600 * 24 * 30)) &gt; 1?&quot;years ago&quot;:&quot;year ago&quot;    return Math.floor(diff / (3600 * 24 * 365))+&quot; &quot;+suffix;  &#125;else&#123;    return time  &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">js格式化时间间隔，格式（刚刚 几分钟前 几小时前 几天前  几周前 几个月前 几年前）</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://heliufang.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue和react封装echart组件</title>
    <link href="https://heliufang.github.io/posts/b1adc31a/"/>
    <id>https://heliufang.github.io/posts/b1adc31a/</id>
    <published>2023-12-11T08:34:28.000Z</published>
    <updated>2024-01-12T13:46:14.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue封装echart"><a href="#Vue封装echart" class="headerlink" title="Vue封装echart"></a>Vue封装echart</h2><p>安装ResizeListener</p><pre><code>npm i element-resize-detector@1.2.4</code></pre><p>VueEchart组件</p><pre><code class="html">&lt;template&gt;    &lt;div :class=&quot;className&quot;&gt;&lt;/div&gt;&lt;/template&gt;    &lt;script&gt;  import &#123; merge &#125; from &quot;lodash&quot;;  import * as echarts from &quot;echarts&quot;;  import ResizeListener from &quot;element-resize-detector&quot;;    export default &#123;    name: &quot;NuxtEchart&quot;,    props: &#123;      options: &#123;        type: Object,        default: () =&gt; (&#123;&#125;),      &#125;,      className: &#123;        type: String,        default: &#39;def&#39;      &#125;,    &#125;,    data() &#123;      return &#123;        chart: null,      &#125;;    &#125;,    watch: &#123;      options: &#123;        deep: true,        handler() &#123;          this.updateChartView();        &#125;,      &#125;,    &#125;,    mounted() &#123;      this.chart = echarts.init(this.$el);      this.updateChartView();      window.addEventListener(&quot;resize&quot;, this.handleWindowResize);      this.addChartResizeListener();      // 监听 &#39;click&#39; 事件        this.chart.on(&#39;click&#39;, (params) =&gt; &#123;            this.$emit(&#39;click&#39;,params)      &#125;);    &#125;,    beforeDestroy() &#123;      window.removeEventListener(&quot;resize&quot;, this.handleWindowResize);    &#125;,    methods: &#123;      myChart()&#123;        return this.chart      &#125;,      mergeOption() &#123;        return merge(          &#123;            //backgroundColor: &quot;#ffffff&quot;,            // textStyle:&#123;            //   color:&#39;#A5D7FA&#39;,            //   fontSize:15            // &#125;          &#125;,          this.options        );      &#125;,        //对chart元素尺寸进行监听，当发生变化时同步更新echart视图      addChartResizeListener() &#123;        const instance = ResizeListener(&#123;          strategy: &quot;scroll&quot;,          callOnAdd: true,        &#125;);          instance.listenTo(this.$el, () =&gt; &#123;          if (!this.chart) return;          this.chart.resize();        &#125;);      &#125;,        //更新echart视图      updateChartView() &#123;        if (!this.chart) return;        this.chart.setOption(this.mergeOption(), true);      &#125;,        // 当窗口缩放时，echart动态调整自身大小      handleWindowResize() &#123;        if (!this.chart) return;        this.chart.resize();      &#125;,    &#125;,  &#125;;  &lt;/script&gt;  &lt;style  scoped&gt;  .def &#123;    width: 100%;    height: 100%;  &#125;  &lt;/style&gt;  </code></pre><h2 id="React封装echart"><a href="#React封装echart" class="headerlink" title="React封装echart"></a>React封装echart</h2><p>ReactEchart组件</p><pre><code class="jsx">import React, &#123; useEffect,useRef &#125; from &quot;react&quot;;import * as echarts from &quot;echarts&quot;;//自定义echart组件export default function ReactEcharts(&#123; option,width,height &#125;) &#123;  const echartRef = useRef()  useEffect(() =&gt; &#123;    setTimeout(() =&gt; &#123;        initChart();    &#125;);  &#125;, [option]);  /*生成图表，做了判断，如果不去判断dom有没有生成，每次更新图表都要生成一个dom节点*/  const initChart = () =&gt; &#123;    // 基于准备好的dom，初始化echarts实例    let myChart = echarts.getInstanceByDom(echartRef.current);    if (myChart === undefined) &#123;      myChart = echarts.init(echartRef.current);    &#125;    // 绘制图表，option设置图表格式及源数据    myChart.setOption(option);    //响应式    window.addEventListener(&#39;resize&#39;, function () &#123;      myChart.resize();    &#125;);  &#125;;  return (    &lt;div ref=&#123;echartRef&#125; style=&#123;&#123; height: height?height:400,width:width?width:'100%' &#125;&#125;&gt;&lt;/div&gt;  );&#125;</code></pre>]]></content>
    
    
    <summary type="html">整理项目中vue和react两种框架下echart组件的封装</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="echart" scheme="https://heliufang.github.io/tags/echart/"/>
    
  </entry>
  
  <entry>
    <title>Nextjs入门笔记</title>
    <link href="https://heliufang.github.io/posts/b4b4770b/"/>
    <id>https://heliufang.github.io/posts/b4b4770b/</id>
    <published>2023-12-11T08:20:28.000Z</published>
    <updated>2024-01-12T13:46:14.026Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://nextjs.org/docs/getting-started/installation">Nextjs英文官网</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>nextjs是基于react语法来实现SSR(服务器渲染)的框架，解决单页应用不利于SEO的问题</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>环境说明</p><ul><li>node v18</li><li>next v14</li></ul><p>执行下面的命令</p><pre><code class="shell">npx create-next-app@latest</code></pre><p>然后依次选择</p><pre><code>H:\study\next-study&gt;npx create-next-app@latestNeed to install the following packages:  create-next-app@latestOk to proceed? (y) ynpm WARN EBADENGINE Unsupported engine &#123;npm WARN EBADENGINE   package: &#39;create-next-app@14.0.3&#39;,npm WARN EBADENGINE   required: &#123; node: &#39;&gt;=18.17.0&#39; &#125;,npm WARN EBADENGINE   current: &#123; node: &#39;v16.15.0&#39;, npm: &#39;8.5.5&#39; &#125;npm WARN EBADENGINE &#125;√ What is your project named? ... my-app√ Would you like to use TypeScript? ... No / Yes #使用ts√ Would you like to use ESLint? ... No / Yes  #使用eslint校验√ Would you like to use Tailwind CSS? ... No / Yes #使用Tailwind CSS样式库√ Would you like to use `src/` directory? ... No / Yes #使用src目录√ Would you like to use App Router? (recommended) ... No / Yes #使用app路由√ Would you like to customize the default import alias (@/*)? ... No / Yes  #使用@相对路径√ What import alias would you like configured? ... @/*</code></pre><p>启动</p><pre><code class="shell">npm run dev</code></pre><p>访问：<a href="http://localhost:3000/">http://localhost:3000/</a></p><h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><pre><code>- public 静态资源目录- src   - app 页面目录（重点）    - favicon.ico 网站favicon.ico图标    - globals.css 全局css文件    - layout.tsx 根布局组件（重点）    - page.tsx 默认页面（重点）- next.config.js 核心配置文件- postcss.config.js postcss配置文件- tailwind.config.ts tailwindcss配置文件- tsconfig.json ts配置文件</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="定义路由"><a href="#定义路由" class="headerlink" title="定义路由"></a>定义路由</h3><p>Next.js使用基于文件系统的路由器，其中文件夹用于定义路由。 文件夹中的page.jsx&#x2F;page.tsx&#x2F;page.js文件代表的就是页面。</p><p>【案例：定义路由】</p><p>创建a页面：src&#x2F;app&#x2F;a&#x2F;page.tsx   访问a页面：<a href="http://localhost:3000/a">http://localhost:3000/a</a></p><pre><code class="jsx">import React from &#39;react&#39;const page = () =&gt; &#123;  return (    &lt;div&gt;a页面&lt;/div&gt;  )&#125;export default page</code></pre><p>创建b页面：src&#x2F;app&#x2F;a&#x2F;b&#x2F;page.tsx  访问b页面：<a href="http://localhost:3000/a/b">http://localhost:3000/a/b</a></p><pre><code class="jsx">import React from &#39;react&#39;const page = () =&gt; &#123;  return (    &lt;div&gt;b页面&lt;/div&gt;  )&#125;export default page</code></pre><p>可以看到创建了两个嵌套的文件夹,文件夹可以无限嵌套。</p><p>页面使用page.tsx导出一个react组件，其中<a href="http://localhost:3000/">http://localhost:3000</a> 访问的就是src&#x2F;app&#x2F;page.tsx</p><h3 id="layout布局"><a href="#layout布局" class="headerlink" title="layout布局"></a>layout布局</h3><p>布局是在多个页面之间共享的用户界面。在导航中，布局保留状态，保持交互，并且不重新呈现。布局也可以嵌套。 </p><p>【案例：定义布局】</p><p>创建根布局：src&#x2F;app&#x2F;layout.tsx  </p><blockquote><p>1.根布局是所有页面共享的布局,并且是必须的</p><p>2.只有根布局可以包含&lt; html &gt;和&lt; body &gt;标记。</p></blockquote><pre><code class="jsx">import type &#123; Metadata &#125; from &#39;next&#39;import &#39;./globals.css&#39;export const metadata: Metadata = &#123; //定义网站的seo  title: &#39;Create Next App&#39;,  description: &#39;Generated by create next app&#39;,&#125;export default function RootLayout(&#123;children&#125;: &#123;children: React.ReactNode&#125;) &#123;  return (    &lt;html lang=&quot;en&quot;&gt;      &lt;body className=&quot;bg-slate-400&quot;&gt;根布局：&#123;children&#125;&lt;/body&gt;    &lt;/html&gt;  )&#125;</code></pre><p>创建a页面的布局：src&#x2F;app&#x2F;a&#x2F;layout.tsx</p><pre><code class="jsx">import React from &#39;react&#39;const layout = (&#123;children&#125;:&#123;children:React.ReactNode&#125;) =&gt; &#123;  return (    &lt;div&gt;layoutA:&#123;children&#125;&lt;/div&gt;  )&#125;export default layout</code></pre><p>访问<a href="http://localhost:3000/a">http://localhost:3000/a</a>   </p><p><img src="/posts/b4b4770b/1701851198502.png" alt="1701851198502"></p><h3 id="Link导航组件"><a href="#Link导航组件" class="headerlink" title="Link导航组件"></a>Link导航组件</h3><p>Link组件可以使用页面跳转c</p><p>创建c页面：src&#x2F;app&#x2F;c&#x2F;page.tsx </p><pre><code class="jsx">import React from &#39;react&#39;import Link from &#39;next/link&#39;const page = () =&gt; &#123;  return (    &lt;div&gt;      c组件&lt;br /&gt;      &lt;Link className=&#39;text-blue-600&#39; href=&quot;/a&quot;&gt;去a组件&lt;/Link&gt;      &lt;/div&gt;  )&#125;export default page</code></pre><h3 id="usePathname"><a href="#usePathname" class="headerlink" title="usePathname"></a>usePathname</h3><p>这个hook可以获取路由地址</p><p>创建d页面：src&#x2F;app&#x2F;d&#x2F;page.tsx </p><pre><code class="jsx">&#39;use client&#39; //表示这个是一个客户端组件import React from &#39;react&#39;import &#123; usePathname &#125; from &#39;next/navigation&#39;const page = () =&gt; &#123;    const pathname = usePathname()    return (        &lt;div&gt;pathname: &#123;pathname&#125;&lt;/div&gt;    )&#125;export default page</code></pre><h3 id="useRouter"><a href="#useRouter" class="headerlink" title="useRouter"></a>useRouter</h3><p>这个hook可以实现编程式导航</p><p>创建e页面：src&#x2F;app&#x2F;d&#x2F;page.tsx </p><pre><code class="jsx">&#39;use client&#39;import React from &#39;react&#39;import &#123; useRouter &#125; from &#39;next/navigation&#39;const page = () =&gt; &#123;  const router = useRouter()  return (    &lt;div&gt;编程式导航：&lt;br /&gt;        &lt;button onClick=&#123;() =&gt; router.push(&#39;/d&#39;)&#125;&gt;跳转到d页面&lt;/button&gt;    &lt;/div&gt;  )&#125;export default page</code></pre><h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><p>路由组的命名除了对组织而言没有特殊意义。它们不影响URL路径。 </p><p>如下用括号进行分组，不会影响URL路径。</p><p><img src="/posts/b4b4770b/1701852815965.png" alt="1701852815965"></p><pre><code>http://localhost:3000/bookhttp://localhost:3000/userhttp://localhost:3000/adminhttp://localhost:3000/shop</code></pre><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>一般用于一些详情页面，比如商品详情、新闻详情等</p><p>创建product页面：src&#x2F;app&#x2F;product&#x2F;[id]&#x2F;page.tsx </p><pre><code class="jsx">import React from &#39;react&#39;const page = (&#123;params&#125;: &#123;params: &#123;id: number&#125;&#125;) =&gt; &#123;  return (    &lt;div&gt;product: &#123;params.id&#125;&lt;/div&gt;  )&#125;export default page</code></pre><p>访问：<a href="http://localhost:3000/product/123">http://localhost:3000/product/123</a></p><h3 id="loading组件"><a href="#loading组件" class="headerlink" title="loading组件"></a>loading组件</h3><p>用户展示loading效果</p><p>新增loading.tsx组件</p><pre><code class="jsx">import React from &#39;react&#39;import &#39;./style.css&#39;const loading = () =&gt; &#123;  return (    &lt;div className=&#39;text-red-500&#39;&gt;loading...&lt;/div&gt;  )&#125;export default loading</code></pre><p>新增layout.tsx布局</p><pre><code class="jsx">import &#123; Suspense &#125; from &#39;react&#39;import Loading from &#39;./loading&#39;export default function Layout(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123;    return (    &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;        &lt;div&gt;layoutE:&#123;children&#125;&lt;/div&gt;    &lt;/Suspense&gt;    )&#125;</code></pre><p>新增page.tsx布局</p><pre><code class="jsx">&#39;use client&#39;import React from &#39;react&#39;const page = async () =&gt; &#123;  const router = useRouter()  //模拟服务器请求数据渲染  await new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(&#39;服务器渲染ok&#39;)    &#125;, 2000);  &#125;)  return (    &lt;div&gt;我来了&lt;/div&gt;  )&#125;export default page</code></pre><p>参考：<a href="https://www.cnblogs.com/azoux/p/17289923.html">Next.js 13 如何使用loading.js</a></p><h3 id="error组件"><a href="#error组件" class="headerlink" title="error组件"></a>error组件</h3><p>创建一个和page.tsx同级的error.tsx</p><pre><code class="jsx">&#39;use client&#39; // Error components must be Client Components import &#123; useEffect &#125; from &#39;react&#39; export default function Error(&#123; error,reset&#125;: &#123;error: Error &amp; &#123; digest?: string &#125;,reset: () =&gt; void&#125;) &#123;      useEffect(() =&gt; &#123;    console.error(error)  &#125;, [error])   return (    &lt;div&gt;      &lt;h2&gt;Something went wrong!&lt;/h2&gt;      &lt;button        onClick=&#123;() =&gt; reset()&#125;      &gt;        Try again      &lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>page.tsx中抛出错误</p><pre><code class="jsx">&#39;use client&#39;import React from &#39;react&#39;const page = async () =&gt; &#123;  const router = useRouter()  //模拟服务器请求数据渲染  await new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      reject(&#39;服务器渲染error&#39;)    &#125;, 2000);  &#125;)  return (    &lt;div&gt;我来了&lt;/div&gt;  )&#125;export default page</code></pre><h3 id="404组件"><a href="#404组件" class="headerlink" title="404组件"></a>404组件</h3><p>app&#x2F;not-found.tsx ,当页面找不到的时候就会展示这个组件。(<strong>名字固定</strong>)</p><pre><code class="jsx">export default function NotFound() &#123;  return (    &lt;div&gt;      &lt;h2&gt;Not Found&lt;/h2&gt;      &lt;p&gt;Could not find requested resource&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><p>特殊情况：当有动态路由时，那么上面的not-found组件无效，需要使用[…not_found]</p><p>app&#x2F;[lang]&#x2F;[…not_found]&#x2F;page.tsx    </p><pre><code class="jsx">export default function NotFound(props) &#123;    return (    &lt;div&gt;      &lt;h2&gt;Not Found&lt;/h2&gt;      &lt;p&gt;Could not find requested resource&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><p>参考：<a href="https://stackoverflow.com/questions/75302340/not-found-page-does-not-work-in-next-js-13">https://stackoverflow.com/questions/75302340/not-found-page-does-not-work-in-next-js-13</a></p><h3 id="并行路由"><a href="#并行路由" class="headerlink" title="并行路由"></a>并行路由</h3><p>并行路由允许在同一布局中同时或有条件地呈现一个或多个页面。对于应用程序的高度动态部分，并行路由可用于实现复杂的路由模式。 </p><blockquote><p>1.并行路由是使用命名文件夹创建的。文件夹名是用 <strong>@文件名</strong> 约定定义的，并作为<code>props</code>传递给<strong>同一级别</strong>的布局。 </p><p>2.并行路由文件夹中也支持error.tsx和loading.tsx</p></blockquote><p>创建src&#x2F;app&#x2F;@analytics&#x2F;page.tsx页面</p><pre><code class="jsx">import React from &#39;react&#39;const page = () =&gt; &#123;  return (    &lt;&gt;analytics page&lt;/&gt;  )&#125;export default page</code></pre><p>创建src&#x2F;app&#x2F;@team&#x2F;page.tsx页面</p><pre><code class="jsx">import React from &#39;react&#39;const page = () =&gt; &#123;  return (    &lt;&gt;team page&lt;/&gt;  )&#125;export default page</code></pre><p>修改src&#x2F;app&#x2F;layout.tsx</p><pre><code class="jsx">import type &#123; Metadata &#125; from &#39;next&#39;import &#39;./globals.css&#39;import React from &#39;react&#39;export const metadata: Metadata = &#123;  title: &#39;Create Next App&#39;,  description: &#39;Generated by create next app&#39;,&#125;// export default function RootLayout(&#123;children&#125;: &#123;children: React.ReactNode&#125;) &#123;export default function RootLayout(props: &#123;  children: React.ReactNode,  team: React.ReactNode, //接受并行路由  analytics: React.ReactNode,//接受并行路由&#125;) &#123;  return (    &lt;html lang=&quot;en&quot;&gt;      &lt;body className=&quot;bg-slate-400&quot;&gt;        根布局：&#123;props.children&#125;        &lt;div className=&#39;text-blue-500&#39;&gt;team: &#123;props.team&#125;&lt;/div&gt;        &lt;div className=&#39;text-green-400&#39;&gt;analytics: &#123;props.analytics&#125;&lt;/div&gt;        &lt;/body&gt;    &lt;/html&gt;  )&#125;</code></pre><p>此时访问<a href="http://localhost:3000/%E5%8F%AF%E4%BB%A5%E5%B9%B6%E8%A1%8C%E8%B7%AF%E7%94%B1%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%80%8C%E8%AE%BF%E9%97%AE%E5%85%B6%E5%AE%83%E7%BA%A7%E5%88%AB%E6%AF%94%E5%A6%82http://localhost:3000/a%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B9%B6%E8%A1%8C%E8%B7%AF%E7%94%B1%E6%97%A0%E6%B3%95%E5%B1%95%E7%A4%BA%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%B9%B6%E8%A1%8C%E8%B7%AF%E7%94%B1%E4%BD%9C%E4%B8%BA%60props%60%E5%8F%AA%E4%BC%A0%E9%80%92%E7%BB%99**%E5%90%8C%E4%B8%80%E7%BA%A7%E5%88%AB**%E7%9A%84%E5%B8%83%E5%B1%80">http://localhost:3000/可以并行路由可以正常展示，而访问其它级别比如http://localhost:3000/a，那么并行路由无法展示，因为并行路由作为`props`只传递给**同一级别**的布局</a></p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件允许在请求完成之前运行代码。然后，根据传入的请求，可以通过重写、重定向、修改请求或响应头或直接响应来修改响应。 （类似拦截器）</p><blockquote><p>新建文件middleware.ts(或js,文件名固定)来定义中间件。与pages或app处于同一级别，或者在src内部。 </p></blockquote><p>比如下面定义的一个用于国际化的中间件</p><pre><code class="jsx">import &#123; NextResponse &#125; from &#39;next/server&#39; let locales = [&#39;en&#39;, &#39;zh&#39;] // Get the preferred locale, similar to above or using a libraryfunction getLocale(request) &#123;  //设置默认语言    return &#39;zh&#39;&#125; export function middleware(request) &#123;  const pathname = request.nextUrl.pathname  //判断不是/en 或者/zh开头  const pathnameIsMissingLocale = locales.every(    (locale) =&gt; !pathname.startsWith(`/$&#123;locale&#125;/`) &amp;&amp; pathname !== `/$&#123;locale&#125;`  )   // 如果不是/en 或者/zh开头 那么重定向到/zh或者/en  if (pathnameIsMissingLocale) &#123;    const locale = getLocale(request)    return NextResponse.redirect(      new URL(`/$&#123;locale&#125;/$&#123;pathname&#125;`, request.url)    )  &#125;&#125;//不需要拦截的路径export const config = &#123;  matcher: [    // Skip all internal paths (_next)    //&#39;/((?!_next).*)&#39;,    // Optional: only run on root (/) URL    // &#39;/&#39;    &#39;/((?!api|_next/static|_next/image|favicon.ico|resources).*)&#39;  ],&#125;</code></pre><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件有客户端组件(由浏览器渲染的组件)、服务端组件(由服务器渲染的组件)、内置组件</p><p>客户端组件和服务端组件需要自己编写，默认是服务端组件，内置组件由next提供。</p><h3 id="服务端组件"><a href="#服务端组件" class="headerlink" title="服务端组件"></a>服务端组件</h3><p>默认就是服务器组件，按照react组件的写法即可</p><h3 id="客户端组件"><a href="#客户端组件" class="headerlink" title="客户端组件"></a>客户端组件</h3><p>需要在组件的第一行加上<code>use client</code></p><h3 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h3><h4 id="Image组件"><a href="#Image组件" class="headerlink" title="Image组件"></a>Image组件</h4><p>用法和img标签类似，只不过做了性能优化</p><pre><code class="jsx">import Image from &#39;next/image&#39; export default function Page() &#123;  return (    &lt;Image      src=&quot;/profile.png&quot;      width=&#123;500&#125;      height=&#123;500&#125;      alt=&quot;Picture of the author&quot;    /&gt;  )&#125;</code></pre><p>Image组件可配置的属性如下：</p><table><thead><tr><th>Prop</th><th>Example</th><th>Type</th><th>Status</th></tr></thead><tbody><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#src"><code>src</code></a></td><td><code>src=&quot;/profile.png&quot;</code></td><td>String</td><td>Required</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#width"><code>width</code></a></td><td><code>width=&#123;500&#125;</code></td><td>Integer (px)</td><td>Required</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#height"><code>height</code></a></td><td><code>height=&#123;500&#125;</code></td><td>Integer (px)</td><td>Required</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#alt"><code>alt</code></a></td><td><code>alt=&quot;Picture of the author&quot;</code></td><td>String</td><td>Required</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#loader"><code>loader</code></a></td><td><code>loader=&#123;imageLoader&#125;</code></td><td>Function</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#fill"><code>fill</code></a></td><td><code>fill=&#123;true&#125;</code></td><td>Boolean</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#sizes"><code>sizes</code></a></td><td><code>sizes=&quot;(max-width: 768px) 100vw, 33vw&quot;</code></td><td>String</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#quality"><code>quality</code></a></td><td><code>quality=&#123;80&#125;</code></td><td>Integer (1-100)</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#priority"><code>priority</code></a></td><td><code>priority=&#123;true&#125;</code></td><td>Boolean</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#placeholder"><code>placeholder</code></a></td><td><code>placeholder=&quot;blur&quot;</code></td><td>String</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#style"><code>style</code></a></td><td><code>style=&#123;&#123;objectFit: "contain"&#125;&#125;</code></td><td>Object</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#onloadingcomplete"><code>onLoadingComplete</code></a></td><td><code>onLoadingComplete=&#123;img =&gt; done())&#125;</code></td><td>Function</td><td>Deprecated</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#onload"><code>onLoad</code></a></td><td><code>onLoad=&#123;event =&gt; done())&#125;</code></td><td>Function</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#onerror"><code>onError</code></a></td><td><code>onError(event =&gt; fail()&#125;</code></td><td>Function</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#loading"><code>loading</code></a></td><td><code>loading=&quot;lazy&quot;</code></td><td>String</td><td>-</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/components/image#blurdataurl"><code>blurDataURL</code></a></td><td><code>blurDataURL=&quot;data:image/jpeg...&quot;</code></td><td>String</td><td>-</td></tr></tbody></table><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>服务器渲染：在服务器上请求数据并渲染好组件</p><pre><code class="jsx">import React from &#39;react&#39;interface IUser &#123;    name: string,    age: number&#125;//1.请求数据的方法const getData = async () =&gt; &#123;    //模拟后端请求，这里也可以换成第三方的请求库，比如axios    const res: IUser = await new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve(&#123; name: &#39;tom&#39;, age: 18 &#125;)        &#125;, 1000);    &#125;)    console.log(&#39;getData res&#39;, res)    return res&#125;//2.使用async关键字标记组件export default async function page() &#123;    //3.请求数据并渲染组件    const data = await getData()    return (        &lt;div&gt;            &lt;div&gt;name: &#123;data.name&#125;&lt;/div&gt;            &lt;div&gt;age: &#123;data.age&#125;&lt;/div&gt;        &lt;/div&gt;    )&#125;</code></pre><p>客户端渲染：和react的写法一直，在useEffect中发送请求，渲染数组即可</p><h2 id="Metadata配置"><a href="#Metadata配置" class="headerlink" title="Metadata配置"></a>Metadata配置</h2><p>静态配置：直接写死</p><pre><code class="jsx">import type &#123; Metadata &#125; from &#39;next&#39; export const metadata: Metadata = &#123;  title: &#39;...&#39;,  description: &#39;...&#39;,&#125; export default function Page() &#123;&#125;</code></pre><p>动态配置：获取数据之后在配置</p><p> app&#x2F;[lang]&#x2F;news&#x2F;[id]&#x2F;page.tsx </p><pre><code class="jsx">import &#123;getData&#125; from &#39;@/api/news&#39;export async function generateMetadata(&#123; params &#125;) &#123;  const &#123; lang, id &#125; = params;  const res = await getData(id); //获取数据  let title = lang == &quot;zh&quot; ? &#39;中文标题&#39; : &#39;英文标题&#39;;  let description = lang == &quot;zh&quot; ? &#39;中文描述&#39; : &#39;英文描述&#39;;  return &#123;    title,    description,    keywords: title  &#125;;&#125;export default function Page() &#123;&#125;</code></pre><h2 id="相对路径的配置"><a href="#相对路径的配置" class="headerlink" title="@相对路径的配置"></a>@相对路径的配置</h2><p>tsconfig.json文件中paths对象中配置</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;paths&quot;: &#123;      &quot;@/api/*&quot;: [&quot;api/*&quot;],      &quot;@/components/*&quot;: [&quot;components/*&quot;],      &quot;@/lang/*&quot;: [&quot;lang/*&quot;],      &quot;@/lib/*&quot;: [&quot;lib/*&quot;],      &quot;@/styles/*&quot;: [&quot;styles/*&quot;],      &quot;@/utils/*&quot;: [&quot;utils/*&quot;]    &#125;  &#125;&#125;</code></pre><h2 id="sass的安装和使用"><a href="#sass的安装和使用" class="headerlink" title="sass的安装和使用"></a>sass的安装和使用</h2><p>安装</p><pre><code class="shell">npm install --save-dev sass</code></pre><p>style.scss</p><pre><code class="css">.g-container&#123;    background-color: deeppink;&#125;</code></pre><p>page.tsx</p><pre><code class="jsx">import React from &#39;react&#39;import &#39;./style.scss&#39;const page = () =&gt; &#123;  return (    &lt;div className=&#39;g-container&#39;&gt;page&lt;/div&gt;  )&#125;export default page</code></pre><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>第一步：安装cross-env</p><pre><code class="shell">npm install --save-dev cross-env</code></pre><p>第二步：新建三个环境文件</p><p>.env.development</p><pre><code>NODE_ENV = developmentNEXT_PUBLIC_API = https://dev.api.com</code></pre><p>.env.test</p><pre><code>NODE_ENV = testNEXT_PUBLIC_API = https://test.api.com</code></pre><p>.env.production</p><pre><code>NODE_ENV = productionNEXT_PUBLIC_API = https://production.api.com</code></pre><p>第三步：修改package.json文件中的script</p><pre><code class="json">&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;cross-env NODE_ENV=development next dev -p 3000&quot;,    &quot;build:stage&quot;: &quot;cross-env NODE_ENV=test next build&quot;,    &quot;build:prod&quot;: &quot;cross-env NODE_ENV=production next build &quot;,    &quot;start:stage&quot;: &quot;cross-env NODE_ENV=test next start -p 3000&quot;,    &quot;start:prod&quot;: &quot;cross-env NODE_ENV=production next start -p 3000&quot;  &#125;</code></pre><p>第四步：页面组件中使用</p><pre><code class="jsx">import React from &#39;react&#39;import &#39;./style.scss&#39;const page = () =&gt; &#123;  const api = process.env.NEXT_PUBLIC_API  return (    &lt;div className=&#39;g-container&#39;&gt;BASE——API: &#123;api&#125;&lt;/div&gt;  )&#125;export default page</code></pre><p>参考：<a href="https://www.yii666.com/blog/422369.html">NextJS 创建项目和环境变量配置</a></p><h2 id="全局状态管理"><a href="#全局状态管理" class="headerlink" title="全局状态管理"></a>全局状态管理</h2><p>在Next.js中，跨不同组件管理状态可能是一项具有挑战性的任务。因此，像ContextApi这样的全局状态管理工具可以帮助简化该过程。核心技术点：react的createContext和useContext<br>参考：<a href="http://news.sangniao.com/p/2516936941">用ContextApi在Next.js中进行全局状态管理</a></p><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>利用动态路由和路由中间件来实现</p><pre><code>中文：localhost:3000/zh/a英文：localhost:3000/en/a</code></pre><p>第一步：在src&#x2F;app目录中新建一个[lang]文件夹，以后所有的页面都放到[lang]文件夹中</p><p>第二步：新建两个国际化文件</p><p>src&#x2F;lang&#x2F;zh.json</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;姓名&quot;,    &quot;age&quot;: &quot;年龄&quot;&#125;</code></pre><p>src&#x2F;lang&#x2F;en.json</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;name&quot;,    &quot;age&quot;: &quot;age&quot;&#125;</code></pre><p>第三步：编写一个国际化方法</p><p>src&#x2F;utils&#x2F;locale.js</p><pre><code class="js">const en = require(&quot;@/lang/en.json&quot;);const zh = require(&quot;@/lang/zh.json&quot;);export const getDictionaryByStr = (locale) =&gt; &#123;  return (key) =&gt; getDeepDict(key, locale === &quot;zh&quot; ? zh : en);&#125;;function getDeepDict(str, value) &#123;  let keys = str?.split(&quot;.&quot;);  for (let key of keys) &#123;    if (value) &#123;      value = value[key];    &#125;  &#125;  return value;&#125;</code></pre><p>第四步：组件中使用</p><p>src&#x2F;[lang]&#x2F;a&#x2F;page.tsx</p><pre><code class="tsx">import React from &#39;react&#39;import &#123;getDictionaryByStr&#125; from &#39;@/utils/locale&#39;const page = (props: &#123;params:&#123;lang:string&#125;&#125;) =&gt; &#123;  const $t = getDictionaryByStr(props.params.lang)  return (    &lt;div&gt;        lang:&#123;props.params.lang&#125;        &lt;div&gt;name: &#123;$t(&#39;name&#39;)&#125;&lt;/div&gt;        &lt;div&gt;age: &#123;$t(&#39;age&#39;)&#125;&lt;/div&gt;    &lt;/div&gt;  )&#125;export default page</code></pre>]]></content>
    
    
    <summary type="html">nextjs是基于react语法来实现SSR(服务器渲染)的框架，能够解决单页应用不利于SEO的问题</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Nextjs" scheme="https://heliufang.github.io/tags/Nextjs/"/>
    
  </entry>
  
  <entry>
    <title>vue中window.open父子窗口通信</title>
    <link href="https://heliufang.github.io/posts/a35b4e10/"/>
    <id>https://heliufang.github.io/posts/a35b4e10/</id>
    <published>2023-11-16T01:57:28.000Z</published>
    <updated>2024-01-05T13:02:35.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js中window相关属性和方法"><a href="#js中window相关属性和方法" class="headerlink" title="js中window相关属性和方法"></a>js中window相关属性和方法</h2><p> window.opener  实际上是通过window.open()打开的窗体的父窗体 </p><p> window.close()    关闭window.open()打开的窗口 </p><h2 id="vue中window窗口通信"><a href="#vue中window窗口通信" class="headerlink" title="vue中window窗口通信"></a>vue中window窗口通信</h2><p>父窗口为a页面，子窗口为b页面</p><p>操作流程图如下：</p><p><img src="/posts/a35b4e10/1700099008976.png" alt="1700099008976"></p><ul><li>a页面</li></ul><pre><code class="html">&lt;template&gt;    &lt;div&gt;        a页面,我是父窗口        &lt;el-button type=&quot;primary&quot; @click=&quot;go&quot;&gt;打开子页面&lt;/el-button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;A&#39;,    data() &#123;        return &#123;                    &#125;;    &#125;,    mounted() &#123;        //给父窗口绑定一个数据        window.myData = &#123;name: &#39;jerry&#39;,age: 6&#125;        //给父窗口绑定一个方法        window.getChildData = (data) =&gt; &#123;            console.log(&#39;接受子窗口数据：&#39;, data)        &#125;    &#125;,    methods: &#123;        go()&#123;            window.open(&#39;http://localhost:81/zh/b&#39;, &quot;payWindow&quot;, &quot;toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=400, height=400&quot;);        &#125;    &#125;,&#125;;&lt;/script&gt;</code></pre><ul><li>b页面</li></ul><pre><code class="html">&lt;template&gt;    &lt;div&gt;        a页面,我是子窗口        &lt;el-button type=&quot;success&quot; @click=&quot;closeWin&quot;&gt;关闭窗口&lt;/el-button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;B&#39;,    data() &#123;        return &#123;                    &#125;;    &#125;,    mounted() &#123;        //获取父窗口的中数据        console.log(&#39;获取父窗口的中数据：&#39;, window.opener.myData)    &#125;,    methods: &#123;        closeWin()&#123;            //向父窗口发送数据            window.opener.getChildData(&#123;name: &#39;linda&#39;,age: 8&#125;) //window.opener代表父窗口对象             //关闭当前窗口            setTimeout(() =&gt; &#123;                window.close()            &#125;, 2000);                    &#125;    &#125;,&#125;;&lt;/script&gt;</code></pre><h2 id="设置子窗口居中"><a href="#设置子窗口居中" class="headerlink" title="设置子窗口居中"></a>设置子窗口居中</h2><ul><li>父窗口</li></ul><pre><code class="js">let win = window.open(&#39;http://localhost:81/zh/b?name=tom&amp;age=18&#39;, &quot;payWindow&quot;, `toolbar=yes, location=no, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=$&#123;width&#125;, height=$&#123;height&#125;`);//设置窗口居中let left = (screen.availWidth - width) / 2let top = (screen.availHeight - height) / 2win.moveTo(left, top);</code></pre><h2 id="子窗口获取父窗口路径参数"><a href="#子窗口获取父窗口路径参数" class="headerlink" title="子窗口获取父窗口路径参数"></a>子窗口获取父窗口路径参数</h2><ul><li>父窗口</li></ul><pre><code class="js">window.open(&#39;http://localhost:81/zh/b?name=tom&amp;age=18&#39;, &quot;payWindow&quot;, &quot;toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=400, height=400&quot;);</code></pre><ul><li>子窗口</li></ul><pre><code class="js">//接收路径参数const p = new URLSearchParams(window.location.search)console.log(&#39;b页面close&#39;,p.get(&#39;name&#39;),p.get(&#39;age&#39;))</code></pre><h2 id="相关文章参考"><a href="#相关文章参考" class="headerlink" title="相关文章参考"></a>相关文章参考</h2><p><a href="http://www.yuyanba.com/default.aspx/did204034">vue跨窗口通信之新窗口调用父窗口方法实例</a></p><p><a href="https://pythonjishu.com/hyxdrfpmyafkqte/">JavaScript window.open打开页面居中显示的示例代码</a></p><p><a href="https://wenku.csdn.net/answer/2d9d24e747a2482e80a617ee3756f5fc">window.open()获取get路径参数</a></p>]]></content>
    
    
    <summary type="html">vue中window.open父子窗口通信</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>java项目跨域问题解决</title>
    <link href="https://heliufang.github.io/posts/55a96b31/"/>
    <id>https://heliufang.github.io/posts/55a96b31/</id>
    <published>2023-10-25T03:10:28.000Z</published>
    <updated>2024-01-05T13:02:35.222Z</updated>
    
    <content type="html"><![CDATA[<p>后端一般用cors解决跨域问题,需要配置下面的内容</p><pre><code>1.允许任何域名使用,正式环境应该指定跨域访问的域名或ip2.允许任何头3.允许任何方法（post、get等）</code></pre><h2 id="ssm-x2F-jsp项目"><a href="#ssm-x2F-jsp项目" class="headerlink" title="ssm&#x2F;jsp项目"></a>ssm&#x2F;jsp项目</h2><p>通过编写一个过滤器【CorsFilter.java】以及配置【web.xml】来实现</p><pre><code class="java">public class CorsFilter implements Filter &#123;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST, GET, OPTIONS, DELETE&quot;);        //推荐允许任何头,否则可能跨域无法解决！！！        response.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot;*&quot;)        filterChain.doFilter(servletRequest, servletResponse);    &#125;&#125;</code></pre><p>配置web.xml</p><pre><code class="xml">  &lt;filter&gt;    &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt;    &lt;filter-class&gt;com.sale4gr.filter.CorsFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;</code></pre><h2 id="springboot项目"><a href="#springboot项目" class="headerlink" title="springboot项目"></a>springboot项目</h2><p>通过编写一个配置类【CorsConfig.java】来实现</p><pre><code class="java">import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Bean;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsConfig &#123;    /**            跨域问题的cors全局解决方案     */    private CorsConfiguration buildConfig() &#123;        CorsConfiguration corsConfiguration = new CorsConfiguration();        corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 1允许任何域名使用,正式环境应该指定跨域访问的域名或ip        corsConfiguration.addAllowedHeader(&quot;*&quot;); // 2允许任何头        corsConfiguration.addAllowedMethod(&quot;*&quot;); // 3允许任何方法（post、get等）        return corsConfiguration;    &#125;    @Bean    public CorsFilter corsFilter() &#123;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); // 4        return new CorsFilter(source);    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">ssm/servlet项目以及springboot项目跨域问题解决</summary>
    
    
    
    <category term="java" scheme="https://heliufang.github.io/categories/java/"/>
    
    
    <category term="跨域" scheme="https://heliufang.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>pm2的安装和常用命令</title>
    <link href="https://heliufang.github.io/posts/fb35de03/"/>
    <id>https://heliufang.github.io/posts/fb35de03/</id>
    <published>2023-09-04T01:48:28.000Z</published>
    <updated>2024-01-05T13:02:35.272Z</updated>
    
    <content type="html"><![CDATA[<p>在项目部署的时候，当linux终端关闭之后项目也停止了，所以需要pm2来解决这个问题</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装pm2工具</p><pre><code class="shell">npm install pm2 -g</code></pre><h2 id="配置软连接"><a href="#配置软连接" class="headerlink" title="配置软连接"></a>配置软连接</h2><p>windows环境默认已配好，linux环境需要配置。参考下面的文章配置</p><p><a href="https://www.cnblogs.com/mmzuo-798/p/11126773.html">linux下安装pm2,pm2: command not found</a></p><h2 id="基本命令-掌握"><a href="#基本命令-掌握" class="headerlink" title="基本命令(掌握)"></a>基本命令(掌握)</h2><p>用<code>npm</code>启动项目</p><pre><code class="shell">npm run start:prod #这种方式启动项目，当终端关闭之后项目也停止了，所以需要pm2来解决这个问题</code></pre><p>用<code>pm2</code>启动项目</p><pre><code class="shell">pm2 --name=&#39;tranalysis&#39; start npm -- run start:prod #这种方式启动项目，当终端关闭项目会在后台运行</code></pre><p>–name 参数内容可任意，只是方便后面查看</p><h3 id="pm2-list"><a href="#pm2-list" class="headerlink" title="pm2 list"></a>pm2 list</h3><p>查询正在运行的进程</p><pre><code class="shell">pm2 list</code></pre><p><img src="/posts/fb35de03/1697509989881.png" alt="1697509989881"></p><h3 id="pm2-stop"><a href="#pm2-stop" class="headerlink" title="pm2 stop"></a>pm2 stop</h3><p>停止正在运行的进程</p><pre><code class="shell">pm2 stop 0  #通过id停止pm2 stop tranalysis #通过name停止</code></pre><h3 id="pm2-start"><a href="#pm2-start" class="headerlink" title="pm2 start"></a>pm2 start</h3><p>启动正在运行的进程</p><pre><code class="shell">pm2 start 0  #通过id停止pm2 start tranalysis #通过name停止</code></pre><h3 id="pm2-delete"><a href="#pm2-delete" class="headerlink" title="pm2 delete"></a>pm2 delete</h3><pre><code class="shell">pm2 delete 0  #通过id删除pm2 delete tranalysis #通过name删除</code></pre>]]></content>
    
    
    <summary type="html">pm2的安装、配置、常用命令</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="pm2" scheme="https://heliufang.github.io/tags/pm2/"/>
    
  </entry>
  
  <entry>
    <title>前端网站分享功能的实现</title>
    <link href="https://heliufang.github.io/posts/e79a8d86/"/>
    <id>https://heliufang.github.io/posts/e79a8d86/</id>
    <published>2023-07-27T01:48:28.000Z</published>
    <updated>2024-01-05T13:02:35.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端网站分享功能的实现"><a href="#前端网站分享功能的实现" class="headerlink" title="前端网站分享功能的实现"></a>前端网站分享功能的实现</h2><p>分享功能，主要通过链接的形式实现,在新标签页打开链接填入分享的url和标题即可。<code>shareUrl</code>为分享的网址，<code>shareTitle</code>为分享的标题</p><p>分享到Twitter</p><pre><code>https://twitter.com/intent/tweet?url=shareUrl&amp;text=shareTitle</code></pre><p>分享到facebook</p><pre><code>http://www.facebook.com/sharer.php?u=shareUrl</code></pre><p>分享到微博</p><pre><code>https://service.weibo.com/share/share.php?url=shareUrl&amp;title=shareTitle</code></pre><p>分享到qq</p><pre><code>https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=shareUrl&amp;title=shareTitle</code></pre><p>分享到微信：通过生成二维码，用户扫码再分享</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/47223273/answer/3065991702?utm_id=0">分享到facebook、twitter、google、youtube、instagram的分享代码？</a></p>]]></content>
    
    
    <summary type="html">前端网站分享功能的实现思路，主要通过链接的形式</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="分享" scheme="https://heliufang.github.io/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>git提交代码注释规范</title>
    <link href="https://heliufang.github.io/posts/7d8cfe28/"/>
    <id>https://heliufang.github.io/posts/7d8cfe28/</id>
    <published>2023-06-25T13:20:28.000Z</published>
    <updated>2024-01-05T13:02:35.192Z</updated>
    
    <content type="html"><![CDATA[<p> 提交代码注释规范 </p><ul><li>feat: 新增feature</li><li>fix: 修复bug</li><li>perf: 优化相关，比如提升性能、体验</li><li>refactor: 代码重构、没有加新功能或者修复bug</li><li>test: 测试用例，包括单元测试、继承测试等</li><li>docs: 仅仅修改了文档，比如README、CHANGELOG、CONTRIBUTE等等</li><li>style: 仅仅修改了空格、格式所以进、变量名等等，不改变代码逻辑</li><li>chore: 改变构建流程、或者依赖库、工具等</li><li>revert: 回滚到上一个版本</li><li>merge: 代码合并同步</li></ul><p>小例子如下</p><p><img src="/posts/7d8cfe28/1696729267355.png" alt="1696729267355"></p><p>参考：<a href="https://www.cnblogs.com/Lcsxx/p/17040818.html">提交代码注释规范</a></p>]]></content>
    
    
    <summary type="html">git提交代码注释规范，提高代码提交的可读性</summary>
    
    
    
    <category term="git" scheme="https://heliufang.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://heliufang.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>angular笔记</title>
    <link href="https://heliufang.github.io/posts/2ea11abc/"/>
    <id>https://heliufang.github.io/posts/2ea11abc/</id>
    <published>2023-03-15T09:20:28.000Z</published>
    <updated>2024-01-12T13:46:14.026Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://angular.cn/docs">angluar中文文档</a></p><p>简书上写的很好的angular教程 — <a href="https://www.jianshu.com/p/018c0bedcdf2">学习angular可以看看，看完会掌握大部分！！！</a></p><h2 id="angular-cli-安装"><a href="#angular-cli-安装" class="headerlink" title="angular cli 安装"></a>angular cli 安装</h2><p>执行下面的命令</p><pre><code class="shell">npm install -g @angular/cli</code></pre><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>执行下面的命令, <code>angular-study</code>可以任意,表示的是项目名称</p><pre><code class="shell">ng new angular-study</code></pre><p>输入n，再输入n。(不共享数据,先不安装路由模块)</p><p>css编写这里选择less</p><pre><code class="shell">? Would you like to share pseudonymous usage data about this project with the Angular Teamat Google under Google&#39;s Privacy Policy at https://policies.google.com/privacy. For moredetails and how to change this setting, see https://angular.io/analytics. NoGlobal setting: disabledLocal setting: No local workspace configuration file.Effective status: disabled? Would you like to add Angular routing? No? Which stylesheet format would you like to use? Less   [ http://lesscss.org ]</code></pre><p>启动项目</p><pre><code class="shell">ng serve </code></pre><p>访问项目</p><pre><code>http://localhost:4200/</code></pre><h2 id="项目结构说明"><a href="#项目结构说明" class="headerlink" title="项目结构说明"></a>项目结构说明</h2><pre><code>src - app 根组件   - app.component.html  html模板   - app.component.less  css样式   - app.component.ts    ts写数据处理逻辑   - app.module.ts  app模块文件 - assets 静态资源目录 - index.html 主页 - main.ts 项目的入口文件 - styles.less 全局样式文件 - .editorconfig 环境配置(开发/测试/上线) - .gitignore git忽略文件 - angular.json  angular cli的配置相关 - tsconfig  ts编译器相关配置</code></pre><p>更多介绍可参考官网：<a href="https://angular.cn/guide/file-structure">工作区和项目文件结构</a></p><h3 id="app-component-ts"><a href="#app-component-ts" class="headerlink" title="app.component.ts"></a>app.component.ts</h3><p>主要用来定义根组件</p><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-root&#39;, //组件的唯一标识，当前是根组件  templateUrl: &#39;./app.component.html&#39;, //当前组件的html模板文件  styleUrls: [&#39;./app.component.less&#39;] //当前组件的样式文件&#125;)export class AppComponent &#123;  title = &#39;angular-study&#39;; //定义一个双向绑定的数据&#125;</code></pre><h3 id="app-module-ts"><a href="#app-module-ts" class="headerlink" title="app.module.ts"></a>app.module.ts</h3><p>Angular 应用是模块化的，它拥有自己的模块化系统，称作 NgModule。 一个 NgModule 就是一个容器，用于存放一些内聚的代码块，这些代码块专注于某个应用领域、某个工作流或一组紧密相关的功能。 它可以包含一些组件、服务提供商或其它代码文件，其作用域由包含它们的 NgModule 定义。 它还可以导入一些由其它模块中导出的功能，并导出一些指定的功能供其它 NgModule 使用。</p><pre><code class="js">/*这个文件是Angular 根模块，告诉Angular如何组装应用*///Angular核心模块import &#123; NgModule &#125; from &#39;@angular/core&#39;;//BrowserModule，浏览器解析的模块import &#123; BrowserModule &#125; from &#39;@angular/platform-browser&#39;;//根组件import &#123; AppComponent &#125; from &#39;./app.component&#39;;//NgModule装饰器, @NgModule接受一个元数据对象，告诉 Angular 如何编译和启动应用@NgModule(&#123;  declarations: [//配置当前项目运行的的组件    AppComponent  ],  imports: [//配置当前模块运行依赖的其他模块    BrowserModule  ],  providers: [],//项目所需要的服务  //指定应用的主视图（称为根组件） 通过引导根AppModule来启动应用  ，这里一般写的是根组件  bootstrap: [AppComponent] &#125;)export class AppModule &#123; &#125;</code></pre><h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><ul><li>在src&#x2F;view下面创建一个Hello组件(先创建view文件夹并且切换到这个文件夹)</li></ul><pre><code class="shell">D:\webcode\angular-study\src\view&gt; ng g component Hello --skip-import</code></pre><ul><li>修改src&#x2F;app&#x2F;app.module.ts</li></ul><pre><code class="js">import &#123; NgModule &#125; from &#39;@angular/core&#39;;import &#123; BrowserModule &#125; from &#39;@angular/platform-browser&#39;;//导入Hello组件import &#123; HelloComponent &#125; from &#39;../view/hello/hello.component&#39;;import &#123; AppComponent &#125; from &#39;./app.component&#39;;@NgModule(&#123;  declarations: [     AppComponent,    HelloComponent //注册Hello组件  ],  imports: [    BrowserModule  ],  providers: [],  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;</code></pre><ul><li>将src&#x2F;app&#x2F;app.component.html内容清空,并引入hello组件</li></ul><pre><code class="html">&lt;app-hello&gt;&lt;/app-hello&gt;</code></pre><p>然后就可以看到hello组件的内容展示了</p><h2 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h2><p>只需要定义类中的属性即可</p><pre><code class="js">export class HelloComponent &#123;  title = &#39;hello angular&#39; //定义双向绑定的数据变量&#125;</code></pre><h2 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h2><h3 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h3><pre><code class="html">&lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;</code></pre><h3 id="绑定html"><a href="#绑定html" class="headerlink" title="绑定html"></a>绑定html</h3><ul><li>定义数据</li></ul><pre><code class="js">export class HelloComponent &#123;  htmlStr = &#39;&lt;h2&gt;hello angular&lt;/h2&gt;&#39;&#125;</code></pre><ul><li>绑定</li></ul><pre><code class="html">&lt;div [innerHTML]=&quot;htmlStr&quot;&gt;&lt;/div&gt;</code></pre><h3 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h3><pre><code class="html">&lt;div [title]=&quot;title&quot; [id]=&quot;id&quot;&gt;绑定属性&lt;/div&gt;</code></pre><h3 id="数据循环-ngFor"><a href="#数据循环-ngFor" class="headerlink" title="数据循环 *ngFor"></a>数据循环 *ngFor</h3><ul><li>定义数据</li></ul><pre><code class="js">export class HelloComponent &#123;  userlist = [&#123;    username: &#39;张三&#39;,    age: 20  &#125;, &#123;    username: &#39;李四&#39;,    age: 21  &#125;,  &#123;    username: &#39;王五&#39;,    age: 40  &#125;]&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;ul&gt;    &lt;li *ngFor=&quot;let user of userlist&quot;&gt;&#123;&#123;user.username + '-' + user.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 带下标/绑定key --&gt;&lt;ul&gt;    &lt;li *ngFor=&quot;let user of userlist;let i = index&quot;&gt;&#123;&#123;i+":"+user.username + '-' + user.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="条件判断-ngIf"><a href="#条件判断-ngIf" class="headerlink" title="条件判断 *ngIf"></a>条件判断 *ngIf</h3><pre><code class="html">&lt;div *ngIf=&quot;gender == &#39;male&#39;&quot;&gt;男的&lt;/div&gt;&lt;div *ngIf=&quot;gender == &#39;famale&#39;&quot;&gt;女的&lt;/div&gt;</code></pre><h3 id="ngSwitch"><a href="#ngSwitch" class="headerlink" title="*ngSwitch"></a>*ngSwitch</h3><ul><li>定义数据</li></ul><pre><code class="js">export class HelloComponent &#123;  status = 2&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;ul [ngSwitch]=&quot;status&quot;&gt;    &lt;li *ngSwitchCase=&quot;1&quot;&gt;未开始&lt;/li&gt;    &lt;li *ngSwitchCase=&quot;2&quot;&gt;进行中&lt;/li&gt;    &lt;li *ngSwitchCase=&quot;3&quot;&gt;已完成&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="绑定click事件"><a href="#绑定click事件" class="headerlink" title="绑定click事件"></a>绑定click事件</h3><ul><li>定义方法</li></ul><pre><code class="js">export class HelloComponent &#123;  age = 18  setAge()&#123;    this.age = this.age + 1  &#125;  getAge()&#123;    return this.age  &#125;&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;h2&gt;当前age：&#123;&#123;getAge()&#125;&#125;&lt;/h2&gt;&lt;button (click)=&quot;setAge()&quot;&gt;age+1&lt;/button&gt;</code></pre><h3 id="input事件"><a href="#input事件" class="headerlink" title="input事件"></a>input事件</h3><ul><li>定义</li></ul><pre><code class="js">export class HelloComponent &#123;  msg = &#39;&#39;  keyUpFn(event:any)&#123;    // console.log(event.target.value)    this.msg = event.target.value  &#125;&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; (keyup)=&quot;keyUpFn($event)&quot;&gt;&lt;div&gt;输入的值为：&#123;&#123;msg&#125;&#125;&lt;/div&gt;</code></pre><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><ul><li>定义</li></ul><pre><code class="js">export class HelloComponent &#123;  text = &#39;&#39;&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;input type=&quot;text&quot; name=&quot;&quot; [(ngModel)]=&quot;text&quot;&gt;&lt;div&gt;双向绑定：&#123;&#123;text&#125;&#125;&lt;/div&gt;</code></pre><h3 id="ngStyle"><a href="#ngStyle" class="headerlink" title="[ngStyle]"></a>[ngStyle]</h3><ul><li>定义</li></ul><pre><code class="js">export class HelloComponent &#123;  textRed = &#39;red&#39;&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;div [style]=&quot;&#123;&#39;color&#39;:&#39;blue&#39;&#125;&quot;&gt;蓝色字体&lt;/div&gt;&lt;div [style]=&quot;&#123;&#39;color&#39;:textRed&#125;&quot;&gt;红色字体-变量&lt;/div&gt;</code></pre><h3 id="ngClass"><a href="#ngClass" class="headerlink" title="[ngClass]"></a>[ngClass]</h3><ul><li>定义样式</li></ul><pre><code class="css">.blueText&#123;    color: blue;&#125;.redText&#123;    color: red;&#125;</code></pre><ul><li>定义数据</li></ul><pre><code class="js">export class HelloComponent &#123;  isRed = true&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;div [ngClass]=&quot;&#123;blueText: true&#125;&quot;&gt;蓝色字体&lt;/div&gt;&lt;div [ngClass]=&quot;&#123;redText: isRed&#125;&quot;&gt;红色字体-变量&lt;/div&gt;</code></pre><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>类似vue中的过滤器</p><p><a href="https://angular.cn/guide/pipes">官方文档：Angular - 用管道转换数据</a></p><ul><li>定义</li></ul><pre><code class="js">export class HelloComponent &#123;  today = new Date()&#125;</code></pre><ul><li>使用</li></ul><pre><code class="html">&lt;div&gt;&#123;&#123;today |  date:'yyyy-MM-dd HH:mm:ss'&#125;&#125;&lt;/div&gt;</code></pre><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>服务是一个广义的概念，它包括应用所需的任何值、函数或特性。狭义的服务是一个明确定义了用途的类。它应该做一些具体的事，并做好。<br>Angular 把组件和服务区分开，以提高模块性和复用性。 通过把组件中和视图有关的功能与其他类型的处理分离开，你可以让组件类更加精简、高效。</p><blockquote><p>一个服务可以为多个组件使用</p></blockquote><blockquote><p>个人理解：类似Java中一个工具类</p></blockquote><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><pre><code class="shell">ng g service services/storage</code></pre><h3 id="编写服务"><a href="#编写服务" class="headerlink" title="编写服务"></a>编写服务</h3><p>src&#x2F;services&#x2F;storage.service.ts</p><pre><code class="js">import &#123; Injectable &#125; from &#39;@angular/core&#39;;@Injectable(&#123;  providedIn: &#39;root&#39;&#125;)export class StorageService &#123;  constructor() &#123; &#125;  private tlist = [    &#123; name: &#39;tom&#39;, age: 18&#125;,    &#123; name: &#39;jerry&#39;, age: 16&#125;  ]  getTlist()&#123;    return this.tlist;  &#125;  setTlist(tlist: [])&#123;    this.tlist = tlist  &#125;&#125;</code></pre><h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>src&#x2F;app&#x2F;app.module.ts</p><pre><code class="js">import &#123; NgModule &#125; from &#39;@angular/core&#39;;import &#123; BrowserModule &#125; from &#39;@angular/platform-browser&#39;;import &#123; HelloComponent &#125; from &#39;../view/hello/hello.component&#39;;import &#123; AppComponent &#125; from &#39;./app.component&#39;;import &#123; FormsModule &#125; from &#39;@angular/forms&#39;;  //导入自己写的服务import &#123;StorageService&#125; from &#39;../services/storage.service&#39;;@NgModule(&#123;  declarations: [     AppComponent,HelloComponent  ],  imports: [    BrowserModule,    FormsModule  ],  providers: [StorageService],//注册服务  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;</code></pre><h3 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h3><p>src&#x2F;view&#x2F;hello&#x2F;hello.component.ts</p><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;//导入服务import &#123;StorageService&#125; from &#39;../../services/storage.service&#39;@Component(&#123;  selector: &#39;app-hello&#39;,  templateUrl: &#39;./hello.component.html&#39;,  styleUrls: [&#39;./hello.component.less&#39;]&#125;)export class HelloComponent &#123;    //注入服务给构造函数参数  constructor(private storage : StorageService) &#123;    console.log(&#39;tlist&#39;, storage.getTlist()) //使用服务  &#125;&#125;</code></pre><h2 id="dom"><a href="#dom" class="headerlink" title="dom"></a>dom</h2><p>ngAfterViewInit() ： angular 中操作dom要在这个生命周期钩子函数中。有原生的获取和ViewChild注入方式来获取</p><ul><li>页面</li></ul><pre><code class="html">&lt;!-- 原生dom --&gt;&lt;div id=&quot;dom1&quot;&gt;dom1111&lt;/div&gt;&lt;!-- ViewChild方式获取dom --&gt;&lt;div #dom2&gt;dom2222&lt;/div&gt;</code></pre><ul><li>ts</li></ul><pre><code class="js">import &#123; Component,ViewChild &#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-hello&#39;,  templateUrl: &#39;./hello.component.html&#39;,  styleUrls: [&#39;./hello.component.less&#39;]&#125;)export class HelloComponent &#123;   //注入dom2  @ViewChild(&#39;dom2&#39;) dom2:any   //页面 初始化之后，可以在这个钩子中操作dom  ngAfterViewInit() &#123;    //1.原生方式操作dom    let dom1:any = document.getElementById(&#39;dom1&#39;)    dom1.style.color = &#39;red&#39;    //2.ViewChild注入的方式，获取dom通过nativeElement属性    this.dom2.nativeElement.style.color = &#39;green&#39;  &#125;&#125;</code></pre><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父组件给子组件传数据"><a href="#父组件给子组件传数据" class="headerlink" title="父组件给子组件传数据"></a>父组件给子组件传数据</h3><ul><li>父组件将变量传给子组件—&gt;通过<code>标签属性</code>的方式传递</li></ul><pre><code class="html">&lt;!-- 给子组件传递数据 --&gt;&lt;app-child [msg]=&quot;msg&quot;&gt;&lt;/app-child&gt;</code></pre><ul><li>子组件接收数据—&gt;通过<code>Input</code>注入</li></ul><pre><code class="js">import &#123; Component,Input &#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-child&#39;,  templateUrl: &#39;./child.component.html&#39;,  styleUrls: [&#39;./child.component.less&#39;]&#125;)export class ChildComponent &#123;  //接受父组件传过来的数据,通过Input注入fatherMsg变量  @Input(&#39;msg&#39;) fatherMsg: string = &#39;&#39;  ngOnInit()&#123;    console.log(&#39;fatherMsg&#39;, this.fatherMsg)  &#125;&#125;</code></pre><h3 id="子组件给父组件传数据"><a href="#子组件给父组件传数据" class="headerlink" title="子组件给父组件传数据"></a>子组件给父组件传数据</h3><ul><li>子组件html</li></ul><pre><code class="html">&lt;button (click)=&quot;sendMsgToFather()&quot;&gt;给父组件传数据&lt;/button&gt;</code></pre><ul><li>子组件ts</li></ul><pre><code class="js">import &#123; Component,Output,EventEmitter &#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-child&#39;,  templateUrl: &#39;./child.component.html&#39;,  styleUrls: [&#39;./child.component.less&#39;]&#125;)export class ChildComponent &#123;  //通过这个对象来触发父组件的方法(如果父组件有多个方法要传递，那么需要创建多个outer)  @Output() private outer = new EventEmitter&lt;string&gt;();  //点击后向父组件传数据  sendMsgToFather()&#123;    //通过emit触发父组件方法给父组件传递数据    this.outer.emit(&#39;我是 child 组件&#39;)  &#125;&#125;</code></pre><ul><li>父组件html</li></ul><pre><code class="html">&lt;app-child (outer)=&quot;reciveChild($event)&quot;&gt;&lt;/app-child&gt;</code></pre><ul><li>父组件ts</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-father&#39;,  templateUrl: &#39;./father.component.html&#39;,  styleUrls: [&#39;./father.component.less&#39;]&#125;)export class FatherComponent &#123;  childMsg = &#39;&#39;  //接收子组件发送来的数据  reciveChild(childMsg:string)&#123;    console.log(&#39;childMsg&#39;, childMsg)    this.childMsg = childMsg  &#125;&#125;</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>1、<strong>ngOnChanges()</strong><br>当 Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的 SimpleChanges 对象当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在 ngOnInit() 之前。<br>2、<strong>ngOnInit()</strong><br>在 Angular 第一次显示数据绑定和设置指令&#x2F;组件的输入属性之后，初始化指令&#x2F;组件。<br>在第一轮 ngOnChanges() 完成之后调用，只调用一次。<br>使用 ngOnInit() 有两个原因：</p><pre><code> &lt;1&gt;在构造函数之后马上执行复杂的初始化逻辑 &lt;2&gt;在 Angular 设置完输入属性之后，对该组件进行准备。 有经验的开发者会认同组件的构建应该很便宜和安全。</code></pre><p>3、<strong>ngDoCheck()</strong><br>检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。在每个 Angular 变更检测周期中调用，ngOnChanges() 和 ngOnInit() 之后<br>4、<strong>ngAfterContentInit()</strong><br>当把内容投影进组件之后调用。第一次 ngDoCheck() 之后调用，只调用一次。<br>5、<strong>ngAfterContentChecked()</strong><br>每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit() 和每次 ngDoCheck() 之后调用。<br>6、<strong>ngAfterViewInit()</strong><br>初始化完组件视图及其子视图之后调用。第 一次 ngAfterContentChecked() 之后调用，只调用一次。<br>7、<strong>ngAfterViewChecked()</strong><br>每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit()和每次 ngAfterContentChecked() 之后调用<br>8、<strong>ngOnDestroy()</strong><br>当 Angular 每次销毁指令&#x2F;组件之前调用并清扫。在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在 Angular 销毁指令&#x2F;组件之前调用</p><pre><code class="js">import &#123; Component,Input&#125; from &#39;@angular/core&#39;;@Component(&#123;  selector: &#39;app-lifecycle&#39;,  templateUrl: &#39;./lifecycle.component.html&#39;,  styleUrls: [&#39;./lifecycle.component.scss&#39;]&#125;)export class LifecycleComponent&#123;    @Input(&#39;title&#39;) title:string;    public msg:string=&#39;生命周期演示&#39;;    public userinfo:string=&#39;&#39;;    public oldUserinfo:string=&#39;&#39;;    constructor() &#123;       console.log(&#39;00构造函数执行了---除了使用简单的值对局部变量进行初始化之外，什么都不应该做&#39;)    &#125;    ngOnChanges() &#123;      console.log(&#39;01ngOnChages执行了---当被绑定的输入属性的值发生变化时调用(父子组件传值的时候会触发)&#39;);     &#125;    ngOnInit() &#123;        console.log(&#39;02ngOnInit执行了--- 请求数据一般放在这个里面&#39;);         &#125;    ngDoCheck() &#123;        //写一些自定义的操作        console.log(&#39;03ngDoCheck执行了---检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应&#39;);        if(this.userinfo!==this.oldUserinfo)&#123;            console.log(`你从$&#123;this.oldUserinfo&#125;改成$&#123;this.userinfo&#125;`);            this.oldUserinfo = this.userinfo;        &#125;else&#123;                        console.log(&quot;数据没有变化&quot;);                  &#125;    &#125;    ngAfterContentInit() &#123;        console.log(&#39;04ngAfterContentInit执行了---当把内容投影进组件之后调用&#39;);    &#125;    ngAfterContentChecked() &#123;        console.log(&#39;05ngAfterContentChecked执行了---每次完成被投影组件内容的变更检测之后调用&#39;);    &#125;    ngAfterViewInit(): void &#123;             console.log(&#39;06 ngAfterViewInit执行了----初始化完组件视图及其子视图之后调用（dom操作放在这个里面）&#39;);    &#125;    ngAfterViewChecked() &#123;        console.log(&#39;07ngAfterViewChecked执行了----每次做完组件视图和子视图的变更检测之后调用&#39;);    &#125;    ngOnDestroy() &#123;        console.log(&#39;08ngOnDestroy执行了····&#39;);    &#125;    //自定义方法    changeMsg()&#123;      this.msg=&quot;数据改变了&quot;;    &#125;&#125;</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>创建一个带路由的项目  angular-routing-study 为项目名称</p><pre><code class="shell">ng new angular-routing-study --routing --defaults</code></pre><p>创建四个组件</p><pre><code>ng g component home --skip-importng g component news --skip-importng g component newsdetails --skip-importng g component pagenotfind --skip-import</code></pre><h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><ul><li>app-routing.module.ts</li></ul><pre><code class="js">import &#123; NgModule &#125; from &#39;@angular/core&#39;;import &#123; RouterModule, Routes &#125; from &#39;@angular/router&#39;;//导入自定义的组件import &#123; HomeComponent &#125; from &#39;../views/home/home.component&#39; import &#123; NewsComponent &#125; from &#39;../views/news/news.component&#39; import &#123; PagenotfindComponent &#125; from &#39;../views/pagenotfind/pagenotfind.component&#39; //配置路由const routes: Routes = [  &#123;path: &#39;home&#39; , component: HomeComponent&#125;,  &#123;path: &#39;news&#39; , component: NewsComponent&#125;,  &#123;path: &#39;&#39; , redirectTo: &#39;/home&#39;,pathMatch: &#39;full&#39;&#125;, //&#39;&#39;表示默认重定向到home页面  &#123;path: &#39;**&#39;,component: PagenotfindComponent&#125; //通配符匹配,404]@NgModule(&#123;  imports: [RouterModule.forRoot(routes)],  exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125;</code></pre><ul><li>app.component.html</li></ul><pre><code class="html">&lt;!-- 路由跳转链接-routerLink属性  routerLinkActive设置路由激活后的按钮链接样式 --&gt;&lt;a class=&quot;menu-btn&quot; routerLink=&quot;/home&quot; routerLinkActive=&quot;active&quot;&gt;首页&lt;/a&gt;&lt;a class=&quot;menu-btn&quot; routerLink=&quot;/news&quot; routerLinkActive=&quot;active&quot;&gt;新闻&lt;/a&gt;&lt;!-- 路由匹配后展示的区域-router-outlet标签 --&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></pre><ul><li>app.component.css</li></ul><pre><code class="css">.active&#123;    color: deeppink;&#125;.menu-btn&#123;    width: 200px;    height: 60px;    padding: 10px;    margin-left: 6px;&#125;</code></pre><p>然后点击页面上的<code>首页</code>和<code>新闻</code>按钮就可以在<code>router-outlet</code>的区域进行的切换了</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>和vue中的类似,也就是传递和接收params参数</p><ul><li>app-routing.module.ts  在Routes数组中新增一条路由规则</li></ul><pre><code class="js">const routes: Routes = [    //新增下面这条路由规则  :id表示传递的参数名为id,也可以是其它的  &#123;path: &#39;newDetails/:id&#39; , component: NewsdetailsComponent&#125;]</code></pre><ul><li>app.component.html 新增一个跳转的按钮</li></ul><pre><code class="html">&lt;a class=&quot;menu-btn&quot; routerLink=&quot;/newDetails/1&quot;&gt;新闻详情1，传递的参数为1&lt;/a&gt;&lt;a class=&quot;menu-btn&quot; [routerLink]=&quot;[&#39;/newDetails&#39;,2]&quot; &gt;新闻详情2，传递的参数为2&lt;/a&gt;</code></pre><ul><li>newsdetails.component.ts</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;//1.导入ActivatedRouteimport &#123; ActivatedRoute &#125; from &#39;@angular/router&#39;;@Component(&#123;  selector: &#39;app-newsdetails&#39;,  templateUrl: &#39;./newsdetails.component.html&#39;,  styleUrls: [&#39;./newsdetails.component.css&#39;]&#125;)export class NewsdetailsComponent &#123;  newsId = &#39;&#39;  //2.将ActivatedRoute注入给route  constructor(private route:ActivatedRoute)&#123; &#125;  ngOnInit()&#123;     console.log(this.route.params);     //3.获取params参数,并赋值给newsId    this.route.params.subscribe((data:any) =&gt; this.newsId = data.id)  &#125;&#125;</code></pre><ul><li>newsdetails.component.html  新闻详情页就可以接收到传递过来的params参数了</li></ul><pre><code class="html">&lt;p&gt;newsdetails works!,接受到参数新闻id：&#123;&#123;newsId&#125;&#125;&lt;/p&gt;</code></pre><h3 id="问号传参跳转"><a href="#问号传参跳转" class="headerlink" title="问号传参跳转"></a>问号传参跳转</h3><p>也就是在链接后面用问号的形式传递参数,跳转页面</p><ul><li>app.component.html修改新闻按钮，这样点击按钮就会以问号传参的形式跳转到新闻页面</li></ul><pre><code class="html">&lt;a class=&quot;menu-btn&quot; href=&quot;/news?name=tom&amp;age=18&quot;&gt;新闻(？传参)&lt;/a&gt;</code></pre><ul><li>news.component.ts  - 接收参数</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;import &#123; ActivatedRoute &#125; from &#39;@angular/router&#39;;@Component(&#123;  selector: &#39;app-news&#39;,  templateUrl: &#39;./news.component.html&#39;,  styleUrls: [&#39;./news.component.css&#39;]&#125;)export class NewsComponent &#123;  name = &#39;&#39;  age = &#39;&#39;  constructor(private router:ActivatedRoute)&#123;    //通过 this.router.queryParams 获取问号传递过来的参数    this.router.queryParams.subscribe(params =&gt; &#123;      console.log(&#39;?参数&#39;, params)      this.age = params[&#39;age&#39;]      this.name = params[&#39;name&#39;]    &#125;);  &#125;&#125;</code></pre><ul><li>news.component.html - 展示接收到的参数</li></ul><pre><code class="html">&lt;p&gt;news works! 接受到的queryParams参数:&#123;&#123;name+'-'+age&#125;&#125;&lt;/p&gt;</code></pre><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>其实就是通过js的形式跳转页面</p><h4 id="问号传参的编程式导航"><a href="#问号传参的编程式导航" class="headerlink" title="问号传参的编程式导航"></a>问号传参的编程式导航</h4><ul><li>app.component.html 新增一个新闻详情按钮</li></ul><pre><code class="html">&lt;button class=&quot;menu-btn&quot; (click)=&quot;goNews()&quot;&gt;新闻(？传参)&lt;/button&gt;</code></pre><ul><li>app.component.ts   通过js事件的形式跳转路由</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;//1.导入Router,NavigationExtrasimport &#123; Router,NavigationExtras &#125; from &#39;@angular/router&#39;;@Component(&#123;  selector: &#39;app-root&#39;,  templateUrl: &#39;./app.component.html&#39;,  styleUrls: [&#39;./app.component.css&#39;]&#125;)export class AppComponent &#123;  title = &#39;angular-routing-study&#39;;  //2.注入Router到router  constructor(private router:Router)&#123;&#125;  goNews()&#123;    //3.定义需要传递的问号参数    let navigationExtras:NavigationExtras = &#123;      queryParams: &#123; name: &#39;jerry&#39;,age: 19 &#125;    &#125;    //4.调用navigate跳转页面并传递参数    this.router.navigate([&#39;/news&#39;],navigationExtras)  &#125;&#125;</code></pre><ul><li>获取参数的方式和前面a标签跳转的方式一致</li></ul><h4 id="动态路由的编程式导航"><a href="#动态路由的编程式导航" class="headerlink" title="动态路由的编程式导航"></a>动态路由的编程式导航</h4><ul><li>app.component.html 新增一个新闻详情按钮</li></ul><pre><code class="html">&lt;button class=&quot;menu-btn&quot; (click)=&quot;goNewsDetails()&quot;&gt;新闻详情1&lt;/button&gt;</code></pre><ul><li>app.component.ts 通过js事件的形式跳转路由</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;//1.导入Routerimport &#123; Router &#125; from &#39;@angular/router&#39;;@Component(&#123;  selector: &#39;app-root&#39;,  templateUrl: &#39;./app.component.html&#39;,  styleUrls: [&#39;./app.component.css&#39;]&#125;)export class AppComponent &#123;  title = &#39;angular-routing-study&#39;;  //2.注入Router到router  constructor(private router:Router)&#123;&#125;  goNewsDetails()&#123;    //3.调用navigate方法携带参数跳转    this.router.navigate([&#39;/newDetails&#39;,1])  &#125;&#125;</code></pre><ul><li>获取参数的方式和前面a标签跳转的方式一致</li></ul><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>假设newsdetails是news的子页面</p><ul><li>app-routing.module.ts 修改news为嵌套路由</li></ul><pre><code class="js">const routes: Routes = [  &#123;       path: &#39;news&#39;,       component: NewsComponent,       //添加一个children节点,并配置      children: [          &#123; path: &#39;newDetails/:id&#39;, component: NewsdetailsComponent &#125;      ]   &#125;]</code></pre><ul><li>news.component.html 页面修改为如下</li></ul><pre><code class="html">&lt;p&gt;news works!&lt;/p&gt;&lt;ul&gt;    &lt;li&gt;&lt;a routerLink=&quot;/news/newDetails/1&quot;&gt;新闻1&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a routerLink=&quot;/news/newDetails/2&quot;&gt;新闻2&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a routerLink=&quot;/news/newDetails/3&quot;&gt;新闻3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 新闻详情展示的区域 --&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></pre><ul><li>newsdetails.component.ts 接收传递过来的路由参数</li></ul><pre><code class="js">import &#123; Component &#125; from &#39;@angular/core&#39;;import &#123; ActivatedRoute &#125; from &#39;@angular/router&#39;;@Component(&#123;  selector: &#39;app-newsdetails&#39;,  templateUrl: &#39;./newsdetails.component.html&#39;,  styleUrls: [&#39;./newsdetails.component.css&#39;]&#125;)export class NewsdetailsComponent &#123;  newsId = &#39;&#39;  constructor(private route:ActivatedRoute)&#123;&#125;  ngOnInit()&#123;     //获取传递来的新闻id并赋值给newsId    this.route.params.subscribe((data:any) =&gt; this.newsId = data.id)  &#125;&#125;</code></pre><ul><li>newsdetails.component.html  渲染传递来的参数</li></ul><pre><code class="html">&lt;p&gt;newsdetails works!,接受到参数新闻id：&#123;&#123;newsId&#125;&#125;&lt;/p&gt;</code></pre><ul><li>新增一个news.module.ts 文件</li></ul><pre><code class="js">import &#123; NgModule &#125; from &#39;@angular/core&#39;;import &#123; RouterModule &#125; from &#39;@angular/router&#39;import &#123; NewsComponent &#125; from &#39;./news.component&#39;;@NgModule(&#123;  declarations: [      //一定要声明这个，否则父组件中使用&lt;router-outlet&gt;标签将报错 ！！！      //https://stackoverflow.com/questions/44517737/router-outlet-is-not-a-known-element    NewsComponent   ],  imports: [   RouterModule  ],  exports: [RouterModule],&#125;)export class NewsModule &#123; &#125;</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是组织应用和使用外部库扩展应用的最佳途径。</p><h3 id="angular内置模块"><a href="#angular内置模块" class="headerlink" title="angular内置模块"></a>angular内置模块</h3><p>Angular 自己的库都是 NgModule，比如 <code>FormsModule</code>、<code>HttpClientModule</code> 和 <code>RouterModule</code>。很多第三方库也是 NgModule，比如 <a href="https://material.angular.cn/">Material Design</a>、 <a href="http://ionicframework.com/">Ionic</a> 和 <a href="https://github.com/angular/angularfire2">AngularFire2</a>。</p><h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>当项目非常庞大的时候把所有的组件都挂载到根模块里面不是特别合适。所以这个时候就可以自定义模块来组织的项目。并且通过 Angular 自定义模块可以实现路由的懒加载。</p><ul><li>在组件中创建模块</li></ul><pre><code class="shell">D:\webcode\angular-routing-study\src\views&gt;ng g module home    # home组件的模块D:\webcode\angular-routing-study\src\views&gt;ng g module newsdetails # newsdetails组件的模块D:\webcode\angular-routing-study\src\views&gt;ng g module pagenotfind # pagenotfind组件的模块</code></pre><ul><li>修改app-routing.module.ts中路由的配置如下</li></ul><pre><code class="js">const routes: Routes = [  //主要通过loadChildren回调函数的形式导入模块,实现懒加载  &#123; path: &#39;**&#39;, loadChildren: () =&gt; import(&#39;../views/pagenotfind/pagenotfind.module&#39;).then(m =&gt; m.PagenotfindModule) &#125; //通配符匹配,404]</code></pre>]]></content>
    
    
    <summary type="html">angular和angularjs是完全不同的两个框架！！！</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="angular" scheme="https://heliufang.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>原生js实现页面滚动到指定dom节点</title>
    <link href="https://heliufang.github.io/posts/97aee00c/"/>
    <id>https://heliufang.github.io/posts/97aee00c/</id>
    <published>2023-03-07T01:48:28.000Z</published>
    <updated>2024-01-05T13:02:35.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原生js实现页面滚动到指定dom节点"><a href="#原生js实现页面滚动到指定dom节点" class="headerlink" title="原生js实现页面滚动到指定dom节点"></a>原生js实现页面滚动到指定dom节点</h2><p>【案例】</p><pre><code class="html">&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;滚动到指定的div案例&lt;/title&gt;    &lt;style&gt;        .box &#123;            height: 1000px;            background-color: #bfa;            border: 1px solid #000;        &#125;        .myBox &#123;            margin-top: 500px;            height: 200px;            background-color: deepskyblue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;button id=&quot;gun&quot;&gt;滚&lt;/button&gt;        &lt;div class=&quot;myBox&quot;&gt;目标元素&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        function heightToTop(ele) &#123;            //ele为指定跳转到该位置的DOM节点            let bridge = ele;            let root = document.body;            let height = 0;            //关键点1：这里使用do while 累加偏移的高度            do &#123;                height += bridge.offsetTop;                bridge = bridge.offsetParent;            &#125; while (bridge !== root)            return height;        &#125;        //按钮点击时        let gunBtn = document.querySelector(&quot;#gun&quot;)        let targetEle = document.querySelector(&quot;.myBox&quot;)        gunBtn.addEventListener(&#39;click&#39;, function () &#123;            //关键点2：使用window的滚动方法            window.scrollTo(&#123;                top: heightToTop(targetEle),                behavior: &#39;smooth&#39;            &#125;)            // window.scrollTo(&#123;            //     top: 0,            //     behavior: &#39;smooth&#39;            // &#125;)        &#125;)            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/m0_46833693/article/details/123186078">JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解（含示例图）</a></p>]]></content>
    
    
    <summary type="html">原生js实现点击按钮，滚动到指定dom节点</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://heliufang.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>angularjs笔记</title>
    <link href="https://heliufang.github.io/posts/b3a0e706/"/>
    <id>https://heliufang.github.io/posts/b3a0e706/</id>
    <published>2023-02-20T10:05:31.000Z</published>
    <updated>2023-02-20T14:34:10.783Z</updated>
    
    <content type="html"><![CDATA[<p>B站教学视频：<a href="https://www.bilibili.com/video/BV1ts411E7qg">尚硅谷AngularJS实战教程(angular.js框架精讲)</a></p><p><a href="https://www.angularjs.net.cn/">AngularJS中文文档</a></p><p><a href="https://www.runoob.com/angularjs/angularjs-intro.html">菜鸟教程Angularjs文档(这个教程写的不错,可作为视频教程的补充)</a></p><p>涉及到的资料在这里,搬运来的链接，大家自取<br>链接: <a href="https://pan.baidu.com/s/180125RF0kI2wzpOMLrzC4A">https://pan.baidu.com/s/180125RF0kI2wzpOMLrzC4A</a> 提取码: pgt4 </p><h2 id="angular简介"><a href="#angular简介" class="headerlink" title="angular简介"></a>angular简介</h2><p>Google开源的 前端JS 结构化 框架</p><p>动态展示页面数据, 并与用户进行交互</p><p>AngularJS特性(优点)</p><ul><li>双向数据绑定</li><li>声明式依赖注入</li><li>解耦应用逻辑, 数据模型和视图</li><li>完善的页面指令</li><li>定制表单验证</li><li>Ajax封装</li></ul><h2 id="入门demo"><a href="#入门demo" class="headerlink" title="入门demo"></a>入门demo</h2><p>语法详解</p><pre><code>ng-app(指令) : 告诉angular核心它管理当前标签所包含的整个区域,并且会自动创建$rootScope根作用域对象ng-model : 将当前输入框的值与谁关联(属性名:属性值), 并作为当前作用域对象($rootScope)的属性&#123;&#123;&#125;&#125; (表达式) : 显示数据,从作用域对象的指定属性名上取  1、表达式：通常有一个返回值，可以放在任何需要值得地方，比如函数调用的参数，一个变量名，一个运算，  2、语句：通常表示一个完整的执行单位，一段完整的js可执行的代码，有的语句也可以用表达式来执行，叫做表达式语句。  3、区别：语句用封号结尾，有些语句我们没有加封号，比如console.log虽然我们没有加封号，但也是语句，因为js引擎会自动解析并且加上封号。  js引擎在解析的时候会自动的加上封号  4、特例：if语句，就不用加封号  可也是完整的语句。</code></pre><p>入门案例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;!-- 设置ng-app接管的区域 --&gt;&lt;body ng-app&gt;    &lt;!-- ng-model实现双向绑定 --&gt;    &lt;input type=&quot;text&quot; ng-model=&quot;username&quot;&gt;    &lt;div&gt;你输入的用户名为：&#123;&#123;username&#125;&#125;&lt;/div&gt;    &lt;script src=&quot;../js/angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>画图理解入门demo</p><p><img src="/posts/b3a0e706/image-20230220181855274.png" alt="image-20230220181855274"></p><p>安装 <code>ng-inspector.crx</code> - chrome扩展程序,如果crx文件装不上可以先改成zip文件,再来加载即可</p><p><a href="https://www.cnplugins.com/zhuanti/newinstall.html">https://www.cnplugins.com/zhuanti/newinstall.html</a></p><h2 id="四个重要概念"><a href="#四个重要概念" class="headerlink" title="四个重要概念"></a>四个重要概念</h2><ol><li><p>数据绑定: 数据从一个地方A转移(传递)到另一个地方B, 而且这个操作由框架来完成</p></li><li><p>双向数据绑定: 数据可以从View(视图层)流向Model（模型）, 也可以从Model流向View</p><pre><code>视图(View): 也就是我们的页面(主要是Andular指令和表达式)模型(Model) : 作用域对象(当前为$rootScope), 它可以包含一些属性或方法当改变View中的数据, Model对象的对应属性也会随之改变:  ng-model指令  数据从View==&gt;Model当Model域对象的属性发生改变时, 页面对应数据随之更新:  &#123;&#123;&#125;&#125;表达式  数据从Model==&gt;Viewng-model是双向数据绑定, 而&#123;&#123;&#125;&#125;是单向数据绑定</code></pre></li><li><p>ng-init  用来初始化当前作用域变量。(不常用)</p></li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body ng-app ng-init=&quot;name=&#39;tom&#39;&quot;&gt;    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;    &lt;div&gt;您输入的用户名为：&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;    &lt;div&gt;您输入的用户名为：&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;script src=&quot;../js/angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>画图说明双向绑定</p></blockquote><p><img src="/posts/b3a0e706/image-20230220183832537.png" alt="image-20230220183832537"></p><ol start="4"><li>依赖注入</li></ol><pre><code>依赖对象：完成某个特定的功能需要某个对象才能实现，这个对象就是依赖对象。依赖注入：依赖的对象以形参的形式被注入进来使用，这种方式就是依赖注入。angular的 ‘$scope’对象就是依赖对象，并且是依赖注入的形式进行使用。！！！形参必须是特定的名称, 否则Angular无法注入抛异常回调函数的event的就是依赖对象回调函数有形参就是依赖注入</code></pre><p>案例</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body ng-app&gt;&lt;div ng-controller=&quot;MyController&quot;&gt;  &lt;input type=&quot;text&quot; placeholder=&quot;姓&quot; ng-model=&quot;firstName&quot;&gt;  &lt;input type=&quot;text&quot; placeholder=&quot;名&quot; ng-model=&quot;lastName&quot;&gt;  &lt;p&gt;输入的姓名为: &#123;&#123;firstName+'-'+lastName&#125;&#125;&lt;/p&gt;  &lt;p&gt;输入的姓名2为: &#123;&#123;getName()&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;  &#123;&#123;firstName&#125;&#125; &lt;!--不能显示--&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/angular-1.2.29/angular.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;  //这种定义controller的方式了解即可,一般不会用这种方式定义controller  //必须是$scope, $scope就是依赖对象, 被angular动态注入的  function MyController ($scope) &#123;    $scope.firstName = &#39;KB&#39;;    $scope.lastName = &#39;Brent&#39;;    //给域对象指定方法    $scope.getName = function() &#123;      return $scope.firstName + &quot;  &quot; + $scope.lastName;    &#125;;    console.log($scope.age);    //声明式和命令式的区别    //1.命令式：命令程序执行的时候每一步都是按照自己的指令，更注重执行的过程    //2.声明式：更注重执行的结果。    //命令式    var arr = [1,2,3,4,5];    var newArr = [];    for(var i=0;i&lt;arr.length;i++)&#123;      var num = arr[i]*2;      newArr.push(num);    &#125;    console.log(newArr);    //声明式    var newArr2 = arr.map(function (item) &#123;      return item*2;    &#125;);    console.log(newArr2);    //命令式更注重的执行的过程    //声明式更注重的执行的结果    //声明式是对命令式的局部包装    //解答题与填空题的区别  &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    document.getElementById(&#39;btn&#39;).onclick = function(event) &#123;        alert(event.clientX);    &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="三个重要对象"><a href="#三个重要对象" class="headerlink" title="三个重要对象"></a>三个重要对象</h2><ol><li>作用域对象 :<br> 一个js实例对象, ng-app指令默认会创建一个根作用域对象(<code>$rootScope</code>)<br> 它的属性和方法与页面中的指令或表达式是关联的</li><li>控制器:<br> 用来控制AngularJS应用数据的 实例对象<br> <code>ng-controller</code> : 指定控制器构造函数, Angular会自动<code>new此函数创建控制器对象</code><br> 同时Angular还有创建一个<code>新的域对象$scope</code>, 它是<code>$rootScope的子对象</code><br> 在控制器函数中声明<code>$scope形参</code>, Angular会自动将$scope传入</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body ng-app&gt;    &lt;div ng-controller=&quot;MyController&quot;&gt;        姓：&lt;input type=&quot;text&quot; ng-model=&quot;firstname&quot;&gt;        名：&lt;input type=&quot;text&quot; ng-model=&quot;lastname&quot;&gt;        &lt;div&gt;输入的姓名为：&#123;&#123;firstname+"-"+lastname&#125;&#125;&lt;/div&gt;        &lt;div&gt;输入的姓名为(func)：&#123;&#123;firstname+"-"+lastname&#125;&#125;&lt;/div&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;!--不能显示--&gt;        &lt;!-- &#123;&#123;name&#125;&#125; --&gt;    &lt;/div&gt;    &lt;script src=&quot;../js/angular-1.2.29/angular.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        function MyController($scope)&#123;            //定义属性            $scope.firstname = &#39;&#39;            $scope.lastname = &#39;&#39;            //定义方法            $scope.getName = function()&#123;                return $scope.firstname+&#39;-&#39;+$scope.lastname            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="3"><li>模块</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body ng-app=&quot;MyApp&quot;&gt;    &lt;div ng-controller=&quot;myctrl1&quot;&gt;        &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;        &lt;div&gt;当前输入的用户名为：&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;/div&gt;    &lt;div ng-controller=&quot;myctrl2&quot;&gt;        &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;        &lt;div&gt;当前输入的用户名为：&#123;&#123;name&#125;&#125;&lt;/div&gt;    &lt;/div&gt;    &lt;script src=&quot;../js/angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        //得到modul对象        // var module = angular.module(&#39;MyApp&#39;,[])        // //通过module注册controller,多个controller之间互相不影响        // module.controller(&#39;myctrl1&#39;,function($scope)&#123;        //     $scope.name = &#39;&#39;        // &#125;)        // module.controller(&#39;myctrl2&#39;,function($scope)&#123;        //     $scope.name = &#39;&#39;        // &#125;)        //改进写法 使用链式调用  【记住这种就好】        //解决问题1：形参只能写固定的变量名$scope;        //解决问题2：一旦文件压缩，将不能使用，会报错。        angular.module(&#39;MyApp&#39;,[])        .controller(&#39;myctrl1&#39;,[&#39;$scope&#39;,function(a)&#123;            a.name = &#39;myctrl1&#39;        &#125;])        .controller(&#39;myctrl2&#39;,[&#39;$scope&#39;,function(b)&#123;            b.name = &#39;myctrl2&#39;        &#125;])     &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="二个页面语法"><a href="#二个页面语法" class="headerlink" title="二个页面语法"></a>二个页面语法</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ol><li>使用Angular表达式:<br>语法: <br>作用: 显示表达式的结果数据<br>注意: 表达式中引用的变量必须是<strong style="color:red">当前域对象</strong>有的属性(包括其原型属性)</li><li>操作的数据<br>基本类型数据: number&#x2F;string&#x2F;boolean<br>undefined, Infinity, NaN, null解析为空串: “”, 不显示任何效果<br>对象的属性或方法<br>数组</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body ng-app&gt;&lt;p&gt;&#123;&#123;1&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;'尚硅谷'&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;undefined&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;'atguigu'+3&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;4+3&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;true&#125;&#125;&lt;/p&gt;&lt;p ng-init=&quot;a=3;b=4&quot;&gt;&#123;&#123;a+b&#125;&#125;&lt;/p&gt;&lt;p ng-init=&quot;p=&#123;name:&#39;Tom&#39;,age:12&#125;;arr=[true, 3, &#39;atguigu&#39;]&quot;&gt;&#123;&#123;p.name&#125;&#125;---&#123;&#123;p.age&#125;&#125;----&#123;&#123;arr[2]&#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;script type=&#39;text/javascript&#39; src=&quot;../../js/angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="Angular指令"><a href="#Angular指令" class="headerlink" title="Angular指令"></a>Angular指令</h4><pre><code>Angular为HTML页面扩展的: 自定义标签属性或标签与Angular的作用域对象(scope)交互,扩展页面的动态表现力</code></pre><h4 id="常用指令-一"><a href="#常用指令-一" class="headerlink" title="常用指令(一)"></a>常用指令(一)</h4><pre><code>ng-app: 指定模块名，angular管理的区域ng-model： 双向绑定，输入相关标签ng-init： 初始化数据ng-click： 调用作用域对象的方法（点击时）ng-controller: 指定控制器构造函数名，内部会自动创建一个新的子作用域（外部的）ng-bind： 解决使用&#123;&#123;&#125;&#125;显示数据闪屏（在很短时间内显示&#123;&#123;&#125;&#125;）ng-repeat： 遍历数组显示数据， 数组有几个元素就会产生几个新的作用域($index,$first, $last, $middle, $odd, $even)ng-show: 布尔类型， 如果为true才显示ng-hide: 布尔类型， 如果为true就隐藏</code></pre><p>【常用指令(一).html】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; &gt;&lt;div ng-controller=&quot;MyCtrl&quot; ng-init=&quot;age=12&quot;&gt;    &lt;div&gt;        &lt;h2&gt;价格计算器(自动)&lt;/h2&gt;        数量：&lt;input type=&quot;number&quot; ng-model=&quot;count1&quot;&gt;        价格：&lt;input type=&quot;number&quot; ng-model=&quot;price1&quot;&gt;        &lt;p&gt;总计：&#123;&#123;count1 * price1&#125;&#125;&lt;/p&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;h2&gt;价格计算器(手动)&lt;/h2&gt;        数量：&lt;input type=&quot;number&quot; ng-model=&quot;count2&quot;&gt;        价格：&lt;input type=&quot;number&quot; ng-model=&quot;price2&quot;&gt;        &lt;button ng-click=&quot;getTotalPrice()&quot;&gt;计算&lt;/button&gt;        &lt;p&gt;总计：&#123;&#123;totalPrice&#125;&#125;&lt;/p&gt;    &lt;/div&gt;    &lt;!--    * ng-repeat： 遍历数组显示数据， 数组有几个元素就会产生几个新的作用域        * $index, $first, $last, $middle, $odd, $even    --&gt;    &lt;h3&gt;人员信息列表&lt;/h3&gt;    &lt;ul&gt;        &lt;li ng-repeat=&quot;person in persons&quot;&gt;偶数行：&#123;&#123;$even&#125;&#125;,奇数行&#123;&#123;$odd&#125;&#125;,中间的：&#123;&#123;$middle&#125;&#125;,最后一个：&#123;&#123;$last&#125;&#125;,第一个：&#123;&#123;$first&#125;&#125;,第&#123;&#123;$index + 1&#125;&#125;个，&#123;&#123;person.name&#125;&#125;----&#123;&#123;person.age&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;!--    * ng-bind： 解决使用&#123;&#123;&#125;&#125;显示数据闪屏（在很短时间内显示&#123;&#123;&#125;&#125;）    --&gt;    &lt;!--当使用ng-bind的时候表达式不在生效--&gt;    &lt;p ng-bind=&quot;count2&quot;&gt;&#123;&#123;'asdfdsfds'&#125;&#125;&lt;/p&gt;    &lt;p&gt;&#123;&#123;count2&#125;&#125;&lt;/p&gt;    &lt;!--      * ng-show: 布尔类型， 如果为true才显示      * ng-hide: 布尔类型， 如果为true就隐藏    --&gt;    &lt;!--&lt;button ng-click=&quot;switch()&quot;&gt;切换&lt;/button&gt;--&gt;    &lt;!--&lt;p ng-show=&quot;isLike&quot;&gt;我爱范冰冰&lt;/p&gt;--&gt;    &lt;!--&lt;p ng-hide=&quot;isLike&quot;&gt;范冰冰爱我&lt;/p&gt;--&gt;    &lt;button ng-click=&quot;switch()&quot;&gt;切换&lt;/button&gt;    &lt;p ng-show=&quot;isLike&quot;&gt;我喜欢贾静雯&lt;/p&gt;    &lt;p ng-hide=&quot;isLike&quot;&gt;贾静雯喜欢我&lt;/p&gt;&lt;/div&gt;&lt;script type=&#39;text/javascript&#39; src=&#39;../../js/angular-1.5.5/angular.js&#39;&gt;&lt;/script&gt;&lt;script type=&#39;text/javascript&#39;&gt;    //创建模块对象    angular.module(&#39;myApp&#39;, [])            .controller(&#39;MyCtrl&#39;, [&#39;$scope&#39;, function ($scope) &#123;                $scope.count1 = 1;                $scope.price1 = 20;                $scope.count2 = 1;                $scope.price2 = 10;                $scope.totalPrice = $scope.count1 * $scope.price1;                $scope.getTotalPrice = function () &#123;                    $scope.totalPrice =  this.count2 * this.count2;                &#125;;                $scope.persons = [                    &#123;name : &#39;kobe&#39;, age : 39&#125;,                    &#123;name : &#39;anverson&#39;, age : 41&#125;,                    &#123;name : &#39;weide&#39;, age : 38&#125;,                    &#123;name : &#39;tim&#39;, age : 40&#125;,                    &#123;name : &#39;curry&#39;, age : 29&#125;                ];                $scope.isLike = true;                $scope.switch = function () &#123;                    $scope.isLike = !$scope.isLike;                &#125;            &#125;])&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="常用指令-二"><a href="#常用指令-二" class="headerlink" title="常用指令(二)"></a>常用指令(二)</h4><pre><code> ng-class: 动态引用定义的样式  &#123;aClass:true, bClass:false&#125; ng-style: 动态引用通过js指定的样式对象   &#123;color:&#39;red&#39;,background:&#39;blue&#39;&#125; ng-click: 点击监听, 值为函数调用, 可以传$event ng-mouseenter: 鼠标移入监听, 值为函数调用, 可以传$event ng-mouseleave: 鼠标移出监听, 值为函数调用, 可以传$event</code></pre><p>【常用指令(二).html】</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;style&gt;  .evenB &#123;    background-color: grey;  &#125;  .oddB &#123;    background-color: green;  &#125;&lt;/style&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;MyController&quot;&gt;&lt;div style=&quot;width: 100px;height: 100px;background-color: red&quot;     ng-mouseover=&quot;over()&quot; ng-mouseleave=&quot;leave()&quot; ng-style=&quot;myStyle&quot;&gt;&lt;/div&gt;&lt;div&gt;  &lt;ul&gt;      &lt;li ng-repeat=&quot;p in persons&quot; ng-class=&quot;&#123;evenB:$even, oddB:$odd&#125;&quot;&gt;        &#123;&#123;p.name&#125;&#125;---&#123;&#123;p.age&#125;&#125;      &lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&#39;text/javascript&#39; src=&quot;../../js/angular-1.5.5/angular.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;  angular.module(&#39;myApp&#39;, [])      .controller(&#39;MyController&#39;, function ($scope) &#123;        $scope.over = function () &#123;          $scope.myStyle = &#123;            background: &#39;blue&#39;          &#125;;        &#125;;        $scope.leave = function () &#123;          $scope.myStyle = &#123;            background: &#39;green&#39;          &#125;;        &#125;;        $scope.persons = [          &#123;name: &#39;Tom&#39;, age: 12&#125;,          &#123;name: &#39;Tom2&#39;, age: 13&#125;,          &#123;name: &#39;Tom3&#39;, age: 14&#125;,          &#123;name: &#39;Tom4&#39;, age: 15&#125;,          &#123;name: &#39;Tom5&#39;, age: 16&#125;        ];      &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">Angularjs1.x简单入门笔记整理</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="angular" scheme="https://heliufang.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>js的防抖和节流</title>
    <link href="https://heliufang.github.io/posts/3c6138e1/"/>
    <id>https://heliufang.github.io/posts/3c6138e1/</id>
    <published>2023-02-12T02:09:09.000Z</published>
    <updated>2023-02-12T03:34:48.079Z</updated>
    
    <content type="html"><![CDATA[<p>B站视频教程: <a href="https://www.bilibili.com/video/BV1tG411J7dc">JS_防抖_节流</a></p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h3 id="搜索框带来的问题"><a href="#搜索框带来的问题" class="headerlink" title="搜索框带来的问题"></a>搜索框带来的问题</h3><p>需求：根据输入框内容来请求数据</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id=&quot;searchTxt&quot; type=&quot;search&quot; placeholder=&quot;请输入关键字检索&quot;&gt;    &lt;script&gt;        document.querySelector(&quot;#searchTxt&quot;).oninput = function()&#123;            console.log(&#39;发送请求，当前输入框值：&#39;,this.value)        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>上面的代码会带来一个问题：用户每输入一个关键字都会触发</p><p><img src="/posts/3c6138e1/image-20230212103615638.png" alt="image-20230212103615638"></p><p>现在是要求是用户停下来不输入的时候再<strong style="color:red">触发一次</strong>，这个时候就需要用到防抖函数了</p><h3 id="实现的思路"><a href="#实现的思路" class="headerlink" title="实现的思路"></a>实现的思路</h3><ol><li>事件函数执行,先<strong style="color:red">创建个定时器</strong></li><li>把<strong style="color:red">逻辑代码</strong>放到<strong style="color:red">定时器</strong>中</li><li>当函数再次触发，<strong style="color:red">清除定时器</strong></li><li>创建一个<strong style="color:red">新定时器</strong>即可</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id=&quot;searchTxt&quot; type=&quot;search&quot; placeholder=&quot;请输入关键字检索&quot;&gt;    &lt;script&gt;        let t = null        document.querySelector(&quot;#searchTxt&quot;).oninput = function()&#123;            clearTimeout(t) //有定时器则清除            t = setTimeout(() =&gt; &#123;                console.log(&#39;发送请求，当前输入框值：&#39;,this.value)            &#125;, 1000);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/posts/3c6138e1/image-20230212104119184.png" alt="image-20230212104119184"></p><h3 id="封装防抖函数"><a href="#封装防抖函数" class="headerlink" title="封装防抖函数"></a>封装防抖函数</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id=&quot;searchTxt&quot; type=&quot;search&quot; placeholder=&quot;请输入关键字检索&quot;&gt;    &lt;script&gt;        document.querySelector(&quot;#searchTxt&quot;).oninput = debounce(function()&#123;            console.log(&#39;发送请求，当前输入框值：&#39;,this.value)        &#125;)        //封装一个公共的防抖函数        function debounce(fn)&#123;//将函数逻辑放入fn中            let t = null //此处利用闭包保存定时器            return function()&#123;                clearTimeout(t) //有定时器则清除                t = setTimeout(() =&gt; &#123;                    //箭头函数指向外面函数的this,而外面函数由input触发                    fn.call(this) //利用call改变fn的this,否则fn的this为undefined                &#125;, 1000);            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="滚动条加载带来的问题"><a href="#滚动条加载带来的问题" class="headerlink" title="滚动条加载带来的问题"></a>滚动条加载带来的问题</h3><p>需求：页面滚动时,加载数据列表</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box&#123;            height: 1000px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        document.onscroll = function()&#123;            console.log(&#39;发送ajax,请求下一页数据&#39;)        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>上面的代码会带来一个问题：用户轻轻下拉滚动条,onscroll中的逻辑会触发很多次</p><p><img src="/posts/3c6138e1/image-20230212111058652.png" alt="image-20230212111058652"></p><p>现在是要求是<strong style="color:red">降低触发事件的频率</strong>,这个时候就需要用到节流函数了。</p><h3 id="实现的思路-1"><a href="#实现的思路-1" class="headerlink" title="实现的思路"></a>实现的思路</h3><ol><li>事件函数执行,先判断是否有定时器，有则直接<strong style="color:red">return</strong></li><li>把逻辑代码放到<strong style="color:red">定时器</strong>中</li><li>定时器执行后，<strong style="color:red">置空</strong>定时器变量</li></ol><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box&#123;            height: 1000px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;    &lt;script&gt;        let t = null        document.onscroll = function()&#123;            if(null != t) return //关键点1：有定时器则return            t = setTimeout(() =&gt; &#123;//关键点2：逻辑代码放到定时器中                console.log(&#39;发送ajax,请求下一页数据&#39;)                t = null  //关键点3：定时器执行完毕,置空定时器变量            &#125;, 500);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="封装节流函数"><a href="#封装节流函数" class="headerlink" title="封装节流函数"></a>封装节流函数</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .box&#123;            height: 1000px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;    &lt;script&gt;                document.onscroll = throttle(function () &#123;            console.log(&#39;发送ajax,请求下一页数据&#39;,this)        &#125;)        //封装一个节流函数        function throttle(fn) &#123;            return function()&#123;                //这里用的是fn.t变量的形式来保存定时器变量                if(null != fn.t) return                 fn.t = setTimeout(() =&gt; &#123;                    fn.call(this)                    fn.t = null                &#125;, 500);            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">防抖和节流技术总结</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="防抖" scheme="https://heliufang.github.io/tags/%E9%98%B2%E6%8A%96/"/>
    
    <category term="节流" scheme="https://heliufang.github.io/tags/%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>pinia笔记</title>
    <link href="https://heliufang.github.io/posts/1e33e6ff/"/>
    <id>https://heliufang.github.io/posts/1e33e6ff/</id>
    <published>2023-02-10T06:57:38.000Z</published>
    <updated>2023-02-10T09:06:48.971Z</updated>
    
    <content type="html"><![CDATA[<p>B站教学视频: <a href="https://www.bilibili.com/video/BV11Y411b7nb">抛弃 Vuex，使用 Pinia</a></p><p><a href="https://pinia.vuejs.org/zh/index.html">pinia官方中文文档</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Pinia <a href="https://github.com/vuejs/pinia/commit/06aeef54e2cad66696063c62829dac74e15fd19e">最初是在 2019 年 11 月左右重新设计使用</a> <a href="https://github.com/vuejs/composition-api">Composition API</a> 。</p><p>Pinia 是 Vue 的存储库，它允许您跨组件&#x2F;页面共享状态。类似vuex</p><blockquote><p>Vuex 3.x 是 Vuex 的 Vue 2 而 Vuex 4.x 是 Vue 3</p></blockquote><p>Pinia API 与 Vuex ≤4 有很大不同，即：</p><ul><li><em>mutations</em> 不再存在</li><li>无需创建自定义复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能利用 TS 类型推断。</li><li>不再需要注入、导入函数、调用函数、享受自动完成功能！</li><li>无需动态添加 Store，默认情况下它们都是动态的</li><li>不再有 <em>modules</em> 的嵌套结构</li><li>没有 <em>命名空间模块</em></li></ul><h2 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h2><ul><li>新建一个新的vite项目</li></ul><pre><code class="shell">yarn create vite</code></pre><p>按提示选择vue、typscript</p><ul><li>安装依赖</li></ul><pre><code class="shell">yarn</code></pre><ul><li>安装pinia</li></ul><pre><code class="shell">yarn add pinia</code></pre><h2 id="pinia基本使用"><a href="#pinia基本使用" class="headerlink" title="pinia基本使用"></a>pinia基本使用</h2><ul><li><code>src/main.ts</code>中创建pinia实例并且挂在vue实例上</li></ul><pre><code class="js">import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#123; createPinia &#125; from &#39;pinia&#39;//创建pinia实例const pinia = createPinia()const app = createApp(App)//挂载pinia实例app.use(pinia)app.mount(&#39;#app&#39;)</code></pre><ul><li><code>src/store/index.ts</code> 主要是定义容器</li></ul><pre><code class="js">import &#123; defineStore &#125; from &#39;pinia&#39;//定义容器export const useMainStore = defineStore(&#39;main&#39;,&#123;    /**   * 类似与组件的data， 用来存储全局状态   * 1.必须是函数：这样是为了在服务端渲染的时候避免交叉请求导致的数据状态污染（客户端其实无所谓）   * 2.必须是箭头函数：为了更好的ts类型推导   * 返回值：一个函数，调用该函数即可得到容器实例   */    state: () =&gt; (&#123;        count: 666,        name: &#39;tom&#39;,        arr: [1,2,3]    &#125;),    /**   * 类似于组件的computed，用来封装计算属性，有【缓存】功能   */    getters: &#123;    &#125;,    /**   * 完全类比于Vue2组件中的methods（可以直接用this)，用来【封装业务逻辑】，修改state   */    actions: &#123;    &#125;&#125;)</code></pre><ul><li><code>src/components/HelloWorld.vue</code></li></ul><pre><code class="html">&lt;template&gt;  &#123;&#123; mainStore.count &#125;&#125;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;//导入上面定义的storeimport &#123; useMainStore &#125; from &#39;../store&#39;//获取容器中的stateconst mainStore = useMainStore()//从store中取值console.log(mainStore.count)&lt;/script&gt;</code></pre><ul><li><code>src/App.vue</code>删除不必要的内容，保留HelloWorld组件</li></ul><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;import HelloWorld from &#39;./components/HelloWorld.vue&#39;&lt;/script&gt;&lt;template&gt;  &lt;HelloWorld /&gt;&lt;/template&gt;</code></pre><h2 id="解构访问pinia数据"><a href="#解构访问pinia数据" class="headerlink" title="解构访问pinia数据"></a>解构访问pinia数据</h2><p>不能直接使用解构,这样会丢失响应式,因为pinia在底层将state用reactive做了处理</p><p><code>src/components/HelloWorld.vue</code></p><pre><code class="html">&lt;template&gt;  &#123;&#123; count &#125;&#125;-&#123;&#123; name &#125;&#125;-&#123;&#123; arr &#125;&#125;  &lt;div&gt;&lt;button @click=&quot;addOne&quot;&gt;count+1&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useMainStore &#125; from &#39;../store&#39;import &#123; storeToRefs &#125; from &#39;pinia&#39; //获取容器中的stateconst mainStore = useMainStore()//修改容器中的stateconst addOne = () =&gt; &#123;  mainStore.count += 1&#125;//不能直接使用解构,这样会丢失响应式,因为pinia在底层将state用reactive做了处理// const &#123;count,name&#125; = mainStore//若想使用解构,则需要用storeToRefs将结构出的数据做ref响应式代理const &#123;count,name&#125; = storeToRefs(mainStore)&lt;/script&gt;</code></pre><h2 id="状态更新和Actions"><a href="#状态更新和Actions" class="headerlink" title="状态更新和Actions"></a>状态更新和Actions</h2><p>状态更新的四种方式</p><ul><li><code>src/components/HelloWorld.vue</code></li></ul><pre><code class="html">&lt;template&gt;  &#123;&#123; count &#125;&#125;-&#123;&#123; name &#125;&#125;-&#123;&#123; arr &#125;&#125;  &lt;div&gt;&lt;button @click=&quot;addOne&quot;&gt;count+1&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useMainStore &#125; from &#39;../store&#39;import &#123; storeToRefs &#125; from &#39;pinia&#39; //获取容器中的stateconst mainStore = useMainStore()//修改容器中的stateconst addOne = () =&gt; &#123;  //方式一：直接修改  //mainStore.count += 1  //方式二：使用 $patch(对象) 批量修改，建议使用，底层做了性能优化  // mainStore.$patch(&#123;  //   count: mainStore.count + 1,  //   name: &#39;jerry&#39;,  //   arr: [...mainStore.arr,4]  // &#125;)  //方式三：使用 $patch(回调函数)  【推荐】  //回调函数中的state参数，就是Store定义时里面的state!  // mainStore.$patch(state =&gt; &#123;  //   state.count ++  //   state.name = &#39;lucy&#39;  //   state.arr.push(5)  // &#125;)  // 方式四：逻辑较为复杂时，应封装到Store的actions中，并对外暴露接口  mainStore.addN(10)&#125;const &#123;count,name,arr&#125; = storeToRefs(mainStore)&lt;/script&gt;</code></pre><ul><li><code>src/store/index.ts</code></li></ul><pre><code class="js">import &#123; defineStore &#125; from &#39;pinia&#39;//定义容器export const useMainStore = defineStore(&#39;main&#39;,&#123;    state: () =&gt; (&#123;        count: 666,        name: &#39;tom&#39;,        arr: [1, 2, 3]    &#125;),    getters: &#123;    &#125;,    //注意：不能使用箭头函数定义actions！因为箭头函数绑定了外部this    actions: &#123;        addN(num: number)&#123;            //单个修改---&gt;直接使用this,类似vue2            // this.count += num            // this.name = &#39;linda&#39;            // this.arr.push(6)             //批量修改---&gt;建议使用patch做优化             this.$patch(state =&gt; &#123;                state.count += num                state.name = &#39;jack&#39;                state.arr.push(8)             &#125;)        &#125;    &#125;&#125;)</code></pre><h2 id="Getters的使用"><a href="#Getters的使用" class="headerlink" title="Getters的使用"></a>Getters的使用</h2><p>和计算属性类似,带有缓存功能</p><ul><li><code>src/components/HelloWorld.vue</code></li></ul><pre><code class="html">&lt;template&gt;  &#123;&#123; count &#125;&#125;-&#123;&#123; name &#125;&#125;-&#123;&#123; arr &#125;&#125;-&#123;&#123; count10 &#125;&#125;-&#123;&#123; count20 &#125;&#125;  &lt;div&gt;&lt;button @click=&quot;addOne&quot;&gt;count+1&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useMainStore &#125; from &#39;../store&#39;import &#123; storeToRefs &#125; from &#39;pinia&#39; //获取容器中的stateconst mainStore = useMainStore()//修改容器中的stateconst addOne = () =&gt; &#123;  mainStore.addN(10)&#125;const &#123;count,name,arr,count10,count20&#125; = storeToRefs(mainStore)&lt;/script&gt;</code></pre><ul><li><code>src/store/index.ts</code></li></ul><pre><code class="js">import &#123; defineStore &#125; from &#39;pinia&#39;//定义容器export const useMainStore = defineStore(&#39;main&#39;,&#123;    state: () =&gt; (&#123;        count: 666,        name: &#39;tom&#39;,        arr: [1, 2, 3]    &#125;),    //类似于组件的computed，用来封装计算属性，有【缓存】功能    getters: &#123;        //不带state参数：此时就不能对返回值类型做自动推导了，必须手动指定        count10(): number&#123;            console.log(&#39;count10&#39;)            return this.count + 10        &#125;,        //带state参数：对返回值类型做自动推导 【推荐这种】        count20(state)&#123;             return state.count + 20        &#125;    &#125;,    //注意：不能使用箭头函数定义actions！因为箭头函数绑定了外部this    actions: &#123;        addN(num: number)&#123;             this.$patch(state =&gt; &#123;                state.count += num                state.name = &#39;jack&#39;                state.arr.push(8)             &#125;)        &#125;    &#125;&#125;)</code></pre><h2 id="pinia和vue-devtools"><a href="#pinia和vue-devtools" class="headerlink" title="pinia和vue devtools"></a>pinia和vue devtools</h2><p>第一种查看方式</p><p><img src="/posts/1e33e6ff/image-20230210165300143.png" alt="image-20230210165300143"></p><p>第二种查看方式： 组件内部</p><p><img src="/posts/1e33e6ff/image-20230210165337467.png" alt="image-20230210165337467"></p>]]></content>
    
    
    <summary type="html">vue状态管理-pinia笔记整理</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
    <category term="pinia" scheme="https://heliufang.github.io/tags/pinia/"/>
    
  </entry>
  
  <entry>
    <title>react笔记</title>
    <link href="https://heliufang.github.io/posts/27fcdfc0/"/>
    <id>https://heliufang.github.io/posts/27fcdfc0/</id>
    <published>2022-12-30T09:15:28.000Z</published>
    <updated>2023-01-08T03:53:03.045Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1wy4y1D7JT">尚硅谷React教程（2022加更，B站超火react教程）</a></p><h2 id="react入门"><a href="#react入门" class="headerlink" title="react入门"></a>react入门</h2><p>React：用于构建用户界面的 JavaScript 库。由 <code>Facebook</code> 开发且开源。</p><p>原生 JavaScript 的痛点：</p><ul><li>操作 DOM 繁琐、效率低</li><li>使用 JavaScript 直接操作 DOM，浏览器进行大量重绘重排</li><li>原生 JavaScript 没有组件化编码方案，代码复用率低</li></ul><p>React 的特点：</p><ul><li>采用组件化模式、声明式编码，提高开发效率和组件复用率</li><li>在 <code>React Native</code> 中可用 React 语法进行移动端开发</li><li>使用虚拟 DOM 和 Diffing 算法，减少与真实 DOM 的交互</li></ul><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><ul><li><code>react.development.js</code> ：React 核心库</li><li><code>react-dom.development.js</code> ：提供 DOM 操作的 React 扩展库</li><li><code>babel.min.js</code> ：解析 JSX 语法，转换为 JS 代码</li></ul><pre><code class="html">&lt;!-- 引入react核心库 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入babel，用于将jsx转为js --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 准备容器 --&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;!-- 此处一定要写babel，表示写的不是 JS，而是 JSX，并且靠 babel 翻译 --&gt;&lt;script type=&quot;text/babel&quot;&gt;        // 创建虚拟dom        let VDOM = &lt;div&gt;Hello React&lt;/div&gt;        // 渲染        ReactDOM.render(VDOM,document.getElementById(&#39;app&#39;))&lt;/script&gt;</code></pre><h3 id="创建虚拟DOM的两种方式"><a href="#创建虚拟DOM的两种方式" class="headerlink" title="创建虚拟DOM的两种方式"></a>创建虚拟DOM的两种方式</h3><p>两种方式是：js和jsx</p><ul><li>使用 JS 创建虚拟 DOM 比 JSX 繁琐</li><li>JSX 可以让程序员更加简单地创建虚拟 DOM，相当于语法糖</li><li>最终 babel 会把 JSX 语法转换为 JS</li></ul><blockquote><p>开发中一般使用jsx的方式，也就是入门案例中使用的方式，会jsx就行</p></blockquote><p>第一种：使用js创建</p><pre><code class="jsx">//1.使用 React 提供的 API 创建虚拟DOMconst VDOM = React.createElement(&#39;h1&#39;, &#123; id: &#39;title&#39; &#125;, React.createElement(&#39;span&#39;, &#123;&#125;, &#39;Hello,React&#39;))//2.渲染虚拟DOM到页面ReactDOM.render(VDOM, document.getElementById(&#39;app&#39;))</code></pre><p>第二种：使用jsx创建(<strong style="color:red">掌握</strong>)  例子见入门案例</p><h3 id="虚拟DOM和真实DOM"><a href="#虚拟DOM和真实DOM" class="headerlink" title="虚拟DOM和真实DOM"></a>虚拟DOM和真实DOM</h3><p>关于虚拟 DOM：</p><ol><li>本质是 Object 类型的对象（一般对象）</li><li>虚拟 DOM 比较<strong style="color:red">“轻”</strong>，真实 DOM 比较<strong style="color:red">“重”</strong>，因为虚拟 DOM 是 React 内部在用，无需真实 DOM 上那么多的属性。</li><li>虚拟 DOM 最终会被 React 转化为真实 DOM，呈现在页面上。</li></ol><pre><code class="jsx">//如果VDOM如果有多行，可以用()包起来const VDOM = (    &lt;h1 id=&quot;title&quot;&gt;    &lt;span&gt;Hello,React&lt;/span&gt;    &lt;/h1&gt;)ReactDOM.render(VDOM, document.getElementById(&#39;app&#39;))const TDOM = document.getElementById(&#39;demo&#39;)console.log(&#39;虚拟DOM&#39;, VDOM)console.log(&#39;真实DOM&#39;, TDOM)</code></pre><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><ul><li>全称：JavaScript XML</li><li>React 定义的类似于 XML 的 JS 扩展语法；本质是 <code>React.createElement()</code> 方法的语法糖</li><li>作用：简化创建虚拟 DOM</li></ul><h4 id="JSX的语法规则"><a href="#JSX的语法规则" class="headerlink" title="JSX的语法规则"></a>JSX的语法规则</h4><ul><li>定义虚拟 DOM 时，不要写引号</li><li>标签中混入 JS 表达式需要使用 <code>&#123;&#125;</code></li><li>指定类名不用 <code>class</code>，使用 <code>className</code></li><li>内联样式，使用 <code>style=&#123; &#123; key: value &#125; &#125;</code> 的形式</li><li>只能有一个根标签</li><li>标签必须闭合，单标签结尾必须添加 <code>/</code>：<code>&lt;input type=&quot;text&quot; /&gt;</code></li><li>标签首字母小写，则把标签转换为 HTML 对应的标签，若没有，则报错</li><li>标签首字母大写，则渲染对应组件，若没有定义组件，则报错</li></ul><pre><code class="jsx">let title = &#39;HeLLOjSx&#39;let VDOM = (    &lt;div title=&#123;title.toUpperCase()&#125;&gt;    &lt;div className=&quot;info&quot;&gt;info&lt;/div&gt;&lt;div style=&#123;&#123;fontSize: '26px',color: 'red'&#125;&#125;&gt;style内联样式&lt;/div&gt;&lt;/div&gt;)ReactDOM.render(VDOM,document.getElementById(&quot;app&quot;))</code></pre><h4 id="js语句和表达式的区别"><a href="#js语句和表达式的区别" class="headerlink" title="js语句和表达式的区别"></a>js语句和表达式的区别</h4><ul><li>表达式：一个表达式会产生一个<code>值</code>，可以放在任何一个需要值的地方</li></ul><pre><code class="js">aa + bdemo(1)arr.map()function test() &#123;&#125;</code></pre><ul><li>语句(代码)：</li></ul><pre><code class="js">if()&#123;&#125;for()&#123;&#125;switch()&#123;case:xxxx&#125;</code></pre><pre><code class="jsx">let arr = [&#39;vue&#39;,&#39;react&#39;,&#39;angular&#39;]let VDOM = (    &lt;ul&gt;    &#123;        arr.map( v =&gt; &lt;li&gt;&#123;v&#125;&lt;/li&gt; )    &#125;      &lt;/ul&gt;)ReactDOM.render(VDOM,document.getElementById(&quot;app&quot;))</code></pre><h2 id="react面向组件编程"><a href="#react面向组件编程" class="headerlink" title="react面向组件编程"></a>react面向组件编程</h2><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>要点：</p><ul><li>组件名称<strong style="color:red">首字母必须大写</strong>，否则会解析成普通标签导致报错，详见 JSX 语法规则</li><li>函数需返回一个虚拟 DOM</li><li>渲染组件时需要使用标签形式，同时标签必须闭合</li></ul><p>渲染组件的过程：</p><ul><li>React 解析标签，寻找对应组件</li><li>发现组件是函数式组件，则调用函数，将返回的虚拟 DOM 转换为真实 DOM ，并渲染到页面中</li></ul><pre><code class="jsx">//1.创建函数式组件  function MyComponent() &#123;    console.log(this)//undefined    return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;  &#125;  //2.渲染组件到页面  ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&#39;app&#39;))</code></pre><blockquote><p>注意： 上面函数组件内部this 是 undefined，因为 babel 编译后开启了严格模式</p></blockquote><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>要点：</p><ul><li>使用class关键字来定义组件</li><li>使用extends来继承React.Component类</li><li>类中使用render方法来返回虚拟DOM</li></ul><p>组件渲染过程：</p><ul><li>React 解析组件标签，寻找组件</li><li>发现是类式组件，则 <code>new</code> 该类的实例对象，通过实例调用原型上的 <code>render</code> 方法</li><li>将 <code>render</code> 返回的虚拟 DOM 转为真实 DOM ，渲染到页面上·</li></ul><pre><code class="jsx">// 创建类式组件  class MyComponent extends React.Component &#123;    render() &#123;      console.log(&#39;render中的this：&#39;, this)      return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;/h2&gt;    &#125;  &#125;  ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(&#39;app&#39;))</code></pre><h3 id="组件实例的三大属性"><a href="#组件实例的三大属性" class="headerlink" title="组件实例的三大属性"></a>组件实例的三大属性</h3><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p><code>state</code> 是组件实例对象最重要的属性，值为对象。又称为状态机，通过更新组件的 <code>state</code> 来更新对应的页面显示。</p><p>要点：</p><ul><li>初始化 <code>state</code></li><li>React 中事件绑定</li><li><code>this</code> 指向问题</li><li><code>setState</code> 修改 <code>state</code> 状态</li><li><code>constructor</code> 、<code>render</code> 、自定义方法的调用次数</li></ul><pre><code class="jsx">class Sum extends React.Component&#123;    constructor(props)&#123;// 调用一次        super(props)        //初始化state        this.state = &#123;count: 0&#125;        //解决this为undefined问题,将原型上面的add方法改变this之后，挂在实例上        this.add = this.add.bind(this)         console.log(this)    &#125;    add()&#123;//这样写是挂在原型上        console.log(&quot;add&quot;,this)        //更新state的值        this.setState(&#123;            count: this.state.count + 1        &#125;)    &#125;    render()&#123;//调用 1+N次        return (            // 注意绑定事件的方式:a)驼峰 b)带上&#123;&#125;  onClick=&#123;this.add&#125;                &lt;div&gt;                    sum的值：&#123; this.state.count &#125;&lt;br/&gt;                    &lt;button onClick=&#123;this.add&#125;&gt;+1&lt;/button&gt;                                    &lt;/div&gt;           )    &#125;&#125;ReactDOM.render(&lt;Sum /&gt;,document.getElementById(&quot;app&quot;))</code></pre><p>简化版(<strong style="color:red">推荐</strong>)</p><pre><code class="jsx">class Sum extends React.Component&#123;    // = 表示直接挂在组件实例身上    state = &#123;count: 0&#125;    //采用箭头函数 + 赋值语句形式 this指向外面组件的this    add = () =&gt; &#123;         console.log(&quot;add&quot;,this) //this为组件实例        //更新state的值        this.setState(&#123;count: this.state.count + 1&#125;)    &#125;    render()&#123;//调用 1+N次        return (            &lt;div&gt;                sum的值：&#123; this.state.count &#125;&lt;br/&gt;                &lt;button onClick=&#123;this.add&#125;&gt;+1&lt;/button&gt;                            &lt;/div&gt;            )    &#125;&#125;ReactDOM.render(&lt;Sum /&gt;,document.getElementById(&quot;app&quot;))</code></pre><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>每个组件对象都有 <code>props</code> 属性，组件标签的属性都保存在 <code>props</code> 中。<code>props</code> 是<code>只读</code>的，不能修改。</p><h5 id="props的基本使用"><a href="#props的基本使用" class="headerlink" title="props的基本使用"></a>props的基本使用</h5><p>通过标签属性传值,会包装在组件的props属性上面。</p><pre><code class="jsx">class Person extends React.Component &#123;    render()&#123;        console.log(this.props)//&#123;name: &#39;青阳&#39;, age: 18, gender: &#39;男&#39;&#125;        const &#123;name , age, gender&#125; = this.props        return (            &lt;div&gt;                &lt;div&gt;name: &#123;name&#125;&lt;/div&gt;                &lt;div&gt;age:  &#123;age&#125;&lt;/div&gt;                &lt;div&gt;gender: &#123;gender&#125;&lt;/div&gt;            &lt;/div&gt;        )    &#125;&#125;// 类似于标签属性传值 注意：数值要用&#123;&#125;ReactDOM.render(&lt;Person name=&quot;青阳&quot; age=&#123;18&#125; gender=&quot;男&quot;/&gt;,document.getElementById(&#39;app&#39;))</code></pre><h5 id="批量传递props"><a href="#批量传递props" class="headerlink" title="批量传递props"></a>批量传递props</h5><pre><code class="jsx">class Person extends React.Component &#123;    render()&#123;        console.log(this.props)        const &#123;name , age, gender&#125; = this.props        return (            &lt;div&gt;                &lt;div&gt;name: &#123;name&#125;&lt;/div&gt;                &lt;div&gt;age:  &#123;age&#125;&lt;/div&gt;                &lt;div&gt;gender: &#123;gender&#125;&lt;/div&gt;            &lt;/div&gt;        )    &#125;&#125;const p = &#123;name: &#39;青阳&#39;,age: 19,gender: &#39;男&#39;&#125;//通过...批量传递propsReactDOM.render(&lt;Person &#123;...p&#125; /&gt;,document.getElementById(&#39;app&#39;))</code></pre><h5 id="props的类型限制"><a href="#props的类型限制" class="headerlink" title="props的类型限制"></a>props的类型限制</h5><p>在 <code>React 15.5</code> 以前，<code>React</code> 身上有一个 <code>PropTypes</code> 属性可直接使用，即 <code>name: React.PropTypes.string.isRequired</code> ，没有把 <code>PropTypes</code> 单独封装为一个模块。</p><p>从 <code>React 15.5</code> 开始，把 <code>PropTypes</code> 单独封装为一个模块，需要额外导入使用。</p><blockquote><p>了解即可,用的时候再看,老项目可能使用这种，最新一般使用ts来做类型校验.</p></blockquote><pre><code class="jsx">&lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;  class Person extends React.Component &#123;    render() &#123;      const &#123; name, age, sex &#125; = this.props      return (        &lt;ul&gt;          &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;          &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;          &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt;        &lt;/ul&gt;      )    &#125;  &#125;  // 类型和必要性限制  Person.propTypes = &#123;    name: PropTypes.string.isRequired,    sex: PropTypes.string,    age: PropTypes.number,    // 限制 speak 为函数    speak: PropTypes.func,  &#125;  // 指定默认值  Person.defaultProps = &#123;    sex: &#39;male&#39;,    age: 19,  &#125;  ReactDOM.render(&lt;Person name=&quot;Vue&quot; sex=&quot;male&quot; age=&#123;11&#125; speak=&#123;speak&#125; /&gt;, document.getElementById(&#39;test&#39;))  function speak() &#123;    console.log(&#39;speaking...&#39;)  &#125;&lt;/script&gt;</code></pre><p><code>Person.propTypes</code> 和 <code>Person.defaultProps</code> 可以看作在类身上添加属性，利用 <code>static</code> 关键词就能在类内部进行声明。因此所谓简写只是从类外部移到类内部。</p><pre><code class="jsx">&lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/prop-types.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt;  class Person extends React.Component &#123;    static propTypes = &#123;      name: PropTypes.string.isRequired,      sex: PropTypes.string,      age: PropTypes.number,      // 限制 speak 为函数      speak: PropTypes.func,    &#125;    static defaultProps = &#123;      sex: &#39;male&#39;,      age: 19,    &#125;    render() &#123;      const &#123; name, age, sex &#125; = this.props      return (        &lt;ul&gt;          &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;          &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;          &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt;        &lt;/ul&gt;      )    &#125;  &#125;  ReactDOM.render(&lt;Person name=&quot;Vue&quot; sex=&quot;male&quot; age=&#123;11&#125; speak=&#123;speak&#125; /&gt;, document.getElementById(&#39;test&#39;))  function speak() &#123;    console.log(&#39;speaking...&#39;)  &#125;&lt;/script&gt;</code></pre><h5 id="函数组件使用props"><a href="#函数组件使用props" class="headerlink" title="函数组件使用props"></a>函数组件使用props</h5><p>由于函数可以传递参数，因此函数式组件可以使用 <code>props</code> 。</p><pre><code class="jsx">function Person(props)&#123;    const &#123;name,age,gender&#125; = props    return &lt;div&gt;个人信息 name：&#123;name&#125; , age：&#123;age&#125; , gender：&#123;gender&#125;&lt;/div&gt;&#125;Person.propTypes = &#123;    age: PropTypes.number.required&#125;Person.defaultProps = &#123;    age: 10&#125;const p = &#123;name: &#39;tom&#39;,gender: &#39;男&#39;&#125;ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="类组件的构造器和props"><a href="#类组件的构造器和props" class="headerlink" title="类组件的构造器和props"></a>类组件的构造器和props</h5><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#constructor">官网文档说明</a>  构造函数一般用在两种情况：</p><ul><li>通过给 <code>this.state</code> 赋值对象来初始化内部 <code>state</code></li><li>为事件处理函数绑定实例</li></ul><pre><code class="jsx">constructor(props) &#123;  super(props)  // 初始化 state  this.state = &#123; isHot: true, wind: &#39;微风&#39; &#125;  // 解决 this 指向问题  this.changeWeather = this.changeWeather.bind(this)&#125;</code></pre><blockquote><p>因此构造器一般都不需要写。如果要在构造器内使用 <code>this.props</code> 才声明构造器，并且需要在最开始调用 <code>super(props)</code></p></blockquote><h4 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h4><p>Refs 提供了一种方式，允许我们<strong style="color:red">访问 DOM 节点</strong>或在 render 方法中创建的 React 元素。</p><h5 id="字符串形式的ref"><a href="#字符串形式的ref" class="headerlink" title="字符串形式的ref"></a>字符串形式的ref</h5><p>这种形式已过时，效率不高，<a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs">官方</a> 不建议使用。</p><pre><code class="jsx">class Demo extends React.Component&#123;    showInput = () =&gt; &#123;        //2.使用ref        const &#123; myRef &#125; = this.refs        console.log(myRef) //input标签dom        console.log(myRef.value) //input标签的值    &#125;    render()&#123;        return (           &lt;div&gt;            &#123;/*1.定义ref*/&#125;            &lt;input type=&quot;text&quot; ref=&quot;myRef&quot; /&gt;            &lt;button type=&quot;button&quot; onClick=&#123;this.showInput&#125;&gt;点击显示输入框内容&lt;/button&gt;        &lt;/div&gt;        )    &#125;&#125;  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="回调形式的ref"><a href="#回调形式的ref" class="headerlink" title="回调形式的ref"></a>回调形式的ref</h5><pre><code class="jsx">class Demo extends React.Component&#123;    showInput = () =&gt; &#123;        console.log(this.myInput.value);    &#125;    render()&#123;        return (            &lt;div&gt;              &#123;/*                  通过回调将input标签的dom 挂在实例的 myInput属性上                  由于是箭头函数，因此 `this` 是 `render` 函数里的 `this` ，即组件实例              */&#125;              &lt;input type=&quot;text&quot; ref=&#123;input =&gt; this.myInput = input&#125; /&gt;              &lt;button type=&quot;button&quot; onClick=&#123;this.showInput&#125;&gt;点击显示输入框内容&lt;/button&gt;            &lt;/div&gt;       )    &#125;&#125;  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="createRef形式的ref"><a href="#createRef形式的ref" class="headerlink" title="createRef形式的ref"></a>createRef形式的ref</h5><p>该方式通过调用 <code>React.createRef</code> 返回一个容器用于存储节点，且一个容器只能存储一个节点。</p><pre><code class="jsx">class Demo extends React.Component&#123;    //1.创建ref对象    myRef = React.createRef()    showInput = () =&gt; &#123;        //3.使用ref对象        console.log(this.myRef.current) //input dom对象        console.log(this.myRef.current.value);    &#125;    render()&#123;        return (            &lt;div&gt;                &#123;/* 2.绑定ref对象 */&#125;                &lt;input type=&quot;text&quot; ref=&#123;this.myRef&#125; /&gt;                &lt;button type=&quot;button&quot; onClick=&#123;this.showInput&#125;&gt;点击显示输入框内容&lt;/button&gt;            &lt;/div&gt;            )        &#125;&#125;  ReactDOM.render(&lt;Demo/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul><li>React 使用自定义事件，而非原生 DOM 事件，即 <code>onClick、onBlur</code> ：为了更好的兼容性</li><li>React 的事件通过事件委托方式进行处理：为了高效</li><li>通过 <code>event.target</code> 可获取触发事件的 DOM 元素：勿过度使用 <code>ref</code></li></ul><p>当触发事件的元素和需要操作的元素为同一个时，可以不使用 <code>ref</code> ：</p><pre><code class="jsx">class Demo extends React.Component &#123;  showData2 = (event) =&gt; &#123;    alert(event.target.value)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;input onBlur=&#123;this.showData2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot; /&gt;        &amp;nbsp;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h3><p>包含表单的组件分类：</p><ul><li>非受控组件：现用现取。即需要使用时，再获取节点得到数据</li><li>受控组件：类似于<code> Vue 双向绑定</code>的从视图层绑定到数据层</li></ul><p>尽量使用受控组件，因为非受控组件需要使用大量的 <code>ref</code> 。</p><h4 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h4><p>主要是通过ref来实现</p><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = (e) =&gt; &#123;        e.preventDefault();        const &#123;username,password&#125; = this        console.log(username.value,&quot;,&quot;,password.value);    &#125;    render()&#123;        return (            &lt;div&gt;                &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;                账号：&lt;input type=&quot;text&quot; ref=&#123;c =&gt; this.username = c&#125;/&gt;&lt;br/&gt;                    密码：&lt;input type=&quot;password&quot; ref=&#123;c =&gt; this.password = c&#125;/&gt;&lt;br/&gt;                        &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;                &lt;/form&gt;            &lt;/div&gt;            )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><h5 id="受控组件基础"><a href="#受控组件基础" class="headerlink" title="受控组件基础"></a>受控组件基础</h5><p>通过表单的onChange事件，当内容变化时，将数据更新到state中</p><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = e =&gt; &#123;        e.preventDefault();//阻止默认提交        const &#123;username,password&#125; = this.state        console.log(username,&quot;,&quot;,password);    &#125;    setUsername = e =&gt; &#123;        this.setState(&#123;username: e.target.value&#125;)    &#125;    setPassword = e =&gt; &#123;        this.setState(&#123;password: e.target.value&#125;)    &#125;    render()&#123;            return (                &lt;div&gt;                    &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;                    账号：&lt;input type=&quot;text&quot; onChange=&#123;this.setUsername&#125;/&gt;&lt;br/&gt;                        密码：&lt;input type=&quot;password&quot; onChange=&#123;this.setPassword&#125;/&gt;&lt;br/&gt;                            &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;                    &lt;/form&gt;                &lt;/div&gt;            )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><p>对上述受控组件的代码进行优化，希望把 <code>saveUsername</code> 和 <code>savePassword</code> 合并为一个函数。有如下两种方案。</p><ul><li>高阶函数：参数为函数或者返回一个函数的函数，如 <code>Promise、setTimeout、Array.map()</code></li><li>函数柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</li></ul><h5 id="受控组件柯里化"><a href="#受控组件柯里化" class="headerlink" title="受控组件柯里化"></a>受控组件柯里化</h5><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = (e) =&gt; &#123;        e.preventDefault();        const &#123;username,password&#125; = this.state        console.log(username,&quot;,&quot;,password);    &#125;    setFormData = name =&gt; &#123;        return e =&gt; &#123;//函数调用返回一个函数,多次接受参数统一处理            this.setState(&#123;[name]: e.target.value&#125;)        &#125;    &#125;    render()&#123;        return (            &lt;div&gt;            &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;            账号：&lt;input type=&quot;text&quot; onChange=&#123;this.setFormData(&#39;username&#39;)&#125;/&gt;&lt;br/&gt;            密码：&lt;input type=&quot;password&quot; onChange=&#123;this.setFormData(&#39;password&#39;)&#125;/&gt;&lt;br/&gt;            &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;            &lt;/form&gt;            &lt;/div&gt;            )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h5 id="受控组件不用柯里化"><a href="#受控组件不用柯里化" class="headerlink" title="受控组件不用柯里化"></a>受控组件不用柯里化</h5><p>和柯里化差不多,只不过是在onChange里面定义一个箭头函数来接受参数</p><pre><code class="jsx">class Login extends React.Component&#123;    handleSubmit = (e) =&gt; &#123;        e.preventDefault();        const &#123;username,password&#125; = this.state        console.log(username,&quot;,&quot;,password);    &#125;    setFormData = (e,name) =&gt; &#123;        this.setState(&#123;[name]: e.target.value&#125;)    &#125;    render()&#123;        return (         &lt;div&gt;            &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;         账号：&lt;input type=&quot;text&quot; onChange=&#123;e =&gt; this.setFormData(e,&#39;username&#39;) &#125;/&gt;             密码：&lt;input type=&quot;password&quot; onChange=&#123;e =&gt; this.setFormData(e,&#39;password&#39;) &#125;/&gt;              &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;            &lt;/form&gt;        &lt;/div&gt;        )    &#125;&#125;  ReactDOM.render(&lt;Login/&gt;,document.getElementById(&quot;app&quot;))</code></pre><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="生命周期-旧版"><a href="#生命周期-旧版" class="headerlink" title="生命周期-旧版"></a>生命周期-旧版</h4><p><strong>初始化阶段</strong>：<code>ReactDOM.render()</code> 触发的初次渲染</p><ul><li><code>constructor</code></li><li><code>componentWillMount</code></li><li><code>render</code></li><li><code>componentDidMount</code></li></ul><p><strong>更新阶段</strong></p><ol><li>父组件重新 <code>render</code> 触发的更新</li></ol><ul><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code> ：控制组件是否更新的阀门，返回值为布尔值，默认为 <code>true</code> 。若返回 <code>false</code> ，则后续流程不会进行。</li><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul><ol><li>组件内部调用 <code>this.setState()</code> 修改状态</li></ol><ul><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul><ol><li>组件内部调用 <code>this.forceUpdate()</code> 强制更新</li></ol><ul><li><code>componentWillUpdate</code></li><li><code>render</code></li><li><code>componentDidUpdate</code></li></ul><p><strong>卸载阶段</strong>：<code>ReactDOM.unmountComponentAtNode()</code> 触发</p><ul><li><code>componentWillUnmount</code></li></ul><p><img src="/posts/27fcdfc0/react-lifecyle-old.5c4592bd.png" alt="React Lifecycle"></p><h4 id="生命周期-新版"><a href="#生命周期-新版" class="headerlink" title="生命周期-新版"></a>生命周期-新版</h4><p><a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html">更改内容</a>：</p><ul><li>废弃三个钩子：<code>componentWillMount</code> 、<code>componentWillReceiveProps</code> 、 <code>componentWillUpdate</code> 。在新版本中这三个钩子需要加 <code>UNSAFE_</code> 前缀才能使用，后续可能会废弃。</li><li>新增两个钩子（实际场景用得很少）：<code>getDerivedStateFromProps</code> 、<code>getSnapshotBeforeUpdate</code></li></ul><p><img src="/posts/27fcdfc0/react-lifecycle-new.7009279b.png" alt="React LIfecycle New"></p><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops">static getDerivedStateFromProps(props, state)</a>：</p><ul><li>需使用 <code>static</code> 修饰</li><li>需返回一个对象更新 <code>state</code> 或返回 <code>null</code></li><li>适用于如下情况：<code>state</code> 的值任何时候都取决于 <code>props</code></li></ul><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate">getSnapshotBeforeUpdate(prevProps, prevState)</a>：</p><ul><li>在组件更新之前获取快照</li><li>得组件能在发生更改之前从 DOM 中捕获一些信息（如滚动位置）</li><li>返回值将作为参数传递给 <code>componentDidUpdate()</code></li></ul><pre><code class="jsx">static getDerivedStateFromProps(props,state)&#123;  console.log(&#39;getDerivedStateFromProps&#39;,props,state);  return null&#125;getSnapshotBeforeUpdate()&#123;  console.log(&#39;getSnapshotBeforeUpdate&#39;);  return &#39;atguigu&#39;&#125;componentDidUpdate(preProps,preState,snapshotValue)&#123;  console.log(&#39;componentDidUpdate&#39;,preProps,preState,snapshotValue);&#125;</code></pre><pre><code class="jsx">// getSnapshotBeforeUpdate 案例class NewsList extends React.Component &#123;  state = &#123; newsArr: [] &#125;  componentDidMount() &#123;    setInterval(() =&gt; &#123;      //获取原状态      const &#123; newsArr &#125; = this.state      //模拟一条新闻      const news = &#39;新闻&#39; + (newsArr.length + 1)      //更新状态      this.setState(&#123; newsArr: [news, ...newsArr] &#125;)    &#125;, 1000)  &#125;  getSnapshotBeforeUpdate() &#123;    return this.refs.list.scrollHeight  &#125;  componentDidUpdate(preProps, preState, height) &#123;    this.refs.list.scrollTop += this.refs.list.scrollHeight - height  &#125;  render() &#123;    return (      &lt;div className=&quot;list&quot; ref=&quot;list&quot;&gt;        &#123;this.state.newsArr.map((n, index) =&gt; &#123;          return (            &lt;div key=&#123;index&#125; className=&quot;news&quot;&gt;              &#123;n&#125;            &lt;/div&gt;          )        &#125;)&#125;      &lt;/div&gt;    )  &#125;&#125;ReactDOM.render(&lt;NewsList /&gt;, document.getElementById(&#39;test&#39;))</code></pre><h4 id="最重要的三个钩子"><a href="#最重要的三个钩子" class="headerlink" title="最重要的三个钩子"></a>最重要的三个钩子</h4><ul><li><code>render</code> ：初始化渲染和更新渲染</li><li><code>componentDidMount</code> ：进行初始化，如开启定时器、发送网络请求、订阅消息</li><li><code>componentWillUnmount</code> ：进行收尾，如关闭定时器、取消订阅消息</li></ul><h3 id="虚拟DOM和diff算法"><a href="#虚拟DOM和diff算法" class="headerlink" title="虚拟DOM和diff算法"></a>虚拟DOM和diff算法</h3><p><img src="/posts/27fcdfc0/Diff.ae9f4adc.png" alt="Diff"></p><p><strong><code>key</code> 的作用：</strong></p><p><code>key</code> 是虚拟 DOM 对象的标识，可提高页面更新渲染的效率。</p><p>当状态中的数据发生变化时，React 会根据新数据生成新的虚拟 DOM ，接着对新旧虚拟 DOM 进行 Diff 比较，规则如下：</p><ul><li>旧虚拟 DOM 找到和新虚拟 DOM 相同的 key：<ul><li>若内容没变，直接复用真实 DOM</li><li>若内容改变，则生成新的真实 DOM ，替换页面中之前的真实 DOM</li></ul></li><li>旧虚拟 DOM 未找到和新虚拟 DOM 相同的 key：根据数据创建新的真实 DOM ，渲染到页面</li></ul><p><strong>使用 <code>index</code> 作为 <code>key</code> 可能引发的问题：</strong></p><ul><li>若对数据进行逆序添加、逆序删除等破坏顺序的操作，会进行没有必要的真实 DOM 更新。界面效果没问题，但效率低下。</li><li>如果结构中包含输入类的 DOM（如 input 输入框） ，则会产生错误的 DOM 更新。</li><li>若不存在对数据逆序添加、逆序删除等破坏顺序的操作，则没有问题。</li></ul><pre><code class="jsx">// 使用 index 作为 key 引发的问题class Person extends React.Component &#123;  state = &#123;    persons: [      &#123; id: 1, name: &#39;小张&#39;, age: 18 &#125;,      &#123; id: 2, name: &#39;小李&#39;, age: 19 &#125;,    ],  &#125;  add = () =&gt; &#123;    const &#123; persons &#125; = this.state    const p = &#123; id: persons.length + 1, name: &#39;小王&#39;, age: 20 &#125;    this.setState(&#123; persons: [p, ...persons] &#125;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h2&gt;展示人员信息&lt;/h2&gt;        &lt;button onClick=&#123;this.add&#125;&gt;添加小王&lt;/button&gt;        &lt;h3&gt;使用index作为key&lt;/h3&gt;        &lt;ul&gt;          &#123;this.state.persons.map((personObj, index) =&gt; &#123;            return (              &lt;li key=&#123;index&#125;&gt;                &#123;personObj.name&#125;---&#123;personObj.age&#125;                &lt;input type=&quot;text&quot; /&gt;              &lt;/li&gt;            )          &#125;)&#125;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h2 id="react脚手架"><a href="#react脚手架" class="headerlink" title="react脚手架"></a>react脚手架</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ul><li>全局安装 React 脚手架：<code>npm i -g create-react-app</code></li><li>创建项目：<code>create-react-app 项目名称</code></li><li>进入文件夹：<code>cd 项目名称</code></li><li>启动项目：<code>npm start</code></li></ul><p>上述方式已经过时，改用下方命令。详见<a href="https://create-react-app.dev/docs/getting-started">官方说明</a>。</p><pre><code class="shell">npx create-react-app my-appcd my-appnpm start</code></pre><h3 id="项目结构说明"><a href="#项目结构说明" class="headerlink" title="项目结构说明"></a>项目结构说明</h3><p><code>public</code> ：静态资源文件</p><ul><li><code>manifest.json</code> ：应用加壳（把网页变成安卓&#x2F;IOS 软件）的配置文件</li><li><code>robots.txt</code> ：爬虫协议文件</li></ul><p><code>src</code> ：源码文件</p><ul><li><code>App.test.js</code> ：用于给 <code>App</code> 组件做测试，一般不用</li><li><strong style="color:red">index.js</strong> ：入口文件</li><li><code>reportWebVitals.js</code> ：页面性能分析文件，需要 <code>web-vitals</code> 库支持</li><li><code>setupTests.js</code> ：组件单元测试文件，需要 <code>jest-dom</code> 库支持</li></ul><p><img src="/posts/27fcdfc0/React-cli.5baa9e94.png" alt="React-cli structure"></p><p><code>index.html</code> 代码分析：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;!-- %PUBLIC_URL% 代表 public 文件夹的路径 --&gt;    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;    &lt;!-- 开启理想视口，用于做移动端网页的适配 --&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;    &lt;!-- 用于配置浏览器页签+地址栏的颜色(仅支持安卓手机浏览器) --&gt;    &lt;meta name=&quot;theme-color&quot; content=&quot;red&quot; /&gt;    &lt;!-- 网站描述 --&gt;    &lt;meta name=&quot;description&quot; content=&quot;Web site created using create-react-app&quot; /&gt;    &lt;!-- 用于指定网页添加到手机主屏幕后的图标 --&gt;    &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;    &lt;!-- 应用加壳时的配置文件 --&gt;    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;    &lt;title&gt;React App&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 若浏览器不支持 js 则展示标签中的内容 --&gt;    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>删除项目中不必要的文件，并且使用jsx文件来定义组件</p><p><img src="/posts/27fcdfc0/image-20220911172638523.png" alt="image-20220911172638523"></p><h3 id="TodoList-案例总结"><a href="#TodoList-案例总结" class="headerlink" title="TodoList 案例总结"></a>TodoList 案例总结</h3><ol><li>拆分组件、实现静态组件，注意：<code>className</code> 、<code>style</code> 的写法</li><li>动态初始化列表，如何确定将数据放在哪个组件的 <code>state</code> 中？</li></ol><ul><li>某个组件使用：放在其自身的 <code>state</code> 中</li><li>某些组件使用：放在他们共同的父组件 <code>state</code> 中，即<strong>状态提升</strong></li></ul><ol><li>关于父子之间通信：</li></ol><ul><li>父传子：直接通过 <code>props</code> 传递</li><li>子传父：父组件通过 <code>props</code> 给子组件传递一个函数，子组件调用该函数</li></ul><pre><code class="jsx">// 父组件class Father extends Component &#123;  state: &#123;    todos: [&#123; id: &#39;001&#39;, name: &#39;吃饭&#39;, done: true &#125;],    flag: true,  &#125;  addTodo = (todo) =&gt; &#123;    const &#123; todos &#125; = this.state    const newTodos = [todo, ...todos]    this.setState(&#123; todos: newTodos &#125;)  &#125;  render() &#123;    return &lt;List todos=&#123;this.state.todos&#125; addTodo=&#123;this.addTodo&#125; /&gt;  &#125;&#125;// 子组件class Son extends Component &#123;  // 由于 addTodo 是箭头函数，this 指向父组件实例对象，因此子组件调用它相当于父组件实例在调用  handleClick = () =&gt; &#123;    this.props.addTodo(&#123; id: &#39;002&#39;, name: &#39;敲代码&#39;, done: false &#125;)  &#125;  render() &#123;    return &lt;button onClick=&#123;this.handleClick&#125;&gt;添加&lt;/button&gt;  &#125;&#125;</code></pre><ol><li>注意 <code>defaultChecked</code> 和 <code>checked</code> 的区别，类似的还有：<code>defaultValue</code> 和 <code>value</code></li><li>状态在哪里，操作状态的方法就在哪里</li></ol><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>方法一：</p><p>在 <code>package.json</code> 文件中进行配置：</p><pre><code class="json">&quot;proxy&quot;: &quot;http://localhost:5000&quot;</code></pre><ul><li>优点：配置简单，前端请求资源可不加前缀</li><li>缺点：不能配置多个代理</li><li>工作方式：当请求了 3000 端口号（本机）不存在的资源时，就会把请求转发给 5000 端口号服务器</li></ul><p>方法二：</p><p>在 <code>src</code> 目录下创建代理配置文件 <code>setupProxy.js</code> ，进行配置：</p><pre><code class="jsx">const proxy = require(&#39;http-proxy-middleware&#39;)module.exports = function (app) &#123;  app.use(    //api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)    proxy(&#39;/api1&#39;, &#123;      //配置转发目标地址(能返回数据的服务器地址)      target: &#39;http://localhost:5000&#39;,      //控制服务器接收到的请求头中host字段的值      /*      changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000      changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000      changeOrigin默认值为false，但一般将changeOrigin改为true      */      changeOrigin: true,      //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)      pathRewrite: &#123; &#39;^/api1&#39;: &#39;&#39; &#125;,    &#125;),    proxy(&#39;/api2&#39;, &#123;      target: &#39;http://localhost:5001&#39;,      changeOrigin: true,      pathRewrite: &#123; &#39;^/api2&#39;: &#39;&#39; &#125;,    &#125;)  )&#125;</code></pre><h2 id="消息订阅发布机制"><a href="#消息订阅发布机制" class="headerlink" title="消息订阅发布机制"></a>消息订阅发布机制</h2><p>即 React 中兄弟组件或任意组件之间的通信方式。（类似vue的bus）</p><ul><li>先订阅，再发布（隔空对话）</li><li>适用于任意组件间通信</li><li>要在 <code>componentWillUnmount</code> 钩子中取消订阅</li></ul><p>使用的工具库：<a href="https://www.npmjs.com/package/pubsub-js">PubSubJS</a> </p><pre><code>npm i pubsub-js --save</code></pre><p>基础用法：</p><pre><code class="jsx">import PubSub from &#39;pubsub-js&#39;// 发布消息PubSub.publish(&#39;topic&#39;, &#39;hello react&#39;)// 订阅消息 token是一个标识，类似setTimeout会有个返回值作为标识let token = PubSub.subscribe(&#39;topic&#39;, (msg, data) =&gt; &#123;  console.log(msg, data)&#125;)// 取消订阅PubSub.unsubscribe(token)</code></pre><h2 id="解构赋值再认识"><a href="#解构赋值再认识" class="headerlink" title="解构赋值再认识"></a>解构赋值再认识</h2><p>熟悉一下连续解构赋值、连续解构赋值+重命名</p><pre><code class="js">let obj = &#123; a: &#123; b: 1 &#125; &#125;//传统解构赋值const &#123; a &#125; = obj//连续解构赋值const &#123;  a: &#123; b &#125;,&#125; = obj//连续解构赋值 + 重命名const &#123;  a: &#123; b: value &#125;,&#125; = obj</code></pre><h2 id="nanoid生成唯一标识"><a href="#nanoid生成唯一标识" class="headerlink" title="nanoid生成唯一标识"></a>nanoid生成唯一标识</h2><p><a href="https://gitee.com/mirrors/nanoid">https://gitee.com/mirrors/nanoid</a></p><p>生成唯一标识的一个库</p><pre><code class="shell">npm install --save nanoid</code></pre><p>使用</p><pre><code class="js">import &#123;nanoid&#125; from &#39;nanoid&#39;console.log(nanoid())</code></pre><h2 id="react-router5"><a href="#react-router5" class="headerlink" title="react-router5"></a>react-router5</h2><h3 id="路由的理解"><a href="#路由的理解" class="headerlink" title="路由的理解"></a>路由的理解</h3><p>何为路由？</p><ul><li>一个路由是一个映射关系</li><li><code>key</code> 为路径，<code>value</code> 可能是 <code>function</code> 或 <strong style="color:red">组件</strong></li></ul><p>后端路由：</p><ul><li><code>value</code> 是 <code>function</code> ，用于处理客户端的请求</li><li>注册路由：<code>router.get(path, function(req, res))</code></li><li>工作过程：Node 接收到请求，根据路径匹配路由，调用对应函数处理请求，返回响应数据</li></ul><p>前端路由：</p><ul><li><code>value</code> 是组件</li><li>注册路由：<code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code></li><li>工作过程：浏览器路径变为 <code>/test</code> ，展示 <code>Test</code> 组件</li></ul><h3 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h3><p>安装 <code>react-router-dom</code> </p><pre><code class="shell">// 安装 5.X 版本路由npm install react-router-dom@5.2.0 -S</code></pre><p>最新默认是安装的6.x版本，这里以 <code>5.x</code> 版本为例展示基本使用,后面再写6.x版本的使用</p><p>导航区使用 <code>&lt;Link&gt;</code>，展示区使用 <code>&lt;Route&gt;</code>。</p><h4 id="Link组件"><a href="#Link组件" class="headerlink" title="Link组件"></a>Link组件</h4><blockquote><p>定义链接，用来替换a标签</p></blockquote><ul><li><p>to属性：定义点击之后切换的路径</p></li><li><p>className属性： 定义类名</p></li><li><p>标签体：定义显示的名称</p></li></ul><p>【例如】</p><pre><code class="html">&lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;about&lt;/Link&gt;</code></pre><h4 id="Route组件"><a href="#Route组件" class="headerlink" title="Route组件"></a>Route组件</h4><blockquote><p>路由组件匹配成功之后的展示区</p></blockquote><ul><li>path属性：匹配的路径</li><li>component属性：匹配成功后展示的组件</li></ul><p>【例如】</p><pre><code class="html">&lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;</code></pre><h4 id="路由入门案例"><a href="#路由入门案例" class="headerlink" title="路由入门案例"></a>路由入门案例</h4><ul><li>复制boostrap.css到public&#x2F;css下,并且在index.html中引入</li></ul><p><img src="/posts/27fcdfc0/image-20220911224233636.png" alt="image-20220911224233636"></p><ul><li><code>&lt;App&gt;</code> 的最外侧包裹 <code>&lt;BrowserRouter&gt;</code> 或 <code>&lt;HashRouter&gt;</code> ：</li></ul><pre><code class="jsx">// index.jsimport React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;import App from &#39;./App&#39;ReactDOM.render(  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;,  document.getElementById(&#39;root&#39;))</code></pre><ul><li>App.jsx</li></ul><pre><code class="jsx">// App.jsximport React, &#123; Component &#125; from &#39;react&#39;import &#123; Link, Route &#125; from &#39;react-router-dom&#39;import Home from &#39;./components/Home&#39;import About from &#39;./components/About&#39;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;div className=&quot;list-group&quot;&gt;          &lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;            About          &lt;/Link&gt;          &lt;Link className=&quot;list-group-item&quot; to=&quot;/home&quot;&gt;            Home          &lt;/Link&gt;        &lt;/div&gt;        &lt;div className=&quot;panel-body&quot;&gt;          &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;          &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;        &lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="路由组件和一般组件"><a href="#路由组件和一般组件" class="headerlink" title="路由组件和一般组件"></a>路由组件和一般组件</h3><p>存放位置不同</p><ul><li>一般组件：<code>components</code></li><li>路由组件：<code>pages</code></li></ul><p><strong style="color:red">写法不同</strong></p><ul><li>一般组件：<code>&lt;Demo/&gt;</code></li><li>路由组件：<code>&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt;</code></li></ul><p><strong style="color:red">接收到的 props不同</strong></p><ul><li>一般组件：标签属性传递</li><li>路由组件：接收到三个固定的属性(history、location、match)</li></ul><pre><code class="js">history:  go: ƒ go(n)  goBack: ƒ goBack()  goForward: ƒ goForward()  push: ƒ push(path, state)  replace: ƒ replace(path, state)location:  pathname: &quot;/home/message/detail/2/hello&quot;  search: &quot;&quot;  state: undefinedmatch:  params: &#123;&#125;  path: &quot;/home/message/detail/:id/:title&quot;  url: &quot;/home/message/detail/2/hello&quot;</code></pre><h3 id="NavLink组件"><a href="#NavLink组件" class="headerlink" title="NavLink组件"></a>NavLink组件</h3><p><code>NavLink</code> 可以实现路由链接的高亮，通过 <code>activeClassName</code> 指定样式名，默认追加类名为 <code>active</code> 。</p><pre><code class="html">&lt;NavLink activeClassName=&quot;navLinkActive&quot; to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;&lt;NavLink activeClassName=&quot;navLinkActive&quot; to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;</code></pre><p>封装 <code>NavLink</code> 组件：由于 <code>NavLink</code> 组件中重复的代码太多，因此进行二次封装。</p><p><strong style="color:red">※ 细节点</strong>：组件标签的内容会传递到 <code>this.props.children</code> 属性中，反过来通过指定标签的 <code>children</code> 属性可以修改组件标签内容</p><pre><code class="jsx">// MyNavLink 组件import React, &#123; Component &#125; from &#39;react&#39;import &#123; NavLink &#125; from &#39;react-router-dom&#39;export default class MyNavLink extends Component &#123;  render() &#123;    // this.props.children 可以取到标签内容，如 About, Home    // 反过来通过指定标签的 children 属性可以修改标签内容   return &lt;NavLink activeClassName=&quot;active&quot; className=&quot;list-group-item&quot; &#123;...this.props&#125;/&gt;  &#125;&#125;</code></pre><pre><code class="html">&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;</code></pre><h3 id="Switch-的使用"><a href="#Switch-的使用" class="headerlink" title="Switch 的使用"></a>Switch 的使用</h3><p><code>Switch</code> 可以提高路由匹配效率，如果匹配成功，则不再继续匹配后面的路由，即单一匹配。</p><pre><code class="html">&lt;!-- 只会展示 Home 组件 --&gt;&lt;Switch&gt;  &lt;Route path=&quot;/about&quot; component=&quot;&#123;About&#125;&quot; /&gt;  &lt;Route path=&quot;/home&quot; component=&quot;&#123;Home&#125;&quot; /&gt;  &lt;Route path=&quot;/home&quot; component=&quot;&#123;Test&#125;&quot; /&gt;&lt;/Switch&gt;</code></pre><h3 id="多级路径刷新样式丢失"><a href="#多级路径刷新样式丢失" class="headerlink" title="多级路径刷新样式丢失"></a>多级路径刷新样式丢失</h3><ul><li><code>public/index.html</code> 中 引入样式时不写 <code>./</code> 写 <code>/</code> （常用）</li><li><code>public/index.html</code> 中 引入样式时不写 <code>./</code> 写 <code>%PUBLIC_URL%</code> （常用）</li><li>使用 <code>HashRouter</code></li></ul><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;%PUBLIC_URL%/css/bootstrap.css&quot; /&gt;</code></pre><h3 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a>路由的严格匹配与模糊匹配</h3><ul><li>默认使用模糊匹配（<code>Route</code>组件的<code>path</code>必须包含<code>Link</code>组件要匹配的路径，且顺序一致）</li><li>开启严格匹配：<code>&lt;Route exact path=&quot;/about&quot; component=&#123;About&#125;/&gt;</code></li><li>严格匹配需要再开，开启可能会导致无法继续匹配二级路由</li></ul><h3 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect (重定向)"></a>Redirect (重定向)</h3><p>一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到 Redirect 指定的路由</p><pre><code class="html">&lt;Switch&gt;  &lt;Route path=&quot;/about&quot; component=&quot;&#123;About&#125;&quot; /&gt;  &lt;Route path=&quot;/home&quot; component=&quot;&#123;Home&#125;&quot; /&gt;  &lt;Redirect to=&quot;/about&quot; /&gt;&lt;/Switch&gt;</code></pre><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul><li>注册子路由需写上父路由的 <code>path</code></li><li>路由的匹配是<strong style="color:red">按照注册路由的顺序进行</strong>的</li></ul><p>父组件</p><pre><code class="html">&lt;!-- 父组件 --&gt;&lt;MyNavLink to=&quot;/about&quot;&gt;About&lt;/MyNavLink&gt;&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;&lt;Switch&gt;  &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;  &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt;  &lt;Redirect to=&quot;/about&quot; /&gt;&lt;/Switch&gt;</code></pre><p>子组件</p><pre><code class="html">&lt;ul className=&quot;nav nav-tabs&quot;&gt;  &lt;li&gt;    &lt;MyNavLink to=&quot;/home/news&quot;&gt;News&lt;/MyNavLink&gt;  &lt;/li&gt;  &lt;li&gt;    &lt;MyNavLink to=&quot;/home/message&quot;&gt;Message&lt;/MyNavLink&gt;  &lt;/li&gt;&lt;/ul&gt;&lt;Switch&gt;  &lt;Route path=&quot;/home/news&quot; component=&#123;News&#125; /&gt;  &lt;Route path=&quot;/home/message&quot; component=&#123;Message&#125; /&gt;  &lt;Redirect to=&quot;/home/news&quot; /&gt;&lt;/Switch&gt;</code></pre><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><p>三种方式：<code>params, search, state</code> 参数</p><p>三种方式对比：</p><ul><li><code>state</code> 方式当前页面刷新可保留参数，但在新页面打开不能保留。前两种方式由于参数保存在 URL 地址上，因此都能保留参数。</li><li><code>params</code> 和 <code>search</code> 参数都会变成字符串</li></ul><pre><code class="html">&lt;!--1.params方式传参 --&gt;&lt;Link to=&#39;/home/message/detail/tom/21&#39;&gt;params&lt;/Link&gt;&lt;Link to=&#123;`/home/message/detail/$&#123;item.name&#125;/$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;&lt;!--2.search方式传参 --&gt;&lt;Link to=&#39;/home/message/detail/?name=tom&amp;age=21&#39;&gt;search&lt;/Link&gt;&lt;Link to=&#123;`/home/message/detail/?id=$&#123;item.name&#125;&amp;title=$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;&lt;!--3.state方式传参 --&gt;&lt;Link to=&#123;&#123;pathname:'/home/message/detail',state: &#123;name: 'tom', age: 21&#125;&#125;&#125;&gt;state&lt;/Link&gt;&lt;!-- params 注册路由 --&gt;&lt;Route path=&#39;/home/message/detail/:name/:age&#39; component=&#123;Detail&#125; /&gt;&lt;!-- search 和 state 按正常注册即可 --&gt;&lt;Route path=&#39;/home/message/detail&#39; component=&#123;Detail&#125; /&gt;</code></pre><p>接收参数</p><pre><code class="js">//1.params方式接受参数const &#123; name, age &#125; = this.props.match.params//2.search方式接受参数import qs from &#39;querystring&#39;const &#123; search &#125; = this.props.locationconst &#123; name, age &#125; = qs.parse(search.slice(1))//3.state方式接受参数const &#123; name, age &#125; = this.props.location.state</code></pre><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>编程式导航是使用路由组件 <code>this.props.history</code> 提供的 API 进行路由跳转：</p><pre><code class="js">this.props.history.push(path, state)this.props.history.replace(path, state)this.props.history.goForward()this.props.history.goBack()this.props.history.go(n)</code></pre><p>三种传参方式的编程式导航</p><pre><code class="js">// 编程式导航传参this.props.history.push(`/home/message/detail/$&#123;id&#125;/$&#123;title&#125;`)this.props.history.push(`/home/message/detail?id=$&#123;id&#125;&amp;title=$&#123;title&#125;`)this.props.history.push(`/home/message/detail`, &#123; id: id, title: title &#125;)</code></pre><h3 id="withRouter-的使用"><a href="#withRouter-的使用" class="headerlink" title="withRouter 的使用"></a>withRouter 的使用</h3><p><code>withRouter</code> 的作用：加工一般组件，让其拥有路由组件的 API ，如 <code>this.props.history.push</code> 等。</p><pre><code class="jsx">import React, &#123;Component&#125; from &#39;react&#39;import &#123;withRouter&#125; from &#39;react-router-dom&#39;class Header extends Component &#123;  ...&#125;export default withRouter(Header) //导出前用withRouter加工一下</code></pre><h3 id="BrowserRouter-和-HashRouter"><a href="#BrowserRouter-和-HashRouter" class="headerlink" title="BrowserRouter 和 HashRouter"></a>BrowserRouter 和 HashRouter</h3><p>底层原理不一样：</p><ul><li><code>BrowserRouter</code> 使用的是 H5 的 history API，不兼容 IE9 及以下版本。</li><li><code>HashRouter</code> 使用的是 URL 的哈希值。</li></ul><p>路径表现形式不一样</p><ul><li><code>BrowserRouter</code> 的路径中没有 <code>#</code> ，如：<code>localhost:3000/demo/test</code></li><li><code>HashRouter</code> 的路径包含#，如：<code>localhost:3000/#/demo/test</code></li></ul><p>刷新后对路由 <code>state</code> 参数的影响</p><ul><li><code>BrowserRouter</code> 没有影响，因为 <code>state</code> 保存在 <code>history</code> 对象中。</li><li><code>HashRouter</code> 刷新后会导致路由 <code>state</code> 参数的丢失！</li></ul><p>备注：<code>HashRouter</code> 可以用于解决一些路径错误相关的<a href="https://brucecai55520.gitee.io/bruceblog/notes/react/react-router5.html#%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%A7%E8%B7%AF%E5%BE%84%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98">问题</a>。</p><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><p><a href="https://redux.js.org/">官网</a></p><p><a href="https://www.redux.org.cn/">中文文档</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Redux 为何物，类似vue中的vuex</p><ul><li>Redux 是用于做 <strong>状态管理</strong> 的 JS 库</li><li>可用于 React、Angular、Vue 等项目中，常用于 React</li><li>集中式管理 React 应用多个组件共享的状态</li></ul><p>何时用 Redux</p><ul><li>某个组件的状态，需要让其他组件拿到（状态共享）</li><li>一个组件需要改变另一个组件的状态（通信）</li><li>使用原则：不到万不得已不要轻易动用</li></ul><p>Redux 工作流程</p><p><img src="/posts/27fcdfc0/redux.4afb4200.png" alt="redux 工作流程图"></p><ul><li>组件想操作 Redux 中的状态：把动作类型和数据告诉 <code>Action Creators</code></li><li><code>Action Creators</code> 创建 <code>action</code> ：同步 <code>action</code> 是一个普通对象，异步 <code>action</code> 是一个函数</li><li><code>Store</code> 调用 <code>dispatch()</code> 分发 <code>action</code> 给 <code>Reducers</code> 执行</li><li><code>Reducers</code> 接收 <code>previousState</code> 、<code>action</code> 两个参数，对状态进行加工后返回新状态</li><li><code>Store</code> 调用 <code>getState()</code> 把状态传给组件</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><ul><li><p>表示动作的对象，包含 2 个属性</p></li><li><p><code>type</code> ：标识属性，值为字符串，唯一，必须属性</p></li><li><p><code>data</code> ：数据属性，类型任意，可选属性。</p></li></ul><p>例如：<code>&#123;type: &#39;increment&#39;, data: 2&#125;</code></p><h4 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h4><ul><li>用于初始化状态、加工状态</li><li>根据旧状态和 <code>action</code> 产生新状态</li><li>是<strong>纯函数</strong></li></ul><blockquote><p>纯函数：输入同样的实参，必定得到同样的输出</p><ul><li>不能改写参数数据</li><li>不产生副作用，如网络请求、输入输出设备（网络请求不稳定）</li><li>不能调用 <code>Date.now()</code> 、<code>Math.random()</code> 等不纯方法</li></ul></blockquote><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><ul><li>Redux 核心对象，内部维护着 <code>state</code> 和 <code>reducer</code></li><li>核心 API<ul><li><code>store.getState()</code> ：获取状态</li><li><code>store.dispatch(action)</code> ：分发任务，触发 <code>reducer</code> 调用，产生新状态</li><li><code>store.subscribe(func)</code> ：注册监听函数，当状态改变自动调用</li></ul></li></ul><h3 id="求和案例"><a href="#求和案例" class="headerlink" title="求和案例"></a>求和案例</h3><ul><li>安装redux</li></ul><pre><code class="shell">npm i redux@4.0.5</code></pre><ul><li>App.jsx</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import Count from &#39;./components/Count&#39;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;Count /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><ul><li>index.js</li></ul><pre><code class="js">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import App from &#39;./App&#39;import store from &#39;./redux/store&#39;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))// 状态改变重新渲染 App 组件store.subscribe(() =&gt; &#123;  ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))&#125;)//react18的写法如下const root = ReactDOM.createRoot(document.getElementById(&#39;root&#39;))root.render(&lt;App /&gt;)store.subscribe(()=&gt;&#123;    root.render(&lt;App /&gt;)&#125;)</code></pre><ul><li>redux&#x2F;constant.js 定义常量</li></ul><pre><code class="js">// 保存常量值export const INCREMENT = &#39;increment&#39;export const DECREMENT = &#39;decrement&#39;</code></pre><ul><li>redux&#x2F;count_reducer.js</li></ul><pre><code class="js">import &#123; INCREMENT, DECREMENT &#125; from &#39;./constant&#39;//初始化状态const initState = 0export default function countReducer(preState = initState, action) &#123;  const &#123; type, data &#125; = action  switch (type) &#123;    case INCREMENT:      return preState + data    case DECREMENT:      return preState - data    default:      return preState  &#125;&#125;</code></pre><ul><li>redux&#x2F;store.js</li></ul><pre><code class="js">import &#123; createStore &#125; from &#39;redux&#39;//引入为 Count 组件服务的 reducerimport countReducer from &#39;./count_reducer&#39;export default createStore(countReducer)</code></pre><ul><li>count_action.js</li></ul><pre><code class="js">import &#123;INCREMENT,DECREMENT&#125; from &#39;./constant&#39;export const createIncrementAction = data =&gt; (&#123;type: INCREMENT,data&#125;)export const createdecrementAction = data =&gt; (&#123;type: DECREMENT,data&#125;)</code></pre><ul><li>components&#x2F;Count&#x2F;index.jsx</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import store from &#39;../../redux/store&#39;import &#123; createIncrementAction, createDecrementAction &#125; from &#39;../../redux/count_action&#39;export default class Count extends Component &#123;  // 可在组件单独监听 Redux 状态变化  // componentDidMount() &#123;  //     store.subscribe(() =&gt; &#123;  //         this.setState(&#123;&#125;)  //     &#125;)  // &#125;  increment = () =&gt; &#123;    const &#123; value &#125; = this.selectNumber    // 将 value 转为数值    // 手动写 Action 对象    store.dispatch(&#123; type: &#39;increment&#39;, data: value * 1 &#125;)    // 专门创建 Action 对象    store.dispatch(createIncrementAction(value * 1))  &#125;  decrement = () =&gt; &#123;    const &#123; value &#125; = this.selectNumber    store.dispatch(createDecrementAction(value * 1))  &#125;  incrementAsync = () =&gt; &#123;    const &#123; value &#125; = this.selectNumber    setTimeout(() =&gt; &#123;      store.dispatch(createIncrementAction(value * 1))    &#125;, 500)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;当前求和为：&#123;store.getState()&#125;&lt;/h1&gt;        &lt;select ref=&#123;(c) =&gt; (this.selectNumber = c)&#125;&gt;          &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;          &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;          &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;        &lt;/select&gt;        &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;        &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;        &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p><strong style="color:red">编写步骤总结：</strong></p><p>1.创建constant.js定义常量</p><p>2.创建count_reducer.js</p><p>3.根据count_reducer创建store</p><p>4.创建action</p><p>5.在组件中使用 store.dispatch(action)更新数据 ，store.getState()获取数据</p><p><strong style="color:red">注意：</strong></p><ul><li>redux 只负责管理状态，状态改变驱动页面展示要自己写</li><li>可以在 <code>index.js</code> 中统一监听状态变化，也可以在组件中单独监听。注意不能直接 <code>this.render()</code> 调用 <code>render</code> 函数，要通过 <code>this.setState(&#123;&#125;)</code> 间接调用</li><li><code>reducer</code> 由 <code>store</code> 自动触发首次调用，传递的 <code>preState</code> 为 <code>undefined</code> ，<code>action</code> 为 <code>&#123;type: &#39;@@REDUX/ININT_a.5.v.9&#39;&#125;</code> 类似的数据格式，只有 <code>type</code></li></ul><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><blockquote><p>1.延迟的动作不想交给组件，而是 <code>action</code><br>2.当操作状态所需数据要靠异步任务返回时，可用异步 <code>action</code><br>3.创建 <code>action</code> 的函数<strong style="color:red">返回一个函数</strong>，该函数中写异步任务<br>4.异步任务完成后，分发一个同步 <code>action</code> 操作状态<br>5.异步 <code>action</code> 不是必要的，完全可以在组件中等待异步任务结果返回在分发同步 <code>action</code></p></blockquote><p>安装中间件</p><pre><code class="shell">npm i redux-thunk@2.3.0</code></pre><p>对上面的求和案例进行修改</p><ul><li>store.js</li></ul><pre><code class="js">import &#123; createStore, applyMiddleware &#125; from &#39;redux&#39;import countReducer from &#39;./count_reducer&#39;import thunk from &#39;redux-thunk&#39; //引入中间件//创建store的时候，使用中间件export default createStore(countReducer, applyMiddleware(thunk))</code></pre><ul><li>count_action.js</li></ul><pre><code class="js">import &#123; INCREMENT, DECREMENT &#125; from &#39;./constant.js&#39;export const createIncrementAction = (data) =&gt; (&#123; type: INCREMENT, data &#125;)export const createDecrementAction = (data) =&gt; (&#123; type: DECREMENT, data &#125;)// 异步 action 返回一个函数export const createIncrementAsyncAction = (data, time) =&gt; &#123;  return (dispatch) =&gt; &#123;    setTimeout(() =&gt; &#123;      dispatch(createIncrementAction(data))    &#125;, time)  &#125;&#125;</code></pre><ul><li>Count.jsx</li></ul><pre><code class="js">incrementAsync = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  store.dispatch(createIncrementAsyncAction(value * 1))&#125;</code></pre><p>整个过程简单理解：<code>store</code> 在分发 <code>action</code> 时，发现返回一个函数，那它知道这是个异步 <code>action</code> 。因此 <code>store</code> 帮忙执行这个函数(ps：使用<strong style="color:red">redux-thunk</strong>才会执行，否则报错)，同时给这个函数传递 <code>dispatch</code> 方法，等待异步任务完成取到数据后，直接调用 <code>dispatch</code> 方法分发同步 <code>action</code> 。</p><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>React-Redux 是一个插件库，用于简化 React 中使用 Redux 。</p><p><img src="/posts/27fcdfc0/image-20221228140202071.png" alt="image-20221228140202071"></p><p>React-Redux 将组件分为两类：</p><ul><li>UI 组件<ul><li>只负责 UI 呈现，不带有业务逻辑</li><li>通过 <code>props</code> 接收数据</li><li>不能使用 Redux 的 API</li><li>保存在 <code>components</code> 文件夹下</li></ul></li><li>容器组件<ul><li>负责管理数据和业务逻辑，和 Redux 通信，将结果交给 UI 组件</li><li>可使用 Redux 的 API</li><li>保存在 <code>containers</code> 文件夹下</li></ul></li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>要点：</p><ul><li>装包：<code>npm i react-redux</code></li></ul><ul><li><code>connect()()</code> ：创建容器组件</li><li><code>mapStateToProps(state)</code> ：映射状态为 UI 组件标签属性，即传递状态</li><li><code>mapDispatchToProps(dispatch)</code> ：传递操作状态的方法</li><li>容器组件中的 <code>store</code> 是靠 <code>props</code> 传进去，而不是在容器组件中直接引入</li></ul><p>【react-redux使用案例】</p><blockquote><p>Count 容器组件</p></blockquote><pre><code class="jsx">// containers/Count/index.jsx// Count 容器组件import CountUI from &#39;../../components/Count&#39;import &#123; connect &#125; from &#39;react-redux&#39;import &#123; createIncrementAction, createDecrementAction, createIncrementAsyncAction &#125; from &#39;../../redux/count_action&#39;function mapStateToProps(state) &#123;  return &#123;    count: state,  &#125;&#125;function mapDispatchToProps(dispatch) &#123;  return &#123;    add: (number) =&gt; dispatch(createIncrementAction(number)),    sub: (number) =&gt; dispatch(createDecrementAction(number)),    addAsync: (number) =&gt; dispatch(createIncrementAsyncAction(number, time)),  &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(CountUI)</code></pre><blockquote><p>App.jsx</p></blockquote><pre><code class="jsx">// App.jsximport React, &#123; Component &#125; from &#39;react&#39;import Count from &#39;./containers/Count&#39;import store from &#39;./redux/store.js&#39;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;Count store=&#123;store&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><blockquote><p>Count UI 组件</p></blockquote><pre><code class="jsx">// components/Count/index.jsx// Count UI 组件increment = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  this.props.add(value * 1)&#125;decrement = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  this.props.sub(value * 1)&#125;incrementAsync = () =&gt; &#123;  const &#123; value &#125; = this.selectNumber  this.props.addAsync(value * 1, 500)&#125;</code></pre><h3 id="优化写法"><a href="#优化写法" class="headerlink" title="优化写法"></a>优化写法</h3><p><code>mapDispatchToProps</code> 可以写成对象形式，React-Redux 底层会帮助自动分发。</p><pre><code class="jsx">// 函数写法export default connect(  state =&gt; (&#123;count:state&#125;),  dispatch =&gt; (&#123;    add: number =&gt; dispatch(createIncrementAction(number)),    sub: number =&gt; dispatch(createDecrementAction(number)),    addAsync: (number,time) =&gt; dispatch(createIncrementAsyncAction(number,time)),  &#125;))(CountUI)// 对象写法export default connect(  state =&gt; (&#123; count: state &#125;),  &#123;    add: createIncrementAction,    sub: createDecrementAction,    addAsync: createIncrementAsyncAction,  &#125;)(CountUI)</code></pre><p>React-Redux 容器组件可以自动监测 Redux 状态变化，因此 <code>index.js</code> 不需要手动监听：</p><pre><code class="jsx">//不用写下面这些代码了store.subscribe(() =&gt; &#123;  ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))&#125;)</code></pre><p><code>Provider</code> 组件的使用：让所有组件都能获得状态数据，不必一个一个传递</p><pre><code class="jsx">// index.jsimport React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import App from &#39;./App&#39;import &#123; Provider &#125; from &#39;react-redux&#39;import store from &#39;./redux/store&#39;ReactDOM.render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&#39;root&#39;))</code></pre><p>整合容器组件和 UI 组件为一个文件：</p><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import &#123;createIncrementAction,createDecrementAction&#125; from &#39;../../redux/count_action&#39;import &#123;connect&#125; from &#39;react-redux&#39;// 定义 UI 组件class Count extends Component &#123;  ...&#125;// 创建容器组件export default connect(  state =&gt; (&#123;count: state&#125;),  &#123;    add: createIncrementAction,    sub: createDecrementAction  &#125;)(Count)</code></pre><h3 id="多组件数据共享"><a href="#多组件数据共享" class="headerlink" title="多组件数据共享"></a>多组件数据共享</h3><p>首先规范化文件结构，容器组件和 UI 组件合为一体后放在 <code>containers</code> 文件夹。<code>redux</code> 文件夹新建 <code>actions</code> 和 <code>reducers</code> 文件夹分别用于存放每个组件对应的 <code>action</code> 和 <code>reducer</code> 。</p><p>新建 <code>Person</code> 组件对应的 <code>action</code> 和 <code>reducer</code> ：</p><pre><code class="jsx">// redux/actions/person.jsimport &#123; ADD_PERSON &#125; from &#39;../constant.js&#39;export const createAddPersonAction = (personObj) =&gt; (&#123; type: ADD_PERSON, data: personObj &#125;)</code></pre><pre><code class="js">// redux/reducers/person.jsimport &#123; ADD_PERSON &#125; from &#39;../constant.js&#39;const initState = [&#123; id: &#39;lsfd&#39;, name: &#39;china&#39;, age: &#39;9999&#39; &#125;]export default function personReducer(preState = initState, action) &#123;  const &#123; type, data &#125; = action  switch (type) &#123;    case ADD_PERSON:      return [data, ...preState]    default:      return preState  &#125;&#125;</code></pre><p>关键步骤：在 <code>store.js</code> 中使用 <code>combineReducers()</code> 整合多个 <code>reducer</code> 来创建 <code>store</code> 对象。</p><p>这样 Redux 中就以对象的形式存储着每个组件的数据。类似于这样：</p><pre><code class="json">&#123;  total: 0,  personList: []&#125;</code></pre><pre><code class="js">// redux/store.jsimport &#123; createStore, applyMiddleware, combineReducers &#125; from &#39;redux&#39;import countReducer from &#39;./reducers/count&#39;import personReducer from &#39;./reducers/person&#39;import thunk from &#39;redux-thunk&#39;const Reducers = combineReducers(&#123; //关键代码！！！  total: countReducer,  personList: personReducer,&#125;)export default createStore(Reducers, applyMiddleware(thunk))</code></pre><p><code>Person</code> 组件中获取 Redux 保存的状态，包括其他组件的数据。</p><pre><code class="js">import React, &#123; Component &#125; from &#39;react&#39;import &#123; connect &#125; from &#39;react-redux&#39;import &#123; createAddPersonAction &#125; from &#39;../../redux/actions/person&#39;import &#123; nanoid &#125; from &#39;nanoid&#39;class Person extends Component &#123;  addPerson = () =&gt; &#123;    const name = this.nameInput.value    const age = this.ageInput.value    const personObj = &#123; id: nanoid(), name, age &#125;    this.props.addPerson(personObj)    this.nameInput.value = &#39;&#39;    this.ageInput.value = &#39;&#39;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h2&gt;在Person组件拿到Count组件的数据：&#123;this.props.count&#125;&lt;/h2&gt;        &lt;input type=&quot;text&quot; ref=&#123;(c) =&gt; (this.nameInput = c)&#125; placeholder=&quot;Please input name&quot; /&gt;        &lt;input type=&quot;text&quot; ref=&#123;(c) =&gt; (this.ageInput = c)&#125; placeholder=&quot;Please input age&quot; /&gt;        &lt;button onClick=&#123;this.addPerson&#125;&gt;添加&lt;/button&gt;        &lt;ul&gt;          &#123;this.props.personList.map((item) =&gt; &#123;            return (              &lt;li key=&#123;item.id&#125;&gt;                &#123;item.name&#125; -- &#123;item.age&#125;              &lt;/li&gt;            )          &#125;)&#125;        &lt;/ul&gt;      &lt;/div&gt;    )  &#125;&#125;export default connect(  // state 是 Redux 保存的状态对象  // 容器组件从 Redux 中取出需要的状态，并传递给 UI 组件  state =&gt; (&#123;personList: state.personList, count: state.total&#125;),  &#123;    addPerson: createAddPersonAction  &#125;)(Person)</code></pre><p>一个细节，在 <code>personReducer</code> 中，是按如下方式修改状态的，而没有使用 <code>unshift</code> 方法。在第二种方式，React 会认为状态没有变化从而不会重新渲染页面，因为 <code>preState</code> 保存的是数组地址值，返回的地址和之前的地址是一样的，尽管数组内容发生了改变。而第一种方式返回一个新的数组的地址值，和之前不一样，因此会重新渲染页面。</p><pre><code class="js">// 方式一switch (type) &#123;  case ADD_PERSON:    return [data, ...preState]  default:    return preState&#125;// 方式二switch (type) &#123;  case ADD_PERSON:    preState.unshift(data)    return preState  default:    return preState&#125;</code></pre><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>概念：输入同样的参数，返回同样的输出。</p><p>约束：</p><ul><li>不能修改参数数据</li><li>不产生任何副作用，如网络请求、输入和输出设备</li><li>不能调用 <code>Date.now()</code> 或 <code>Math.random()</code> 等不纯的方法</li></ul><p><code>reducer</code> 的函数必须是纯函数。</p><h3 id="redux开发工具"><a href="#redux开发工具" class="headerlink" title="redux开发工具"></a>redux开发工具</h3><ul><li><p>Chrome 安装 Redux DevTools 开发者工具</p></li><li><p>项目下载依赖包 <code>npm i redux-devtools-extension --save-dev</code>，</p></li><li><p>最后在 <code>store.js</code> 进行配置：</p></li></ul><pre><code class="js">import &#123; composeWithDevTools &#125; from &#39;redux-devtools-extension&#39;...export default createStore(Reducers, composeWithDevTools(applyMiddleware(thunk)))// 不需要异步中间件export default createStore(Reducers, composeWithDevTools())</code></pre><h2 id="react扩展"><a href="#react扩展" class="headerlink" title="react扩展"></a>react扩展</h2><h3 id="setState-更新状态的两种写法"><a href="#setState-更新状态的两种写法" class="headerlink" title="setState 更新状态的两种写法"></a>setState 更新状态的两种写法</h3><p>对象式：<code>setState(stateChange, [callback])</code></p><ul><li><code>stateChange</code> 为状态改变对象(该对象可以体现出状态的更改)</li><li><code>callback</code> 是可选的回调函数, 它在状态更新完毕、界面也更新后才被调用</li></ul><p>函数式：<code>setState(updater, [callback])</code></p><ul><li>updater 为返回 stateChange 对象的函数。</li><li>updater 可以接收到 state 和 props。</li></ul><p>说明：</p><ul><li>React 状态更新是异步的。下述代码打印的 <code>count</code> 值是上一次的值，而非更新后的。可在第二个参数回调中获取更新后的状态。</li></ul><pre><code class="js">add = () =&gt; &#123;  this.setState(&#123; count: this.state.count + 1 &#125;)  console.log(this.state.count)&#125;add = () =&gt; &#123;  this.setState(&#123; count: this.state.count + 1 &#125;, () =&gt; &#123;    console.log(this.state.count)  &#125;)&#125;</code></pre><ul><li><code>callback</code> 回调在 <code>componentDidMount</code> 钩子之后执行</li><li>对象式写法可以看做函数式写法的语法糖</li></ul><pre><code class="js">add = () =&gt; &#123;  this.setState((state, props) =&gt; &#123;    return &#123; count: state.count + props.step &#125;  &#125;)&#125;</code></pre><h3 id="路由组件懒加载-lazyLoad"><a href="#路由组件懒加载-lazyLoad" class="headerlink" title="路由组件懒加载 lazyLoad"></a>路由组件懒加载 lazyLoad</h3><pre><code class="jsx">import React, &#123; Component, lazy, Suspense &#125; from &#39;react&#39;import Loading from &#39;./Loading&#39;// 通过 lazy 函数配合 import() 函数动态加载路由组件// 路由组件代码会被分开打包const Home = lazy(() =&gt; import(&#39;./Home&#39;)) const About = lazy(() =&gt; import(&#39;./About&#39;))export default Demo extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Demo 组件&lt;/h1&gt;        &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt;        &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;        // 通过 &lt;Suspense&gt; 指定在加载得到路由打包文件前显示一个自定义 Loading 界面        &lt;Suspense fallback=&#123;Loading&#125;&gt;          &lt;Switch&gt;            &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;&gt;            &lt;Route path=&quot;/about&quot; component=&#123;About&#125;&gt;          &lt;/Switch&gt;        &lt;/Suspense&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h3><blockquote><p>Hook 是 React 16.8.0 增加的新特性，让我们能在函数式组件中使用 <code>state</code> 和其他特性</p></blockquote><h4 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h4><ul><li><code>State Hook</code> 让函数式组件也可拥有 <code>state</code> 状态。</li><li>语法：<code>const [Xxx, setXxx] = React.useState(initValue)</code></li><li><code>useState()</code> 参数：状态初始化值；返回值：包含 2 个元素的数组，分别为状态值和状态更新函数</li><li><code>setXxx()</code> 的 2 种用法：</li></ul><pre><code>setXxx(newValue)setXxx(value =&gt; newValue)</code></pre><p>注意！<strong style="color:orange">新状态值会覆盖原状态值！</strong>因此<strong style="color:red">若有多个状态，只能多次调用 React.useState ，不能使用对象！</strong></p><pre><code class="jsx">import React from &#39;react&#39;export default function StateHook() &#123;    const [count, setCount] = React.useState(0);    const add = () =&gt; setCount(count + 1);    const sub = () =&gt; setCount((count) =&gt; count - 1)    return (        &lt;div&gt;            &lt;h2&gt;状态值：&#123;count&#125;&lt;/h2&gt;            &lt;button onClick=&#123;add&#125;&gt;+1&lt;/button&gt;            &lt;button onClick=&#123;sub&#125;&gt;-1&lt;/button&gt;        &lt;/div&gt;    )&#125;</code></pre><h4 id="Ref-Hook"><a href="#Ref-Hook" class="headerlink" title="Ref Hook"></a>Ref Hook</h4><ul><li><code>Ref Hook</code> 可以在函数式组件存储或查找组件内的标签或其他数据</li><li>语法：<code>const refContainer = React.useRef()</code></li><li>保存标签对象的容器，和 <code>React.createRef()</code> 类似，也是专人专用</li></ul><pre><code class="jsx">import React from &#39;react&#39;export default function RefHook() &#123;  const myref = React.useRef()  const submit = () =&gt; console.log(&#39;myref.current.value&#39;, myref.current.value)  return (    &lt;div&gt;        &lt;input type=&quot;text&quot;  ref=&#123;myref&#125;/&gt;        &lt;button onClick=&#123;submit&#125;&gt;submit&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h4><ul><li><code>Effect Hook</code> 让我们能在函数式组件中执行副作用操作（就是模拟生命周期钩子）</li><li>副作用操作：发送 Ajax 请求、定时器、手动更改真实 DOM</li><li><code>Effect Hook</code> 可以模拟三个钩子：<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code></li><li><code>React.useEffect</code> 第一个参数 <code>return</code> 的函数相当于 <code>componentWillUnmount</code> ，若有多个会按顺序执行</li></ul><pre><code class="js">// 语法React.useEffect(() =&gt; &#123;  ...  return () =&gt; &#123;    // 组件卸载前执行，即 componentWillUnmount 钩子    ...  &#125;&#125;, [stateValue])// 模拟 componentDidMount// 第二个参数数组为空，表示不监听任何状态的更新// 因此只有页面首次渲染会执行输出React.useEffect(() =&gt; &#123;  console.log(&#39;DidMount&#39;)  return () =&gt; &#123;    console.log(&#39;WillUnmount 1&#39;)  &#125;&#125;, [])// 模拟全部状态 componentDidUpdate// 若第二个参数不写，表示监听所有状态的更新React.useEffect(() =&gt; &#123;  console.log(&#39;All DidUpdate&#39;)  return () =&gt; &#123;    console.log(&#39;WillUnmount 2&#39;)  &#125;&#125;)// 模拟部分状态 componentDidUpdate// 第二个参数数组写上状态，表示只监听这些状态的更新React.useEffect(() =&gt; &#123;  console.log(&#39;Part DidUpdate&#39;)  return () =&gt; &#123;    console.log(&#39;WillUnmount 3&#39;)  &#125;&#125;, [count, name])// 若调用 ReactDOM.unmountComponentAtNode(document.getElementById(&#39;root&#39;))// 会输出 WillUnmount 1、2、3</code></pre><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><ul><li><code>Fragment</code> 标签本身不会被渲染成一个真实 DOM 标签，有点像 Vue 的 <code>template</code>。</li><li>用空标签也有相同效果，但是空标签不能传递任何属性，<code>Fragment</code> 标签可以传递 <code>key</code> 属性，遍历时候可用。</li></ul><pre><code class="jsx">import React, &#123; Component, Fragment &#125; from &#39;react&#39;export default class Demo extends Component &#123;  render() &#123;    return (      &lt;Fragment key=&#123;1&#125;&gt;        &lt;input type=&quot;text&quot; /&gt;        &lt;input type=&quot;text&quot; /&gt;      &lt;/Fragment&gt;    )    // 或    return (      &lt;&gt;        &lt;input type=&quot;text&quot; /&gt;        &lt;input type=&quot;text&quot; /&gt;      &lt;/&gt;    )  &#125;&#125;</code></pre><h3 id="Context-了解"><a href="#Context-了解" class="headerlink" title="Context (了解)"></a>Context (了解)</h3><p>Context 是一种组件间通信方式，常用于祖父组件与子孙组件。实际开发一般不用，一般用 React-Redux</p><p>用法说明：</p><pre><code class="jsx">1) 创建Context容器对象：const XxxContext = React.createContext()2) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：&lt;XxxContext.Provider value=&#123;数据&#125;&gt;  子组件&lt;/XxxContext.Provider&gt;3) 后代组件读取数据：// 第一种方式：仅适用于类组件// 声明接收contextstatic contextType = xxxContext// 读取context中的value数据this.context//第二种方式: 可用于函数组件与类组件&lt;XxxContext.Consumer&gt;  &#123;    // value就是context中的value数据    value =&gt; (      ...    )  &#125;&lt;/XxxContext.Consumer&gt;</code></pre><p>举个例子：</p><pre><code class="js">// context.jsimport React from &#39;react&#39;export const MyContext = React.createContext()export const &#123; Provider, Consumer &#125; = MyContext</code></pre><pre><code class="jsx">// A.jsximport React, &#123; Component &#125; from &#39;react&#39;import B from &#39;./B.jsx&#39;import &#123; Provider &#125; from &#39;./context.js&#39;export default class A extends Component &#123;  state = &#123; username: &#39;tom&#39;, age: 18 &#125;  render() &#123;    const &#123; username, age &#125; = this.state    return (      &lt;div&gt;        &lt;h3&gt;A组件&lt;/h3&gt;        &lt;h4&gt;用户名是:&#123;username&#125;&lt;/h4&gt;        &lt;Provider value=&#123;&#123; username, age &#125;&#125;&gt;          &lt;B /&gt;        &lt;/Provider&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><pre><code class="jsx">// B.jsximport React, &#123; Component &#125; from &#39;react&#39;import C from &#39;./C.jsx&#39;export default class B extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;B组件&lt;/h3&gt;        &lt;C /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><pre><code class="jsx">// C.jsximport React, &#123; Component &#125; from &#39;react&#39;import &#123; MyContext &#125; from &#39;./context.js&#39;export default class C extends Component &#123;  static contextType = MyContext  render() &#123;    const &#123; username, age &#125; = this.context    return (      &lt;div&gt;        &lt;h3&gt;C组件&lt;/h3&gt;        &lt;h4&gt;          从A组件接收到的用户名:&#123;username&#125;,年龄:&#123;age&#125;        &lt;/h4&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><pre><code class="jsx">// C.jsx 为函数式组件import &#123; Consumer &#125; from &#39;./context.js&#39;export default function C() &#123;  return (    &lt;div&gt;      &lt;h3&gt;我是C组件&lt;/h3&gt;      &lt;h4&gt;        从A组件接收到的用户名:        &lt;Consumer&gt;&#123;(value) =&gt; `$&#123;value.username&#125;,年龄是$&#123;value.age&#125;`&#125;&lt;/Consumer&gt;      &lt;/h4&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="组件渲染优化"><a href="#组件渲染优化" class="headerlink" title="组件渲染优化"></a>组件渲染优化</h3><p>问题：</p><ul><li>只要调用 <code>setState()</code> ，即使没有修改状态，组件也会重新 <code>render()</code></li><li>只要父组件重新渲染，即使子组件没有使用父组件的状态，也会重新 <code>render()</code></li></ul><p>原因：</p><ul><li><code>shouldComponentUpdate()</code> 钩子默认总是返回 <code>true</code></li></ul><p>改进：</p><ul><li>只有组件的 <code>state</code> 或 <code>props</code> 的数据发生改变时才重新渲染</li></ul><p>方式：</p><ol><li>手动重写 <code>shouldComponentUpdate(nextProps, nextState)</code> 的逻辑，只有数据发生改变才返回 <code>true</code></li><li>使用 <code>PureComponent</code> ，它重写了 <code>shouldComponentUpdate()</code> ， 只有 <code>state</code> 或 <code>props</code> 数据有变化才返回 <code>true</code></li></ol><blockquote><p>TIP</p><ul><li>它只是进行 <code>state</code> 和 <code>props</code> 数据的浅比较, 如果只是数据对象内部数据变了, 返回 <code>false</code>。即对于引用数据类型，比较的是地址引用</li><li>不要直接修改 <code>state</code> 数据, 而是要产生新数据</li></ul></blockquote><pre><code class="js">import React, &#123; PureComponent &#125; from &#39;react&#39;class Demo extends PureComponent &#123;  ...  addStu = () =&gt; &#123;    // 不会渲染    const &#123; stus &#125; = this.state    stus.unshift(&#39;小刘&#39;)    this.setState(&#123; stus &#125;)    // 重新渲染    const &#123; stus &#125; = this.state    this.setState(&#123; stus: [&#39;小刘&#39;, ...stus] &#125;)  &#125;  ...&#125;</code></pre><h3 id="render-props-插槽"><a href="#render-props-插槽" class="headerlink" title="render props (插槽)"></a>render props (插槽)</h3><blockquote><p>类似于 Vue 中的插槽技术</p></blockquote><p>如何向组件内部动态传入带内容的结构（即标签或组件）？</p><ul><li>Vue：插槽技术</li><li>React：<ul><li>使用 <code>children props</code>：通过组件标签体传入结构</li><li>使用 <code>render props</code>：通过组件标签属性传入结构，可携带数据</li></ul></li></ul><p><code>children props</code> 方式：</p><ul><li>组件标签体内容会存储到 <code>this.props.children</code> 中</li><li>缺点：A 组件无法向 B 组件传递数据</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;export default class Parent extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;Parent组件&lt;/h3&gt;        &lt;A&gt;          &lt;B /&gt;        &lt;/A&gt;      &lt;/div&gt;    )  &#125;&#125;class A extends Component &#123;  state = &#123; name: &#39;tom&#39; &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;A组件&lt;/h3&gt;        &#123;this.props.children&#125;      &lt;/div&gt;    )  &#125;&#125;class B extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;B组件&lt;/h3&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p><code>render props</code> 方式：</p><ul><li><code>&lt;A render=&#123;(name) =&gt; &lt;B name=&#123;name&#125; /&gt;&#125; /&gt;</code></li><li><code>&#123;this.props.render(name)&#125;</code></li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;export default class Parent extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;Parent组件&lt;/h3&gt;        &lt;A render=&#123;(name) =&gt; &lt;B name=&#123;name&#125; /&gt;&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;class A extends Component &#123;  state = &#123; name: &#39;tom&#39; &#125;  render() &#123;    const &#123; name &#125; = this.state    return (      &lt;div&gt;        &lt;h3&gt;A组件&lt;/h3&gt;        &#123;this.props.render(name)&#125;      &lt;/div&gt;    )  &#125;&#125;class B extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;B组件,&#123;this.props.name&#125;&lt;/h3&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><blockquote><p>TIP</p><p>错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面。</p><p>注意：只在生产环境（项目上线）起效</p></blockquote><p>特点：</p><ul><li>只能捕获<strong>后代组件生命周期</strong>产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</li><li>简单理解就是只能捕获后代组件生命周期钩子里面代码的错误</li></ul><pre><code class="jsx">import React, &#123; Component &#125; from &#39;react&#39;import Child from &#39;./Child&#39;export default class Parent extends Component &#123;  state = &#123;    //用于标识子组件是否产生错误    hasError: &#39;&#39;,  &#125;  // 当子组件出现错误，会触发调用，并携带错误信息  static getDerivedStateFromError(error) &#123;    // render 之前触发    // 返回新的 state    return &#123; hasError: error &#125;  &#125;  // 子组件产生错误时调用该钩子  componentDidCatch(error, info) &#123;    console.log(error, info)    console.log(&#39;此处统计错误，反馈给服务器&#39;)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h2&gt;Parent组件&lt;/h2&gt;        &#123;this.state.hasError ? &lt;h2&gt;网络不稳定，稍后再试&lt;/h2&gt; : &lt;Child /&gt;&#125;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="组件通信方式总结"><a href="#组件通信方式总结" class="headerlink" title="组件通信方式总结"></a>组件通信方式总结</h3><ul><li><code>props</code></li><li>消息订阅发布：<code>pubs-sub</code></li><li>集中管理：Redux、dva 等</li><li>Context</li></ul><p>推荐搭配：</p><ul><li>父子组件：<code>props</code></li><li>兄弟组件：消息订阅-发布、集中式管理</li><li>祖孙组件(跨级组件)：消息订阅-发布、集中式管理、<code>conText</code>(开发用的少，封装插件用的多即 React-Redux)</li></ul><h2 id="react-router6"><a href="#react-router6" class="headerlink" title="react-router6"></a>react-router6</h2><p><a href="https://reactrouter.com/">官方文档</a></p><p>React Router 发布了三个不同的包：</p><ul><li><code>react-router</code>：路由核心库，提供许多组件、钩子</li><li><code>react-router-dom</code>：包括了 <code>react-router</code> 所有内容，同时添加了用于 DOM 的组件，如 <code>&lt;BrowserRouter&gt;</code></li><li><code>react-router-native</code>：包括了 <code>react-router</code> 所有内容，同时添加了用于 ReactNative 的 API，如 <code>&lt;NativeRouter&gt;</code></li></ul><p>与 React Router 5.x 版本的区别：</p><ul><li>内置组件的变化：移除 <code>&lt;Switch/&gt;</code>，新增 <code>&lt;Routes/&gt;</code>……</li><li>语法变化：<code>component=&#123;About&#125;</code> 变成 <code>element=&#123;&lt;About/&gt;&#125;</code>……</li><li>新增 hook：<code>useParams</code>、<code>useNavigate</code>、<code>useMatch</code>……</li><li>官方明确表示推荐使用函数式组件</li></ul><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装 6 版本的 React Router。</p><pre><code class="shell">npm install react-router-dom</code></pre><p><code>index.js</code> 文件引入 <code>&lt;BrowserRouter&gt;</code>。</p><pre><code class="jsx">// 从 react-dom/client 引入 ReactDOMimport ReactDOM from &#39;react-dom/client&#39;import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;import App from &#39;./App&#39;// React 18 的语法发生改变了ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;)</code></pre><p><code>App.js</code> 设置路由链接和注册路由。<code>&lt;Route caseSensitive&gt;</code> 属性用于指定匹配时是否区分大小写（默认为 false）</p><pre><code class="jsx">import &#123; NavLink, Routes, Route &#125; from &#39;react-router-dom&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;// React 18 默认使用函数式组件了export default function App() &#123;  return (    &lt;div&gt;      &lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &lt;Routes&gt;        &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;        &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h3><p><code>&lt;BrowserRouter&gt;</code> 用于包裹整个应用。</p><pre><code class="jsx">import ReactDOM from &#39;react-dom/client&#39;import &#123; BrowserRouter &#125; from &#39;react-router-dom&#39;import App from &#39;./App&#39;ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;)</code></pre><h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><p>作用与 <code>&lt;BrowserRouter&gt;</code> 一样，但 <code>&lt;HashRouter&gt;</code> 修改的是地址栏的 hash 值。</p><p>6.x 版本中 <code>&lt;HashRouter&gt;</code>、<code>&lt;BrowserRouter&gt;</code> 的用法与 5.x 相同。</p><h3 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h3><p>6 版本中移出了 <code>&lt;Switch&gt;</code>，引入了新的替代者：<code>&lt;Routes&gt;</code>。</p><p><code>&lt;Routes&gt;</code> 和 <code>&lt;Route&gt;</code> 要配合使用，且必须要用 <code>&lt;Routes&gt;</code> 包裹 <code>&lt;Route&gt;</code>。</p><h3 id="Navigate-重定向"><a href="#Navigate-重定向" class="headerlink" title="Navigate-重定向"></a>Navigate-重定向</h3><p>只要 <code>&lt;Navigate&gt;</code> 组件被渲染，就会修改路径，切换视图。可用于<code>路由重定向</code>。</p><p><code>replace</code> 属性用于控制跳转模式（push 或 replace，默认是 push）。</p><pre><code class="jsx">import &#123; NavLink, Routes, Route, Navigate &#125; from &#39;react-router-dom&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;export default function App() &#123;  return (    &lt;div&gt;      &lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &lt;Routes&gt;        &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125;&gt;&lt;/Route&gt;        &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;&lt;/Route&gt;        &lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&quot;/about&quot; /&gt;&#125;&gt;&lt;/Route&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><pre><code class="jsx">import React, &#123; useState &#125; from &#39;react&#39;import &#123; Navigate &#125; from &#39;react-router-dom&#39;export default function Home() &#123;  const [sum, setSum] = useState(1)  return (    &lt;div&gt;      &lt;h1&gt;Home&lt;/h1&gt;      &#123;/* 根据sum的值决定是否切换视图 */&#125;      &#123;sum === 1 ? &lt;h4&gt;sum的值为&#123;sum&#125;&lt;/h4&gt; : &lt;Navigate to=&quot;/about&quot; replace=&#123;true&#125; /&gt;&#125;      &lt;button onClick=&#123;() =&gt; setSum(2)&#125;&gt;将sum变为 2&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="useRoutes-路由表"><a href="#useRoutes-路由表" class="headerlink" title="useRoutes() 路由表"></a>useRoutes() 路由表</h3><p>路由规则可以单独抽出一个模块。</p><pre><code class="jsx">// 路由表// routes/index.jsimport &#123; Navigate &#125; from &#39;react-router-dom&#39;import About from &#39;../components/About&#39;import Home from &#39;../components/Home&#39;const routes = [    &#123;        path: &#39;/about&#39;,        element: &lt;About /&gt;    &#125;,    &#123;        path: &#39;/home&#39;,        element: &lt;Home /&gt;    &#125;,    &#123;        path: &#39;/&#39;,        element: &lt;Navigate to=&quot;/home&quot; /&gt;    &#125;]export default routes</code></pre><pre><code class="jsx">// 引入路由表// App.jsimport &#123; NavLink, useRoutes &#125; from &#39;react-router-dom&#39;import routes from &#39;./routes&#39;export default function App() &#123;  // 生成路由规则  const element = useRoutes(routes)  return (    &lt;div&gt;      &lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &#123;element&#125;    &lt;/div&gt;  )&#125;</code></pre><h3 id="Outlet-嵌套路由"><a href="#Outlet-嵌套路由" class="headerlink" title="Outlet 嵌套路由"></a>Outlet 嵌套路由</h3><ul><li>嵌套路由中，需要使用 <code>&lt;Outlet&gt;</code> 设置子路由的路由出口，即在何处渲染子路由。</li><li>设置二级路由链接时，可以是 <code>to=&quot;news&quot;</code>、<code>to=&quot;./news&quot;</code>，但不能是 <code>to=&quot;/news&quot;</code>。</li></ul><p>不使用路由表的嵌套路由：</p><pre><code class="jsx">// App.jsexport default function App() &#123;  return (    &lt;div&gt;      &lt;NavLink to=&quot;about&quot;&gt;About&lt;/NavLink&gt;      &lt;NavLink to=&quot;home&quot;&gt;Home&lt;/NavLink&gt;      &lt;hr /&gt;      &lt;Routes&gt;        &lt;Route path=&quot;about&quot; element=&#123;&lt;About /&gt;&#125; /&gt;        &lt;Route path=&quot;home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;          &lt;Route path=&quot;news&quot; element=&#123;&lt;News /&gt;&#125; /&gt;          &lt;Route path=&quot;message&quot; element=&#123;&lt;Message /&gt;&#125; /&gt;        &lt;/Route&gt;        &lt;Route path=&quot;/&quot; element=&#123;&lt;Navigate to=&quot;about&quot; /&gt;&#125; /&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><p>使用路由表的嵌套路由：</p><pre><code class="jsx">// 路由表const routes = [  &#123;    path: &#39;/about&#39;,    element: &lt;About /&gt;,  &#125;,  &#123;    path: &#39;/home&#39;,    element: &lt;Home /&gt;,    // 定义二级路由，注意不要加 /    children: [      &#123;        path: &#39;news&#39;,        element: &lt;News /&gt;,      &#125;,      &#123;        path: &#39;message&#39;,        element: &lt;Message /&gt;,      &#125;,    ],  &#125;,  &#123;    path: &#39;/&#39;,    element: &lt;Navigate to=&quot;/about&quot; /&gt;,  &#125;,]</code></pre><pre><code class="jsx">// Home 子组件import React, &#123; Fragment &#125; from &#39;react&#39;import &#123; NavLink, Outlet &#125; from &#39;react-router-dom&#39;export default function Hello() &#123;  return (    &lt;Fragment&gt;      &lt;h2&gt;I am Hello!&lt;/h2&gt;      &#123;/* 子路由链接 */&#125;      &lt;NavLink to=&quot;news&quot;&gt;News&lt;/NavLink&gt;      &lt;NavLink to=&quot;message&quot;&gt;Message&lt;/NavLink&gt;      &lt;hr /&gt;      &#123;/* 子路由出口 */&#125;      &lt;Outlet&gt;&lt;/Outlet&gt;    &lt;/Fragment&gt;  )&#125;</code></pre><h3 id="NavLink-路由高亮"><a href="#NavLink-路由高亮" class="headerlink" title="NavLink 路由高亮"></a>NavLink 路由高亮</h3><p>实现导航的 “高亮” 效果，6 版本不能直接指定高亮类名，需要通过函数返回。该函数传入一个对象，类似于 <code>&#123;isActive: true&#125;</code> 标识路由是否被激活。</p><p>默认情况下，当 <code>Home</code> 的子组件匹配成功，<code>Home</code> 的导航也会高亮，<code>end</code> 属性可移除该效果。</p><pre><code class="jsx">// NavLink 默认类名是 active，下面是指定自定义类名//自定义样式&lt;NavLink    to=&quot;login&quot;    className=&#123;(&#123; isActive &#125;) =&gt; &#123;        console.log(&#39;home&#39;, isActive)        return isActive ? &#39;base MyClass&#39; : &#39;base&#39;    &#125;&#125;&gt;about&lt;/NavLink&gt;// 默认情况下，当 Home 的子组件匹配成功，Home 的导航也会高亮// 当 NavLink 上添加了 end 属性后，若 Home 的子组件匹配成功，则 Home 的导航没有高亮效果。&lt;NavLink to=&quot;home&quot; end &gt;home&lt;/NavLink&gt;</code></pre><h3 id="路由传参-1"><a href="#路由传参-1" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="传递-params参数"><a href="#传递-params参数" class="headerlink" title="传递 params参数"></a>传递 params参数</h4><p>注册路由时声明 <code>params</code> 参数，和 React Router 5 一样。</p><pre><code class="jsx">export default function App() &#123;  return (    &lt;div&gt;      &lt;Routes&gt;        &lt;Route path=&quot;home&quot; element=&#123;&lt;Home /&gt;&#125;&gt;          &lt;Route path=&quot;message&quot; element=&#123;&lt;Message /&gt;&#125;&gt;            &lt;Route path=&quot;detail/:id/:name/:age&quot; element=&#123;&lt;Detail /&gt;&#125; /&gt;          &lt;/Route&gt;        &lt;/Route&gt;      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;</code></pre><p>传递参数</p><pre><code class="jsx">&lt;Link to=&#123;`detail/$&#123;item.id&#125;/$&#123;item.name&#125;/$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;</code></pre><p>使用 <code>useParams()</code> 接收 <code>params</code> 参数。<code>useParams()</code> 返回一个参数对象。</p><pre><code class="jsx">import React from &#39;react&#39;import &#123; useParams, useMatch &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  // 解构赋值  const &#123; id, name, age &#125; = useParams()  return (    &lt;div&gt;      &lt;li&gt;id:&#123;id&#125;&lt;/li&gt;      &lt;li&gt;name:&#123;name&#125;&lt;/li&gt;      &lt;li&gt;age:&#123;age&#125;&lt;/li&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="传递-search参数"><a href="#传递-search参数" class="headerlink" title="传递 search参数"></a>传递 search参数</h4><p>和 5 版本一样，正常注册路由即可。</p><pre><code class="jsx">&lt;Route path=&quot;detail&quot; element=&#123;&lt;Detail /&gt;&#125; /&gt;</code></pre><p>传递参数。</p><pre><code class="jsx">&lt;Link to=&#123;`detail?id=$&#123;item.id&#125;&amp;name=$&#123;item.name&#125;&amp;age=$&#123;item.age&#125;`&#125;&gt;&#123;item.name&#125;&lt;/Link&gt;</code></pre><p>使用 <code>useSearchParams()</code> 接收参数。该方法返回一个包含两个元素的数组：<code>search</code> 参数和修改 <code>search</code> 参数的方法。</p><pre><code class="jsx">import React from &#39;react&#39;import &#123; useSearchParams &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  // 数组的解构赋值  const [searchParams, setSearchParams] = useSearchParams()  // 需要调用 get() 方法获取对应的参数值  const id = searchParams.get(&#39;id&#39;)  const name = searchParams.get(&#39;name&#39;)  const age = searchParams.get(&#39;age&#39;)  function change() &#123;    setSearchParams(&#39;id=666&amp;name=Lily&amp;age=888&#39;)  &#125;  return (    &lt;div&gt;      &lt;li&gt;id:&#123;id&#125;&lt;/li&gt;      &lt;li&gt;name:&#123;name&#125;&lt;/li&gt;      &lt;li&gt;age:&#123;age&#125;&lt;/li&gt;      &lt;button onClick=&#123;change&#125;&gt;Change search params&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="传递-state-参数"><a href="#传递-state-参数" class="headerlink" title="传递 state 参数"></a>传递 state 参数</h4><p>和 5 版本一样，正常注册路由即可。</p><pre><code class="jsx">&lt;Route path=&quot;detail&quot; element=&#123;&lt;Detail /&gt;&#125; /&gt;</code></pre><p>传递参数，这里相较于 5 版本有所不同，不必写到一个对象里面。</p><pre><code class="jsx">&lt;Link to=&quot;detail&quot; state=&#123;&#123; id: item.id, name: item.name, age: item.age &#125;&#125;&gt;  &#123;item.name&#125;&lt;/Link&gt;</code></pre><p>使用 <code>useLocation()</code> 接收参数。该方法返回路由组件的 <code>location</code> 对象，就是 5 版本路由组件的 <code>location</code> 属性，其中包含 <code>state</code> 参数。</p><pre><code class="jsx">import &#123; useLocation &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  // 连续解构赋值  const &#123;    state: &#123; id, name, age &#125;,  &#125; = useLocation()  return (    &lt;div&gt;      &lt;li&gt;id:&#123;id&#125;&lt;/li&gt;      &lt;li&gt;name:&#123;name&#125;&lt;/li&gt;      &lt;li&gt;age:&#123;age&#125;&lt;/li&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="useNavigate-编程式路由导航"><a href="#useNavigate-编程式路由导航" class="headerlink" title="useNavigate() 编程式路由导航"></a>useNavigate() 编程式路由导航</h3><p><code>useNavigate()</code> 返回一个函数，调用该函数实现编程式路由导航。函数有两种参数传递方式。</p><p>第一种方式传递两个参数：路由和相关参数。参数只能设置 <code>replace</code> 和 <code>state</code>。<strong style="color:red">想要传递 <code>params</code> 和 <code>search</code> 参数直接在路由带上</strong>。</p><p>第二种方式传递数字，代表前进或后退几步。</p><pre><code class="jsx">import React, &#123; useState &#125; from &#39;react&#39;import &#123; Outlet, useNavigate &#125; from &#39;react-router-dom&#39;export default function Message() &#123;  const [list] = useState([    &#123; id: 1, name: &#39;Bruce&#39;, age: 33 &#125;,    &#123; id: 2, name: &#39;You&#39;, age: 3 &#125;,    &#123; id: 3, name: &#39;React&#39;, age: 333 &#125;,  ])  const navigate = useNavigate()  function showDetail(item) &#123;    navigate(&#39;detail&#39;, &#123;      replace: true,      state: &#123;        id: item.id,        name: item.name,        age: item.age,      &#125;,    &#125;)  &#125;  function back() &#123;    navigate(1)  &#125;  function forward() &#123;    navigate(-1)  &#125;  return (    &lt;div&gt;      &lt;ul&gt;        &#123;list.map((item) =&gt; &#123;          return (            &lt;li key=&#123;item.id&#125;&gt;              &lt;button onClick=&#123;() =&gt; showDetail(item)&#125;&gt;查看详情&lt;/button&gt;              &lt;button onClick=&#123;back&#125;&gt;后退&lt;/button&gt;              &lt;button onClick=&#123;forward&#125;&gt;前进&lt;/button&gt;            &lt;/li&gt;          )        &#125;)&#125;      &lt;/ul&gt;      &lt;Outlet&gt;&lt;/Outlet&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="Other-Hooks-了解"><a href="#Other-Hooks-了解" class="headerlink" title="Other Hooks(了解)"></a>Other Hooks(了解)</h3><h4 id="useMatch"><a href="#useMatch" class="headerlink" title="useMatch()"></a>useMatch()</h4><p>返回路由组件的 <code>match</code> 数据，即 5 版本中的 <code>match</code> 属性。</p><p>必须传入该组件对应的路由规则才能正确返回，否则返回 <code>null</code>。</p><pre><code class="jsx">// Detail.jsximport &#123; useParams, useMatch &#125; from &#39;react-router-dom&#39;export default function Detail() &#123;  const match = useMatch(&#39;home/message/detail/:id/:name/:age&#39;)  console.log(match)  return (    &lt;div&gt;      &lt;li&gt;id&lt;/li&gt;    &lt;/div&gt;  )&#125;/*params: &#123;id: &#39;1&#39;, name: &#39;tom&#39;, age: &#39;33&#39;&#125;pathname: &quot;/home/message/detail/1/tom/33&quot;pathnameBase: &quot;/home/message/detail/1/tom/33&quot;pattern: &#123;path: &#39;home/message/detail/:id/:name/:age&#39;, caseSensitive: false, end: true&#125;*/</code></pre><h4 id="useInRouterContext"><a href="#useInRouterContext" class="headerlink" title="useInRouterContext"></a>useInRouterContext</h4><p>如果组件在 <code>&lt;Router&gt;</code> 的上下文中呈现，则 <code>useInRouterContext</code> 钩子返回 <code>true</code>，否则返回 <code>false</code>。即组件有没有被包裹在 <code>&lt;BrowserRouter&gt;</code> 这种东西里面。这个对第三方组件库有用处。</p><h4 id="useNavigationType"><a href="#useNavigationType" class="headerlink" title="useNavigationType"></a>useNavigationType</h4><p>返回当前的导航类型（用户是如何来到当前页面的）。</p><p>返回值：<code>POP</code>、<code>PUSH</code>、<code>REPLACE</code>。</p><p><code>POP</code> 是指在浏览器中直接打开了这个路由组件（<code>刷新页面</code>）。</p><h4 id="useOutlet"><a href="#useOutlet" class="headerlink" title="useOutlet"></a>useOutlet</h4><p>用来呈现当前组件中渲染的嵌套路由。</p><pre><code class="jsx">const result = useOutlet()console.log(result)// 如果嵌套路由没有挂载,则返回 null// 如果嵌套路由已经挂载,则展示嵌套的路由对象</code></pre><h4 id="useResolvedPath"><a href="#useResolvedPath" class="headerlink" title="useResolvedPath"></a>useResolvedPath</h4><p>给定一个 URL 值，解析其中的：<code>path</code>、<code>search</code>、<code>hash</code> 值。</p><pre><code class="jsx">const res = useResolvedPath(&#39;/user?id=001&amp;name=tom#React&#39;)console.log(res)/*hash: &#39;#React&#39;pathname: &#39;/user&#39;search: &#39;?id=001&amp;name=tom&#39;*/</code></pre>]]></content>
    
    
    <summary type="html">react基础、react-router5/6、react-redux等</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="react" scheme="https://heliufang.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vue3.2新特性笔记</title>
    <link href="https://heliufang.github.io/posts/304cd95d/"/>
    <id>https://heliufang.github.io/posts/304cd95d/</id>
    <published>2022-12-09T13:20:28.000Z</published>
    <updated>2023-01-08T03:53:03.031Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1hh411p79n/">vue3.2视频教程</a></p><h2 id="script-setup基本语法"><a href="#script-setup基本语法" class="headerlink" title="script setup基本语法"></a>script setup基本语法</h2><p>要使用这个语法，需要将 <code>setup</code> 属性添加到 <code>&lt;script&gt;</code> 代码块上：</p><p>里面的代码会被编译成组件<code> setup()</code> 函数的内容。</p><p>这也就意味着与普通的 <code>&lt;script&gt;</code> 只在组件被首次引入的时候<strong style="color:red">仅执行一次不同</strong>，<code>&lt;script setup&gt;</code> 中的代码会在<strong style="color:red">每次组件实例被创建的时候执行</strong>。这一点非常的重要，也就是写在<code> &lt;script setup&gt;</code> 中的代码，例如初始化的赋值等在组件每次实例创建时都重新执行一次。</p><pre><code class="html">&lt;script setup&gt;const a = ref(1);console.log(&#39;hello script setup&#39;)&lt;/script&gt;</code></pre><p>当使用 <code>&lt;script setup&gt;</code> 的时候，任何在<code> &lt;script setup&gt;</code> 声明的顶层的绑定 (包括声明的<code>变量</code>，<code>函数声明</code>，以及 <code>import 引入的内容</code>) 都能<strong style="color:red">在模板中直接使用，不再需要使用 return 导出。</strong></p><h2 id="script-setup新特性"><a href="#script-setup新特性" class="headerlink" title="script setup新特性"></a>script setup新特性</h2><h3 id="自动组件名推断"><a href="#自动组件名推断" class="headerlink" title="自动组件名推断"></a>自动组件名推断</h3><p>在 vue2.x options API 和使用普通的 <code>&lt;script&gt;</code> 的情况下，都可以为组件进行命名</p><p>但是在 <code>&lt;script setup&gt;</code> 下，却并没有提供直接的方式来设置的组件的名称，因此，vue 在上述情况下会依据它的<strong style="color:red">文件名</strong>来自动推断组件名称。</p><p>例如：名为 <code>Foo.vue</code> 的文件可以在模板中用 <code>&lt;Foo/&gt;</code> 引用它自己，在 devtools 中看到的组件名称也是 <code>Foo</code>。</p><p>使用 <code>&lt;script setup&gt;</code> 的情况下如何修改注册组件名呢？？&#x3D;&#x3D;&#x3D;&gt;使用script</p><pre><code class="html">&lt;script lang=&quot;ts&quot;&gt;export default &#123; name: &#39;CustomComponentsName&#39; &#125;&lt;/script&gt;&lt;script setup lang=&quot;ts&quot;&gt;// code&lt;/script&gt;&lt;template&gt;    &lt;p&gt;利用 script 自定义组件名称&lt;/p&gt;&lt;/template&gt;</code></pre><h3 id="普通组件"><a href="#普通组件" class="headerlink" title="普通组件"></a>普通组件</h3><p><code>&lt;script setup&gt;</code> 中引入组件后可直接在模板使用，不再需要注册了。</p><pre><code class="html">&lt;script setup lang=&#39;ts&#39;&gt;import SaySomething from &quot;./Components/SaySomething.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;SaySomething /&gt;&lt;/template&gt;</code></pre><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>动态组件仍然是使用 <code>is</code>，相对于 vue2.x 没有变化</p><pre><code class="html">&lt;script setup lang=&#39;ts&#39;&gt;import &#123; ref &#125; from &quot;vue&quot;;import Bar from &quot;./Components/Bar.vue&quot;;import Foo from &quot;./Components/Foo.vue&quot;;const condition = ref(false);setTimeout(() =&gt; condition.value = true, 2000);&lt;/script&gt;&lt;template&gt;  &lt;component :is=&quot;condition ? Bar : Foo&quot;/&gt;&lt;/template&gt;</code></pre><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>因为自动组件名推断的缘故，一个单文件组件可以通过它的文件名被其自己所引用。例如：名为 Foo.vue 的组件可以在其模板中用 <code>&lt;Foo/&gt;</code> 引用它自己。</p><p>请注意这种方式相比于 import 导入的组件和自主注册的组件<strong style="color:red">优先级更低</strong>。所有如果有命名的 import 导入和组件的推断名冲突了，可以使用 import 别名导入：</p><pre><code class="js">import &#123; Foo as FooChild &#125; from &#39;./components&#39;</code></pre><h3 id="命名空间组件"><a href="#命名空间组件" class="headerlink" title="命名空间组件"></a>命名空间组件</h3><p>可以使用带点的组件标记，例如 <code>&lt;Foo.Bar&gt;</code> 来引用嵌套在对象属性中的组件。这在需要从单个文件中导入多个组件的时候非常有用：</p><p><code>Components/index.ts</code> 用于导出组件</p><pre><code class="js">import Foo from &#39;./Foo.vue&#39;;import Bar from &#39;./Bar.vue&#39;;export &#123; Foo, Bar &#125;;</code></pre><p><code>index.vue</code> 基于命名空间使用组件</p><pre><code class="html">&lt;script setup lang=&#39;ts&#39;&gt;import * as Form from &quot;../Components&quot;;&lt;/script&gt;&lt;template&gt;  &lt;Form.Foo /&gt;  &lt;Form.Bar /&gt;&lt;/template&gt;</code></pre><h3 id="props的使用"><a href="#props的使用" class="headerlink" title="props的使用"></a>props的使用</h3><p>接受父组件传递过来的属性</p><h4 id="definedProps"><a href="#definedProps" class="headerlink" title="definedProps"></a>definedProps</h4><p>为了在<code> &lt;script setup&gt;</code> 中 声明 props ，必须使用 <code>defineProps</code> API，这是一个宏命令，不需要导入，直接可在<code> &lt;script setup&gt;</code> 使用且只能在 <code>&lt;script setup&gt;</code> 中使用，有两种方式可以使用这个宏命令类声明 props，<code>运行时声明</code>和<code>类型声明式</code>，不同的方式下使用这个宏命令后 props 将具备不同的类型推断。</p><ul><li>使用运行时声明（runtime declaration）</li></ul><p>defineProps 运行时声明的基本用法如下，<code>仅支持运行时的校验</code>。<em>和vue2类似</em></p><pre><code class="java">&lt;script setup lang=&#39;ts&#39;&gt;const props = defineProps(&#123;    foo: String,    bar: &#123;      type: Number,      required: true    &#125;&#125;)&lt;/script&gt;</code></pre><ul><li>类型声明（type declaration）</li></ul><p><code>defineProps</code> 类型声明的基本用法如下，完美的支持 IDE 的类型推断和检查。<strong style="color:red">推荐这种方式</strong></p><pre><code class="html">&lt;script setup lang=&#39;ts&#39;&gt;const props = defineProps&lt;&#123;  foo?: string  //?表示可选,不带?表示必传  bar: number&#125;&gt;()&lt;/script&gt;</code></pre><p>运行时声明和类型声明的比较</p><table><thead><tr><th>类型</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>运行时声明</td><td>不使用 ts 的情况下能够对 props 进行一定的、运行时的类型校验</td><td>1. 运行时校验2. 只能进行基本类型的校验3. 编码时无任何提示</td></tr><tr><td>类型声明</td><td>完美的支持类型的校验，包括props 的完美类型约束、父组件在传 props 时的提示以及子组件在使用 props 的提示</td><td>目前 ts 的<strong style="color:red">接口暂时只支持写在本组件的文件内</strong>，未来应该会实现可从外部导入的，但目前可通过ts自动扫描types来解决</td></tr></tbody></table><h4 id="widthDefaults"><a href="#widthDefaults" class="headerlink" title="widthDefaults"></a>widthDefaults</h4><p><code>defineProps</code> 使用类型声明时的不足之处在于，它没有可以给 props 提供默认值的方式。为了解决这个问题，提供了 <code>withDefaults</code> 宏命令。</p><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;const props = withDefaults(defineProps&lt;&#123;  title?: string,  list?: List.Basic[],&#125;&gt;(), &#123;  title: &#39;Hello withDefaults&#39;,  list: () =&gt; [&#123; id: 3, content: &#39;3&#39;, isDone: false &#125;],&#125;);&lt;/script&gt;</code></pre><p>注意：<code>widthDefaults</code> 是为了给 <code>defineProps</code> 使用类型声明时提供添加默认值的的方法，因此，需要注意这仅仅适用于 <code>&lt;script setup lang=&#39;ts&#39;&gt;</code> 且 <code>defineProps</code> 使用类型声明。</p><h3 id="自定义事件-defineEmits"><a href="#自定义事件-defineEmits" class="headerlink" title="自定义事件-defineEmits"></a>自定义事件-defineEmits</h3><p>在 <code>&lt;script setup&gt;</code> 中 声明 <code>emit</code> ，必须使用 <code>defineEmits</code> API，这也是一个宏命令。同样可采用运行时声明和类型声明式两种方式，在类型声明下 <code>emit</code> 将具备完美的类型推断。</p><ul><li>运行时声明</li></ul><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;// 这样是没有任何的类型检查的const emit = defineEmits([&#39;handleClick&#39;, &#39;handleChange&#39;]);const handleClick = () =&gt; emit(&#39;handleClick&#39;, Date.now()+&#39;&#39;);const handleChange = () =&gt; emit(&#39;handleChange&#39;, Date.now());&lt;/script&gt;</code></pre><ul><li>类型声明</li></ul><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;interface Click &#123;  id: string,  val: number,&#125;// 完美的类型检查// List.Basic 是基于 ts 自动扫描 types 文件夹以及 delcare namespace 自动导入的const emit = defineEmits&lt;&#123;  (e: &#39;handleClickWithTypeDeclaration&#39;, data: Click): void,  (e: &#39;handleChangeWithTypeDeclaration&#39;, data: List.Basic): void,&#125;&gt;();const handleClickWithTypeDeclaration = () =&gt; emit(&#39;handleClickWithTypeDeclaration&#39;, &#123; id: &#39;1&#39;, val: Date.now() &#125;);const handleChangeWithTypeDeclaration = () =&gt; emit(&#39;handleChangeWithTypeDeclaration&#39;, &#123;  id: 1,  content: &#39;change&#39;,  isDone: false,&#125;);&lt;/script&gt;</code></pre><p>跟 <code>defineProps</code> 一样，运行时声明和类型声明式同样不可同时使用，且类型声明只能用于在 ts 环境下。</p><h3 id="显示的暴露-defineExpose"><a href="#显示的暴露-defineExpose" class="headerlink" title="显示的暴露-defineExpose"></a>显示的暴露-defineExpose</h3><p>官方文档指出默认情况下使用 <code>&lt;script setup&gt;</code> 的组件是默认关闭的，也就是说通过<code>模板 ref</code> 或者 <code>$parent</code> 链获取到的子组件的实例，并不会暴露任何在<code> &lt;script setup&gt;</code> 中声明的绑定（变量，函数）。</p><p>为了在<code> &lt;script setup&gt;</code> 组件中明确要暴露出去的属性，那么就需要使用 <code>defineExpose</code> 这个宏命令。</p><pre><code class="html">&lt;script setup&gt;import &#123; ref &#125; from &#39;vue&#39;const a = 1const b = ref(2)defineExpose(&#123;  a,  b&#125;)&lt;/script&gt;</code></pre><p>当父组件通过模板 ref 的方式获取到当前子组件的实例，获取到的实例会像这样 <code>&#123; a: number, b: number &#125;</code> (ref 会和在普通实例中一样被自动解包)</p><h3 id="useSlots-和-useAttrs"><a href="#useSlots-和-useAttrs" class="headerlink" title="useSlots 和 useAttrs"></a>useSlots 和 useAttrs</h3><p>在 <code>&lt;script setup&gt;</code> 使用 <code>slots</code> 和 <code>attrs</code> 获取插槽和兜底属性，可以用 <code>useSlots</code> 和 <code>useAttrs</code> 两个函数</p><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useSlots, useAttrs &#125; from &quot;vue&quot;;const slot = useSlots();console.log(&#39;TestUseSlots&#39;, slot.header &amp;&amp; slot.header());        // 获取到使用插槽的具体信息  const attrs = useAttrs();console.log(&#39;TestUseAttrs&#39;, attrs);        // 获取到使用组件时传递的 attributes&lt;/script&gt;&lt;template&gt;  &lt;h1&gt; Here is slots test!!&lt;/h1&gt;  &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;&lt;/template&gt;</code></pre><p><code>useSlots</code> 和 <code>useAttrs</code> 是真实的运行时函数，它会返回与 <code>setupContext.slots</code> 和 <code>setupContext.attrs</code> 等价的值，同样也能在普通的 <code>composition API</code> 中使用。</p><h3 id="与普通的script一起使用"><a href="#与普通的script一起使用" class="headerlink" title="与普通的script一起使用"></a>与普通的script一起使用</h3><p><code>&lt;script setup&gt;</code> 可以和普通的 <code>&lt;script&gt;</code> 一起使用。普通的 <code>&lt;script&gt; </code>在有这些需要的情况下或许会被使用到：</p><ul><li>无法在<code>&lt;script setup&gt;</code>声明的选项，例如 inheritAttrs 或通过插件启用的自定义的选项。</li><li>显示定义组件的名称。</li><li>运行副作用或者创建只需要执行一次的对象。</li></ul><pre><code class="html">&lt;script&gt;// 普通 &lt;script&gt;, 在模块范围下执行(只执行一次)runSideEffectOnce()// 声明额外的选项export default &#123;  inheritAttrs: false,  customOptions: &#123;&#125;&#125;&lt;/script&gt;&lt;script setup&gt;// 在 setup() 作用域中执行 (对每个实例皆如此)&lt;/script&gt;</code></pre><p>注意：如果同时使用 <code>&lt;script setup&gt;</code> 和 <code>&lt;script&gt;</code> ，那么将打破 <code>&lt;script setup&gt;</code> 的默认关闭（即外部无法获取组件内部的属性和方法），此时，子组件内部的属性和方法都将在外部可获取到，如 <code>ref.xxx</code></p><h3 id="顶层await-了解"><a href="#顶层await-了解" class="headerlink" title="顶层await(了解)"></a>顶层await(了解)</h3><p><code>await</code> 的使用必须是要在<code>async</code> 语法糖的包裹下，否者将无法执行，为了更简化代码， <code>&lt;script setup&gt;</code> 中可以使用顶层 <code>await</code>。</p><pre><code class="html">&lt;script setup&gt;const post = await fetch(`/api/post/1`).then(r =&gt; r.json())&lt;/script&gt;</code></pre><h2 id="限制使用src-导入-了解"><a href="#限制使用src-导入-了解" class="headerlink" title="限制使用src 导入(了解)"></a>限制使用src 导入(了解)</h2><p>SFC 的三个模块都可以通过 <code>src</code> 的方式进行导入，如下所示：</p><pre><code class="html">&lt;template src=&quot;./template.html&quot;&gt;&lt;/template&gt;&lt;style src=&quot;./style.css&quot;&gt;&lt;/style&gt;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;</code></pre><p>但是在<code> &lt;script setup&gt;</code>下强烈建议不使用 Src 导入。</p><p>由于模块执行语义的差异，<code>&lt;script setup&gt;</code> 中的代码依赖单文件组件的上下文。当将其移动到外部的 .js 或者 .ts 文件中的时候，对于开发者和工具来说都会感到混乱。因而<code> &lt;script setup&gt;</code> 不能和<code> src attribute</code> 一起使用。</p><h2 id="style-v-bind-新特性"><a href="#style-v-bind-新特性" class="headerlink" title="style  v-bind 新特性"></a>style  v-bind 新特性</h2><h3 id="style-module-了解"><a href="#style-module-了解" class="headerlink" title="style module(了解)"></a>style module(了解)</h3><p>设计和使用上跟 Vue2.x 是一致的，因此也不多赘述。<br>唯一新的点是使用 <code>&lt;script setup&gt;</code> 时，可以使用 <code>useCssModule</code> API 获取到 css module 对象。</p><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useCssModule &#125; from &quot;vue&quot;;const css = useCssModule();console.log(css);        // &#123; blue: &quot;_blue_13cse_5&quot;, red: &quot;_red_13cse_2&quot;&#125;&lt;/script&gt;&lt;style module&gt;.red &#123;  color: red;&#125;.blue &#123;  color: blue;&#125;&lt;/style&gt;</code></pre><h3 id="动态css"><a href="#动态css" class="headerlink" title="动态css"></a>动态css</h3><p>单文件组件的 <code>&lt;style&gt;</code> 标签可以通过 <code>v-bind</code> 这一 CSS 函数将 CSS 的值关联到动态的组件状态上，<strong>有了这一特性，可以将大量的动态样式通过状态来驱动了，而不是写动态的 calss 类名或者获取 dom 来动态设置了</strong>。</p><pre><code class="html">&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &quot;vue&quot;;const color = ref(&#39;red&#39;);setTimeout(() =&gt; color.value = &#39;blue&#39; , 2000);&lt;/script&gt;&lt;template&gt;  &lt;p&gt;hello&lt;/p&gt;&lt;/template&gt;&lt;style scoped&gt;p &#123;  color: v-bind(color);&#125;&lt;/style&gt;</code></pre><h2 id="volar插件"><a href="#volar插件" class="headerlink" title="volar插件"></a>volar插件</h2><p>vue3必备vscode的插件，安装后有代码提示、点击css类&#x2F;组件跳转、自动补全等等功能！</p>]]></content>
    
    
    <summary type="html">vue3.2新特性，以setup语法糖为核心的相关api学习笔记</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>node笔记</title>
    <link href="https://heliufang.github.io/posts/f2f1536e/"/>
    <id>https://heliufang.github.io/posts/f2f1536e/</id>
    <published>2022-10-30T11:19:28.000Z</published>
    <updated>2023-01-08T03:53:03.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node基本概念"><a href="#node基本概念" class="headerlink" title="node基本概念"></a>node基本概念</h2><h3 id="node是什么"><a href="#node是什么" class="headerlink" title="node是什么"></a>node是什么</h3><p>node.js，也叫作node，或者nodejs，指的都是一个东西。</p><ol><li><a href="https://nodejs.org/">node.js官方网站</a></li><li><a href="http://nodejs.cn/">node.js中文网</a></li><li><a href="https://cnodejs.org/">node.js 中文社区</a></li><li><a href="https://www.runoob.com/nodejs/nodejs-tutorial.html">菜鸟教程-node</a></li></ol><p>Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。 </p><ul><li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</li></ul><pre><code>1. nodejs是在服务端运行javascript的运行环境2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎。</code></pre><ul><li>Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，使其轻量又高效。  </li><li>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li></ul><p><strong>nodejs的本质：不是一门新的编程语言，nodejs是javascript运行在服务端的运行环境，编程语言还是javascript</strong></p><h3 id="nodejs与浏览器的区别"><a href="#nodejs与浏览器的区别" class="headerlink" title="nodejs与浏览器的区别"></a>nodejs与浏览器的区别</h3><p>相同点：nodejs与浏览器都是浏览器的运行环境，都能够解析js程序。对于ECMAScript语法来说，在nodejs和浏览器中都能运行。</p><p>不同点：<code>nodejs无法使用DOM和BOM的操作</code>，浏览器无法执行nodejs中的文件操作等功能</p><p><img src="/posts/f2f1536e/image-20221024215658030.png" alt="image-20221024215658030"></p><h3 id="nodejs可以干什么？"><a href="#nodejs可以干什么？" class="headerlink" title="nodejs可以干什么？"></a>nodejs可以干什么？</h3><ol><li>开发服务端程序</li><li>开发命令行工具（CLI），比如npm,webpack,gulp,less,sass等</li><li>开发桌面应用程序（借助 node-webkit、<code>electron</code> 等框架实现）</li></ol><h2 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h2><p>下载地址</p><ul><li><a href="https://nodejs.org/en/download/">当前版本</a></li><li><a href="https://nodejs.org/en/download/releases/">历史版本</a></li></ul><p>官网术语解释</p><ul><li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li><li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入。</li></ul><p>下载之后一直点下一步即可完成安装，安装之后查看node版本</p><pre><code class="bash">node -v</code></pre><h2 id="运行node程序"><a href="#运行node程序" class="headerlink" title="运行node程序"></a>运行node程序</h2><h3 id="repl方式"><a href="#repl方式" class="headerlink" title="repl方式"></a>repl方式</h3><ol><li>REPL 全称: Read-Eval-Print-Loop（交互式解释器）<ul><li>R 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</li><li>E 执行 - 执行输入的数据结构</li><li>P 打印 - 输出结果</li><li>L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。</li></ul></li><li>在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能）<ul><li>直接在控制台输入 <code>node</code> 命令进入 REPL 环境</li></ul></li><li>按两次 Control + C 退出REPL界面 或者 输入 <code>.exit</code> 退出 REPL 界面<ul><li>按住 control 键不要放开, 然后按两下 c 键</li></ul></li></ol><p><img src="/posts/f2f1536e/image-20221024220716342.png" alt="image-20221024220716342"></p><h3 id="node执行js文件方式-掌握"><a href="#node执行js文件方式-掌握" class="headerlink" title="node执行js文件方式(掌握)"></a>node执行js文件方式(掌握)</h3><ul><li>创建js文件 <code>helloworld.js</code></li></ul><ul><li>写nodejs的内容：<code>console.log(&#39;hello nodejs&#39;)</code></li><li>打开命令窗口 <code>cmd</code><ul><li>shift加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li><li>给vscode安装<code>terminal</code>插件，直接在vscode中执行</li></ul></li><li>执行命令：<code>node helloworld.js</code></li></ul><p>注意：<strong style="color:red">在nodejs中是无法使用DOM和BOM的内容的，因此<code>document, window</code>等内容是无法使用的。</strong></p><h2 id="node常用模块"><a href="#node常用模块" class="headerlink" title="node常用模块"></a>node常用模块</h2><h3 id="global模块-全局变量"><a href="#global模块-全局变量" class="headerlink" title="global模块(全局变量)"></a>global模块(全局变量)</h3><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p><p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 <code>global</code>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p><p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p><p>常用的global属性</p><pre><code class="js">console: //用于打印日志setTimeout/clearTimeout: //设置清除延时器setInterval/clearInterval: //设置清除定时器__dirname: //当前文件的路径，不包括文件名__filename： //获取当前文件的路径，包括文件名//与模块化相关的，模块化的时候会用到requireexportsmodule</code></pre><h3 id="fs模块-操作文件"><a href="#fs模块-操作文件" class="headerlink" title="fs模块(操作文件)"></a>fs模块(操作文件)</h3><blockquote><p>fs模块是nodejs中最常用的一个模块，因此掌握fs模块非常的有必要，fs模块的方法非常多,用到了哪个查哪个即可。</p><p>文档地址：<a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p></blockquote><p>  在nodejs中，提供了fs模块，这是node的核心模块</p><p>  注意：</p><ol><li>除了global模块中的内容可以直接使用，其他<strong style="color:red">模块都是需要加载的</strong>。</li><li>fs模块不是全局的，不能直接使用。因此需要导入才能使用。</li></ol><pre><code class="js">let fs = require(&quot;fs&quot;);</code></pre><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><blockquote><p>语法：fs.readFile(path[,options], callback</p><p>path: 带文件名称的文件路径</p><p>options： 文件编码(可选) 若不传则返回buffer对象</p><p>callback(err,data):   文件读完的回调</p></blockquote><p>方式1：不传编码参数,回调函数中可以得到buffer对象,需要使用toString转化成字符串</p><pre><code class="js">let fs = require(&#39;fs&#39;)fs.readFile(&#39;1.txt&#39;,(err,data) =&gt; &#123;    console.log(data) //打印buffer对象    console.log(data.toString()) //正常打印字符串&#125;)</code></pre><p>方式2： 传编码参数,回调函数中可以得到读取到的字符串</p><pre><code class="js">let fs = require(&#39;fs&#39;)fs.readFile(&#39;1.txt&#39;,&#39;utf-8&#39;,(err,data) =&gt; &#123;    console.log(&#39;data :&gt;&gt; &#39;, data);&#125;)</code></pre><p>关于Buffer对象</p><pre><code>1. Buffer对象是Nodejs用于处理二进制数据的。2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制。3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象4. Buffer对象可以调用toString()方法转换成字符串。</code></pre><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><blockquote><p>语法：fs.writeFile(filepath, data[, options], callback)</p><p>filepath：带文件名称的文件路径</p><p>data： 要写入的文件内容</p><p>callback(err)： 写入成功之后的回调</p></blockquote><p>注意：此方式会把之前文件的内容覆盖</p><pre><code class="js">let fs = require(&#39;fs&#39;)fs.writeFile(&#39;2.txt&#39;,&#39;node写文件&#39;,err =&gt; &#123;    console.log(&#39;写入成功！&#39;)&#125;)</code></pre><h4 id="追加文件"><a href="#追加文件" class="headerlink" title="追加文件"></a>追加文件</h4><blockquote><p>语法：fs.appendFile(filepath, data[, options], callback)</p><p>filepath：带文件名称的文件路径</p><p>data： 要追加的文件内容</p><p>callback(err)： 追加成功之后的回调</p></blockquote><pre><code class="js">let fs = require(&#39;fs&#39;)fs.appendFile(&#39;2.txt&#39;,&#39;我是追加的&#39;,err =&gt; &#123;    console.log(&#39;追加成功！&#39;)&#125;)</code></pre><p>思考：如果没有appendFile，通过readFile与writeFile应该怎么实现？</p><pre><code>先把之前的内容readFile读取再将之前的内容+新内容拼串最后把拼接好的内容通过writeFile写入文件</code></pre><h4 id="文件的同步与异步"><a href="#文件的同步与异步" class="headerlink" title="文件的同步与异步"></a>文件的同步与异步</h4><blockquote><p>fs中所有的文件操作，都提供了异步和同步两种方式</p></blockquote><p>异步方式：不会阻塞代码的执行</p><pre><code class="js">//异步方式var fs = require(&quot;fs&quot;);console.log(111);fs.readFile(&quot;2.txt&quot;, &quot;utf8&quot;, function(err, data)&#123;  if(err) &#123;    return console.log(&quot;读取文件失败&quot;, err);  &#125;  console.log(data);&#125;);console.log(&quot;222&quot;);</code></pre><p>同步方式：会阻塞代码的执行</p><pre><code class="js">//同步方式console.log(111);var result = fs.readFileSync(&quot;2.txt&quot;, &quot;utf-8&quot;);console.log(result);console.log(222);</code></pre><p><strong style="color:red">总结</strong>：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p><h4 id="其他api（了解）"><a href="#其他api（了解）" class="headerlink" title="其他api（了解）"></a>其他api（了解）</h4><p>方法有很多，但是用起来都非常的简单，学会查文档。文档：<a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>fs.readFile(path, callback)</code></td><td>读取文件内容（异步）</td></tr><tr><td><code>fs.readFileSync(path)</code></td><td>读取文件内容（同步）</td></tr><tr><td><code>fs.writeFile(path, data, callback)</code></td><td>写入文件内容（异步）</td></tr><tr><td><code>fs.writeFileSync(path, data)</code></td><td>写入文件内容（同步）</td></tr><tr><td><code>fs.appendFile(path, data, callback)</code></td><td>追加文件内容（异步）</td></tr><tr><td><code>fs.appendFileSync(path, data)</code></td><td>追加文件内容（同步）</td></tr><tr><td><code>fs.rename(oldPath, newPath, callback)</code></td><td>重命名文件（异步）</td></tr><tr><td><code>fs.renameSync(oldPath, newPath)</code></td><td>重命名文件（同步）</td></tr><tr><td><code>fs.unlink(path, callback)</code></td><td>删除文件（异步）</td></tr><tr><td><code>fs.unlinkSync(path)</code></td><td>删除文件（同步）</td></tr><tr><td><code>fs.mkdir(path, mode, callback)</code></td><td>创建文件夹（异步）</td></tr><tr><td><code>fs.mkdirSync(path, mode)</code></td><td>创建文件夹（同步）</td></tr><tr><td><code>fs.rmdir(path, callback)</code></td><td>删除文件夹（异步）</td></tr><tr><td><code>fs.rmdirSync(path)</code></td><td>删除文件夹（同步）</td></tr><tr><td><code>fs.readdir(path, option, callback)</code></td><td>读取文件夹内容（异步）</td></tr><tr><td><code>fs.readdirSync(path, option)</code></td><td>读取文件夹内容（同步）</td></tr><tr><td><code>fs.stat(path, callback)</code></td><td>查看文件状态（异步）</td></tr><tr><td><code>fs.statSync(path)</code></td><td>查看文件状态（同步）</td></tr></tbody></table><h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><h4 id="创建服务器基本步骤"><a href="#创建服务器基本步骤" class="headerlink" title="创建服务器基本步骤"></a>创建服务器基本步骤</h4><pre><code class="js">//1. 导入http模块，http模块是node的核心模块，作用是用来创建http服务器的。let http = require(&quot;http&quot;);//2. 创建服务器-createServer方法let server = http.createServer();//3. 服务器处理请求-on监听request事件server.on(&quot;request&quot;, function() &#123;  console.log(&quot;我接收到请求了&quot;);&#125;);//4. 启动服务器，监听某个端口-通过listen监听某个端口来启动服务server.listen(9999, function()&#123;  console.log(&quot;服务器启动成功了, 请访问： http://localhost:9999&quot;);&#125;);</code></pre><p>详细说明</p><ol><li>给服务器注册request事件，只要服务器接收到了客户端的请求，就会触发request事件</li><li>request事件有两个参数，request表示请求对象，可以获取所有与请求相关的信息，response是响应对象，可以获取所有与响应相关的信息。</li><li>服务器监听的端口范围为：1-65535之间，推荐使用3000以上的端口，因为3000以下的端口一般留给系统使用</li></ol><h4 id="request对象详解"><a href="#request对象详解" class="headerlink" title="request对象详解"></a>request对象详解</h4><p>文档地址：<a href="http://nodejs.cn/api/http.html#http_message_headers">http://nodejs.cn/api/http.html#http_message_headers</a></p><p>常见属性：</p><pre><code class="javascript">method： 请求的方式url： 请求的地址headers: 所有的请求头信息rawHeaders： 所有的请求头信息（数组的方式）</code></pre><p>例如</p><pre><code class="js">let http = require(&#39;http&#39;)let server = http.createServer()server.on(&#39;request&#39;,(request,response) =&gt; &#123;    let &#123;method,url&#125; = request    console.log(&#39;method :&gt;&gt; &#39;, method);    console.log(&#39;url :&gt;&gt; &#39;, url);&#125;)server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))</code></pre><p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求。</p><p>小结：request对象中，常用的就是<code>method</code>和<code>url</code>两个参数</p><h4 id="response对象详解"><a href="#response对象详解" class="headerlink" title="response对象详解"></a>response对象详解</h4><p>文档地址：<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p><p>常见的属性和方法：</p><pre><code class="javascript">res.write(data): 给浏览器发送请求体，可以调用多次，从而提供连续的请求体res.end();   通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成。res.end(data); 结束请求，并且响应一段内容，相当于res.write(data) + res.end()res.statusCode: 响应的的状态码 200 404 500res.statusMessage: 响应的状态信息， OK Not Found ,会根据statusCode自动设置。res.setHeader(name, value); 设置响应头信息， 比如content-typeres.writeHead(statusCode, statusMessage, options); 设置响应头，同时可以设置状态码和状态信息。</code></pre><p><strong>注意：必须先设置响应头，才能设置响应体。</strong> </p><p>案例</p><pre><code class="js">let http = require(&#39;http&#39;)let server = http.createServer()server.on(&#39;request&#39;,(req,res) =&gt; &#123;    // res.writeHead(200,&#123;&#39;content-type&#39;: &#39;application/json&#39;&#125;)    // res.write(JSON.stringify(&#123;name: &#39;tom&#39; , age: 18&#125;))    // res.end()    //res.setHeader(&#39;content-type&#39;, &#39;application/json&#39;)    res.end(JSON.stringify(&#123;name: &#39;jerry&#39; , age: 18&#125;))&#125;)server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))</code></pre><h4 id="根据不同请求输出不同响应数据"><a href="#根据不同请求输出不同响应数据" class="headerlink" title="根据不同请求输出不同响应数据"></a>根据不同请求输出不同响应数据</h4><ul><li><a href="http://nodejs.cn/api/http.html#http_message_url">request.url</a></li><li><code>req.url</code>：获取请求路径<ul><li>例如：请求<code>http://127.0.0.1:3000/index</code> 获取到的是：<code>/index</code></li><li>例如：请求<code>http://127.0.0.1:3000/</code> 获取到的是：<code>/</code></li><li>例如：请求<code>http://127.0.0.1:3000</code> 获取到的是：<code>/</code></li></ul></li></ul><pre><code class="js">let http = require(&#39;http&#39;)let server = http.createServer()server.on(&#39;request&#39;,(req,res) =&gt; &#123;    let &#123;url&#125; = req    console.log(&#39;url :&gt;&gt; &#39;, url);    let pageName = &#39;未知页面&#39;    if(&#39;/&#39; === url)&#123;        pageName = &#39;首页&#39;    &#125;else if(&#39;/login&#39; === url)&#123;           pageName = &#39;登录页&#39;    &#125;    res.setHeader(&#39;content-type&#39;, &#39;application/json&#39;)    res.end(pageName)&#125;)server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))</code></pre><h4 id="服务器响应文件"><a href="#服务器响应文件" class="headerlink" title="服务器响应文件"></a>服务器响应文件</h4><p>浏览器中输入的URL地址，仅仅是一个标识，不与服务器中的目录一致。</p><p>也就是说：返回什么内容是由服务端的逻辑决定</p><pre><code class="js">let http = require(&#39;http&#39;)let fs = require(&#39;fs&#39;)let server = http.createServer()server.on(&#39;request&#39;,(req,res) =&gt; &#123;    let &#123;url&#125; = req    console.log(&#39;url :&gt;&gt; &#39;, url);    let pageName = &#39;error.html&#39;    if(&#39;/&#39; === url)&#123;        pageName = &#39;index.html&#39;    &#125;else if(&#39;/login&#39; === url)&#123;           pageName = &#39;login.html&#39;    &#125;    //读取不同的文件,返回    fs.readFile(`./pages/$&#123;pageName&#125;`,&#39;utf-8&#39;,(err,data) =&gt; &#123;        res.setHeader(&#39;content-type&#39;, &#39;text/html&#39;)        res.end(data)    &#125;)&#125;)server.listen(8000,() =&gt; console.log(&#39;server start success at 8000&#39;))</code></pre><h4 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h4><ul><li>MIME(Multipurpose Internet Mail Extensions)多用途Internet邮件扩展类型 是一种表示文档性质和格式的标准化方式</li><li>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的MIME类型附加到响应对象的头部是非常重要的</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types">MIME 类型</a></li></ul><h5 id="mime模块"><a href="#mime模块" class="headerlink" title="mime模块"></a>mime模块</h5><ul><li>作用：获取文件的MIME类型</li><li>安装：<code>npm i mime</code></li></ul><pre><code class="js">let mime = require(&#39;mime&#39;)// 获取路径对应的MIME类型mime.getType(&#39;txt&#39;)                    // ⇨ &#39;text/plain&#39;// 根据MIME获取到文件后缀名mime.getExtension(&#39;text/plain&#39;)        // ⇨ &#39;txt&#39;</code></pre><h3 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h3><ul><li>说明：用于 URL 处理与解析</li><li>注意：通过url拿到的查询参数都是字符串格式</li></ul><pre><code class="js">// 导入url模块let url = require(&#39;url&#39;)// 解析 URL 字符串并返回一个 URL 对象// 第一个参数：表示要解析的URL字符串// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象let res = url.parse(&#39;http://localhost:3000/details?id=1&amp;name=jack&#39;, true)console.log(res.query) // &#123; id: &#39;1&#39;, name: &#39;jack&#39; &#125;</code></pre><h3 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h3><h4 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h4><p>语法：path.join(path1,path2…)</p><p>作用：用来拼接字符串</p><pre><code class="js">const path = require(&#39;path&#39;)//1 基本用法(掌握)const res1 = path.join(__dirname,&#39;1.txt&#39;)console.log(&#39;res1:&#39;,res1) // res1: D:\webcode\node-test\6.path模块\1.txt//2 一个../ 会抵消一个上一级目录(了解)const res2 = path.join(__dirname,&#39;../&#39;,&#39;1.txt&#39;)console.log(&#39;res2:&#39;,res2) // res2: D:\webcode\node-test\1.txt//3 ./ 会被忽略(了解)const res3 = path.join(__dirname,&#39;./&#39;,&#39;1.txt&#39;)console.log(&#39;res3:&#39;,res3) // res3: D:\webcode\node-test\6.path模块\1.txt</code></pre><h4 id="获取文件名"><a href="#获取文件名" class="headerlink" title="获取文件名"></a>获取文件名</h4><p>使用 <code>path.basename()</code> 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名</p><p>语法：path.basename(path[, ext])</p><ul><li>path: 文件路径</li><li>ext: 文件扩展名（可选）</li></ul><pre><code class="js">const path = require(&#39;path&#39;)const filepath = &#39;D:/webcode/node-test/1.txt&#39;//获取文件名带后缀console.log(path.basename(filepath))//1.txt //获取文件名不带后缀console.log(path.basename(filepath,&#39;.txt&#39;))//1 </code></pre><h4 id="获取扩展名"><a href="#获取扩展名" class="headerlink" title="获取扩展名"></a>获取扩展名</h4><p>语法：<code>path.extname(filepath)</code></p><pre><code class="js">const filepath = &#39;D:/webcode/node-test/1.txt&#39;//获取扩展名console.log(path.extname(filepath)) //.txt</code></pre><h2 id="包管理器-npm"><a href="#包管理器-npm" class="headerlink" title="包管理器-npm"></a>包管理器-npm</h2><h3 id="npm的基本概念"><a href="#npm的基本概念" class="headerlink" title="npm的基本概念"></a>npm的基本概念</h3><ul><li>node package manager</li><li><a href="https://npmjs.com/">npm官网</a></li><li><a href="https://www.npmjs.com.cn/">npm中文文档</a></li></ul><pre><code>1. npm 是node的包管理工具，2. 它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。3. 来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。npm 由三个独立的部分组成：    网站    注册表（registry）    命令行工具 (CLI)</code></pre><ul><li>作用：通过<code>npm</code>来快速安装开发中使用的包</li><li>npm不需要安装，只要安装了node，就自带了<code>npm</code></li></ul><h3 id="npm基本使用"><a href="#npm基本使用" class="headerlink" title="npm基本使用"></a>npm基本使用</h3><ul><li>初始化包</li></ul><pre><code class="js">npm init;    //这个命令用于初始化一个包，创建一个package.json文件，我们的项目都应该先执行npm initnpm init -y;  //快速的初始化一个包， 不能是一个中文名</code></pre><ul><li>安装包</li></ul><pre><code class="js">npm install 包名;  //安装指定的包名的最新版本到项目中npm install 包名@版本号;  //安装指定包的指定版本npm i 包名； //简写</code></pre><ul><li>卸载包</li></ul><pre><code class="js">npm uninstall 包名;  //卸载已经安装的包npm uni 包名；//简写</code></pre><h3 id="本地安装和全局安装"><a href="#本地安装和全局安装" class="headerlink" title="本地安装和全局安装"></a>本地安装和全局安装</h3><p>有两种方式用来安装 npm 包：本地安装和全局安装。选用哪种方式来安装，取决于你如何使用这个包。 </p><ul><li>全局安装：如果你想将其作为一个命令行工具，那么你应该将其安装到全局。这种安装方式后可以让你在任何目录下使用这个命令。比如less命令，webpack命令。</li><li>本地安装：如果你自己的模块依赖于某个包，并通过 Node.js 的 <code>require</code> 加载，那么你应该选择本地安装，这种方式也是 <code>npm install</code> 命令的默认行为。</li></ul><pre><code class="js">// 全局安装,会把npm包安装到C:\Users\cc\AppData\Roaming\npm目录下，作为命令行工具使用npm install -g 包名;//本地安装，会把npm包安装到当前项目的node_modules文件中，作为项目的依赖npm install 包名;  </code></pre><h3 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h3><p>package.json文件，包（项目）描述文件，用来管理组织一个包（项目），它是一个纯JSON格式的。</p><ul><li>作用：描述当前项目（包）的信息，描述当前包（项目）的依赖项</li><li>如何生成：<code>npm init</code>或者<code>npm init -y</code></li><li>作用<ul><li>作为一个标准的包，必须要有<code>package.json</code>文件进行描述</li><li>一个项目的node_modules目录通常都会很大，不用拷贝node_modules目录，可以通过package.json文件配合<code>npm install</code>直接安装项目所有的依赖项</li></ul></li><li>描述内容</li></ul><pre><code class="js">&#123;  &quot;name&quot;: &quot;03-npm&quot;,  //描述了包的名字，不能有中文  &quot;version&quot;: &quot;1.0.0&quot;,  //描述了包的的版本信息， x.y.z  如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。  &quot;description&quot;: &quot;&quot;, //包的描述信息  &quot;main&quot;: &quot;index.js&quot;, //入口文件（模块化加载规则的时候详细的讲）  &quot;scripts&quot;: &#123;  //配置一些脚本，在vue的时候会用到，现在体会不到    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;keywords&quot;: [],  //关键字（方便搜索）  &quot;author&quot;: &quot;&quot;,  //作者的信息  &quot;license&quot;: &quot;ISC&quot;,  //许可证，开源协议  &quot;dependencies&quot;: &#123;   //重要，项目的依赖， 方便代码的共享  通过 npm install可以直接安装所有的依赖项    &quot;bootstrap&quot;: &quot;^3.3.7&quot;,    &quot;jquery&quot;: &quot;^3.3.1&quot;  &#125;&#125;</code></pre><p><strong>注意：一个合法的package.json，必须要有name和version两个属性</strong> </p><p>如果安装失败， 可以通过以下命令清除npm缓存：</p><pre><code class="js">npm cache clean -f  // -f强制清除</code></pre><h3 id="npm下载加速-nrm"><a href="#npm下载加速-nrm" class="headerlink" title="npm下载加速-nrm"></a>npm下载加速-nrm</h3><ul><li>nrm：npm registry manager（npm仓库地址管理工具）</li><li>安装：<code>npm i -g nrm</code></li></ul><pre><code class="bash"># 带*表示当前正在使用的地址# 查看仓库地址列表nrm ls# 切换仓库地址nrm use taobao</code></pre><h2 id="nodemon-自动重启"><a href="#nodemon-自动重启" class="headerlink" title="nodemon 自动重启"></a>nodemon 自动重启</h2><ul><li>作用：监视到js文件修改后，自动重启node程序</li><li>安装：<code>npm i -g nodemon</code></li><li>使用：<code>nodemon app.js</code> 运行node程序</li></ul><h2 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art-template 模板引擎"></a>art-template 模板引擎</h2><ul><li><a href="https://aui.github.io/art-template/zh-cn/docs/">文档</a></li><li>安装： <code>npm install art-template</code></li></ul><ul><li>核心方法</li></ul><pre><code class="js">// 基于模板路径渲染模板//参数1：文件的路径//参数2：数据//返回值：返回渲染后的内容// template(filename, data)let html = template(path.join(__dirname, &quot;pages&quot;, &quot;index.html&quot;), &#123;name:&quot;大吉大利，今晚吃鸡&quot;&#125;);</code></pre><p><strong>注意点：文件的路径必须是绝对路径</strong></p><h2 id="服务端重定向"><a href="#服务端重定向" class="headerlink" title="服务端重定向"></a>服务端重定向</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 状态码说明</a></li><li><a href="http://shuai.be/archives/301-302-redirection/">301 和 302</a></li><li>说明：服务端可以通过HTTP状态码让浏览器中的页面重定向</li></ul><pre><code class="js">res.writeHead(302, &#123;  &#39;Location&#39;: &#39;/&#39;&#125;)res.end()</code></pre><h2 id="post请求参数处理"><a href="#post请求参数处理" class="headerlink" title="post请求参数处理"></a>post请求参数处理</h2><p>说明：POST请求可以发送大量数据，没有大小限制</p><pre><code class="js">// 接受POST参数var postData = []// 给req注册一个data事件， 只要浏览器给服务器发送post请求，data事件就会触发// post请求发送的数据量可以很大， 这个data事件会触发多次，一块一块的传输// 要把所有的chunk都拼接起来// data事件：用来接受客户端发送过来的POST请求数据var result = &quot;&quot;;req.on(&#39;data&#39;, function (chunk) &#123;  result += chunk;&#125;)// end事件：当POST数据接收完毕时，触发req.on(&#39;end&#39;, function () &#123;  cosnole.log(result); &#125;)</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化规范：</p><ul><li>AMD:  requirejs</li><li>CMD:  seajs  玉伯  浏览器端的模块 </li><li>commonJS： nodejs  服务端的模块</li></ul><blockquote><p>在nodejs中，应用由模块组成，nodejs中采用commonJS模块规范。</p></blockquote><ol><li>一个js文件就是一个模块</li><li>每个模块都是一个独立的作用域，在这个而文件中定义的变量、函数、对象都是私有的，对其他文件不可见。</li></ol><h3 id="node模块分类"><a href="#node模块分类" class="headerlink" title="node模块分类"></a>node模块分类</h3><ul><li><p>1 核心模块</p><ul><li>由 node 本身提供，不需要单独安装（npm），可直接引入使用。例如：fs模块、path模块等</li></ul></li><li><p>2 第三方模块</p><ul><li>由社区或个人提供，需要通过npm安装后使用。</li></ul></li><li><p>3 自定义模块</p><ul><li><p>由开发人员创建的模块（JS文件）</p></li><li><p>基本使用：1 创建模块 2 引入模块</p></li><li><p>注意：自定义模块的路径必须以<code>./</code>获取<code>../</code>开头</p></li><li><pre><code class="js">// 加载模块require(&#39;./a&#39;)     // 推荐使用，省略.js后缀！require(&#39;./a.js&#39;)</code></pre></li></ul></li></ul><h3 id="模块的导入导出"><a href="#模块的导入导出" class="headerlink" title="模块的导入导出"></a>模块的导入导出</h3><h4 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h4><ul><li>通过<code>require(&quot;fs&quot;)</code>来加载模块</li><li>如果是第三方模块，需要先使用npm进行下载</li><li>如果是自定义模块，需要加上相对路径<code>./</code>或者<code>../</code>,可以省略<code>.js</code>后缀，如果文件名是<code>index.js</code>那么index.js也可以省略。</li><li>模块可以被多次导入，但是<code>只会在第一次加载</code></li></ul><h4 id="模块导出"><a href="#模块导出" class="headerlink" title="模块导出"></a>模块导出</h4><p>在模块的内部，<strong style="color:red">module变量代表的就是当前模块</strong>，它的<code>exports</code>属性就是对外的接口，加载某个模块，加载的就是<code>module.exports</code>属性，这个属性指向一个空的对象。</p><pre><code class="js">//module.exports指向的是一个对象，我们给对象增加属性即可。//module.exports.num = 123;//module.exports.age = 18;//通过module.exports也可以导出一个值，但是多次导出会覆盖module.exports = &#39;123&#39;;module.exports = &quot;abc&quot;;</code></pre><h4 id="module-exports与exports"><a href="#module-exports与exports" class="headerlink" title="module.exports与exports"></a>module.exports与exports</h4><ul><li><code>exports</code> 是 <code>module.exports</code> 的引用</li><li>注意：给 <code>module.exports</code> 赋值会<code>切断</code>与 <code>exports</code> 之间的联系<ul><li>1 直接添加属性两者皆可</li><li>2 赋值操作时，只能使用 <code>module.exports</code></li></ul></li></ul><pre><code class="js">console.log( module.exports === exports ) // ==&gt; true// 等价操作module.exports.num = 123exports.num = 123// 赋值操作：不要使用 exports = &#123;&#125;module.exports = &#123;&#125;</code></pre><h4 id="第三方模块代码执行流程-了解"><a href="#第三方模块代码执行流程-了解" class="headerlink" title="第三方模块代码执行流程(了解)"></a>第三方模块代码执行流程(了解)</h4><p>以mime包为例</p><ul><li>先基于当前文件模块所属目录找 node_modules 目录</li><li>如果找到，则去该目录中找 mime 目录</li><li>如果找到 mime 目录，则找该目录中的 package.json 文件</li><li>如果找到 package.json 文件，则找该文件中的 main 属性</li><li>如果找到 main 属性，则拿到该属性对应的文件路径</li><li>如果找到 mime 目录之后<ul><li>发现没有 package.json</li><li>或者 有 package.json 没有 main 属性</li><li>或者 有 main 属性，但是指向的路径不存在</li><li>则 node 会默认去看一下 mime 目录中有没有 index.js index.node index.json 文件</li></ul></li><li>如果找不到 index 或者找不到 mime 或者找不到 node_modules</li><li>则进入上一级目录找 node_moudles 查找规则同上</li><li>如果上一级还找不到，继续向上，一直到当前文件所属磁盘根目录</li><li>如果最后到磁盘根目录还找不到，最后报错：<code>can not find module xxx</code></li></ul><h3 id="CommonJS-规范参考文档"><a href="#CommonJS-规范参考文档" class="headerlink" title="CommonJS 规范参考文档"></a>CommonJS 规范参考文档</h3><ul><li><a href="http://nodejs.cn/api/modules.html">module (模块)</a></li><li><a href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS规范</a></li><li><a href="http://www.jianshu.com/p/09ffac7a3b2c">浅析JS模块规范：AMD，CMD，CommonJS</a></li></ul><h2 id="node操作mysql数据库"><a href="#node操作mysql数据库" class="headerlink" title="node操作mysql数据库"></a>node操作mysql数据库</h2><p>数据库准备：</p><p>1.安装mysql5数据库</p><p>2.在mysql中创建nodedb这个数据库（可利用Navicat图形工具）</p><p>3.在nodedb数据库中添加users表 （可利用Navicat图形工具）</p><p>建表sql语句如下：</p><pre><code class="sql">SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for users-- ----------------------------DROP TABLE IF EXISTS `users`;CREATE TABLE `users`  (  `id` int(11) NOT NULL AUTO_INCREMENT,  `username` varchar(255) ,  `password` varchar(255) ,  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;SET FOREIGN_KEY_CHECKS = 1;</code></pre><h3 id="配置-mysql-模块"><a href="#配置-mysql-模块" class="headerlink" title="配置 mysql 模块"></a>配置 mysql 模块</h3><ol><li>安装 mysql 模块</li></ol><pre><code class="bash">npm install mysql</code></pre><ol start="2"><li>建立连接</li></ol><pre><code class="js">const mysql = require(&#39;mysql&#39;)const db = mysql.createPool(&#123;  host: &#39;127.0.0.1&#39;,  user: &#39;root&#39;, //mysql账号  password: &#39;root&#39;,//mysql密码  database: &#39;nodedb&#39;, //自己创建的mysql库 &#125;)</code></pre><ol start="3"><li>测试是否正常工作</li></ol><pre><code class="js">db.query(&#39;select 1&#39;, (err, results) =&gt; &#123;  if (err) console.log(err.message)  console.log(results)&#125;)</code></pre><h3 id="node操作mysql增删改查"><a href="#node操作mysql增删改查" class="headerlink" title="node操作mysql增删改查"></a>node操作mysql增删改查</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>第一种添加方式：</p><pre><code class="js">//1.准备数据const &#123;name,username,password&#125; = &#123;name: &#39;汤姆&#39;, username: &#39;tom&#39;, password: &#39;123&#39;&#125;//2.准备sql ?标识占位符const sqlStr = &#39;insert into users (name,username, password) values(?,?,?)&#39;//3.执行sql 参数1：sql字符串  参数2：占位符对应的数据 参数3：插入之后的回调db.query(sqlStr,[name,username,password],(err,res) =&gt; &#123;  if(err) console.log(&#39;err :&gt;&gt; &#39;, err);  console.log(&#39;res :&gt;&gt; &#39;, res);  if(res.affectedRows == 1) console.log(&#39;插入成功！&#39;)&#125;)</code></pre><p>第二种添加方式：向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据：</p><pre><code class="js">const obj = &#123;name: &#39;汤姆&#39;, username: &#39;tom&#39;, password: &#39;123&#39;&#125;db.query(&#39;insert into  users set ?&#39;,obj,(err,res) =&gt; &#123;   if(err) console.log(&#39;err :&gt;&gt; &#39;, err)   console.log(&#39;res :&gt;&gt; &#39;, res);   if(res.affectedRows == 1) console.log(&#39;插入成功11！&#39;)&#125;)</code></pre><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code class="js">//查询数据db.query(&#39;select * from users&#39;,(err,res) =&gt; &#123;  console.log(&#39;res :&gt;&gt; &#39;, res);&#125;)</code></pre><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><pre><code class="js">const &#123;username,password,name,id&#125; = &#123;id: 3, name: &#39;杰瑞&#39;, username: &#39;jerry&#39;, password: &#39;456&#39;&#125;const sqlStr = &#39;update users set username=?,password=?,name=? where id=?&#39;db.query(sqlStr,[username,password,name,id],(err,res) =&gt; &#123;//注意第二个参数的顺序   if(err) console.log(&#39;err :&gt;&gt; &#39;, err)   if(res.affectedRows == 1) console.log(&#39;修改成功！&#39;)&#125;)</code></pre><p>快捷修改方式</p><pre><code class="js">const obj = &#123;id: 3, name: &#39;杰瑞1&#39;, username: &#39;jerry1&#39;, password: &#39;4516&#39;&#125;const sqlStr = &#39;update users set ? where id=?&#39;db.query(sqlStr,[obj,obj.id],(err,res) =&gt; &#123;//注意第二个参数的顺序  if(err) console.log(&#39;err :&gt;&gt; &#39;, err)  if(res.affectedRows == 1) console.log(&#39;修改成功！&#39;)&#125;)</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre><code class="js">db.query(&#39;delete from users where id=?&#39;,[1],(err,res) =&gt; &#123;  if(res.affectedRows == 1) console.log(&#39;删除成功！&#39;)&#125;)</code></pre><h2 id="node操作mongodb数据库"><a href="#node操作mongodb数据库" class="headerlink" title="node操作mongodb数据库"></a>node操作mongodb数据库</h2><p>安装：<code>npm i  mongodb</code></p><pre><code class="js">// 导入 mongodb，并获取到客户端对象const MongoClient = require(&#39;mongodb&#39;).MongoClient// 连接数据库服务地址const url = &#39;mongodb://localhost:27017&#39;// 连接数据库MongoClient.connect(url, function (err, client) &#123;  if (err) &#123;    return console.log(&#39;链接数据库失败&#39;, err)  &#125;  console.log(&#39;数据库链接成功&#39;);  // 获取集合对象  const db = client.db(&#39;nodedb&#39;)  // 关闭数据库链接  client.close()&#125;)</code></pre><h3 id="数据增删改查"><a href="#数据增删改查" class="headerlink" title="数据增删改查"></a>数据增删改查</h3><ul><li>添加数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)// 添加db.collection(&#39;users&#39;)  // 添加一条数据  .insert(&#123;name: &#39;rose&#39;, age: 19&#125;, function (err, data) &#123;    console.log(data);  &#125;)  // 添加多条数据  .insertMany([&#123; name: &#39;tom&#39;, age: 20 &#125;, &#123; name: &#39;jerry&#39;, age: 21 &#125;], function (err, data) &#123;    console.log(data);  &#125;)</code></pre><ul><li>查询数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)// 查询db.collection(&#39;users&#39;).find().toArray(function (err, data) &#123;  console.log(data)&#125;)</code></pre><ul><li>修改数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)db.collection(&#39;users&#39;).update(&#123; name: &#39;tom&#39; &#125;, &#123; $set: &#123; age: 22 &#125; &#125;, function (err, result) &#123;    console.log(result);  &#125;)</code></pre><ul><li>删除数据</li></ul><pre><code class="js">const db = client.db(&#39;nodedb&#39;)db.collection(&#39;users&#39;)  // 删除一条数据：  .deleteOne(&#123;name: &#39;rose&#39;&#125;, function (err, result) &#123;    console.log(result);  &#125;)  // 删除多条数据：  .deleteMany(&#123;age: &#123;$lt: 20&#125;&#125;, function (err, result) &#123;    console.log(result);  &#125;)</code></pre><h2 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>安装express</li></ul><pre><code class="bash">npm i express</code></pre><ul><li>案例</li></ul><pre><code class="js">// 导入 expressvar express = require(&#39;express&#39;)// 创建 express实例，也就是创建 express服务器var app = express()// 路由app.get(&#39;/&#39;, function (req, res) &#123;  res.send(&#39;Hello World!&#39;)&#125;)// 启动服务器app.listen(3000, function () &#123;  console.log(&#39;服务器已启动&#39;)&#125;)</code></pre><p>参数说明</p><ul><li><code>express()</code>：创建一个Express应用，并返回，即：app</li><li><code>app.get()</code>：注册一个GET类型的路由<ul><li>注意：只要注册了路由，所有的请求都会被处理（未配置的请求路径，响应404）</li></ul></li><li><code>res.send()</code>：发送数据给客户端，并自动设置Content-Type<ul><li>参数可以是：字符串、数组、对象、Buffer</li><li>注意：只能使用一次</li></ul></li><li><code>req</code> 和 <code>res</code>：与http模块中的作用相同，是扩展后的请求和响应对象</li></ul><h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ul><li>通过 <code>express.static()</code> 方法可创建静态资源服务器，向外开放访问静态资源。</li><li>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，<strong style="color:red">存放静态文件的目录名不会出现在 URL 中</strong></li><li>访问静态资源时，会根据托管顺序查找文件</li><li>可为静态资源访问路径添加前缀</li></ul><pre><code class="js">app.use(express.static(&#39;static&#39;))app.use(&#39;/web&#39;, express.static(&#39;web&#39;))//可直接访问 static 目录下的静态资源http://localhost:3000/img/2.jpg//通过带有 /web 前缀的地址访问 bruce 目录下的文件http://localhost:8080/web/img/1.jpg</code></pre><h3 id="request和response"><a href="#request和response" class="headerlink" title="request和response"></a>request和response</h3><h4 id="request常用方法"><a href="#request常用方法" class="headerlink" title="request常用方法"></a>request常用方法</h4><ul><li>query属性：获取get请求参数，是一个对象</li></ul><pre><code class="js">//传参：http://localhost:8088/user?name=jerry&amp;age=18//处理请求app.get(&#39;/user&#39;,(req,resp) =&gt; &#123;    resp.send(req.query)//将get参数直接返回&#125;)</code></pre><ul><li>body：获取POST请求参数，需要配置<code>body-parser</code>模块， POST请求参数</li></ul><pre><code class="js">//导入bodyParser模块const bodyParser = require(&#39;body-parser&#39;)//将POST请求参数转化为对象，存储到req.body中 (application/x-www-form-urlencoded方式)app.use(bodyParser.urlencoded(&#123; extended: true &#125;))app.post(&#39;/user&#39;,(req,resp) =&gt; &#123;    resp.send(req.body)//将post参数直接返回&#125;)</code></pre><ul><li>params：获取restful风格的参数</li></ul><pre><code class="js">//传参：http://localhost:8088/user/jerry/19app.put(&#39;/user/:name/:age&#39;,(req,resp) =&gt; &#123;    resp.send(req.params)//将restful参数直接返回&#125;)</code></pre><h4 id="response常用方法"><a href="#response常用方法" class="headerlink" title="response常用方法"></a>response常用方法</h4><pre><code class="js">// send() 发送数据给客户端，并自动设置Content-Typeres.send()// 发送文件给浏览器，并根据文件后缀名自动设置Content-Type// 注意：文件路径必须是绝对路径res.sendFile(path.join(__dirname, &#39;index.html&#39;))// 设置HTTP响应码res.status(200)；// 设置响应头res.set(&#39;Content-Type&#39;, &#39;text/plain&#39;)res.set(&#123;  &#39;Content-Type&#39;: &#39;text/plain&#39;,  &#39;cute&#39;: &#39;fangfang&#39;&#125;)// 重定向res.redirect(&#39;/index&#39;)</code></pre><h3 id="expres中使用art-template"><a href="#expres中使用art-template" class="headerlink" title="expres中使用art-template"></a>expres中使用art-template</h3><p>安装</p><pre><code class="bash">npm install art-template npm install express-art-template</code></pre><p>给express绑定一个模版引擎</p><pre><code class="js">//给express设置模版引擎//参数1： 模版引擎的后缀名，  以后的模版文件都应该是 html结尾//参数2： 使用什么模版引擎app.engine(&quot;html&quot;, require(&#39;express-art-template&#39;))</code></pre><p>通过<code>res.render()</code>渲染模版引擎</p><pre><code class="js">//参数1； 模版文件的路径,相对路径，回去views目录下查找//参数2： 数据res.render(path.join(__dirname, &quot;index.html&quot;), &#123;name:&quot;zs&quot;&#125;)</code></pre><p>关于模版引擎的配置（了解）</p><pre><code class="js">//模版文件默认去aa目录下查找  默认值：  viewsapp.set(&quot;views&quot;, &quot;aa&quot;);//设置模板引擎的默认后缀app.set(&quot;view engine&quot;, &quot;html&quot;);</code></pre><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>创建路由模块：</p><pre><code class="js">// router.jsconst express = require(&#39;express&#39;)// 创建路由对象const router = express.Router()// 挂载具体路由router.get(&#39;/user/list&#39;, (req, res) =&gt; &#123;  res.send(&#39;Get user list.&#39;)&#125;)router.post(&#39;/user/add&#39;, (req, res) =&gt; &#123;  res.send(&#39;Add new user.&#39;)&#125;)// 向外导出路由对象module.exports = router</code></pre><p>注册路由模块：</p><pre><code class="js">const express = require(&#39;express&#39;)const router = require(&#39;./router&#39;)const app = express()// 注册路由模块，添加访问前缀app.use(&#39;/api&#39;, router) //测试时记得代码 /api 前缀app.listen(8088, () =&gt; &#123;  console.log(&#39;http://127.0.0.1&#39;)&#125;)</code></pre><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li>中间件是指流程的中间处理环节</li><li>服务器收到请求后，可先调用中间件进行预处理(比如登录拦截、错误拦截等)</li><li>中间件是一个函数，包含 <code>req, res, next</code> 三个参数，<code>next()</code> 参数把流转关系交给下一个中间件或路由</li></ul><p>中间件注意事项；</p><ul><li>在注册路由之前注册中间件（错误级别中间件除外）</li><li>中间件可连续调用多个</li><li>别忘记调用 <code>next()</code> 函数</li><li><code>next()</code> 函数后别写代码</li><li>多个中间件共享 <code>req</code>、 <code>res</code>对象</li></ul><h4 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h4><ul><li>通过 <code>app.use()</code> 定义的中间件为全局中间件</li></ul><pre><code class="js">const express = require(&#39;express&#39;)const app = express()// 定义第一个全局中间件app.use((req, res, next) =&gt; &#123;  console.log(&#39;调用了第1个全局中间件&#39;)  next()&#125;)// 定义第二个全局中间件app.use((req, res, next) =&gt; &#123;  console.log(&#39;调用了第2个全局中间件&#39;)  next()&#125;)app.get(&#39;/user&#39;, (req, res) =&gt; &#123;  res.send(&#39;User page.&#39;)&#125;)app.listen(80, () =&gt; &#123;  console.log(&#39;http://127.0.0.1&#39;)&#125;)</code></pre><h4 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h4><pre><code class="js">const express = require(&#39;express&#39;)const app = express()// 定义中间件函数const mw1 = (req, res, next) =&gt; &#123;  console.log(&#39;调用了第一个局部生效的中间件&#39;)  next()&#125;const mw2 = (req, res, next) =&gt; &#123;  console.log(&#39;调用了第二个局部生效的中间件&#39;)  next()&#125;// 两种定义局部中间件的方式app.get(&#39;/hello&#39;, mw2, mw1, (req, res) =&gt; res.send(&#39;hello page.&#39;))app.get(&#39;/about&#39;, [mw1, mw2], (req, res) =&gt; res.send(&#39;about page.&#39;))app.get(&#39;/user&#39;, (req, res) =&gt; res.send(&#39;User page.&#39;))app.listen(80, function () &#123;  console.log(&#39;Express server running at http://127.0.0.1&#39;)&#125;)</code></pre><h4 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h4><h5 id="应用级别的中间件"><a href="#应用级别的中间件" class="headerlink" title="应用级别的中间件"></a>应用级别的中间件</h5><p>通过 <code>app.use()</code> 或 <code>app.get()</code> 或 <code>app.post()</code> ，绑定到 <code>app</code> 实例上的中间件</p><h5 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h5><p>绑定到 <code>express.Router()</code> 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 <code>app</code> 实例上，路由级别中间件绑定到 <code>router</code> 实例上。</p><pre><code class="js">const app = express()const router = express.Router()router.use(function (req, res, next) &#123;  console.log(1)  next()&#125;)app.use(&#39;/&#39;, router)</code></pre><h5 id="错误级别的中间件"><a href="#错误级别的中间件" class="headerlink" title="错误级别的中间件"></a>错误级别的中间件</h5><ul><li>用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</li><li>错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 <code>(err, req, res, next)</code> 。</li><li>错误级别的中间件必须注册在所有路由之后</li></ul><pre><code class="js">const express = require(&#39;express&#39;)const app = express()app.get(&#39;/&#39;, (req, res) =&gt; &#123;  throw new Error(&#39;服务器内部发生了错误！&#39;)  res.send(&#39;Home page.&#39;)&#125;)// 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃app.use((err, req, res, next) =&gt; &#123;  console.log(&#39;发生了错误！&#39; + err.message)  res.send(&#39;Error：&#39; + err.message)&#125;)app.listen(80, function () &#123;  console.log(&#39;Express server running at http://127.0.0.1&#39;)&#125;)</code></pre><h5 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h5><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p><ul><li><code>express.static</code> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li><li><code>express.json</code> 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li><li><code>express.urlencoded</code> 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li></ul><pre><code class="js">app.use(express.json())app.use(express.urlencoded(&#123; extended: false &#125;))</code></pre><h5 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h5><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><ul><li>CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</li><li>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</li><li>CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li><li>CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</li></ul><h4 id="CORS-常见响应头"><a href="#CORS-常见响应头" class="headerlink" title="CORS 常见响应头"></a>CORS 常见响应头</h4><ul><li><code>Access-Control-Allow-Origin</code>：制定了允许访问资源的外域 URL</li></ul><pre><code class="js">res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://bruceblog.io&#39;)res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)</code></pre><ul><li><code>Access-Control-Allow-Headers</code></li><li>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：<code>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</code></li><li>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 A<code>ccess-Control-Allow-Headers</code> 对额外的请求头进行声明，否则这次请求会失败！</li></ul><pre><code class="js">res.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;Content-Type, X-Custom-Header&#39;)</code></pre><ul><li><code>Access-Control-Allow-Methods</code></li><li>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 <code>Access-Control-Alow-Methods</code> 来指明实际请求所允许使用的 HTTP 方法</li></ul><pre><code class="js">res.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, GET, DELETE, HEAD&#39;)res.setHEader(&#39;Access-Control-Allow-Methods&#39;, &#39;*&#39;)</code></pre><h4 id="CORS-请求分类"><a href="#CORS-请求分类" class="headerlink" title="CORS 请求分类"></a>CORS 请求分类</h4><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><ul><li>请求方式：GET、POST、HEAD 三者之一</li><li>HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application&#x2F;x-www-formurlencoded、multipart&#x2F;form-data、text&#x2F;plain）</li></ul><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><ul><li>请求方式为 GET、POST、HEAD 之外的请求 Method 类型</li><li>请求头中包含自定义头部字段</li><li>向服务器发送了 application&#x2F;json 格式的数据</li></ul><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p><h4 id="express中使用cors"><a href="#express中使用cors" class="headerlink" title="express中使用cors"></a>express中使用cors</h4><p>安装中间件：<code>npm install cors</code><br>导入中间件：<code>const cors = require(&#39;cors&#39;)</code><br>配置中间件：<code>app.use(cors())</code></p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><h3 id="jwt认证"><a href="#jwt认证" class="headerlink" title="jwt认证"></a>jwt认证</h3><p>前后端分离推荐使用 JWT（JSON Web Token）认证机制，是目前最流行的跨域认证解决方案</p><h4 id="Session-的局限性"><a href="#Session-的局限性" class="headerlink" title="Session 的局限性"></a>Session 的局限性</h4><ul><li>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</li><li>当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。</li><li>当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制</li></ul><h4 id="JWT-工作原理图"><a href="#JWT-工作原理图" class="headerlink" title="JWT 工作原理图"></a>JWT 工作原理图</h4><p>用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p><p><img src="/posts/f2f1536e/image-20221030192657149.png" alt="image-20221030192657149"></p><h4 id="JWT-组成部分"><a href="#JWT-组成部分" class="headerlink" title="JWT 组成部分"></a>JWT 组成部分</h4><ul><li>Header、Payload、Signature</li><li>Payload 是真正的用户信息，加密后的字符串</li><li>Header 和 Signature 是安全性相关部分，保证 Token 安全性</li><li>三者使用 <code>.</code> 分隔</li></ul><pre><code class="js">Header.Payload.SignatureeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTcsInVzZXJuYW1lIjoiQnJ1Y2UiLCJwYXNzd29yZCI6IiIsIm5pY2tuYW1lIjoiaGVsbG8iLCJlbWFpbCI6InNjdXRAcXEuY29tIiwidXNlcl9waWMiOiIiLCJpYXQiOjE2NDE4NjU3MzEsImV4cCI6MTY0MTkwMTczMX0.bmqzAkNSZgD8IZxRGGyVlVwGl7EGMtWitvjGD-a5U5c</code></pre><h4 id="JWT的使用方式"><a href="#JWT的使用方式" class="headerlink" title="JWT的使用方式"></a>JWT的使用方式</h4><ul><li>客户端会把 JWT 存储在 localStorage 或 sessionStorage 中</li><li>此后客户端与服务端通信需要携带 JWT 进行身份认证，将 JWT 存在 HTTP 请求头 Authorization 字段中</li><li>加上 Bearer 前缀</li></ul><pre><code class="text">Authorization: Bearer &lt;token&gt;</code></pre><h4 id="Express-使用-JWT认证"><a href="#Express-使用-JWT认证" class="headerlink" title="Express 使用 JWT认证"></a>Express 使用 JWT认证</h4><ol><li>安装：<code>jsonwebtoken</code> 用于生成 JWT 字符串;<code>express-jwt</code> 用于将 JWT 字符串解析还原成 JSON 对象</li></ol><pre><code class="bash">npm install jsonwebtoken express-jwt</code></pre><ol start="2"><li>定义 secret 密钥</li></ol><ul><li>为保证 JWT 字符串的安全性，防止其在网络传输过程中被破解，需定义用于加密和解密的 secret 密钥</li><li>生成 JWT 字符串时，使用密钥加密信息，得到加密好的 JWT 字符串</li><li>把 JWT 字符串解析还原成 JSON 对象时，使用密钥解密</li></ul><pre><code class="js">const jwt = require(&#39;jsonwebtoken&#39;)const expressJWT = require(&#39;express-jwt&#39;)// 密钥为任意字符串const secretKey = &#39;hlf&#39;</code></pre><ol start="3"><li>生成 JWT 字符串</li></ol><pre><code class="js">app.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;  ...  res.send(&#123;    status: 200,    message: &#39;登录成功&#39;,    // jwt.sign() 生成 JWT 字符串    // 参数：用户信息对象、加密密钥、配置对象-token有效期    // 尽量不保存敏感信息，因此只有用户名，没有密码    token: jwt.sign(&#123;username: userInfo.username&#125;, secretKey, &#123;expiresIn: &#39;10h&#39;&#125;)  &#125;)&#125;)</code></pre><ol start="4"><li>JWT 字符串还原为 JSON 对象</li></ol><ul><li>客户端访问有权限的接口时，需通过请求头的 <code>Authorization</code> 字段，将 Token 字符串发送到服务器进行身份认证</li><li>服务器可以通过 express-jwt 中间件将客户端发送过来的 Token 解析还原成 JSON 对象</li></ul><pre><code class="js">// unless(&#123; path: [/^\/api\//] &#125;) 指定哪些接口无需jwt认证app.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\/api\//] &#125;))</code></pre><ol start="5"><li>获取用户信息</li></ol><ul><li>当 express-jwt 中间件配置成功后，即可在那些有权限的接口中，使用 <code>req.user</code> 对象，来访问从 JWT 字符串中解析出来的用户信息</li></ul><pre><code class="js">app.get(&#39;/admin/getinfo&#39;, (req, res) =&gt; &#123;  console.log(req.user)  res.send(&#123;    status: 200,    message: &#39;获取信息成功&#39;,    data: req.user,  &#125;)&#125;)</code></pre><ol start="6"><li>捕获解析 JWT 失败后产生的错误</li></ol><ul><li>当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行</li><li>通过 Express 的错误中间件，捕获这个错误并进行相关的处理</li></ul><pre><code class="js">app.use((err, req, res, next) =&gt; &#123;  if (err.name === &#39;UnauthorizedError&#39;) &#123;    return res.send(&#123; status: 401, message: &#39;Invalid token&#39; &#125;)  &#125;  res.send(&#123; status: 500, message: &#39;Unknown error&#39; &#125;)&#125;)</code></pre><h3 id="session认证"><a href="#session认证" class="headerlink" title="session认证"></a>session认证</h3><p>服务端渲染推荐使用 Session 认证机制</p><h4 id="session认证原理"><a href="#session认证原理" class="headerlink" title="session认证原理"></a>session认证原理</h4><p><img src="/posts/f2f1536e/image-20221030194211947.png" alt="image-20221030194211947"></p><h4 id="Express中使用session认证"><a href="#Express中使用session认证" class="headerlink" title="Express中使用session认证"></a>Express中使用session认证</h4><ol><li>安装 express-session 中间件</li></ol><pre><code class="bash">npm install express-session</code></pre><ol start="2"><li>配置中间件</li></ol><pre><code class="js">const session = require(&#39;express-session&#39;)app.use(  session(&#123;    secret: &#39;hlf&#39;, // secret 的值为任意字符串    resave: false,    saveUninitalized: true,  &#125;))</code></pre><ol start="3"><li>向 session 中存数据</li></ol><p>中间件配置成功后，可通过 <code>req.session</code> 访问 session 对象，存储用户信息</p><pre><code class="js">app.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;  req.session.user = req.body  req.session.isLogin = true  res.send(&#123; status: 0, msg: &#39;login done&#39; &#125;)&#125;)</code></pre><ol start="4"><li>从 session 取数据</li></ol><pre><code class="js">app.get(&#39;/api/username&#39;, (req, res) =&gt; &#123;  if (!req.session.isLogin) &#123;    return res.send(&#123; status: 1, msg: &#39;fail&#39; &#125;)  &#125;  res.send(&#123; status: 0, msg: &#39;success&#39;, username: req.session.user.username &#125;)&#125;)</code></pre><ol start="5"><li>清空 session</li></ol><pre><code class="js">app.post(&#39;/api/logout&#39;, (req, res) =&gt; &#123;  // 清空当前客户端的session信息  req.session.destroy()  res.send(&#123; status: 0, msg: &#39;logout done&#39; &#125;)&#125;)</code></pre>]]></content>
    
    
    <summary type="html">含node基础、express框架、jwt认证、session认证等内容</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="node" scheme="https://heliufang.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>vue3笔记</title>
    <link href="https://heliufang.github.io/posts/73c9868e/"/>
    <id>https://heliufang.github.io/posts/73c9868e/</id>
    <published>2022-07-09T10:34:28.000Z</published>
    <updated>2023-01-08T03:53:03.033Z</updated>
    
    <content type="html"><![CDATA[<p>b站vue3教学视频：<a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=136">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=136</a></p><h1 id="vue3快速上手"><a href="#vue3快速上手" class="headerlink" title="vue3快速上手"></a>vue3快速上手</h1><h2 id="vue3简介"><a href="#vue3简介" class="headerlink" title="vue3简介"></a>vue3简介</h2><p><font color="red">2020年9月18日</font>，Vue.js发布3.0版本，代号：One Piece（海贼王）<br>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a><br>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></p><p><img src="/posts/73c9868e/image-20220709144941109.png" alt="image-20220709144941109"></p><h2 id="Vue3带来了什么"><a href="#Vue3带来了什么" class="headerlink" title="Vue3带来了什么"></a>Vue3带来了什么</h2><h3 id="性能的提升"><a href="#性能的提升" class="headerlink" title="性能的提升"></a>性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="源码的升级"><a href="#源码的升级" class="headerlink" title="源码的升级"></a>源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="拥抱TypeScript"><a href="#拥抱TypeScript" class="headerlink" title="拥抱TypeScript"></a>拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h2 id="创建vue3的工程"><a href="#创建vue3的工程" class="headerlink" title="创建vue3的工程"></a>创建vue3的工程</h2><h3 id="使用vue-cli创建"><a href="#使用vue-cli创建" class="headerlink" title="使用vue-cli创建"></a>使用vue-cli创建</h3><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><pre><code class="bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve</code></pre><h3 id="使用-vite-创建"><a href="#使用-vite-创建" class="headerlink" title="使用 vite 创建"></a>使用 vite 创建</h3><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="/posts/73c9868e/image-20220709145533098.png" alt="image-20220709145533098"></p><pre><code class="bash">## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev</code></pre><h1 id="常用-Composition-API"><a href="#常用-Composition-API" class="headerlink" title="常用 Composition API"></a>常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="setup函数"><a href="#setup函数" class="headerlink" title="setup函数"></a>setup函数</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li><font color="red">组件中所用到的：数据、方法等等，均要配置在setup中。</font></li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li><font color="red">尽量不要与Vue2.x配置混用</font>（都用3了就不要写vue2的那套了）<ul><li>Vue2.x配置（data、methods、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a>ref函数</h2><ul><li>作用: <font color="red" style="font-weight:bold">定义一个响应式的数据</font></li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。RefImpl</li><li>JS中操作数据： <code>xxx.value</code> （<font color="red" style="font-weight:bold">无论是基本类型还是对象类型</font>）</li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="reactive函数"><a href="#reactive函数" class="headerlink" title="reactive函数"></a>reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong><ul><li>js中、模板中都不需要操作xxx.value操作数据，可以直接操作</li></ul></li><li>reactive定义的响应式数据是<strong>深层次的</strong>。(vue2中并不是)</li><li><font color="red" style="font-weight:bold">内部基于 ES6 的 Proxy 实现</font>，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="Vue3-0中的响应式原理"><a href="#Vue3-0中的响应式原理" class="headerlink" title="Vue3.0中的响应式原理"></a>Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><pre><code class="js">Object.defineProperty(data, &#39;count&#39;, &#123;    get () &#123;&#125;,     set () &#123;&#125;&#125;)</code></pre></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li>实现原理: <ul><li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li><li>通过Reflect（反射）:  对源对象的属性进行操作。</li><li>MDN文档中描述的Proxy与Reflect：<ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><pre><code class="js">new Proxy(data, &#123;    // 拦截读取属性值    get (target, prop) &#123;        return Reflect.get(target, prop)    &#125;,    // 拦截设置属性值或添加新属性    set (target, prop, value) &#123;        return Reflect.set(target, prop, value)    &#125;,    // 拦截删除属性    deleteProperty (target, prop) &#123;        return Reflect.deleteProperty(target, prop)    &#125;&#125;)proxy.name = &#39;tom&#39;   </code></pre></li></ul></li></ul></li></ul><h2 id="reactive对比ref"><a href="#reactive对比ref" class="headerlink" title="reactive对比ref"></a>reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="setup的注意点"><a href="#setup的注意点" class="headerlink" title="setup的注意点"></a>setup的注意点</h2><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><ul><li>父组件给子组件传递的属性和自定义事件，子组件一定要接受一下，否则会抛出警告</li></ul><p><img src="/posts/73c9868e/image-20220709164507893.png" alt="image-20220709164507893"></p><h2 id="计算属性与监视"><a href="#计算属性与监视" class="headerlink" title="计算属性与监视"></a>计算属性与监视</h2><h3 id="computed函数"><a href="#computed函数" class="headerlink" title="computed函数"></a>computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><pre><code class="js">import &#123;computed&#125; from &#39;vue&#39;setup()&#123;    ...    //计算属性——简写    let fullName = computed(()=&gt;&#123;        return person.firstName + &#39;-&#39; + person.lastName    &#125;)    //计算属性——完整    let fullName = computed(&#123;        get()&#123;            return person.firstName + &#39;-&#39; + person.lastName        &#125;,        set(value)&#123;            const nameArr = value.split(&#39;-&#39;)            person.firstName = nameArr[0]            person.lastName = nameArr[1]        &#125;    &#125;)&#125;</code></pre></li></ul><h3 id="watch函数"><a href="#watch函数" class="headerlink" title="watch函数"></a>watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul><pre><code class="js">//情况一：监视ref定义的响应式数据 immediate表示初始化之后马上执行一次watch(sum,(newValue,oldValue)=&gt;&#123;    console.log(&#39;sum变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true&#125;) //情况二：监视多个ref定义的响应式数据//此时newValue,oldValue分别为两个数组watch([sum,msg],(newValue,oldValue)=&gt;&#123;    console.log(&#39;sum或msg变化了&#39;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123;    console.log(&#39;person变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性 watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;//注意第一个参数要用箭头函数    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况,这个就是情况四watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;    console.log(&#39;person的job变化了&#39;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</code></pre></li></ul><h3 id="watchEffect函数"><a href="#watchEffect函数" class="headerlink" title="watchEffect函数"></a>watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><pre><code class="js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123;    const x1 = sum.value    const x2 = person.age    console.log(&#39;watchEffect配置的回调执行了&#39;)&#125;)</code></pre></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li><li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li></ul></li></ul><h3 id="vue2生命周期"><a href="#vue2生命周期" class="headerlink" title="vue2生命周期"></a>vue2生命周期</h3><p><img src="https://cn.vuejs.org/images/lifecycle.png"></p><h3 id="vue3生命周期"><a href="#vue3生命周期" class="headerlink" title="vue3生命周期"></a>vue3生命周期</h3><p><img src="https://v3.cn.vuejs.org/images/lifecycle.svg"></p><h2 id="自定义hook函数"><a href="#自定义hook函数" class="headerlink" title="自定义hook函数"></a>自定义hook函数</h2><ul><li>什么是hook？—— 本质是一个函数，<font color="red" style="font-weight:bold">把setup函数中使用的Composition API进行了封装</font>。</li><li>类似于vue2.x中的mixin。</li><li>自定义hook的优势: <strong>复用代码, 让setup中的逻辑更清楚易懂</strong>。</li></ul><p>使用方法：把setup可以复用的逻辑代码抽离到一个js文件，然后在需要用的地方import导入即可</p><h2 id="toRef和toRefs"><a href="#toRef和toRefs" class="headerlink" title="toRef和toRefs"></a>toRef和toRefs</h2><ul><li><p>作用：创建一个 ref 对象，<font color="red" style="font-weight:bold">其value值指向另一个对象中的某个属性</font>（注意这里是指向）</p></li><li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p></li><li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><pre><code class="js">setup()&#123;    let person = reactive(&#123;      name: &#39;tom&#39;,      age: 18    &#125;)    let name = toRef(person,&#39;name&#39;)//创建一个 ref 对象    let props = toRefs(person) //批量创建多个ref对象，返回一个ref数组    console.log(props);    return &#123;      //name:toRef(person,&#39;name&#39;)      ...props    &#125;  &#125;</code></pre><p>页面上直接使用</p><pre><code class="html">&lt;div&gt;name:&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;div&gt;age:&#123;&#123;age&#125;&#125;&lt;/div&gt;</code></pre><h1 id="其它-Composition-API"><a href="#其它-Composition-API" class="headerlink" title="其它 Composition API"></a>其它 Composition API</h1><h2 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h2><ul><li>shallowReactive：<font color="red" style="font-weight:bold">只处理对象最外层属性的响应式</font>（浅响应式）。</li><li>shallowRef：<font color="red" style="font-weight:bold">只处理基本数据类型的响应式, 不进行对象的响应式处理</font>。<ul><li>也就是说：  shallowRef(对象)—》不处理      shallowRef(基本类型)—》处理</li></ul></li><li>什么时候使用?<ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li></ul></li></ul><h2 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的-<font color="red" style="font-weight:bold">第一层只读</font>（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。(正好和reactive相反)</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，<font color="orange" style="font-weight:bold">使其永远不会再成为响应式对象</font>。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h2><ul><li><p>作用：创建一个<font color="green" style="font-weight:bold">自定义的 ref</font>，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><pre><code class="vue">&lt;template&gt;    &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;    &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;    import &#123;ref,customRef&#125; from &#39;vue&#39;    export default &#123;        name:&#39;Demo&#39;,        setup()&#123;            // let keyword = ref(&#39;hello&#39;) //使用Vue准备好的内置ref            //自定义一个myRef            function myRef(value,delay)&#123;                let timer                //通过customRef去实现自定义                return customRef((track,trigger)=&gt;&#123;                    return&#123;                        get()&#123;                            track() //告诉Vue这个value值是需要被“追踪”的                            return value                        &#125;,                        set(newValue)&#123;                            clearTimeout(timer)                            timer = setTimeout(()=&gt;&#123;                                value = newValue                                trigger() //告诉Vue去更新界面                            &#125;,delay)                        &#125;                    &#125;                &#125;)            &#125;            let keyword = myRef(&#39;hello&#39;,500) //使用程序员自定义的ref            return &#123;                keyword            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre></li></ul><h2 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h2><p><img src="https://v3.cn.vuejs.org/images/components_provide.png"></p><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><pre><code class="js">setup()&#123;    ......    let car = reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)    provide(&#39;car&#39;,car)    ......&#125;</code></pre></li><li><p>后代组件中：</p><pre><code class="js">setup(props,context)&#123;    ......    const car = inject(&#39;car&#39;)    return &#123;car&#125;    ......&#125;</code></pre></li></ol></li></ul><h2 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a>响应式数据的判断</h2><ul><li>isRef: 检查一个值<strong style="color:red">是否为一个 ref 对象</strong></li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h1><h2 id="Options-API-存在的问题"><a href="#Options-API-存在的问题" class="headerlink" title="Options API 存在的问题"></a>Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="Composition-API-的优势-1"><a href="#Composition-API-的优势-1" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"></p><h1 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h1><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><pre><code class="vue">&lt;!--移动位置可以写body,或者id选择器等--&gt;&lt;teleport to=&quot;移动位置&quot;&gt;    &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;        &lt;div class=&quot;dialog&quot;&gt;            &lt;h3&gt;我是一个弹窗&lt;/h3&gt;            &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/teleport&gt;</code></pre></li></ul><h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><pre><code class="js">import &#123;defineAsyncComponent&#125; from &#39;vue&#39;const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;))</code></pre></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><pre><code class="vue">&lt;template&gt;    &lt;div class=&quot;app&quot;&gt;        &lt;h3&gt;我是App组件&lt;/h3&gt;        &lt;Suspense&gt;            &lt;template v-slot:default&gt;                &lt;Child/&gt;            &lt;/template&gt;            &lt;template v-slot:fallback&gt;                &lt;h3&gt;加载中.....&lt;/h3&gt;            &lt;/template&gt;        &lt;/Suspense&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre></li></ul></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="全局API的转移"><a href="#全局API的转移" class="headerlink" title="全局API的转移"></a>全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><pre><code class="js">//注册全局组件Vue.component(&#39;MyButton&#39;, &#123;  data: () =&gt; (&#123;    count: 0  &#125;),  template: &#39;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#39;&#125;)//注册全局指令Vue.directive(&#39;focus&#39;, &#123;  inserted: el =&gt; el.focus()&#125;</code></pre></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="其他改变"><a href="#其他改变" class="headerlink" title="其他改变"></a>其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><pre><code class="css">.v-enter,.v-leave-to &#123;  opacity: 0;&#125;.v-leave,.v-enter-to &#123;  opacity: 1;&#125;</code></pre></li><li><p>Vue3.x写法</p><pre><code class="css">.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;.v-leave-from,.v-enter-to &#123;  opacity: 1;&#125;</code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><pre><code class="vue">&lt;my-component  v-on:close=&quot;handleComponentEvent&quot;  v-on:click=&quot;handleNativeClickEvent&quot;/&gt;</code></pre></li><li><p>子组件中声明自定义事件</p><pre><code class="vue">&lt;script&gt;  export default &#123;    emits: [&#39;close&#39;]  &#125;&lt;/script&gt;</code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
    
    
    <summary type="html">vue3笔记整理</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript笔记</title>
    <link href="https://heliufang.github.io/posts/9d362be7/"/>
    <id>https://heliufang.github.io/posts/9d362be7/</id>
    <published>2022-07-09T03:03:28.000Z</published>
    <updated>2023-01-08T03:53:03.040Z</updated>
    
    <content type="html"><![CDATA[<p>B站教学视频：<a href="https://www.bilibili.com/video/BV1Xy4y1v7S2">尚硅谷TypeScript教程（李立超老师TS新课）</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>TypeScript是JavaScript的超集。</li><li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li><li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li><li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。</li><li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局ts的命令</p><pre><code>npm i -g typescript</code></pre><p>装好之后输入下面指令即可看到版本号，表示安装成功</p><pre><code>tsc -v</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>新建xxx.ts文件,ts文件里面随便写点js代码</p><ul><li>进入命令行</li><li>进入ts文件所在目录</li><li>执行初始化配置文件的命令： tsc –init</li><li>执行命令：tsc xxx.ts</li></ul><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>略。要用的时候再去查询</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><table><thead><tr><th align="center">类型</th><th align="center">例子</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">number</td><td align="center">1, -33, 2.5</td><td align="center">任意数字</td></tr><tr><td align="center">string</td><td align="center">‘hi’, “hi”, <code>hi</code></td><td align="center">任意字符串</td></tr><tr><td align="center">boolean</td><td align="center">true、false</td><td align="center">布尔值true或false</td></tr><tr><td align="center">字面量</td><td align="center">其本身</td><td align="center">限制变量的值就是该字面量的值</td></tr><tr><td align="center"><strong style="color:red">any</strong></td><td align="center">*</td><td align="center">任意类型</td></tr><tr><td align="center"><strong style="color:red">unknown</strong></td><td align="center">*</td><td align="center">类型安全的any</td></tr><tr><td align="center">void</td><td align="center">空值（undefined）</td><td align="center">没有值（或undefined）</td></tr><tr><td align="center"><strong style="color:red">never</strong></td><td align="center">没有值</td><td align="center">不能是任何值</td></tr><tr><td align="center">object</td><td align="center">{name:’孙悟空’}</td><td align="center">任意的JS对象</td></tr><tr><td align="center">array</td><td align="center">[1,2,3]</td><td align="center">任意JS数组</td></tr><tr><td align="center"><strong style="color:red">tuple（元祖）</strong></td><td align="center">[4,5]</td><td align="center">元素，TS新增类型，固定长度数组</td></tr><tr><td align="center"><strong style="color:red">enum</strong></td><td align="center">enum{A, B}</td><td align="center">枚举，TS中新增类型</td></tr></tbody></table><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><ul><li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p></li><li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p></li><li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p></li></ul><p>语法：</p><pre><code class="typescript">let 变量: 类型;let 变量: 类型 = 值;function fn(参数: 类型, 参数: 类型): 类型&#123;    ...&#125;</code></pre><h3 id="自动类型判断"><a href="#自动类型判断" class="headerlink" title="自动类型判断"></a>自动类型判断</h3><ul><li>TS拥有自动的类型判断机制</li><li>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</li><li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li></ul><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><pre><code class="typescript">let decimal: number = 6;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744;let big: bigint = 100n; //es11</code></pre><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><pre><code class="typescript">let isDone: boolean = false;</code></pre><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><pre><code class="typescript">let color: string = &quot;blue&quot;;color = &#39;red&#39;;let fullName: string = `Bob Bobbington`;let age: number = 37;let sentence: string = `my name is $&#123;fullName&#125;.I&#39;ll be $&#123;age + 1&#125; years old next month.`;</code></pre><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p><pre><code class="typescript">let color: &#39;red&#39; | &#39;blue&#39; | &#39;black&#39;;let num: 1 | 2 | 3 | 4 | 5;</code></pre><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>任意类型(不安全),<strong style="color:red">会使ts的类型判断失效</strong></p><pre><code class="typescript">let d: any = 4;d = &#39;hello&#39;;d = true;d.sayHello() //不会报错</code></pre><h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p>任意类型(安全)</p><pre><code class="typescript">let notSure: unknown = 4;notSure = &#39;hello&#39;;//d.sayHello() //会报错</code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>没有值（当时可以是undefined）</p><pre><code class="typescript">let unusable: void = undefined;</code></pre><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>从不会出现的值，没有值，不能是任何值,永远不会有返回结果（返回“从不”的函数不能具有可访问的终结点）</p><pre><code class="typescript">let good: never;// good = &#39;123&#39;; //error// good = undefined; //error// good = null; //error function goodFun(): never &#123;    // return &#39;123&#39;; //error    // return;  //error    // return undefined; //error    // return null; //error    // console.log(&#39;123&#39;); //error    throw new Error(&#39;error&#39;); //只有这种不报错&#125;</code></pre><h3 id="object（没啥用）"><a href="#object（没啥用）" class="headerlink" title="object（没啥用）"></a>object（没啥用）</h3><pre><code class="typescript">let obj: object = &#123;&#125;;</code></pre><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><pre><code class="typescript">let list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3]; //有点像java的泛型</code></pre><h3 id="tuple（元祖）"><a href="#tuple（元祖）" class="headerlink" title="tuple（元祖）"></a>tuple（元祖）</h3><p>指定数组内部元素的类型和个数</p><pre><code class="typescript">let x: [string, number];x = [&quot;hello&quot;, 10]; </code></pre><h3 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h3><pre><code class="typescript">// 不给默认值Red-0  Green-1 Blue-2enum Color &#123;  Red,  Green,  Blue,&#125;let c: Color = Color.Green;// 给默认值Red-1  Green-2 Blue-3enum Color &#123;  Red = 1,  Green,  Blue,&#125;let c: Color = Color.Green;// 给默认值Red-1  Green-2 Blue-4enum Color &#123;  Red = 1,  Green = 2,  Blue = 4,&#125;let c: Color = Color.Green;</code></pre><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p><p>第一种： 使用as</p><pre><code class="typescript">let someValue: unknown = &quot;this is a string&quot;;let strLength: number = (someValue as string).length;</code></pre><p>第二种：类似java的强制类型转换</p><pre><code class="typescript">let someValue: unknown = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length;</code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象是程序中一个非常重要的思想。简而言之就是程序之中所有的操作都需要通过对象来完成。</p><ul><li>举例来说：<ul><li>操作浏览器要使用window对象</li><li>操作网页要使用document对象</li><li>操作控制台要使用console对象</li></ul></li></ul><p>一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。</p><p>在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。</p><ul><li>定义类</li></ul><pre><code class="typescript">class 类名 &#123;    属性名: 类型;        constructor(参数: 类型)&#123;        this.属性名 = 参数;    &#125;    方法名()&#123;        ....    &#125;&#125;</code></pre><ul><li>示例</li></ul><pre><code class="typescript">class Person&#123;    name: string;    age: number;    constructor(name: string, age: number)&#123;        this.name = name;        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;</code></pre><ul><li>使用类</li></ul><pre><code class="typescript">const p = new Person(&#39;孙悟空&#39;, 18);p.sayHello();</code></pre><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p></li><li><p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</p></li><li><p>只读属性（readonly）：</p><ul><li>如果在声明属性时添加一个<strong style="color:red">readonly</strong>，则属性便成了<strong style="color:red">只读</strong>属性无法修改</li></ul></li><li><p>TS中属性具有三种修饰符：</p><ul><li>public（默认值），可以在类、子类和实例对象中修改</li><li>protected ，可以在类、子类中修改</li><li>private ，可以在类中修改</li></ul></li></ul><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><pre><code class="typescript">class Person&#123;    public name: string; // 写或什么都不写,都是public    public age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以在类中修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中可以修改    &#125;&#125;const p = new Person(&#39;孙悟空&#39;, 18);p.name = &#39;猪八戒&#39;;// 可以通过对象修改</code></pre><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><pre><code class="typescript">class Person&#123;    protected name: string;    protected age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中可以修改    &#125;&#125;const p = new Person(&#39;孙悟空&#39;, 18);p.name = &#39;猪八戒&#39;;// 不能修改</code></pre><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><pre><code class="typescript">class Person&#123;    private name: string;    private age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中不能修改    &#125;&#125;const p = new Person(&#39;孙悟空&#39;, 18);p.name = &#39;猪八戒&#39;;// 不能修改</code></pre><h4 id="属性存取器"><a href="#属性存取器" class="headerlink" title="(*)属性存取器"></a>(*)属性存取器</h4><ul><li><p>对于一些不希望被任意修改的属性，可以将其设置为private</p></li><li><p>直接将其设置为private将导致无法再通过对象修改其中的属性</p></li><li><p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p></li><li><p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p></li></ul><pre><code class="typescript">class Person&#123;    private _name: string;    constructor(name: string)&#123;        this._name = name;    &#125;    get name()&#123;        return this._name;    &#125;    set name(name: string)&#123;        this._name = name;    &#125;&#125;const p1 = new Person(&#39;孙悟空&#39;);console.log(p1.name); // 通过getter读取name属性p1.name = &#39;猪八戒&#39;; // 通过setter修改name属性</code></pre><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><ul><li><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p></li><li><p>静态属性（方法）使用static开头</p></li></ul><pre><code class="typescript">class Tools&#123;    static PI = 3.1415926;        static sum(num1: number, num2: number)&#123;        return num1 + num2    &#125;&#125;console.log(Tools.PI);console.log(Tools.sum(123, 456));</code></pre><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>在类中，使用this表示当前对象</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>继承是面向对象中的又一个特性</li><li>通过继承可以将其他类中的属性和方法引入到当前类中</li><li>通过继承可以在不修改类的情况下完成对类的扩展</li></ul><pre><code class="typescript">class Animal&#123;    name: string;    age: number;    constructor(name: string, age: number)&#123;        this.name = name;        this.age = age;    &#125;&#125;class Dog extends Animal&#123;    bark()&#123;        console.log(`$&#123;this.name&#125;在汪汪叫！`);    &#125;&#125;const dog = new Dog(&#39;旺财&#39;, 4);dog.bark();</code></pre><ul><li>重写:发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</li></ul><pre><code class="typescript">class Animal&#123;    name: string;    age: number;    constructor(name: string, age: number)&#123;        this.name = name;        this.age = age;    &#125;    run()&#123;        console.log(`父类中的run方法！`);    &#125;&#125;class Dog extends Animal&#123;    bark()&#123;        console.log(`$&#123;this.name&#125;在汪汪叫！`);    &#125;    run()&#123;        console.log(`子类中的run方法，会重写父类中的run方法！`);    &#125;&#125;const dog = new Dog(&#39;旺财&#39;, 4);dog.bark();</code></pre><p>在子类中可以使用<strong style="color:red">super</strong>来完成对父类的引用</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</p><pre><code class="typescript">abstract class Animal&#123;    abstract run(): void;    bark()&#123;        console.log(&#39;动物在叫~&#39;);    &#125;&#125;class Dog extends Animals&#123;    run()&#123;        console.log(&#39;狗在跑~&#39;);    &#125;&#125;</code></pre><p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。</p><ul><li>示例（<strong style="color:red">检查对象类型-开发中常用</strong>）：</li></ul><pre><code class="typescript">interface Person&#123;    name: string;    sayHello():void;&#125;function fn(per: Person)&#123;    per.sayHello();&#125;fn(&#123;name:&#39;孙悟空&#39;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);</code></pre><ul><li>示例（实现）</li></ul><pre><code class="typescript">interface Person&#123;    name: string;    sayHello():void;&#125;class Student implements Person&#123;    constructor(public name: string) &#123;    &#125;    sayHello() &#123;        console.log(&#39;大家好，我是&#39;+this.name);    &#125;&#125;</code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。</p><ul><li>举个例子</li></ul><pre><code class="typescript">function test(arg: any): any&#123;    return arg;&#125;</code></pre><p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</p><ul><li>使用泛型</li></ul><pre><code class="typescript">function test&lt;T&gt;(arg: T): T&#123;    return arg;&#125;</code></pre><p>这里的<code>&lt;T&gt;</code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。那么如何使用上边的函数呢？</p><p>方式一（直接使用）</p><pre><code class="typescript">test(10)</code></pre><p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p><p><strong style="color:red">方式二</strong>（指定类型—&gt;这种更好）</p><pre><code class="typescript">test&lt;number&gt;(10)</code></pre><ul><li>同时指定多个泛型，泛型间使用逗号隔开</li></ul><pre><code class="typescript">function test&lt;T, K&gt;(a: T, b: K): K&#123;    return b;&#125;test&lt;number, string&gt;(10, &quot;hello&quot;);</code></pre><p>使用泛型时，完全可以将泛型当成是一个普通的类去使用</p><ul><li>类中同样可以使用泛型</li></ul><pre><code class="typescript">class MyClass&lt;T&gt;&#123;    prop: T;    constructor(prop: T)&#123;        this.prop = prop;    &#125;&#125;</code></pre><ul><li>除此之外，也可以对泛型的范围进行约束</li></ul><pre><code class="typescript">interface MyInter&#123;    length: number;&#125;function test&lt;T extends MyInter&gt;(arg: T): number&#123;    return arg.length;&#125;</code></pre><p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。</p>]]></content>
    
    
    <summary type="html">TypeScript入门笔记整理</summary>
    
    
    
    <category term="web前端" scheme="https://heliufang.github.io/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="typescript" scheme="https://heliufang.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>vue-router笔记</title>
    <link href="https://heliufang.github.io/posts/2c957da0/"/>
    <id>https://heliufang.github.io/posts/2c957da0/</id>
    <published>2022-07-06T13:13:28.000Z</published>
    <updated>2023-01-08T03:53:03.028Z</updated>
    
    <content type="html"><![CDATA[<p>vue-router官网：<a href="https://v3.router.vuejs.org/zh/guide/essentials/navigation.html">https://v3.router.vuejs.org/zh/guide/essentials/navigation.html</a></p><h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>只有一个页面，切换页面不通过服务器刷新页面，而是通过路由和ajax。</p><h2 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h2><p>用 Vue.js + Vue Router 创建单页应用</p><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3><p>Bar.vue</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;bar组件&lt;/div&gt;&lt;/template&gt;</code></pre><p>Foo.vue</p><pre><code class="html">&lt;template&gt;    &lt;div&gt;foo组件&lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="定义路由规则"><a href="#定义路由规则" class="headerlink" title="定义路由规则"></a>定义路由规则</h3><p>router&#x2F;index.js</p><pre><code class="js">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;import Foo from &#39;../views/Foo.vue&#39;import Bar from &#39;../views/Bar.vue&#39;Vue.use(VueRouter)const routes = [  &#123;    path: &#39;/foo&#39;, // 匹配的路径    component: Foo // 匹配的组件  &#125;,  &#123;    path: &#39;/bar&#39;,    component: Bar  &#125;]const router = new VueRouter(&#123;  routes&#125;)export default router</code></pre><h3 id="main-js挂载路由"><a href="#main-js挂载路由" class="headerlink" title="main.js挂载路由"></a>main.js挂载路由</h3><pre><code class="js">import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import router from &#39;./router&#39;import store from &#39;./store&#39;Vue.config.productionTip = falsenew Vue(&#123;  router,//挂载路由  store,  render: h =&gt; h(App)&#125;).$mount(&#39;#app&#39;)</code></pre><h3 id="app-vue展示组件和导航"><a href="#app-vue展示组件和导航" class="headerlink" title="app.vue展示组件和导航"></a>app.vue展示组件和导航</h3><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;APP组件&lt;/h2&gt;    &lt;!--router-link 组件来导航： 通过传入 `to` 属性指定链接    &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签      active-class:表示激活的样式      --&gt;    &lt;router-link to=&quot;/foo&quot; active-class=&quot;active&quot;&gt;foo&lt;/router-link&gt;&amp;nbsp;    &lt;router-link to=&quot;/bar&quot; active-class=&quot;active&quot;&gt;bar&lt;/router-link&gt;    &lt;!-- --&gt;    &lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;less&quot;&gt;  .active&#123;    color: red;  &#125;&lt;/style&gt;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.router.js中定义路由 </p><p>2.main.js中挂载路由</p><p>3.router-link定义路由导航   router-view 定义路由展示区域</p><p>4.main.js中注入路由器之后，在任何组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由</p><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>其实就是restful风格的路径传参</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>第一步：创建组件</p><pre><code class="html">&lt;template&gt;    &lt;!-- 获取路由的路径参数 $route.params --&gt;    &lt;div&gt;user组件id: &#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><p>第二步：router&#x2F;index.js配置路由</p><pre><code class="js">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;import Foo from &#39;../views/Foo.vue&#39;import Bar from &#39;../views/Bar.vue&#39;import User from &#39;../views/User.vue&#39;Vue.use(VueRouter)const routes = [  //....  &#123;    path: &#39;/user/:id&#39;,// 动态路径参数 以冒号开头    component: User  &#125;]const router = new VueRouter(&#123;  routes&#125;)export default router</code></pre><p>第三步：app.vue中使用</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;APP组件&lt;/h2&gt;    &lt;!--此处传递一个666参数,对应路由的id--&gt;    &lt;router-link to=&quot;/user/666&quot; active-class=&quot;active&quot;&gt;User&lt;/router-link&gt;&amp;nbsp;    &lt;!-- --&gt;    &lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>也可以在一个路由中设置多段“路径参数”，对应的值都会设置到 <code>$route.params</code> 中。例如：</p><table><thead><tr><th>模式</th><th>匹配路径</th><th>$route.params</th></tr></thead><tbody><tr><td>&#x2F;user&#x2F;:username</td><td>&#x2F;user&#x2F;evan</td><td><code>&#123; username: &#39;evan&#39; &#125;</code></td></tr><tr><td>&#x2F;user&#x2F;:username&#x2F;post&#x2F;:post_id</td><td>&#x2F;user&#x2F;evan&#x2F;post&#x2F;123</td><td><code>&#123; username: &#39;evan&#39;, post_id: &#39;123&#39; &#125;</code></td></tr></tbody></table><p>如果是通过？传参那么对应的值会设置到<code>$route.query</code>中</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;APP组件&lt;/h2&gt;    &lt;!--通过？传参那么对应的值会设置到`$route.query`--&gt;    &lt;router-link to=&quot;/user?id=1&amp;name=tom&quot; active-class=&quot;active&quot;&gt;User&lt;/router-link&gt;&amp;nbsp;    &lt;!-- --&gt;    &lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h3><p>从 <code>/user/1</code> 导航到  <code>/user/2</code>，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子(destroyed)不会再被调用</strong>。</p><p>例如: 从666切换到777的时候，user组件的destroyed方法不会被调用</p><ul><li>app.vue</li></ul><pre><code class="html">&lt;router-link to=&quot;/user/666&quot; active-class=&quot;active&quot;&gt;User666&lt;/router-link&gt;&amp;nbsp;&lt;router-link to=&quot;/user/777&quot; active-class=&quot;active&quot;&gt;User777&lt;/router-link&gt;&amp;nbsp;</code></pre><ul><li>user.vue</li></ul><pre><code class="html">&lt;template&gt;    &lt;!-- 获取路由的路径参数 --&gt;    &lt;div&gt;user组件id: &#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  destroyed () &#123;    console.log(&#39;User组件被销毁&#39;)  &#125;,  //   watch: &#123;  //     $route (to, from) &#123;  //       console.log(to, from)  //     &#125;  //   &#125;,  beforeRouteUpdate (to, from, next) &#123;    console.log(to, from)    next()  &#125;&#125;&lt;/script&gt;</code></pre><p>两种方式：  监听路由参数的变化作出响应</p><p>第一种：watch监听</p><pre><code class="html">watch: &#123;    $route (to, from) &#123;      console.log(to, from)    &#125;  &#125;</code></pre><p>第二种：使用组件内路由守卫<code>beforeRouteUpdate</code>这个路由钩子</p><pre><code class="js"> beforeRouteUpdate (to, from, next) &#123;    console.log(to, from)    next() //千万别忘了放行  &#125;</code></pre><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符 (*)"></a>通配符 (*)</h3><p>匹配所有。一般把这个放到最后面用来展示404错误页面</p><pre><code class="js">&#123;    path: &#39;*&#39;,    component: Error  &#125;</code></pre><p>匹配以xxx开头</p><pre><code class="js">&#123;    path: &#39;/user-*&#39;,    component: Test  &#125;</code></pre><p>当使用一个<em>通配符</em>时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过<em>通配符</em>被匹配的部分.也就是user-后面的部分</p><pre><code class="js">// 给出一个路由 &#123; path: &#39;/user-*&#39; &#125;this.$router.push(&#39;/user-admin&#39;)this.$route.params.pathMatch // &#39;admin&#39;// 给出一个路由 &#123; path: &#39;*&#39; &#125;this.$router.push(&#39;/non-existing&#39;)this.$route.params.pathMatch // &#39;/non-existing&#39;</code></pre><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><p>路由定义得越早，优先级就越高。</p><h2 id="嵌套路由-多级路由"><a href="#嵌套路由-多级路由" class="headerlink" title="嵌套路由(多级路由)"></a>嵌套路由(多级路由)</h2><p>在路由中新增一个children数组,数组中的每一个对象就是子路由.</p><p>注意： 子路由的path不要写 &#x2F; </p><p>router&#x2F;index.js</p><pre><code class="js">&#123;    path: &#39;/user&#39;,    component: User,    children: [      &#123;        path: &#39;add&#39;,        component: UserAdd      &#125;,      &#123;        path: &#39;update&#39;,        component: UserUpdate      &#125;    ]  &#125;</code></pre><p>user.vue组件</p><pre><code class="html">&lt;template&gt;    &lt;div class=&quot;main&quot;&gt;      &lt;h1&gt;user组件&lt;/h1&gt;      &lt;router-link to=&quot;/user/add&quot;&gt;添加用户&lt;/router-link&gt;      &lt;router-link to=&quot;/user/update&quot;&gt;修改用户&lt;/router-link&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><p>UserAdd.vue组件</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;新增用户组件&lt;/div&gt;&lt;/template&gt;</code></pre><p>UserUpdate.vue组件</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;修改用户组件&lt;/div&gt;&lt;/template&gt;</code></pre><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候</p><pre><code class="js">&#123;      path: &#39;/user/:userId&#39;,      name: &#39;user&#39;, //给路由起个名字      component: User    &#125;</code></pre><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p><h3 id="router-push"><a href="#router-push" class="headerlink" title="router.push()"></a>router.push()</h3><p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td><td><code>router.push(...)</code></td></tr></tbody></table><p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p><pre><code class="js">// 字符串router.push(&#39;home&#39;)// 对象router.push(&#123; path: &#39;home&#39; &#125;)// 命名的路由router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</code></pre><p>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。</p><pre><code class="js">const userId = &#39;123&#39;router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: &#39;/user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user</code></pre><p>记忆：   <strong>pp不能组合（path和params）</strong></p><h3 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace()"></a>router.replace()</h3><p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td><td><code>router.replace(...)</code></td></tr></tbody></table><h3 id="router-go"><a href="#router-go" class="headerlink" title="router.go()"></a>router.go()</h3><pre><code class="js">// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100)</code></pre><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p><pre><code class="html">&lt;router-view&gt;&lt;/router-view&gt;&lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt;</code></pre><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 s)：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/&#39;,      components: &#123; //这里变为components        default: Foo,        a: Bar, //a,b为名字和router-view中的name属性值对应        b: Baz      &#125;    &#125;  ]&#125;)</code></pre><h2 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/a&#39;, redirect: &#39;/b&#39; &#125;  ]&#125;)</code></pre><p>重定向的目标也可以是一个命名的路由：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/a&#39;, redirect: &#123; name: &#39;foo&#39; &#125;&#125;  ]&#125;)</code></pre><p>甚至是一个方法，动态返回重定向目标：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/a&#39;, redirect: to =&gt; &#123;      // 方法接收 目标路由 作为参数      // return 重定向的 字符串路径/路径对象    &#125;&#125;  ]&#125;)</code></pre><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>“重定向”的意思是，当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢？</p><p><strong><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</strong></p><p>上面对应的路由配置为：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/a&#39;, component: A, alias: &#39;/b&#39; &#125;  ]&#125;)</code></pre><p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p><h2 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h2><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。使用 <code>props</code> 将组件和路由解耦：（简化这种写法 $route.params.id）</p><h3 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h3><p>如果 <code>props</code> 被设置为 <code>true</code>，<code>route.params</code> 将会被设置为组件属性（类似父组件给子组件传值）。</p><pre><code class="js">const User = &#123;  props: [&#39;id&#39;], //这里和父组件给子组件传值一样  template: &#39;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#39;&#125;const router = new VueRouter(&#123;  routes: [    &#123; path: &#39;/user/:id&#39;, component: User, props: true &#125;,//props设置为true    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：    &#123;      path: &#39;/user/:id&#39;,      components: &#123; default: User, sidebar: Sidebar &#125;,      props: &#123; default: true, sidebar: false &#125;    &#125;  ]&#125;)</code></pre><h3 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h3><p><code>props</code> 是对象，它会被按原样设置为组件属性。当 <code>props</code> 是<strong>静态</strong>的时候有用。（props后对象是写死的）</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/promotion/from-newsletter&#39;,      component: Promotion,      props: &#123; newsletterPopup: false &#125;    &#125;  ]&#125;)</code></pre><h3 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h3><p>你可以创建一个函数返回 <code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/search&#39;,      component: SearchUser,      props: route =&gt; (&#123; query: route.query.q &#125;)    &#125;  ]&#125;)</code></pre><p>URL <code>/search?q=vue</code> 会将 <code>&#123;query: &#39;vue&#39;&#125;</code> 作为属性传递给 <code>SearchUser</code> 组件。</p><p>请尽可能保持 <code>props</code> 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 <code>props</code>，请使用包装组件，这样 Vue 才可以对状态变化做出反应。</p><h2 id="history工作模式"><a href="#history工作模式" class="headerlink" title="history工作模式"></a>history工作模式</h2><p>hash模式，页面不会重新加载，带#  ，url不好看</p><p>history模式, 页面会重新加载，但是需要后端配合配置，否则就报错了。url好看</p><pre><code class="js">const router = new VueRouter(&#123;  mode: &#39;history&#39;,  routes: [...]&#125;)</code></pre><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>导航守卫主要用来通过跳转或取消的方式守卫导航。分为：全局的, 单个路由独享的,和组件级的</p><p>记住<strong>参数或查询的改变并不会触发进入&#x2F;离开的导航守卫</strong>。你可以通过<a href="https://v3.router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">观察 <code>$route</code> 对象</a>来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫。例如：&#x2F;user&#x2F;1 和 &#x2F;user&#x2F;2 </p><p>守卫说白了，类似拦截器</p><h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p><pre><code class="js">const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123;  // ...&#125;)</code></pre><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p><p>每个守卫方法接收三个参数：</p><ul><li><strong><code>to: Route</code></strong>: 即将要进入的目标 <a href="https://v3.router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1">路由对象</a></li><li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</li><li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。<ul><li><strong><code>next()</code></strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li><li><strong><code>next(false)</code></strong>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li><li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://v3.router.vuejs.org/zh/api/#to"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://v3.router.vuejs.org/zh/api/#router-push"><code>router.push</code></a> 中的选项。</li><li><strong><code>next(error)</code></strong>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://v3.router.vuejs.org/zh/api/#router-onerror"><code>router.onError()</code></a> 注册过的回调。</li></ul></li></ul><p><strong>确保 <code>next</code> 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错</strong>。这里有一个在用户未能验证身份时重定向到 <code>/login</code> 的示例：</p><pre><code class="js">// BADrouter.beforeEach((to, from, next) =&gt; &#123;  if (to.name !== &#39;Login&#39; &amp;&amp; !isAuthenticated) next(&#123; name: &#39;Login&#39; &#125;)  // 如果用户未能验证身份，则 `next` 会被调用两次  next()&#125;)// GOODrouter.beforeEach((to, from, next) =&gt; &#123;  if (to.name !== &#39;Login&#39; &amp;&amp; !isAuthenticated) next(&#123; name: &#39;Login&#39; &#125;)  else next()&#125;)</code></pre><h3 id="全局后置守卫"><a href="#全局后置守卫" class="headerlink" title="全局后置守卫"></a>全局后置守卫</h3><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p><pre><code class="js">router.afterEach((to, from) =&gt; &#123;  // ...&#125;)</code></pre><h3 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h3><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/foo&#39;,      component: Foo,      beforeEnter: (to, from, next) =&gt; &#123;        // ...      &#125;    &#125;  ]&#125;)</code></pre><p>这些守卫与全局前置守卫的方法参数是一样的。</p><h3 id="组件独享守卫"><a href="#组件独享守卫" class="headerlink" title="组件独享守卫"></a>组件独享守卫</h3><p>可以在路由组件内直接定义以下路由导航守卫：</p><ul><li><code>beforeRouteEnter</code>   <strong>通过路由进入组件之前</strong></li><li><code>beforeRouteUpdate</code> (2.2 新增)   <strong>当前路由改变，但是该组件被复用时调用</strong></li><li><code>beforeRouteLeave</code>   <strong>通过路由离开组件之前</strong></li></ul><pre><code class="js">const Foo = &#123;  template: `...`,  beforeRouteEnter(to, from, next) &#123;    // 在渲染该组件的对应路由被 confirm 前调用    // 不！能！获取组件实例 `this`    // 因为当守卫执行前，组件实例还没被创建  &#125;,  beforeRouteUpdate(to, from, next) &#123;    // 在当前路由改变，但是该组件被复用时调用    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。    // 可以访问组件实例 `this`  &#125;,  beforeRouteLeave(to, from, next) &#123;    // 导航离开该组件的对应路由时调用    // 可以访问组件实例 `this`  &#125;&#125;</code></pre><h3 id="activated和deactivated"><a href="#activated和deactivated" class="headerlink" title="activated和deactivated"></a>activated和deactivated</h3><p>当在router-view开启组件缓存的时候,组件不会调用destoryd生命周期方法,此时可以通过activated和deactivated这两个方法判断当前组件是激活状态还是失活状态。</p><pre><code class="html">&lt;!-- 路由出口 ：路由匹配到的组件将渲染在这里 --&gt;    &lt;keep-alive include=&quot;Foo&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;</code></pre><p>Foo.vue</p><pre><code class="html">&lt;template&gt;    &lt;!-- &lt;div&gt;foo组件：&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt; --&gt;    &lt;div&gt;foo组件：&#123;&#123;query&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;Foo&#39;,  props: [&#39;query&#39;],  beforeRouteUpdate (to, from, next) &#123;    console.log(&#39;Foo组件独享守卫--beforeRouteUpdate&#39;, to, from)    next()  &#125;,  activated () &#123; // 组件被激活了    console.log(&#39;Foo组件activated&#39;)  &#125;,  deactivated () &#123;    console.log(&#39;Foo组件deactivated&#39;)  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>定义路由的时候可以配置 <code>meta</code> 字段，那么如何访问这个 <code>meta</code> 字段呢？<code>$route.matched</code> 数组</p><pre><code class="js">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#39;/foo&#39;,      component: Foo,      children: [        &#123;          path: &#39;bar&#39;,          component: Bar,          // a meta field          meta: &#123; requiresAuth: true &#125;        &#125;      ]    &#125;  ]&#125;)</code></pre><p>下面例子展示在全局导航守卫中检查元字段：</p><pre><code class="js">router.beforeEach((to, from, next) =&gt; &#123;  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;    // this route requires auth, check if logged in    // if not, redirect to login page.    if (!auth.loggedIn()) &#123;      next(&#123;        path: &#39;/login&#39;,        query: &#123; redirect: to.fullPath &#125;      &#125;)    &#125; else &#123;      next()    &#125;  &#125; else &#123;    next() // 确保一定要调用 next()  &#125;&#125;)</code></pre><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>结合 Vue 的<a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6">异步组件 (opens new window)</a>和 Webpack 的<a href="https://doc.webpack-china.org/guides/code-splitting-async/#require-ensure-/">代码分割功能 (opens new window)</a>，轻松实现路由组件的懒加载。</p><pre><code class="js">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)</code></pre><p>webpackChunkName为打包分块的名称</p>]]></content>
    
    
    <summary type="html">vue-router笔记整理</summary>
    
    
    
    <category term="vue" scheme="https://heliufang.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://heliufang.github.io/tags/vue/"/>
    
    <category term="vue-router" scheme="https://heliufang.github.io/tags/vue-router/"/>
    
  </entry>
  
</feed>
