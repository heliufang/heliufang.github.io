<html>
<head>
	<title>贺刘芳的搬砖日记-文章页</title>
	<meta charset="utf-8">
  	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="stylesheet" href="../../../../../layui/css/layui.css"/>
	<link rel="stylesheet" href="../../../../../css/common.css"/>
	<link rel="stylesheet" href="../../../../../css/post.css"/>
	<link rel="stylesheet" href="../../../../../lib/google-code-prettify/skins/desert.css"/>
<meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="贺刘芳的搬砖日记" type="application/atom+xml">
</head>
<body>
	<!-- 导航模板 -->
	<!-- 导航 -->
<div class="qy-nav">
  <ul class="layui-nav" lay-filter="" lay-bar="disabled" lay-unselect>
    <li class="layui-nav-item">贺刘芳的搬砖日记</li>
    <li class="hide-xs layui-nav-item "><a href="/"><i class="layui-icon layui-icon-chart-screen"></i> 首页</a></li>
    <li class="hide-xs layui-nav-item "><a href="/about"><i class="layui-icon layui-icon-friends"></i> 关于</a></li>
    <li class="hide-xs layui-nav-item " id="searchBtn"><a href="javascript:void(0);"><i
          class="layui-icon layui-icon-search"></i> 搜索</a></li>
    <li id="mobileMenu" style="float: right" class="hide-sm hide-md hide-lg layui-nav-item ">
      <a href="javascript:void(0);"><i class="layui-icon layui-icon-down"></i> 菜单</a>
    </li>
  </ul>
</div>
<!-- 搜索弹框 -->
<div id="searchShade" class="searchShade">
  <div id="searchLayer">
    <div id="closeBtn" class="close"><i class="layui-icon layui-icon-close"></i></div>
    <input id="searchTxt" type="text" placeholder="搜索文章(只支持文章标题关键字)" />
    <div id="searchResult">
      <!-- <ul>
        <li>java笔记
        <li>
      </ul> -->
    </div>

  </div>
</div>
<script>
  window.onload = function () {
    //下拉菜单
    layui.use('dropdown', function () {
      var dropdown = layui.dropdown
      dropdown.render({
        elem: '#mobileMenu', //可绑定在任意元素中，此处以上述按钮为例
        data: [
          {
            title: '首页'
            , id: 11
            , href: '/'
            // , templet: '<i class="layui-icon layui-icon-chart-screen"></i>  {{d.title}}'
          },
          {
            title: '关于'
            , id: 22
            , href: '/about'
            // , templet: '<i class="layui-icon layui-icon-chart-friends"></i>  {{d.title}}'
          },
          {
            title: '搜索'
            , id: 33
            , href: '#'
            // , templet: '<i class="layui-icon layui-icon-chart-search"></i>  {{d.title}}'
          }
        ],
        click: function (data, othis) {
          var elem = $(this.elem)
            , listId = elem.data('id'); //表格列表的预埋数据
            if(data.id == 33){
              $("#searchShade").show()
            }
        }
      })

    })

    //点击搜索
    $("#searchBtn").click(function () {
      $("#searchShade").show()
    })

    //关闭弹框
    $("#closeBtn").click(function () {
      $("#searchShade").hide()
    })

    //搜索本地文章标题 https://cloud.tencent.com/developer/article/1624646
    var searchFunc = function (path, search_id, content_id) {
      $.ajax({
        url: path,
        dataType: "json",
        success: function (datas) {
          // console.log('datas :>> ', datas);
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function () {
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var data_title = data.title.trim().toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var first_occur = -1;
              if (data_title != '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  if (index_title < 0) {
                    isMatch = false;
                  }
                });
              }
              // show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                str += "</li>";
              }
            });
            str += "</ul>";
            $resultContent.innerHTML = str;
          });
        }
      });
    }
    searchFunc("/" + "search.json", 'searchTxt', 'searchResult');

  }


</script>
	<!-- 中间内容区域 -->
	<div class="layui-container  center" id="top">
		<div class="layui-row layui-col-space20">
			<div class="layui-col-md3 hide-xs hide-sm" >
				<div class="layui-card">
					<div class="layui-card-header"><i style="font-weight: bold;"
							class="layui-icon layui-icon-speaker"></i> 公告</div>
					<div class="layui-card-body">
						<!-- 个人信息模块 -->
						<div class="userinfo">
							<img src="/head.png">
							<div class="name">淡泊明志，宁静致远</div>
							<div class="other">
								<div class="item">
									<p class="num">
										39
									</p>
									<p class="title">文章</p>
								</div>
								<div class="item">
									<p class="num">
										8
									</p>
									<p class="title">分类</p>
								</div>
							</div>
						</div>
					</div>
				</div>
				<!-- 分类 -->
				<div class="layui-card">
					<div class="layui-card-header"><i class="layui-icon layui-icon-template-1"></i> 分类</div>
					<div class="layui-card-body">
						<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/java/">java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/vue/">vue</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/web%E5%89%8D%E7%AB%AF/">web前端</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/">公众号和小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/">其它技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li></ul>
					</div>
				</div>
				<!-- 归档 -->
				<div class="layui-card">
					<div class="layui-card-header"><i style="font-weight: bold;"
							class="layui-icon layui-icon-date"></i> 归档</div>
					<div class="layui-card-body">
						<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/12/">2022 十二月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/10/">2022 十月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/07/">2022 七月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/06/">2022 六月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/03/">2022 三月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/08/">2021 八月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/07/">2021 七月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/05/">2021 五月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/01/">2021 一月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/12/">2020 十二月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/11/">2020 十一月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/08/">2020 八月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/06/">2020 六月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2019/10/">2019 十月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2019/07/">2019 七月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2018/12/">2018 十二月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2018/10/">2018 十月</a><span class="archive-list-count">1</span></li></ul>
					</div>
				</div>
				
				<div style="height: 90%;width: 267px;" id="toc-area"  class="layui-card">
				  <div class="layui-card-header">本文目录</div>
				  <div class="layui-card-body" style="overflow:auto;height: calc(100% - 60px - 50px);">
				   <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">node基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">node是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodejs%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">nodejs与浏览器的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodejs%E5%8F%AF%E4%BB%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">nodejs可以干什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E5%AE%89%E8%A3%85"><span class="toc-text">node安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8Cnode%E7%A8%8B%E5%BA%8F"><span class="toc-text">运行node程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#repl%E6%96%B9%E5%BC%8F"><span class="toc-text">repl方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E6%89%A7%E8%A1%8Cjs%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F-%E6%8E%8C%E6%8F%A1"><span class="toc-text">node执行js文件方式(掌握)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">node常用模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#global%E6%A8%A1%E5%9D%97-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">global模块(全局变量)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs%E6%A8%A1%E5%9D%97-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6"><span class="toc-text">fs模块(操作文件)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E6%96%87%E4%BB%B6"><span class="toc-text">追加文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-text">文件的同步与异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96api%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">其他api（了解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E6%A8%A1%E5%9D%97"><span class="toc-text">http模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-text">创建服务器基本步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#request%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3"><span class="toc-text">request对象详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#response%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3"><span class="toc-text">response对象详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C%E8%AF%B7%E6%B1%82%E8%BE%93%E5%87%BA%E4%B8%8D%E5%90%8C%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE"><span class="toc-text">根据不同请求输出不同响应数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6"><span class="toc-text">服务器响应文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MIME%E7%B1%BB%E5%9E%8B"><span class="toc-text">MIME类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mime%E6%A8%A1%E5%9D%97"><span class="toc-text">mime模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#url%E6%A8%A1%E5%9D%97"><span class="toc-text">url模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#path%E6%A8%A1%E5%9D%97"><span class="toc-text">path模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5"><span class="toc-text">路径拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-text">获取文件名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%89%A9%E5%B1%95%E5%90%8D"><span class="toc-text">获取扩展名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-npm"><span class="toc-text">包管理器-npm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#npm%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">npm的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">npm基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E5%92%8C%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85"><span class="toc-text">本地安装和全局安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package-json%E6%96%87%E4%BB%B6"><span class="toc-text">package.json文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F-nrm"><span class="toc-text">npm下载加速-nrm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nodemon-%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF"><span class="toc-text">nodemon 自动重启</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#art-template-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="toc-text">art-template 模板引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">服务端重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#post%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-text">post请求参数处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E6%A8%A1%E5%9D%97%E5%88%86%E7%B1%BB"><span class="toc-text">node模块分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#module-exports%E4%B8%8Eexports"><span class="toc-text">module.exports与exports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E4%BA%86%E8%A7%A3"><span class="toc-text">第三方模块代码执行流程(了解)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonJS-%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-text">CommonJS 规范参考文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">node操作mysql数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-mysql-%E6%A8%A1%E5%9D%97"><span class="toc-text">配置 mysql 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E6%93%8D%E4%BD%9Cmysql%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">node操作mysql增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-text">添加数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">查询数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-text">修改数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-text">删除数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E6%93%8D%E4%BD%9Cmongodb%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">node操作mongodb数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">数据增删改查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Express%E6%A1%86%E6%9E%B6"><span class="toc-text">Express框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-text">托管静态资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request%E5%92%8Cresponse"><span class="toc-text">request和response</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#request%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">request常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#response%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">response常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#expres%E4%B8%AD%E4%BD%BF%E7%94%A8art-template"><span class="toc-text">expres中使用art-template</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-text">路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">全局中间件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">局部中间件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%88%86%E7%B1%BB"><span class="toc-text">中间件分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">应用级别的中间件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BA%A7%E5%88%AB%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">路由级别的中间件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%BA%A7%E5%88%AB%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">错误级别的中间件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">内置中间件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">第三方中间件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="toc-text">CORS 跨域资源共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS-%E5%B8%B8%E8%A7%81%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-text">CORS 常见响应头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS-%E8%AF%B7%E6%B1%82%E5%88%86%E7%B1%BB"><span class="toc-text">CORS 请求分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82"><span class="toc-text">预检请求</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#express%E4%B8%AD%E4%BD%BF%E7%94%A8cors"><span class="toc-text">express中使用cors</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-text">身份认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt%E8%AE%A4%E8%AF%81"><span class="toc-text">jwt认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">Session 的局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-text">JWT 工作原理图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">JWT 组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">JWT的使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Express-%E4%BD%BF%E7%94%A8-JWT%E8%AE%A4%E8%AF%81"><span class="toc-text">Express 使用 JWT认证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session%E8%AE%A4%E8%AF%81"><span class="toc-text">session认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#session%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86"><span class="toc-text">session认证原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Express%E4%B8%AD%E4%BD%BF%E7%94%A8session%E8%AE%A4%E8%AF%81"><span class="toc-text">Express中使用session认证</span></a></li></ol></li></ol></li></ol>
				  </div>
				  <div class="readprocess">
					  <div>已阅读：<span id="progressTxt"></span>%</div>
					  <div class="layui-progress" lay-filter="demo">
						<div class="layui-progress-bar" lay-percent="10%"></div>
					  </div>
				  </div>
				</div>
				
			</div>
			<div class="layui-col-md9 markdown-body" style="background:#fff;margin-top: 10px;">
				
				<div class="article-title">
					<h1>node笔记</h1>
					<p>
						<i class="layui-icon layui-icon-time"></i>发表于：2022-10-30
						|
						<i class="layui-icon layui-icon-form"></i>字数统计：10.6k
					</p>
				</div>
				
					
				<!-- 文章内容 -->
				<div id="article">
				    <h2 id="node基本概念"><a href="#node基本概念" class="headerlink" title="node基本概念"></a>node基本概念</h2><h3 id="node是什么"><a href="#node是什么" class="headerlink" title="node是什么"></a>node是什么</h3><p>node.js，也叫作node，或者nodejs，指的都是一个东西。</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/">node.js官方网站</a></li>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/">node.js中文网</a></li>
<li><a target="_blank" rel="noopener" href="https://cnodejs.org/">node.js 中文社区</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/nodejs/nodejs-tutorial.html">菜鸟教程-node</a></li>
</ol>
<p>Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。 </p>
<ul>
<li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</li>
</ul>
<pre><code class="hljs plaintext">1. nodejs是在服务端运行javascript的运行环境
2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。
3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎。</code></pre>

<ul>
<li>Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，使其轻量又高效。  </li>
<li>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li>
</ul>
<p><strong>nodejs的本质：不是一门新的编程语言，nodejs是javascript运行在服务端的运行环境，编程语言还是javascript</strong></p>
<h3 id="nodejs与浏览器的区别"><a href="#nodejs与浏览器的区别" class="headerlink" title="nodejs与浏览器的区别"></a>nodejs与浏览器的区别</h3><p>相同点：nodejs与浏览器都是浏览器的运行环境，都能够解析js程序。对于ECMAScript语法来说，在nodejs和浏览器中都能运行。</p>
<p>不同点：<code>nodejs无法使用DOM和BOM的操作</code>，浏览器无法执行nodejs中的文件操作等功能</p>
<p><img src="/2022/10/30/1593064784100724736/images/image-20221024215658030.png" alt="image-20221024215658030"></p>
<h3 id="nodejs可以干什么？"><a href="#nodejs可以干什么？" class="headerlink" title="nodejs可以干什么？"></a>nodejs可以干什么？</h3><ol>
<li>开发服务端程序</li>
<li>开发命令行工具（CLI），比如npm,webpack,gulp,less,sass等</li>
<li>开发桌面应用程序（借助 node-webkit、<code>electron</code> 等框架实现）</li>
</ol>
<h2 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h2><p>下载地址</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">当前版本</a></li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/en/download/releases/">历史版本</a></li>
</ul>
<p>官网术语解释</p>
<ul>
<li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li>
<li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入。</li>
</ul>
<p>下载之后一直点下一步即可完成安装，安装之后查看node版本</p>
<pre><code class="hljs bash">node -v</code></pre>

<h2 id="运行node程序"><a href="#运行node程序" class="headerlink" title="运行node程序"></a>运行node程序</h2><h3 id="repl方式"><a href="#repl方式" class="headerlink" title="repl方式"></a>repl方式</h3><ol>
<li>REPL 全称: Read-Eval-Print-Loop（交互式解释器）<ul>
<li>R 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</li>
<li>E 执行 - 执行输入的数据结构</li>
<li>P 打印 - 输出结果</li>
<li>L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。</li>
</ul>
</li>
<li>在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能）<ul>
<li>直接在控制台输入 <code>node</code> 命令进入 REPL 环境</li>
</ul>
</li>
<li>按两次 Control + C 退出REPL界面 或者 输入 <code>.exit</code> 退出 REPL 界面<ul>
<li>按住 control 键不要放开, 然后按两下 c 键</li>
</ul>
</li>
</ol>
<p><img src="/2022/10/30/1593064784100724736/images/image-20221024220716342.png" alt="image-20221024220716342"></p>
<h3 id="node执行js文件方式-掌握"><a href="#node执行js文件方式-掌握" class="headerlink" title="node执行js文件方式(掌握)"></a>node执行js文件方式(掌握)</h3><ul>
<li>创建js文件 <code>helloworld.js</code></li>
</ul>
<ul>
<li>写nodejs的内容：<code>console.log(&#39;hello nodejs&#39;)</code></li>
<li>打开命令窗口 <code>cmd</code><ul>
<li>shift加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li>
<li>给vscode安装<code>terminal</code>插件，直接在vscode中执行</li>
</ul>
</li>
<li>执行命令：<code>node helloworld.js</code></li>
</ul>
<p>注意：<strong style="color:red">在nodejs中是无法使用DOM和BOM的内容的，因此<code>document, window</code>等内容是无法使用的。</strong></p>
<h2 id="node常用模块"><a href="#node常用模块" class="headerlink" title="node常用模块"></a>node常用模块</h2><h3 id="global模块-全局变量"><a href="#global模块-全局变量" class="headerlink" title="global模块(全局变量)"></a>global模块(全局变量)</h3><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 <code>global</code>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<p>常用的global属性</p>
<pre><code class="hljs js"><span class="hljs-attr">console</span>: <span class="hljs-comment">//用于打印日志</span>
<span class="hljs-built_in">setTimeout</span>/<span class="hljs-attr">clearTimeout</span>: <span class="hljs-comment">//设置清除延时器</span>
<span class="hljs-built_in">setInterval</span>/<span class="hljs-attr">clearInterval</span>: <span class="hljs-comment">//设置清除定时器</span>

<span class="hljs-attr">__dirname</span>: <span class="hljs-comment">//当前文件的路径，不包括文件名</span>
__filename： <span class="hljs-comment">//获取当前文件的路径，包括文件名</span>

<span class="hljs-comment">//与模块化相关的，模块化的时候会用到</span>
<span class="hljs-built_in">require</span>
<span class="hljs-built_in">exports</span>
<span class="hljs-variable language_">module</span></code></pre>

<h3 id="fs模块-操作文件"><a href="#fs模块-操作文件" class="headerlink" title="fs模块(操作文件)"></a>fs模块(操作文件)</h3><blockquote>
<p>fs模块是nodejs中最常用的一个模块，因此掌握fs模块非常的有必要，fs模块的方法非常多,用到了哪个查哪个即可。</p>
<p>文档地址：<a target="_blank" rel="noopener" href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p>
</blockquote>
<p>  在nodejs中，提供了fs模块，这是node的核心模块</p>
<p>  注意：</p>
<ol>
<li>除了global模块中的内容可以直接使用，其他<strong style="color:red">模块都是需要加载的</strong>。</li>
<li>fs模块不是全局的，不能直接使用。因此需要导入才能使用。</li>
</ol>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);</code></pre>

<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><blockquote>
<p>语法：fs.readFile(path[,options], callback</p>
<p>path: 带文件名称的文件路径</p>
<p>options： 文件编码(可选) 若不传则返回buffer对象</p>
<p>callback(err,data):   文件读完的回调</p>
</blockquote>
<p>方式1：不传编码参数,回调函数中可以得到buffer对象,需要使用toString转化成字符串</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;1.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>) =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <span class="hljs-comment">//打印buffer对象</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">//正常打印字符串</span>
&#125;)</code></pre>

<p>方式2： 传编码参数,回调函数中可以得到读取到的字符串</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>) =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data :&gt;&gt; &#x27;</span>, data);
&#125;)</code></pre>

<p>关于Buffer对象</p>
<pre><code class="hljs plaintext">1. Buffer对象是Nodejs用于处理二进制数据的。
2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制。
3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象
4. Buffer对象可以调用toString()方法转换成字符串。</code></pre>

<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><blockquote>
<p>语法：fs.writeFile(filepath, data[, options], callback)</p>
<p>filepath：带文件名称的文件路径</p>
<p>data： 要写入的文件内容</p>
<p>callback(err)： 写入成功之后的回调</p>
</blockquote>
<p>注意：此方式会把之前文件的内容覆盖</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)
fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;2.txt&#x27;</span>,<span class="hljs-string">&#x27;node写文件&#x27;</span>,<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入成功！&#x27;</span>)
&#125;)</code></pre>

<h4 id="追加文件"><a href="#追加文件" class="headerlink" title="追加文件"></a>追加文件</h4><blockquote>
<p>语法：fs.appendFile(filepath, data[, options], callback)</p>
<p>filepath：带文件名称的文件路径</p>
<p>data： 要追加的文件内容</p>
<p>callback(err)： 追加成功之后的回调</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)
fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">&#x27;2.txt&#x27;</span>,<span class="hljs-string">&#x27;我是追加的&#x27;</span>,<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;追加成功！&#x27;</span>)
&#125;)</code></pre>

<p>思考：如果没有appendFile，通过readFile与writeFile应该怎么实现？</p>
<pre><code class="hljs plaintext">先把之前的内容readFile读取
再将之前的内容+新内容拼串
最后把拼接好的内容通过writeFile写入文件</code></pre>

<h4 id="文件的同步与异步"><a href="#文件的同步与异步" class="headerlink" title="文件的同步与异步"></a>文件的同步与异步</h4><blockquote>
<p>fs中所有的文件操作，都提供了异步和同步两种方式</p>
</blockquote>
<p>异步方式：不会阻塞代码的执行</p>
<pre><code class="hljs js"><span class="hljs-comment">//异步方式</span>
<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>)&#123;
  <span class="hljs-keyword">if</span>(err) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;读取文件失败&quot;</span>, err);
  &#125;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
&#125;);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;222&quot;</span>);</code></pre>

<p>同步方式：会阻塞代码的执行</p>
<pre><code class="hljs js"><span class="hljs-comment">//同步方式</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);
<span class="hljs-keyword">var</span> result = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);</code></pre>

<p><strong style="color:red">总结</strong>：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p>
<h4 id="其他api（了解）"><a href="#其他api（了解）" class="headerlink" title="其他api（了解）"></a>其他api（了解）</h4><p>方法有很多，但是用起来都非常的简单，学会查文档。文档：<a target="_blank" rel="noopener" href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>fs.readFile(path, callback)</code></td>
<td>读取文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.readFileSync(path)</code></td>
<td>读取文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.writeFile(path, data, callback)</code></td>
<td>写入文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.writeFileSync(path, data)</code></td>
<td>写入文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.appendFile(path, data, callback)</code></td>
<td>追加文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.appendFileSync(path, data)</code></td>
<td>追加文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.rename(oldPath, newPath, callback)</code></td>
<td>重命名文件（异步）</td>
</tr>
<tr>
<td><code>fs.renameSync(oldPath, newPath)</code></td>
<td>重命名文件（同步）</td>
</tr>
<tr>
<td><code>fs.unlink(path, callback)</code></td>
<td>删除文件（异步）</td>
</tr>
<tr>
<td><code>fs.unlinkSync(path)</code></td>
<td>删除文件（同步）</td>
</tr>
<tr>
<td><code>fs.mkdir(path, mode, callback)</code></td>
<td>创建文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.mkdirSync(path, mode)</code></td>
<td>创建文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.rmdir(path, callback)</code></td>
<td>删除文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.rmdirSync(path)</code></td>
<td>删除文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.readdir(path, option, callback)</code></td>
<td>读取文件夹内容（异步）</td>
</tr>
<tr>
<td><code>fs.readdirSync(path, option)</code></td>
<td>读取文件夹内容（同步）</td>
</tr>
<tr>
<td><code>fs.stat(path, callback)</code></td>
<td>查看文件状态（异步）</td>
</tr>
<tr>
<td><code>fs.statSync(path)</code></td>
<td>查看文件状态（同步）</td>
</tr>
</tbody></table>
<h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><h4 id="创建服务器基本步骤"><a href="#创建服务器基本步骤" class="headerlink" title="创建服务器基本步骤"></a>创建服务器基本步骤</h4><pre><code class="hljs js"><span class="hljs-comment">//1. 导入http模块，http模块是node的核心模块，作用是用来创建http服务器的。</span>
<span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);

<span class="hljs-comment">//2. 创建服务器-createServer方法</span>
<span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>();

<span class="hljs-comment">//3. 服务器处理请求-on监听request事件</span>
server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我接收到请求了&quot;</span>);
&#125;);

<span class="hljs-comment">//4. 启动服务器，监听某个端口-通过listen监听某个端口来启动服务</span>
server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">9999</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;服务器启动成功了, 请访问： http://localhost:9999&quot;</span>);
&#125;);</code></pre>

<p>详细说明</p>
<ol>
<li>给服务器注册request事件，只要服务器接收到了客户端的请求，就会触发request事件</li>
<li>request事件有两个参数，request表示请求对象，可以获取所有与请求相关的信息，response是响应对象，可以获取所有与响应相关的信息。</li>
<li>服务器监听的端口范围为：1-65535之间，推荐使用3000以上的端口，因为3000以下的端口一般留给系统使用</li>
</ol>
<h4 id="request对象详解"><a href="#request对象详解" class="headerlink" title="request对象详解"></a>request对象详解</h4><p>文档地址：<a target="_blank" rel="noopener" href="http://nodejs.cn/api/http.html#http_message_headers">http://nodejs.cn/api/http.html#http_message_headers</a></p>
<p>常见属性：</p>
<pre><code class="hljs javascript">method： 请求的方式
url： 请求的地址
<span class="hljs-attr">headers</span>: 所有的请求头信息
rawHeaders： 所有的请求头信息（数组的方式）</code></pre>

<p>例如</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)

<span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>()

server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">request,response</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">let</span> &#123;method,url&#125; = request
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;method :&gt;&gt; &#x27;</span>, method);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;url :&gt;&gt; &#x27;</span>, url);
&#125;)

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>,<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server start success at 8000&#x27;</span>))</code></pre>

<p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求。</p>
<p>小结：request对象中，常用的就是<code>method</code>和<code>url</code>两个参数</p>
<h4 id="response对象详解"><a href="#response对象详解" class="headerlink" title="response对象详解"></a>response对象详解</h4><p>文档地址：<a target="_blank" rel="noopener" href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p>
<p>常见的属性和方法：</p>
<pre><code class="hljs javascript">res.<span class="hljs-title function_">write</span>(data): 给浏览器发送请求体，可以调用多次，从而提供连续的请求体
res.<span class="hljs-title function_">end</span>();   通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成。
res.<span class="hljs-title function_">end</span>(data); 结束请求，并且响应一段内容，相当于res.<span class="hljs-title function_">write</span>(data) + res.<span class="hljs-title function_">end</span>()
res.<span class="hljs-property">statusCode</span>: 响应的的状态码 <span class="hljs-number">200</span> <span class="hljs-number">404</span> <span class="hljs-number">500</span>
res.<span class="hljs-property">statusMessage</span>: 响应的状态信息， <span class="hljs-variable constant_">OK</span> <span class="hljs-title class_">Not</span> <span class="hljs-title class_">Found</span> ,会根据statusCode自动设置。
res.<span class="hljs-title function_">setHeader</span>(name, value); 设置响应头信息， 比如content-type
res.<span class="hljs-title function_">writeHead</span>(statusCode, statusMessage, options); 设置响应头，同时可以设置状态码和状态信息。</code></pre>

<p><strong>注意：必须先设置响应头，才能设置响应体。</strong> </p>
<p>案例</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)

<span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>()

server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// res.writeHead(200,&#123;&#x27;content-type&#x27;: &#x27;application/json&#x27;&#125;)</span>
    <span class="hljs-comment">// res.write(JSON.stringify(&#123;name: &#x27;tom&#x27; , age: 18&#125;))</span>
    <span class="hljs-comment">// res.end()</span>

    <span class="hljs-comment">//res.setHeader(&#x27;content-type&#x27;, &#x27;application/json&#x27;)</span>
    res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerry&#x27;</span> , <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;))
&#125;)

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>,<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server start success at 8000&#x27;</span>))</code></pre>

<h4 id="根据不同请求输出不同响应数据"><a href="#根据不同请求输出不同响应数据" class="headerlink" title="根据不同请求输出不同响应数据"></a>根据不同请求输出不同响应数据</h4><ul>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/api/http.html#http_message_url">request.url</a></li>
<li><code>req.url</code>：获取请求路径<ul>
<li>例如：请求<code>http://127.0.0.1:3000/index</code> 获取到的是：<code>/index</code></li>
<li>例如：请求<code>http://127.0.0.1:3000/</code> 获取到的是：<code>/</code></li>
<li>例如：请求<code>http://127.0.0.1:3000</code> 获取到的是：<code>/</code></li>
</ul>
</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)

<span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>()

server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">let</span> &#123;url&#125; = req
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;url :&gt;&gt; &#x27;</span>, url);
    <span class="hljs-keyword">let</span> pageName = <span class="hljs-string">&#x27;未知页面&#x27;</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;/&#x27;</span> === url)&#123;
        pageName = <span class="hljs-string">&#x27;首页&#x27;</span>
    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;/login&#x27;</span> === url)&#123;   
        pageName = <span class="hljs-string">&#x27;登录页&#x27;</span>
    &#125;
    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;content-type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>)
    res.<span class="hljs-title function_">end</span>(pageName)
&#125;)

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>,<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server start success at 8000&#x27;</span>))</code></pre>

<h4 id="服务器响应文件"><a href="#服务器响应文件" class="headerlink" title="服务器响应文件"></a>服务器响应文件</h4><p>浏览器中输入的URL地址，仅仅是一个标识，不与服务器中的目录一致。</p>
<p>也就是说：返回什么内容是由服务端的逻辑决定</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)
<span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)

<span class="hljs-keyword">let</span> server = http.<span class="hljs-title function_">createServer</span>()

server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">let</span> &#123;url&#125; = req
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;url :&gt;&gt; &#x27;</span>, url);
    <span class="hljs-keyword">let</span> pageName = <span class="hljs-string">&#x27;error.html&#x27;</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;/&#x27;</span> === url)&#123;
        pageName = <span class="hljs-string">&#x27;index.html&#x27;</span>
    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;/login&#x27;</span> === url)&#123;   
        pageName = <span class="hljs-string">&#x27;login.html&#x27;</span>
    &#125;
    <span class="hljs-comment">//读取不同的文件,返回</span>
    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">`./pages/<span class="hljs-subst">$&#123;pageName&#125;</span>`</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>) =&gt;</span> &#123;
        res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;content-type&#x27;</span>, <span class="hljs-string">&#x27;text/html&#x27;</span>)
        res.<span class="hljs-title function_">end</span>(data)
    &#125;)
&#125;)

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>,<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server start success at 8000&#x27;</span>))</code></pre>

<h4 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h4><ul>
<li>MIME(Multipurpose Internet Mail Extensions)多用途Internet邮件扩展类型 是一种表示文档性质和格式的标准化方式</li>
<li>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的MIME类型附加到响应对象的头部是非常重要的</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types">MIME 类型</a></li>
</ul>
<h5 id="mime模块"><a href="#mime模块" class="headerlink" title="mime模块"></a>mime模块</h5><ul>
<li>作用：获取文件的MIME类型</li>
<li>安装：<code>npm i mime</code></li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> mime = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mime&#x27;</span>)

<span class="hljs-comment">// 获取路径对应的MIME类型</span>
mime.<span class="hljs-title function_">getType</span>(<span class="hljs-string">&#x27;txt&#x27;</span>)                    <span class="hljs-comment">// ⇨ &#x27;text/plain&#x27;</span>
<span class="hljs-comment">// 根据MIME获取到文件后缀名</span>
mime.<span class="hljs-title function_">getExtension</span>(<span class="hljs-string">&#x27;text/plain&#x27;</span>)        <span class="hljs-comment">// ⇨ &#x27;txt&#x27;</span></code></pre>

<h3 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h3><ul>
<li>说明：用于 URL 处理与解析</li>
<li>注意：通过url拿到的查询参数都是字符串格式</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// 导入url模块</span>
<span class="hljs-keyword">let</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)

<span class="hljs-comment">// 解析 URL 字符串并返回一个 URL 对象</span>
<span class="hljs-comment">// 第一个参数：表示要解析的URL字符串</span>
<span class="hljs-comment">// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象</span>
<span class="hljs-keyword">let</span> res = url.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;http://localhost:3000/details?id=1&amp;name=jack&#x27;</span>, <span class="hljs-literal">true</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">query</span>) <span class="hljs-comment">// &#123; id: &#x27;1&#x27;, name: &#x27;jack&#x27; &#125;</span></code></pre>

<h3 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h3><h4 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h4><p>语法：path.join(path1,path2…)</p>
<p>作用：用来拼接字符串</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)
<span class="hljs-comment">//1 基本用法(掌握)</span>
<span class="hljs-keyword">const</span> res1 = path.<span class="hljs-title function_">join</span>(__dirname,<span class="hljs-string">&#x27;1.txt&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;res1:&#x27;</span>,res1) <span class="hljs-comment">// res1: D:\webcode\node-test\6.path模块\1.txt</span>
<span class="hljs-comment">//2 一个../ 会抵消一个上一级目录(了解)</span>
<span class="hljs-keyword">const</span> res2 = path.<span class="hljs-title function_">join</span>(__dirname,<span class="hljs-string">&#x27;../&#x27;</span>,<span class="hljs-string">&#x27;1.txt&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;res2:&#x27;</span>,res2) <span class="hljs-comment">// res2: D:\webcode\node-test\1.txt</span>
<span class="hljs-comment">//3 ./ 会被忽略(了解)</span>
<span class="hljs-keyword">const</span> res3 = path.<span class="hljs-title function_">join</span>(__dirname,<span class="hljs-string">&#x27;./&#x27;</span>,<span class="hljs-string">&#x27;1.txt&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;res3:&#x27;</span>,res3) <span class="hljs-comment">// res3: D:\webcode\node-test\6.path模块\1.txt</span></code></pre>

<h4 id="获取文件名"><a href="#获取文件名" class="headerlink" title="获取文件名"></a>获取文件名</h4><p>使用 <code>path.basename()</code> 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名</p>
<p>语法：path.basename(path[, ext])</p>
<ul>
<li>path: 文件路径</li>
<li>ext: 文件扩展名（可选）</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)
<span class="hljs-keyword">const</span> filepath = <span class="hljs-string">&#x27;D:/webcode/node-test/1.txt&#x27;</span>
<span class="hljs-comment">//获取文件名带后缀</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">basename</span>(filepath))<span class="hljs-comment">//1.txt </span>
<span class="hljs-comment">//获取文件名不带后缀</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">basename</span>(filepath,<span class="hljs-string">&#x27;.txt&#x27;</span>))<span class="hljs-comment">//1 </span></code></pre>

<h4 id="获取扩展名"><a href="#获取扩展名" class="headerlink" title="获取扩展名"></a>获取扩展名</h4><p>语法：<code>path.extname(filepath)</code></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> filepath = <span class="hljs-string">&#x27;D:/webcode/node-test/1.txt&#x27;</span>
<span class="hljs-comment">//获取扩展名</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(path.<span class="hljs-title function_">extname</span>(filepath)) <span class="hljs-comment">//.txt</span></code></pre>



<h2 id="包管理器-npm"><a href="#包管理器-npm" class="headerlink" title="包管理器-npm"></a>包管理器-npm</h2><h3 id="npm的基本概念"><a href="#npm的基本概念" class="headerlink" title="npm的基本概念"></a>npm的基本概念</h3><ul>
<li>node package manager</li>
<li><a target="_blank" rel="noopener" href="https://npmjs.com/">npm官网</a></li>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com.cn/">npm中文文档</a></li>
</ul>
<pre><code class="hljs plaintext">1. npm 是node的包管理工具，
2. 它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。
3. 来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。

npm 由三个独立的部分组成：
    网站
    注册表（registry）
    命令行工具 (CLI)</code></pre>

<ul>
<li>作用：通过<code>npm</code>来快速安装开发中使用的包</li>
<li>npm不需要安装，只要安装了node，就自带了<code>npm</code></li>
</ul>
<h3 id="npm基本使用"><a href="#npm基本使用" class="headerlink" title="npm基本使用"></a>npm基本使用</h3><ul>
<li>初始化包</li>
</ul>
<pre><code class="hljs js">npm init;    <span class="hljs-comment">//这个命令用于初始化一个包，创建一个package.json文件，我们的项目都应该先执行npm init</span>
npm init -y;  <span class="hljs-comment">//快速的初始化一个包， 不能是一个中文名</span></code></pre>

<ul>
<li>安装包</li>
</ul>
<pre><code class="hljs js">npm install 包名;  <span class="hljs-comment">//安装指定的包名的最新版本到项目中</span>
npm install 包名@版本号;  <span class="hljs-comment">//安装指定包的指定版本</span>

npm i 包名； <span class="hljs-comment">//简写</span></code></pre>

<ul>
<li>卸载包</li>
</ul>
<pre><code class="hljs js">npm uninstall 包名;  <span class="hljs-comment">//卸载已经安装的包</span>

npm uni 包名；<span class="hljs-comment">//简写</span></code></pre>

<h3 id="本地安装和全局安装"><a href="#本地安装和全局安装" class="headerlink" title="本地安装和全局安装"></a>本地安装和全局安装</h3><p>有两种方式用来安装 npm 包：本地安装和全局安装。选用哪种方式来安装，取决于你如何使用这个包。 </p>
<ul>
<li>全局安装：如果你想将其作为一个命令行工具，那么你应该将其安装到全局。这种安装方式后可以让你在任何目录下使用这个命令。比如less命令，webpack命令。</li>
<li>本地安装：如果你自己的模块依赖于某个包，并通过 Node.js 的 <code>require</code> 加载，那么你应该选择本地安装，这种方式也是 <code>npm install</code> 命令的默认行为。</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// 全局安装,会把npm包安装到C:\Users\cc\AppData\Roaming\npm目录下，作为命令行工具使用</span>
npm install -g 包名;

<span class="hljs-comment">//本地安装，会把npm包安装到当前项目的node_modules文件中，作为项目的依赖</span>
npm install 包名;</code></pre>

<h3 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a>package.json文件</h3><p>package.json文件，包（项目）描述文件，用来管理组织一个包（项目），它是一个纯JSON格式的。</p>
<ul>
<li>作用：描述当前项目（包）的信息，描述当前包（项目）的依赖项</li>
<li>如何生成：<code>npm init</code>或者<code>npm init -y</code></li>
<li>作用<ul>
<li>作为一个标准的包，必须要有<code>package.json</code>文件进行描述</li>
<li>一个项目的node_modules目录通常都会很大，不用拷贝node_modules目录，可以通过package.json文件配合<code>npm install</code>直接安装项目所有的依赖项</li>
</ul>
</li>
<li>描述内容</li>
</ul>
<pre><code class="hljs js">&#123;
  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;03-npm&quot;</span>,  <span class="hljs-comment">//描述了包的名字，不能有中文</span>
  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,  <span class="hljs-comment">//描述了包的的版本信息， x.y.z  如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。</span>
  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">//包的描述信息</span>
  <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>, <span class="hljs-comment">//入口文件（模块化加载规则的时候详细的讲）</span>
  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;  <span class="hljs-comment">//配置一些脚本，在vue的时候会用到，现在体会不到</span>
    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>
  &#125;,
  <span class="hljs-string">&quot;keywords&quot;</span>: [],  <span class="hljs-comment">//关键字（方便搜索）</span>
  <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,  <span class="hljs-comment">//作者的信息</span>
  <span class="hljs-string">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span>,  <span class="hljs-comment">//许可证，开源协议</span>
  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;   <span class="hljs-comment">//重要，项目的依赖， 方便代码的共享  通过 npm install可以直接安装所有的依赖项</span>
    <span class="hljs-string">&quot;bootstrap&quot;</span>: <span class="hljs-string">&quot;^3.3.7&quot;</span>,
    <span class="hljs-string">&quot;jquery&quot;</span>: <span class="hljs-string">&quot;^3.3.1&quot;</span>
  &#125;
&#125;</code></pre>

<p><strong>注意：一个合法的package.json，必须要有name和version两个属性</strong> </p>
<p>如果安装失败， 可以通过以下命令清除npm缓存：</p>
<pre><code class="hljs js">npm cache clean -f  <span class="hljs-comment">// -f强制清除</span></code></pre>

<h3 id="npm下载加速-nrm"><a href="#npm下载加速-nrm" class="headerlink" title="npm下载加速-nrm"></a>npm下载加速-nrm</h3><ul>
<li>nrm：npm registry manager（npm仓库地址管理工具）</li>
<li>安装：<code>npm i -g nrm</code></li>
</ul>
<pre><code class="hljs bash"><span class="hljs-comment"># 带*表示当前正在使用的地址</span>

<span class="hljs-comment"># 查看仓库地址列表</span>
nrm <span class="hljs-built_in">ls</span>

<span class="hljs-comment"># 切换仓库地址</span>
nrm use taobao</code></pre>

<h2 id="nodemon-自动重启"><a href="#nodemon-自动重启" class="headerlink" title="nodemon 自动重启"></a>nodemon 自动重启</h2><ul>
<li>作用：监视到js文件修改后，自动重启node程序</li>
<li>安装：<code>npm i -g nodemon</code></li>
<li>使用：<code>nodemon app.js</code> 运行node程序</li>
</ul>
<h2 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art-template 模板引擎"></a>art-template 模板引擎</h2><ul>
<li><a target="_blank" rel="noopener" href="https://aui.github.io/art-template/zh-cn/docs/">文档</a></li>
<li>安装： <code>npm install art-template</code></li>
</ul>
<ul>
<li>核心方法</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// 基于模板路径渲染模板</span>
<span class="hljs-comment">//参数1：文件的路径</span>
<span class="hljs-comment">//参数2：数据</span>
<span class="hljs-comment">//返回值：返回渲染后的内容</span>
<span class="hljs-comment">// template(filename, data)</span>
<span class="hljs-keyword">let</span> html = <span class="hljs-title function_">template</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-string">&quot;index.html&quot;</span>), &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;大吉大利，今晚吃鸡&quot;</span>&#125;);</code></pre>

<p><strong>注意点：文件的路径必须是绝对路径</strong></p>
<h2 id="服务端重定向"><a href="#服务端重定向" class="headerlink" title="服务端重定向"></a>服务端重定向</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 状态码说明</a></li>
<li><a target="_blank" rel="noopener" href="http://shuai.be/archives/301-302-redirection/">301 和 302</a></li>
<li>说明：服务端可以通过HTTP状态码让浏览器中的页面重定向</li>
</ul>
<pre><code class="hljs js">res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">302</span>, &#123;
  <span class="hljs-string">&#x27;Location&#x27;</span>: <span class="hljs-string">&#x27;/&#x27;</span>
&#125;)
res.<span class="hljs-title function_">end</span>()</code></pre>

<h2 id="post请求参数处理"><a href="#post请求参数处理" class="headerlink" title="post请求参数处理"></a>post请求参数处理</h2><p>说明：POST请求可以发送大量数据，没有大小限制</p>
<pre><code class="hljs js"><span class="hljs-comment">// 接受POST参数</span>
<span class="hljs-keyword">var</span> postData = []

<span class="hljs-comment">// 给req注册一个data事件， 只要浏览器给服务器发送post请求，data事件就会触发</span>
<span class="hljs-comment">// post请求发送的数据量可以很大， 这个data事件会触发多次，一块一块的传输</span>
<span class="hljs-comment">// 要把所有的chunk都拼接起来</span>
<span class="hljs-comment">// data事件：用来接受客户端发送过来的POST请求数据</span>
<span class="hljs-keyword">var</span> result = <span class="hljs-string">&quot;&quot;</span>;
req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) &#123;
  result += chunk;
&#125;)

<span class="hljs-comment">// end事件：当POST数据接收完毕时，触发</span>
req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
  cosnole.<span class="hljs-title function_">log</span>(result); 
&#125;)</code></pre>

<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化规范：</p>
<ul>
<li>AMD:  requirejs</li>
<li>CMD:  seajs  玉伯  浏览器端的模块 </li>
<li>commonJS： nodejs  服务端的模块</li>
</ul>
<blockquote>
<p>在nodejs中，应用由模块组成，nodejs中采用commonJS模块规范。</p>
</blockquote>
<ol>
<li>一个js文件就是一个模块</li>
<li>每个模块都是一个独立的作用域，在这个而文件中定义的变量、函数、对象都是私有的，对其他文件不可见。</li>
</ol>
<h3 id="node模块分类"><a href="#node模块分类" class="headerlink" title="node模块分类"></a>node模块分类</h3><ul>
<li><p>1 核心模块</p>
<ul>
<li>由 node 本身提供，不需要单独安装（npm），可直接引入使用。例如：fs模块、path模块等</li>
</ul>
</li>
<li><p>2 第三方模块</p>
<ul>
<li>由社区或个人提供，需要通过npm安装后使用。</li>
</ul>
</li>
<li><p>3 自定义模块</p>
<ul>
<li><p>由开发人员创建的模块（JS文件）</p>
</li>
<li><p>基本使用：1 创建模块 2 引入模块</p>
</li>
<li><p>注意：自定义模块的路径必须以<code>./</code>获取<code>../</code>开头</p>
</li>
<li><p>&#96;&#96;&#96;js<br>&#x2F;&#x2F; 加载模块<br>require(‘.&#x2F;a’)     &#x2F;&#x2F; 推荐使用，省略.js后缀！</p>
<p>require(‘.&#x2F;a.js’)</p>
<pre><code class="hljs plaintext">
### 模块的导入导出

#### 模块导入

- 通过`require(&quot;fs&quot;)`来加载模块
- 如果是第三方模块，需要先使用npm进行下载
- 如果是自定义模块，需要加上相对路径`./`或者`../`,可以省略`.js`后缀，如果文件名是`index.js`那么index.js也可以省略。
- 模块可以被多次导入，但是`只会在第一次加载`

#### 模块导出

在模块的内部，&lt;strong style=&#x27;color:red&#x27;&gt;module变量代表的就是当前模块&lt;/strong&gt;，它的`exports`属性就是对外的接口，加载某个模块，加载的就是`module.exports`属性，这个属性指向一个空的对象。

```js
//module.exports指向的是一个对象，我们给对象增加属性即可。
//module.exports.num = 123;
//module.exports.age = 18;

//通过module.exports也可以导出一个值，但是多次导出会覆盖
module.exports = &#x27;123&#x27;;
module.exports = &quot;abc&quot;;</code></pre></li>
</ul>
</li>
</ul>
<h4 id="module-exports与exports"><a href="#module-exports与exports" class="headerlink" title="module.exports与exports"></a>module.exports与exports</h4><ul>
<li><code>exports</code> 是 <code>module.exports</code> 的引用</li>
<li>注意：给 <code>module.exports</code> 赋值会<code>切断</code>与 <code>exports</code> 之间的联系<ul>
<li>1 直接添加属性两者皆可</li>
<li>2 赋值操作时，只能使用 <code>module.exports</code></li>
</ul>
</li>
</ul>
<pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> === <span class="hljs-built_in">exports</span> ) <span class="hljs-comment">// ==&gt; true</span>

<span class="hljs-comment">// 等价操作</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">num</span> = <span class="hljs-number">123</span>
<span class="hljs-built_in">exports</span>.<span class="hljs-property">num</span> = <span class="hljs-number">123</span>

<span class="hljs-comment">// 赋值操作：不要使用 exports = &#123;&#125;</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;&#125;</code></pre>

<h4 id="第三方模块代码执行流程-了解"><a href="#第三方模块代码执行流程-了解" class="headerlink" title="第三方模块代码执行流程(了解)"></a>第三方模块代码执行流程(了解)</h4><p>以mime包为例</p>
<ul>
<li>先基于当前文件模块所属目录找 node_modules 目录</li>
<li>如果找到，则去该目录中找 mime 目录</li>
<li>如果找到 mime 目录，则找该目录中的 package.json 文件</li>
<li>如果找到 package.json 文件，则找该文件中的 main 属性</li>
<li>如果找到 main 属性，则拿到该属性对应的文件路径</li>
<li>如果找到 mime 目录之后<ul>
<li>发现没有 package.json</li>
<li>或者 有 package.json 没有 main 属性</li>
<li>或者 有 main 属性，但是指向的路径不存在</li>
<li>则 node 会默认去看一下 mime 目录中有没有 index.js index.node index.json 文件</li>
</ul>
</li>
<li>如果找不到 index 或者找不到 mime 或者找不到 node_modules</li>
<li>则进入上一级目录找 node_moudles 查找规则同上</li>
<li>如果上一级还找不到，继续向上，一直到当前文件所属磁盘根目录</li>
<li>如果最后到磁盘根目录还找不到，最后报错：<code>can not find module xxx</code></li>
</ul>
<h3 id="CommonJS-规范参考文档"><a href="#CommonJS-规范参考文档" class="headerlink" title="CommonJS 规范参考文档"></a>CommonJS 规范参考文档</h3><ul>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/api/modules.html">module (模块)</a></li>
<li><a target="_blank" rel="noopener" href="http://javascript.ruanyifeng.com/nodejs/module.html">CommonJS规范</a></li>
<li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/09ffac7a3b2c">浅析JS模块规范：AMD，CMD，CommonJS</a></li>
</ul>
<h2 id="node操作mysql数据库"><a href="#node操作mysql数据库" class="headerlink" title="node操作mysql数据库"></a>node操作mysql数据库</h2><p>数据库准备：</p>
<p>1.安装mysql5数据库</p>
<p>2.在mysql中创建nodedb这个数据库（可利用Navicat图形工具）</p>
<p>3.在nodedb数据库中添加users表 （可利用Navicat图形工具）</p>
<p>建表sql语句如下：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">SET</span> NAMES utf8mb4;
<span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

<span class="hljs-comment">-- ----------------------------</span>
<span class="hljs-comment">-- Table structure for users</span>
<span class="hljs-comment">-- ----------------------------</span>
<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `users`;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `users`  (
  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,
  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) ,
  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) ,
  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE
) ENGINE <span class="hljs-operator">=</span> InnoDB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="hljs-operator">=</span> Compact;

<span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre>

<h3 id="配置-mysql-模块"><a href="#配置-mysql-模块" class="headerlink" title="配置 mysql 模块"></a>配置 mysql 模块</h3><ol>
<li>安装 mysql 模块</li>
</ol>
<pre><code class="hljs bash">npm install mysql</code></pre>

<ol start="2">
<li>建立连接</li>
</ol>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)

<span class="hljs-keyword">const</span> db = mysql.<span class="hljs-title function_">createPool</span>(&#123;
  <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,
  <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-comment">//mysql账号</span>
  <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<span class="hljs-comment">//mysql密码</span>
  <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;nodedb&#x27;</span>, <span class="hljs-comment">//自己创建的mysql库 </span>
&#125;)</code></pre>

<ol start="3">
<li>测试是否正常工作</li>
</ol>
<pre><code class="hljs js">db.<span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;select 1&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, results</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (err) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results)
&#125;)</code></pre>

<h3 id="node操作mysql增删改查"><a href="#node操作mysql增删改查" class="headerlink" title="node操作mysql增删改查"></a>node操作mysql增删改查</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>第一种添加方式：</p>
<pre><code class="hljs js"><span class="hljs-comment">//1.准备数据</span>
<span class="hljs-keyword">const</span> &#123;name,username,password&#125; = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;汤姆&#x27;</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;
<span class="hljs-comment">//2.准备sql ?标识占位符</span>
<span class="hljs-keyword">const</span> sqlStr = <span class="hljs-string">&#x27;insert into users (name,username, password) values(?,?,?)&#x27;</span>
<span class="hljs-comment">//3.执行sql 参数1：sql字符串  参数2：占位符对应的数据 参数3：插入之后的回调</span>
db.<span class="hljs-title function_">query</span>(sqlStr,[name,username,password],<span class="hljs-function">(<span class="hljs-params">err,res</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span>(err) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;err :&gt;&gt; &#x27;</span>, err);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;res :&gt;&gt; &#x27;</span>, res);
  <span class="hljs-keyword">if</span>(res.<span class="hljs-property">affectedRows</span> == <span class="hljs-number">1</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;插入成功！&#x27;</span>)
&#125;)</code></pre>

<p>第二种添加方式：向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;汤姆&#x27;</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;
db.<span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;insert into  users set ?&#x27;</span>,obj,<span class="hljs-function">(<span class="hljs-params">err,res</span>) =&gt;</span> &#123;
   <span class="hljs-keyword">if</span>(err) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;err :&gt;&gt; &#x27;</span>, err)
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;res :&gt;&gt; &#x27;</span>, res);
   <span class="hljs-keyword">if</span>(res.<span class="hljs-property">affectedRows</span> == <span class="hljs-number">1</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;插入成功11！&#x27;</span>)
&#125;)</code></pre>

<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code class="hljs js"><span class="hljs-comment">//查询数据</span>
db.<span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;select * from users&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,res</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;res :&gt;&gt; &#x27;</span>, res);
&#125;)</code></pre>

<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;username,password,name,id&#125; = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;杰瑞&#x27;</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;jerry&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;456&#x27;</span>&#125;
<span class="hljs-keyword">const</span> sqlStr = <span class="hljs-string">&#x27;update users set username=?,password=?,name=? where id=?&#x27;</span>
db.<span class="hljs-title function_">query</span>(sqlStr,[username,password,name,id],<span class="hljs-function">(<span class="hljs-params">err,res</span>) =&gt;</span> &#123;<span class="hljs-comment">//注意第二个参数的顺序</span>
   <span class="hljs-keyword">if</span>(err) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;err :&gt;&gt; &#x27;</span>, err)
   <span class="hljs-keyword">if</span>(res.<span class="hljs-property">affectedRows</span> == <span class="hljs-number">1</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;修改成功！&#x27;</span>)
&#125;)</code></pre>

<p>快捷修改方式</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;杰瑞1&#x27;</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;jerry1&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;4516&#x27;</span>&#125;
<span class="hljs-keyword">const</span> sqlStr = <span class="hljs-string">&#x27;update users set ? where id=?&#x27;</span>
db.<span class="hljs-title function_">query</span>(sqlStr,[obj,obj.<span class="hljs-property">id</span>],<span class="hljs-function">(<span class="hljs-params">err,res</span>) =&gt;</span> &#123;<span class="hljs-comment">//注意第二个参数的顺序</span>
  <span class="hljs-keyword">if</span>(err) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;err :&gt;&gt; &#x27;</span>, err)
  <span class="hljs-keyword">if</span>(res.<span class="hljs-property">affectedRows</span> == <span class="hljs-number">1</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;修改成功！&#x27;</span>)
&#125;)</code></pre>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre><code class="hljs js">db.<span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;delete from users where id=?&#x27;</span>,[<span class="hljs-number">1</span>],<span class="hljs-function">(<span class="hljs-params">err,res</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span>(res.<span class="hljs-property">affectedRows</span> == <span class="hljs-number">1</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功！&#x27;</span>)
&#125;)</code></pre>

<h2 id="node操作mongodb数据库"><a href="#node操作mongodb数据库" class="headerlink" title="node操作mongodb数据库"></a>node操作mongodb数据库</h2><p>安装：<code>npm i  mongodb</code></p>
<pre><code class="hljs js"><span class="hljs-comment">// 导入 mongodb，并获取到客户端对象</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MongoClient</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongodb&#x27;</span>).<span class="hljs-property">MongoClient</span>

<span class="hljs-comment">// 连接数据库服务地址</span>
<span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;mongodb://localhost:27017&#x27;</span>

<span class="hljs-comment">// 连接数据库</span>
<span class="hljs-title class_">MongoClient</span>.<span class="hljs-title function_">connect</span>(url, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, client</span>) &#123;
  <span class="hljs-keyword">if</span> (err) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;链接数据库失败&#x27;</span>, err)
  &#125;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数据库链接成功&#x27;</span>);

  <span class="hljs-comment">// 获取集合对象</span>
  <span class="hljs-keyword">const</span> db = client.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;nodedb&#x27;</span>)

  <span class="hljs-comment">// 关闭数据库链接</span>
  client.<span class="hljs-title function_">close</span>()
&#125;)</code></pre>

<h3 id="数据增删改查"><a href="#数据增删改查" class="headerlink" title="数据增删改查"></a>数据增删改查</h3><ul>
<li>添加数据</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> db = client.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;nodedb&#x27;</span>)

<span class="hljs-comment">// 添加</span>
db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;users&#x27;</span>)
  <span class="hljs-comment">// 添加一条数据</span>
  .<span class="hljs-title function_">insert</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
  &#125;)
  <span class="hljs-comment">// 添加多条数据</span>
  .<span class="hljs-title function_">insertMany</span>([&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerry&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span> &#125;], <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
  &#125;)</code></pre>

<ul>
<li>查询数据</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> db = client.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;nodedb&#x27;</span>)

<span class="hljs-comment">// 查询</span>
db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;users&#x27;</span>).<span class="hljs-title function_">find</span>().<span class="hljs-title function_">toArray</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)
&#125;)</code></pre>

<ul>
<li>修改数据</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> db = client.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;nodedb&#x27;</span>)

db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;users&#x27;</span>).<span class="hljs-title function_">update</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span> &#125;, &#123; <span class="hljs-attr">$set</span>: &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">22</span> &#125; &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
  &#125;)</code></pre>

<ul>
<li>删除数据</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> db = client.<span class="hljs-title function_">db</span>(<span class="hljs-string">&#x27;nodedb&#x27;</span>)

db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">&#x27;users&#x27;</span>)
  <span class="hljs-comment">// 删除一条数据：</span>
  .<span class="hljs-title function_">deleteOne</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;rose&#x27;</span>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
  &#125;)
  <span class="hljs-comment">// 删除多条数据：</span>
  .<span class="hljs-title function_">deleteMany</span>(&#123;<span class="hljs-attr">age</span>: &#123;<span class="hljs-attr">$lt</span>: <span class="hljs-number">20</span>&#125;&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
  &#125;)</code></pre>

<h2 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>安装express</li>
</ul>
<pre><code class="hljs bash">npm i express</code></pre>

<ul>
<li>案例</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// 导入 express</span>
<span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)
<span class="hljs-comment">// 创建 express实例，也就是创建 express服务器</span>
<span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>()

<span class="hljs-comment">// 路由</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>)
&#125;)

<span class="hljs-comment">// 启动服务器</span>
app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器已启动&#x27;</span>)
&#125;)</code></pre>

<p>参数说明</p>
<ul>
<li><code>express()</code>：创建一个Express应用，并返回，即：app</li>
<li><code>app.get()</code>：注册一个GET类型的路由<ul>
<li>注意：只要注册了路由，所有的请求都会被处理（未配置的请求路径，响应404）</li>
</ul>
</li>
<li><code>res.send()</code>：发送数据给客户端，并自动设置Content-Type<ul>
<li>参数可以是：字符串、数组、对象、Buffer</li>
<li>注意：只能使用一次</li>
</ul>
</li>
<li><code>req</code> 和 <code>res</code>：与http模块中的作用相同，是扩展后的请求和响应对象</li>
</ul>
<h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><ul>
<li>通过 <code>express.static()</code> 方法可创建静态资源服务器，向外开放访问静态资源。</li>
<li>Express 在指定的静态目录中查找文件，并对外提供资源的访问路径，<strong style="color:red">存放静态文件的目录名不会出现在 URL 中</strong></li>
<li>访问静态资源时，会根据托管顺序查找文件</li>
<li>可为静态资源访问路径添加前缀</li>
</ul>
<pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;static&#x27;</span>))
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/web&#x27;</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;web&#x27;</span>))

<span class="hljs-comment">//可直接访问 static 目录下的静态资源</span>
<span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:3000/img/2.jpg</span>

<span class="hljs-comment">//通过带有 /web 前缀的地址访问 bruce 目录下的文件</span>
<span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:8080/web/img/1.jpg</span></code></pre>

<h3 id="request和response"><a href="#request和response" class="headerlink" title="request和response"></a>request和response</h3><h4 id="request常用方法"><a href="#request常用方法" class="headerlink" title="request常用方法"></a>request常用方法</h4><ul>
<li>query属性：获取get请求参数，是一个对象</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">//传参：http://localhost:8088/user?name=jerry&amp;age=18</span>

<span class="hljs-comment">//处理请求</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,resp</span>) =&gt;</span> &#123;
    resp.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">query</span>)<span class="hljs-comment">//将get参数直接返回</span>
&#125;)</code></pre>

<ul>
<li>body：获取POST请求参数，需要配置<code>body-parser</code>模块， POST请求参数</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">//导入bodyParser模块</span>
<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)
<span class="hljs-comment">//将POST请求参数转化为对象，存储到req.body中 (application/x-www-form-urlencoded方式)</span>
app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span> &#125;))
app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,resp</span>) =&gt;</span> &#123;
    resp.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">body</span>)<span class="hljs-comment">//将post参数直接返回</span>
&#125;)</code></pre>

<ul>
<li>params：获取restful风格的参数</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">//传参：http://localhost:8088/user/jerry/19</span>

app.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/user/:name/:age&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,resp</span>) =&gt;</span> &#123;
    resp.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">params</span>)<span class="hljs-comment">//将restful参数直接返回</span>
&#125;)</code></pre>

<h4 id="response常用方法"><a href="#response常用方法" class="headerlink" title="response常用方法"></a>response常用方法</h4><pre><code class="hljs js"><span class="hljs-comment">// send() 发送数据给客户端，并自动设置Content-Type</span>
res.<span class="hljs-title function_">send</span>()

<span class="hljs-comment">// 发送文件给浏览器，并根据文件后缀名自动设置Content-Type</span>
<span class="hljs-comment">// 注意：文件路径必须是绝对路径</span>
res.<span class="hljs-title function_">sendFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;index.html&#x27;</span>))

<span class="hljs-comment">// 设置HTTP响应码</span>
res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>)；

<span class="hljs-comment">// 设置响应头</span>
res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/plain&#x27;</span>)
res.<span class="hljs-title function_">set</span>(&#123;
  <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>,
  <span class="hljs-string">&#x27;cute&#x27;</span>: <span class="hljs-string">&#x27;fangfang&#x27;</span>
&#125;)

<span class="hljs-comment">// 重定向</span>
res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;/index&#x27;</span>)</code></pre>

<h3 id="expres中使用art-template"><a href="#expres中使用art-template" class="headerlink" title="expres中使用art-template"></a>expres中使用art-template</h3><p>安装</p>
<pre><code class="hljs bash">npm install art-template 
npm install express-art-template</code></pre>

<p>给express绑定一个模版引擎</p>
<pre><code class="hljs js"><span class="hljs-comment">//给express设置模版引擎</span>
<span class="hljs-comment">//参数1： 模版引擎的后缀名，  以后的模版文件都应该是 html结尾</span>
<span class="hljs-comment">//参数2： 使用什么模版引擎</span>
app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">&quot;html&quot;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>))</code></pre>

<p>通过<code>res.render()</code>渲染模版引擎</p>
<pre><code class="hljs js"><span class="hljs-comment">//参数1； 模版文件的路径,相对路径，回去views目录下查找</span>
<span class="hljs-comment">//参数2： 数据</span>
res.<span class="hljs-title function_">render</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;index.html&quot;</span>), &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;zs&quot;</span>&#125;)</code></pre>

<p>关于模版引擎的配置（了解）</p>
<pre><code class="hljs js"><span class="hljs-comment">//模版文件默认去aa目录下查找  默认值：  views</span>
app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;views&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>);

<span class="hljs-comment">//设置模板引擎的默认后缀</span>
app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;view engine&quot;</span>, <span class="hljs-string">&quot;html&quot;</span>);</code></pre>

<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>创建路由模块：</p>
<pre><code class="hljs js"><span class="hljs-comment">// router.js</span>

<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)
<span class="hljs-comment">// 创建路由对象</span>
<span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()

<span class="hljs-comment">// 挂载具体路由</span>
router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get user list.&#x27;</span>)
&#125;)
router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user/add&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add new user.&#x27;</span>)
&#125;)

<span class="hljs-comment">// 向外导出路由对象</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router</code></pre>

<p>注册路由模块：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)
<span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>)

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()

<span class="hljs-comment">// 注册路由模块，添加访问前缀</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, router) <span class="hljs-comment">//测试时记得代码 /api 前缀</span>

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8088</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)
&#125;)</code></pre>

<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul>
<li>中间件是指流程的中间处理环节</li>
<li>服务器收到请求后，可先调用中间件进行预处理(比如登录拦截、错误拦截等)</li>
<li>中间件是一个函数，包含 <code>req, res, next</code> 三个参数，<code>next()</code> 参数把流转关系交给下一个中间件或路由</li>
</ul>
<p>中间件注意事项；</p>
<ul>
<li>在注册路由之前注册中间件（错误级别中间件除外）</li>
<li>中间件可连续调用多个</li>
<li>别忘记调用 <code>next()</code> 函数</li>
<li><code>next()</code> 函数后别写代码</li>
<li>多个中间件共享 <code>req</code>、 <code>res</code>对象</li>
</ul>
<h4 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h4><ul>
<li>通过 <code>app.use()</code> 定义的中间件为全局中间件</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()

<span class="hljs-comment">// 定义第一个全局中间件</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第1个全局中间件&#x27;</span>)
  <span class="hljs-title function_">next</span>()
&#125;)
<span class="hljs-comment">// 定义第二个全局中间件</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第2个全局中间件&#x27;</span>)
  <span class="hljs-title function_">next</span>()
&#125;)

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span>)
&#125;)

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http://127.0.0.1&#x27;</span>)
&#125;)</code></pre>

<h4 id="局部中间件"><a href="#局部中间件" class="headerlink" title="局部中间件"></a>局部中间件</h4><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()

<span class="hljs-comment">// 定义中间件函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">mw1</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第一个局部生效的中间件&#x27;</span>)
  <span class="hljs-title function_">next</span>()
&#125;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">mw2</span> = (<span class="hljs-params">req, res, next</span>) =&gt; &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用了第二个局部生效的中间件&#x27;</span>)
  <span class="hljs-title function_">next</span>()
&#125;

<span class="hljs-comment">// 两种定义局部中间件的方式</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/hello&#x27;</span>, mw2, mw1, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello page.&#x27;</span>))
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/about&#x27;</span>, [mw1, mw2], <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;about page.&#x27;</span>))

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page.&#x27;</span>))

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)
&#125;)</code></pre>

<h4 id="中间件分类"><a href="#中间件分类" class="headerlink" title="中间件分类"></a>中间件分类</h4><h5 id="应用级别的中间件"><a href="#应用级别的中间件" class="headerlink" title="应用级别的中间件"></a>应用级别的中间件</h5><p>通过 <code>app.use()</code> 或 <code>app.get()</code> 或 <code>app.post()</code> ，绑定到 <code>app</code> 实例上的中间件</p>
<h5 id="路由级别的中间件"><a href="#路由级别的中间件" class="headerlink" title="路由级别的中间件"></a>路由级别的中间件</h5><p>绑定到 <code>express.Router()</code> 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 <code>app</code> 实例上，路由级别中间件绑定到 <code>router</code> 实例上。</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()
<span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()

router.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)
  <span class="hljs-title function_">next</span>()
&#125;)

app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, router)</code></pre>

<h5 id="错误级别的中间件"><a href="#错误级别的中间件" class="headerlink" title="错误级别的中间件"></a>错误级别的中间件</h5><ul>
<li>用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题</li>
<li>错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 <code>(err, req, res, next)</code> 。</li>
<li>错误级别的中间件必须注册在所有路由之后</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;服务器内部发生了错误！&#x27;</span>)
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page.&#x27;</span>)
&#125;)

<span class="hljs-comment">// 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;发生了错误！&#x27;</span> + err.<span class="hljs-property">message</span>)
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Error：&#x27;</span> + err.<span class="hljs-property">message</span>)
&#125;)

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)
&#125;)</code></pre>

<h5 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h5><p>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：</p>
<ul>
<li><code>express.static</code> 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li>
<li><code>express.json</code> 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li>
<li><code>express.urlencoded</code> 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li>
</ul>
<pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>())
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))</code></pre>

<h5 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h5><h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h3><ul>
<li>CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</li>
<li>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</li>
<li>CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li>
<li>CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</li>
</ul>
<h4 id="CORS-常见响应头"><a href="#CORS-常见响应头" class="headerlink" title="CORS 常见响应头"></a>CORS 常见响应头</h4><ul>
<li><code>Access-Control-Allow-Origin</code>：制定了允许访问资源的外域 URL</li>
</ul>
<pre><code class="hljs js">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://bruceblog.io&#x27;</span>)
res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)</code></pre>

<ul>
<li><code>Access-Control-Allow-Headers</code></li>
<li>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：<code>Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</code></li>
<li>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 A<code>ccess-Control-Allow-Headers</code> 对额外的请求头进行声明，否则这次请求会失败！</li>
</ul>
<pre><code class="hljs js">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;Content-Type, X-Custom-Header&#x27;</span>)</code></pre>

<ul>
<li><code>Access-Control-Allow-Methods</code></li>
<li>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 <code>Access-Control-Alow-Methods</code> 来指明实际请求所允许使用的 HTTP 方法</li>
</ul>
<pre><code class="hljs js">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;POST, GET, DELETE, HEAD&#x27;</span>)
res.<span class="hljs-title function_">setHEader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)</code></pre>

<h4 id="CORS-请求分类"><a href="#CORS-请求分类" class="headerlink" title="CORS 请求分类"></a>CORS 请求分类</h4><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><ul>
<li>请求方式：GET、POST、HEAD 三者之一</li>
<li>HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application&#x2F;x-www-formurlencoded、multipart&#x2F;form-data、text&#x2F;plain）</li>
</ul>
<h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><ul>
<li>请求方式为 GET、POST、HEAD 之外的请求 Method 类型</li>
<li>请求头中包含自定义头部字段</li>
<li>向服务器发送了 application&#x2F;json 格式的数据</li>
</ul>
<p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p>
<h4 id="express中使用cors"><a href="#express中使用cors" class="headerlink" title="express中使用cors"></a>express中使用cors</h4><p>安装中间件：<code>npm install cors</code><br>导入中间件：<code>const cors = require(&#39;cors&#39;)</code><br>配置中间件：<code>app.use(cors())</code></p>
<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><h3 id="jwt认证"><a href="#jwt认证" class="headerlink" title="jwt认证"></a>jwt认证</h3><p>前后端分离推荐使用 JWT（JSON Web Token）认证机制，是目前最流行的跨域认证解决方案</p>
<h4 id="Session-的局限性"><a href="#Session-的局限性" class="headerlink" title="Session 的局限性"></a>Session 的局限性</h4><ul>
<li>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</li>
<li>当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。</li>
<li>当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制</li>
</ul>
<h4 id="JWT-工作原理图"><a href="#JWT-工作原理图" class="headerlink" title="JWT 工作原理图"></a>JWT 工作原理图</h4><p>用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p>
<p><img src="/2022/10/30/1593064784100724736/images/image-20221030192657149.png" alt="image-20221030192657149"></p>
<h4 id="JWT-组成部分"><a href="#JWT-组成部分" class="headerlink" title="JWT 组成部分"></a>JWT 组成部分</h4><ul>
<li>Header、Payload、Signature</li>
<li>Payload 是真正的用户信息，加密后的字符串</li>
<li>Header 和 Signature 是安全性相关部分，保证 Token 安全性</li>
<li>三者使用 <code>.</code> 分隔</li>
</ul>
<pre><code class="hljs js"><span class="hljs-title class_">Header</span>.<span class="hljs-property">Payload</span>.<span class="hljs-property">Signature</span>

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.<span class="hljs-property">eyJpZCI6MTcsInVzZXJuYW1lIjoiQnJ1Y2UiLCJwYXNzd29yZCI6IiIsIm5pY2tuYW1lIjoiaGVsbG8iLCJlbWFpbCI6InNjdXRAcXEuY29tIiwidXNlcl9waWMiOiIiLCJpYXQiOjE2NDE4NjU3MzEsImV4cCI6MTY0MTkwMTczMX0</span>.<span class="hljs-property">bmqzAkNSZgD8IZxRGGyVlVwGl7EGMtWitvjGD</span>-a5U5c</code></pre>

<h4 id="JWT的使用方式"><a href="#JWT的使用方式" class="headerlink" title="JWT的使用方式"></a>JWT的使用方式</h4><ul>
<li>客户端会把 JWT 存储在 localStorage 或 sessionStorage 中</li>
<li>此后客户端与服务端通信需要携带 JWT 进行身份认证，将 JWT 存在 HTTP 请求头 Authorization 字段中</li>
<li>加上 Bearer 前缀</li>
</ul>
<pre><code class="hljs text">Authorization: Bearer &lt;token&gt;</code></pre>

<h4 id="Express-使用-JWT认证"><a href="#Express-使用-JWT认证" class="headerlink" title="Express 使用 JWT认证"></a>Express 使用 JWT认证</h4><ol>
<li>安装：<code>jsonwebtoken</code> 用于生成 JWT 字符串;<code>express-jwt</code> 用于将 JWT 字符串解析还原成 JSON 对象</li>
</ol>
<pre><code class="hljs bash">npm install jsonwebtoken express-jwt</code></pre>

<ol start="2">
<li>定义 secret 密钥</li>
</ol>
<ul>
<li>为保证 JWT 字符串的安全性，防止其在网络传输过程中被破解，需定义用于加密和解密的 secret 密钥</li>
<li>生成 JWT 字符串时，使用密钥加密信息，得到加密好的 JWT 字符串</li>
<li>把 JWT 字符串解析还原成 JSON 对象时，使用密钥解密</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)
<span class="hljs-keyword">const</span> expressJWT = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>)

<span class="hljs-comment">// 密钥为任意字符串</span>
<span class="hljs-keyword">const</span> secretKey = <span class="hljs-string">&#x27;hlf&#x27;</span></code></pre>

<ol start="3">
<li>生成 JWT 字符串</li>
</ol>
<pre><code class="hljs js">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
  ...
  res.<span class="hljs-title function_">send</span>(&#123;
    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;登录成功&#x27;</span>,
    <span class="hljs-comment">// jwt.sign() 生成 JWT 字符串</span>
    <span class="hljs-comment">// 参数：用户信息对象、加密密钥、配置对象-token有效期</span>
    <span class="hljs-comment">// 尽量不保存敏感信息，因此只有用户名，没有密码</span>
    <span class="hljs-attr">token</span>: jwt.<span class="hljs-title function_">sign</span>(&#123;<span class="hljs-attr">username</span>: userInfo.<span class="hljs-property">username</span>&#125;, secretKey, &#123;<span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&#x27;10h&#x27;</span>&#125;)
  &#125;)
&#125;)</code></pre>

<ol start="4">
<li>JWT 字符串还原为 JSON 对象</li>
</ol>
<ul>
<li>客户端访问有权限的接口时，需通过请求头的 <code>Authorization</code> 字段，将 Token 字符串发送到服务器进行身份认证</li>
<li>服务器可以通过 express-jwt 中间件将客户端发送过来的 Token 解析还原成 JSON 对象</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// unless(&#123; path: [/^\/api\//] &#125;) 指定哪些接口无需jwt认证</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">expressJWT</span>(&#123; <span class="hljs-attr">secret</span>: secretKey &#125;).<span class="hljs-title function_">unless</span>(&#123; <span class="hljs-attr">path</span>: [<span class="hljs-regexp">/^\/api\//</span>] &#125;))</code></pre>

<ol start="5">
<li>获取用户信息</li>
</ol>
<ul>
<li>当 express-jwt 中间件配置成功后，即可在那些有权限的接口中，使用 <code>req.user</code> 对象，来访问从 JWT 字符串中解析出来的用户信息</li>
</ul>
<pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/admin/getinfo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">user</span>)
  res.<span class="hljs-title function_">send</span>(&#123;
    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;获取信息成功&#x27;</span>,
    <span class="hljs-attr">data</span>: req.<span class="hljs-property">user</span>,
  &#125;)
&#125;)</code></pre>

<ol start="6">
<li>捕获解析 JWT 失败后产生的错误</li>
</ol>
<ul>
<li>当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行</li>
<li>通过 Express 的错误中间件，捕获这个错误并进行相关的处理</li>
</ul>
<pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (err.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;UnauthorizedError&#x27;</span>) &#123;
    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">401</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Invalid token&#x27;</span> &#125;)
  &#125;
  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">500</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Unknown error&#x27;</span> &#125;)
&#125;)</code></pre>

<h3 id="session认证"><a href="#session认证" class="headerlink" title="session认证"></a>session认证</h3><p>服务端渲染推荐使用 Session 认证机制</p>
<h4 id="session认证原理"><a href="#session认证原理" class="headerlink" title="session认证原理"></a>session认证原理</h4><p><img src="/2022/10/30/1593064784100724736/images/image-20221030194211947.png" alt="image-20221030194211947"></p>
<h4 id="Express中使用session认证"><a href="#Express中使用session认证" class="headerlink" title="Express中使用session认证"></a>Express中使用session认证</h4><ol>
<li>安装 express-session 中间件</li>
</ol>
<pre><code class="hljs bash">npm install express-session</code></pre>

<ol start="2">
<li>配置中间件</li>
</ol>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>)
app.<span class="hljs-title function_">use</span>(
  <span class="hljs-title function_">session</span>(&#123;
    <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;hlf&#x27;</span>, <span class="hljs-comment">// secret 的值为任意字符串</span>
    <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">saveUninitalized</span>: <span class="hljs-literal">true</span>,
  &#125;)
)</code></pre>

<ol start="3">
<li>向 session 中存数据</li>
</ol>
<p>中间件配置成功后，可通过 <code>req.session</code> 访问 session 对象，存储用户信息</p>
<pre><code class="hljs js">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
  req.<span class="hljs-property">session</span>.<span class="hljs-property">user</span> = req.<span class="hljs-property">body</span>
  req.<span class="hljs-property">session</span>.<span class="hljs-property">isLogin</span> = <span class="hljs-literal">true</span>

  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;login done&#x27;</span> &#125;)
&#125;)</code></pre>

<ol start="4">
<li>从 session 取数据</li>
</ol>
<pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/username&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (!req.<span class="hljs-property">session</span>.<span class="hljs-property">isLogin</span>) &#123;
    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;fail&#x27;</span> &#125;)
  &#125;
  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-attr">username</span>: req.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">username</span> &#125;)
&#125;)</code></pre>

<ol start="5">
<li>清空 session</li>
</ol>
<pre><code class="hljs js">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/logout&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// 清空当前客户端的session信息</span>
  req.<span class="hljs-property">session</span>.<span class="hljs-title function_">destroy</span>()
  res.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;logout done&#x27;</span> &#125;)
&#125;)</code></pre>
				</div>
		</div>
	</div>
	</div>
	
	<ul class="layui-fixbar"><a id="toTopBtn" href="javascript:void(0)"><li class="layui-icon layui-fixbar-top" lay-type="top" style="display: list-item;"></li></a></ul>
	
	<!-- 底部版权 -->
	<div class="qy-footer">
    <div class="font-Area">
        Copyright © 2018~2022 Heliufang All Rights Reserved
    </div>
</div>

<script>
    //随机背景线条 https://blog.csdn.net/qq526362801/article/details/108863458
    function DynamicLine() {
        function n(n, e, t) {
            return n.getAttribute(e) || t
        }

        function e(n) {
            return document.getElementsByTagName(n)
        }

        function t() {
            var t = e("script"),
                o = t.length,
                i = t[o - 1];
            return {
                l: o,
                z: n(i, "zIndex", -1),
                o: n(i, "opacity", .5),
                c: n(i, "color", "0,0,50"), //颜色rgb
                n: n(i, "count", 99)
            }
        }

        function o() {
            a = m.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
                c = m.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
        }

        function i() {
            r.clearRect(0, 0, a, c);
            var n, e, t, o, m, l;
            s.forEach(function (i, x) {
                for (i.x += i.xa, i.y += i.ya, i.xa *= i.x > a || i.x < 0 ? -1 : 1, i.ya *= i.y > c || i.y < 0 ? -1 : 1, r.fillRect(
                    i.x - .5, i.y - .5, 1, 1), e = x + 1; e < u.length; e++) n = u[e],
                        null !== n.x && null !== n.y && (o = i.x - n.x, m = i.y - n.y,
                            l = o * o + m * m, l < n.max && (n === y && l >= n.max / 2 && (i.x -= .03 * o, i.y -= .03 * m),
                                t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t / 2, r.strokeStyle = "rgba(" + d.c + "," + (t + .2) +
                                ")", r.moveTo(i.x, i.y), r.lineTo(n.x, n.y), r.stroke()))
            }),
                x(i)
        }
        var a, c, u, m = document.createElement("canvas"),
            d = t(),
            l = "c_n" + d.l,
            r = m.getContext("2d"),
            x = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window
                .oRequestAnimationFrame || window.msRequestAnimationFrame ||
                function (n) {
                    window.setTimeout(n, 1e3 / 45)
                },
            w = Math.random,
            y = {
                x: null,
                y: null,
                max: 2e4
            };
        m.id = l, m.style.cssText = "position:fixed;top:0;left:0;z-index:" + d.z + ";opacity:" + d.o, e("body")[0].appendChild(
            m), o(), window.onresize = o,
            window.onmousemove = function (n) {
                n = n || window.event, y.x = n.clientX, y.y = n.clientY
            },
            window.onmouseout = function () {
                y.x = null, y.y = null
            };
        for (var s = [], f = 0; d.n > f; f++) {
            var h = w() * a,
                g = w() * c,
                v = 2 * w() - 1,
                p = 2 * w() - 1;
            s.push({
                x: h,
                y: g,
                xa: v,
                ya: p,
                max: 6e3
            })
        }
        u = s.concat([y]),
            setTimeout(function () {
                i()
            }, 100)
    }
    DynamicLine()
</script>
</body>
<script src="../../../../../js/jquery.min.js"></script>
<script src="../../../../../layui/layui.js"></script>
<script src="../../../../../js/clipboard.min.js"></script>
<script src="../../../../../js/clipboard-use.js"></script>
<script src="../../../../../js/mouse.js"></script>
<!-- 谷歌代码高亮 -->
<script type="text/javascript" src="../../../../../lib/google-code-prettify/run_prettify.js"></script>
<script>
	//注意：导航 依赖 element 模块，否则无法进行功能性操作
	var element = null
	var layer = null
	layui.use(['element','layer'], function(){
	  element = layui.element;
	  layer = layui.layer
	});
	
	$(function() { 
	    var elm = $('#toc-area'); 
	    var startPos = $(elm).offset().top; 
		var totalTop = $(document).height(); 
	    $.event.add(window, "scroll", function() { 
	        var p = $(window).scrollTop(); 
			//文章阅读进度条
			var percent = ((p/totalTop)*100).toFixed(2)
			if(percent > 100){
				percent = 100
			}
			if(percent == 0){
				percent = 0
			}
			element.progress('demo', percent+"%");
			$("#progressTxt").text(percent)
			//固定文章目录
	        $(elm).css('position',((p) > startPos) ? 'fixed' : 'static'); 
	        $(elm).css('top',((p) > startPos) ? '60px' : ''); 
	    }); 
		//谷歌代码高亮
		$('pre').addClass('prettyprint').attr('style', 'overflow:auto;');

		let timer = null;
		//点击回到顶部
		//增加scrollTop的动画效果,使用定时器，将scrollTop的值每次减少50(减少六十分之一)，直到减少到0，则动画完毕
		$("#toTopBtn").click(function(){
			var oTop = document.body.scrollTop || document.documentElement.scrollTop;
			var t = parseInt(oTop / 60) //每次六十分之一
			var time = setInterval(function () {
				// document.body.scrollTop = document.body.scrollTop - 50;
				document.body.scrollTop = document.body.scrollTop - t;
				if (document.body.scrollTop === 0) {
					clearInterval(time);
				}
			}, 1);
		})

		
	});
	
</script>
</html>