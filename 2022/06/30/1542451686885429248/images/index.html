<!DOCTYPE html><html lang="zh-CN"><head><title>贺刘芳的搬砖日记</title><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="stylesheet" href="../../../../../layui/css/layui.css"><link rel="stylesheet" href="../../../../../css/common.css"><link rel="stylesheet" href="../../../../../css/post.css"><link rel="stylesheet" href="../../../../../lib/prism/prism.css"><link rel="shortcut icon" href="../../../../../img/favicon.ico"><link rel="stylesheet" href="../../../../../lib/iconfont/iconfont.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="贺刘芳的搬砖日记" type="application/atom+xml"></head><body style="overflow:hidden" data-prismjs-copy="复制" data-prismjs-copy-success="复制成功!"><div class="qy-nav"><ul class="layui-nav" lay-filter="" lay-bar="disabled" lay-unselect><li class="hide-xs layui-nav-item" id="searchBtn" style="float:right"><a class="searchBtn" href="javascript:void(0);"><i class="layui-icon layui-icon-search"></i> 搜索</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://github.com/heliufang"><i class="icon iconfont icon-github"></i> github</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://gitee.com/heliufang"><i class="icon iconfont icon-gitee"></i> gitee</a></li><li class="hide-xs layui-nav-item" style="float:right"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf"><i class="icon iconfont icon-cnblogs"></i> 博客园</a></li><li class="layui-nav-item"><a class="title" href="/" style="padding:0"><i class="layui-anim layui-anim-rotate layui-anim-loop layui-icon layui-icon-star-fill"></i> 贺刘芳的笔记本</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/about"><i class="layui-icon layui-icon-friends"></i> 关于</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/archives"><i class="layui-icon layui-icon-date"></i> 归档</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/tags"><i class="layui-icon layui-icon-note"></i> 标签</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/categories"><i class="layui-icon layui-icon-template-1"></i> 分类</a></li><li class="hide-xs layui-nav-item" style="float:right"><a href="/"><i class="layui-icon layui-icon-home"></i> 首页</a></li><li class="layui-nav-item hide-sm hide-md hide-lg" style="float:right"><a href="javascript:;">菜单</a><dl class="layui-nav-child"><dd><a href="/">首页</a></dd><dd><a href="/archives">归档</a></dd><dd><a href="/tags">标签</a></dd><dd><a href="/categories">分类</a></dd><dd><a href="/about">关于</a></dd><dd><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github">github</a></dd><dd><a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee">gitee</a></dd><dd><a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园">博客园</a></dd><dd><a href="javascript:void(0)" onclick='document.querySelector("#searchShade").style.display="block"'>搜索</a></dd></dl></li></ul><div id="loadingBox" class="loadingBox"><img src="/img/loading.gif"></div></div><div id="searchShade" class="searchShade"><div id="searchLayer"><div id="closeBtn" class="close"><i class="layui-icon layui-icon-close"></i></div><input id="searchTxt" type="text" placeholder="搜索文章(只支持文章标题关键字)" autofocus><div id="searchResult"></div></div></div><div class="layui-container center" id="top"><div class="layui-row layui-col-space20"><div class="layui-col-md3 hide-xs hide-sm"><div class="layui-card"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-speaker"></i> 公告</div><div class="layui-card-body"><div class="userinfo"><img src="/head.png"><div class="name">淡泊明志，宁静致远</div><div class="icons"><a target="_blank" rel="noopener" href="https://github.com/heliufang" title="github"><i class="icon iconfont icon-github"></i></a> <a target="_blank" rel="noopener" href="https://gitee.com/heliufang" title="gitee"><i class="icon iconfont icon-gitee"></i></a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/helf" title="博客园"><i class="icon iconfont icon-cnblogs"></i></a></div><div class="other"><div class="item"><a class="title" style="color:#ff5722" href="/"><p class="num">40</p><div>文章</div></a></div><div class="item"><a style="color:#009688" href="/categories"><div class="num">8</div><div class="title">分类</div></a></div><div class="item"><a class="title" style="color:#01aaed" href="/tags"><div class="num">44</div><div>标签</div></a></div></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-website"></i> 网站资讯</div><div class="layui-card-body"><div class="webInfo-item"><div class="title">已运行时间</div><div class="content"><span id="runDays" data-since-date="2020-12-24"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span>天</div></div><div class="webInfo-item"><div class="title">本站文章字数合计</div><div class="content">200.8k</div></div><div class="webInfo-item"><div class="title">最后更新时间</div><div class="content" id="lastUpdate" data-last-update="2023-01-07 14:48:52"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></div></div></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-time"></i> 最新文章</div><div class="layui-card-body"><ul><li><a href="/2022/12/30/1608754051799977984/images/">1.react笔记</a></li><li><a href="/2022/12/09/1601805950963027968/images/">2.vue3.2新特性笔记</a></li><li><a href="/2022/10/30/1593064784100724736/images/">3.node笔记</a></li><li><a href="/2022/07/09/1545789245413789696/images/">4.vue3笔记</a></li><li><a href="/2022/07/09/1551862167303753728/images/">5.TypeScript笔记</a></li></ul></div></div><div class="layui-card ahover"><div class="layui-card-header"><i style="font-weight:700" class="layui-icon layui-icon-template-1"></i> 文章分类</div><div class="layui-card-body left-a-color"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/java/">java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/vue/">vue</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/web%E5%89%8D%E7%AB%AF/">web前端</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/">公众号和小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/">其它技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li></ul></div></div><div style="height:calc(100% - 60px - 60px);width:267px" id="toc-area" class="layui-card ahover"><div class="layui-card-header"><i class="layui-icon layui-icon-align-center"></i> 本文目录</div><div id="tocMain" class="layui-card-body" style="overflow:auto;height:calc(100% - 60px - 60px)"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">vue-cli脚手架创建项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ESLint"><span class="toc-text">ESLint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vscode%E7%9A%84eslint%E6%8F%92%E4%BB%B6"><span class="toc-text">vscode的eslint插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vant%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">vant组件库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%BA%93%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%AE%9A%E5%88%B6"><span class="toc-text">组件库样式的定制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D"><span class="toc-text">移动端适配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85axios"><span class="toc-text">封装axios</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try%E5%92%8Ccatch"><span class="toc-text">try和catch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-text">路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-text">时间处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4-%E5%B0%81%E8%A3%85"><span class="toc-text">自定义指令-封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E9%98%B2%E7%9B%97%E9%93%BE"><span class="toc-text">图片防盗链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E7%BB%84%E4%BB%B6%E5%8A%A0%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6"><span class="toc-text">给组件加原生事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">阻止事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-text">防抖和节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E9%9A%90%E8%97%8F%E5%9F%9F"><span class="toc-text">文件上传-隐藏域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api%E6%8E%A5%E5%8F%A3%E5%88%86%E6%96%87%E4%BB%B6"><span class="toc-text">api接口分文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86"><span class="toc-text">大整数问题处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">持久化存储方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E7%A6%BB%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C"><span class="toc-text">抽离组件注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98"><span class="toc-text">组件缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E5%83%8F%E4%B8%8D%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-text">头像不更新问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%9C%AA%E9%81%82%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">登录未遂的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-text">跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cors%E6%96%B9%E5%BC%8F"><span class="toc-text">cors方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsonp%E6%96%B9%E5%BC%8F"><span class="toc-text">jsonp方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91"><span class="toc-text">代理转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hbuilder%E6%89%93%E5%8C%85app"><span class="toc-text">Hbuilder打包app</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HBuilder%E5%BC%80%E5%8F%91%E7%89%88"><span class="toc-text">HBuilder开发版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA5-App%E9%A1%B9%E7%9B%AE"><span class="toc-text">创建5+App项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E6%89%93%E5%8C%85"><span class="toc-text">准备打包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E6%89%93%E5%8C%85"><span class="toc-text">云打包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C"><span class="toc-text">运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iOS%E9%97%AE%E9%A2%98"><span class="toc-text">iOS问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%8E%E8%80%81%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB"><span class="toc-text">李老师经验分享</span></a></li></ol></div><div class="readprocess"><div><i class="layui-icon layui-icon-read"></i> 已阅读：<span id="progressTxt"></span>%</div><div class="layui-progress" lay-filter="demo"><div class="layui-progress-bar" lay-percent="10%"></div></div></div></div></div><div class="layui-col-md9 markdown-body" style="background:#fff;margin-top:10px"><div class="article-title"><h1>黑马头条-vue移动端项目笔记整理</h1><p><i class="layui-icon layui-icon-survey"></i>发表于:2022-06-30 | <i class="layui-icon layui-icon-app"></i>字数:7k</p></div><div id="article"><p>b站教学视频 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1D3411L7PP">Vue2_项目_黑马头条-移动端项目</a></p><p>视频里配套资料: <a target="_blank" rel="noopener" href="http://m6z.cn/6guyjV">http://m6z.cn/6guyjV</a><br>最新的接口基地址: <a target="_blank" rel="noopener" href="http://geek.itheima.net/">http://geek.itheima.net/</a></p><p>只记录自己get到的一些知识，详细的老师的配套的笔记里面都有</p><h2 id="vue-cli脚手架创建项目"><a href="#vue-cli脚手架创建项目" class="headerlink" title="vue-cli脚手架创建项目"></a>vue-cli脚手架创建项目</h2><ul><li>安装vue-cli脚手架</li></ul><pre><code>npm install -g @vue/cli
</code></pre><ul><li>创建项目 采用自定义方式去创建项目</li></ul><pre><code>vue create hmtt
</code></pre><p>上下箭头切换, 回车确认, 空格选中</p><pre><code>? Please pick a preset:
  Default ([Vue 2] babel, eslint)
  Default (Vue 3 Preview) ([Vue 3] babel, eslint)
&gt; Manually select features  
</code></pre><p>手动选择特性: Babel, Router, Vuex, CSS Pre-processors, Linter</p><pre><code>? Please pick a preset: Manually select features
? Check the features needed for your project:
 (*) Choose Vue version
 (*) Babel
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
 (*) Router
 (*) Vuex
&gt;(*) CSS Pre-processors
 (*) Linter / Formatter
 ( ) Unit Testing
 ( ) E2E Testing  
</code></pre><p>版本Vue2.x</p><pre><code>? Choose a version of Vue.js that you want to start the project with (Use arrow keys)
&gt; 2.x
  3.x (Preview) 
</code></pre><p>路由是否使用history模式：不采用</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630153712490.png" alt="image-20220630153712490"></p><p>css 预处理器: 使用less</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630153737945.png" alt="image-20220630153737945"></p><p>eslint语法风格：Standard (一定)</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630153811062.png" alt="image-20220630153811062"></p><p>检查节点：保存时检查，提交时检查 (提交时可以不选)</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630153831434.png" alt="image-20220630153831434"></p><p>存储插件配置位置：单独放在不同的文件中</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630153904318.png" alt="image-20220630153904318"></p><p>接下来，它会问你是否要保存前面的设置作为预设方案，以便后续创建其它项目时直接使用。</p><p>如果选择Y, 保存, 以后就可以一键完成以上步骤</p><p>经过长长的等待，创建完毕, 进入文件夹, 启动项目</p><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><ol><li><p>什么是ESLint?</p><p>代码检查工具</p></li><li><p>为什么要使用ESLint?</p><p>规范我们写代码的格式, 看着整洁 &#x2F; 团队内成员风格统一</p></li><li><p>ESLint在哪里生效?</p><p>webpack开发服务器+ESLint配置检查</p></li></ol><p>规范文档: <a target="_blank" rel="noopener" href="http://www.verydoc.net/eslint/00003312.html">http://www.verydoc.net/eslint/00003312.html</a></p><p>规范文档2: <a target="_blank" rel="noopener" href="https://standardjs.com/rules-zhcn.html">https://standardjs.com/rules-zhcn.html</a></p><p>规范文档3: <a target="_blank" rel="noopener" href="http://eslint.cn/docs/rules/">http://eslint.cn/docs/rules/</a></p><h3 id="vscode的eslint插件"><a href="#vscode的eslint插件" class="headerlink" title="vscode的eslint插件"></a>vscode的eslint插件</h3><p>ctrl+s 这个插件就会修复常见的eslint抛出的错误</p><ul><li>下载这个插件到vscode中</li></ul><p><img src="/2022/06/30/1542451686885429248/images/image-20220630154354610.png" alt="image-20220630154354610"></p><p>注意： 一定要把脚手架工程, 作为vscode<strong>根目录</strong>, 因为eslint要使用配置文件.eslintrc</p><ul><li>一定要配置插件监测的时机, 修改ESLint插件配置</li></ul><p><img src="/2022/06/30/1542451686885429248/images/image-20220630154453277.png" alt="image-20220630154453277"></p><p>不用管别的, 把红框的放在{}内即可</p><pre><code class="json">&quot;eslint.run&quot;: &quot;onType&quot;,
&quot;editor.codeActionsOnSave&quot;: &#123;
    &quot;source.fixAll.eslint&quot;: true
&#125;
</code></pre><p>更多的规则可以参考这里: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiaoshou/p/12218642.html">https://www.cnblogs.com/jiaoshou/p/12218642.html</a></p><p>.eslintrc.js 配置文件关闭驼峰命名</p><pre><code class="js">rules: &#123;
    &#39;no-console&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;warn&#39; : &#39;off&#39;,
    &#39;no-debugger&#39;: process.env.NODE_ENV === &#39;production&#39; ? &#39;warn&#39; : &#39;off&#39;,
    // 取消文件和变量的驼峰命名
    &#39;vue/multi-word-component-names&#39;: 0,
    camelcase: &#39;off&#39;
  &#125;
</code></pre><h2 id="vant组件库"><a href="#vant组件库" class="headerlink" title="vant组件库"></a>vant组件库</h2><p>移动端组件库</p><p>vant官网：<a target="_blank" rel="noopener" href="https://vant-contrib.gitee.io/vant/v2/#/zh-CN/quickstart">https://vant-contrib.gitee.io/vant/v2/#/zh-CN/quickstart</a></p><ul><li>下载vant组件库</li></ul><pre><code class="js">yarn add vant

# Vue 2 项目，安装 Vant 2：
npm i vant@latest-v2 -S
</code></pre><ul><li>下载插件</li></ul><pre><code class="js">yarn add babel-plugin-import -D
</code></pre><ul><li>在babel.config.js-添加如下配置</li></ul><pre><code class="js">module.exports = &#123;
    // ...省略了其他
    plugins: [
        [&#39;import&#39;, &#123;
            libraryName: &#39;vant&#39;,
            libraryDirectory: &#39;es&#39;,
            style: true
        &#125;, &#39;vant&#39;]
    ]
&#125;;
</code></pre><p>一定要重启vscode和webpack开发服务器才会生效</p><h3 id="组件库样式的定制"><a href="#组件库样式的定制" class="headerlink" title="组件库样式的定制"></a>组件库样式的定制</h3><p>vant组件配置 - <strong>less文件</strong></p><ul><li>src&#x2F;styles&#x2F;cover.less - vant定制less变量统一在这管理</li></ul><pre><code class="css">// NavBar导航
@nav-bar-background-color:#007bff;
@nav-bar-title-text-color:white;
</code></pre><ul><li>vue.config.js - 注释变量, 放开引入文件路径</li></ul><pre><code class="js">// 不要手动写绝对路径, 用代码来动态获取, 绝对地址
const path = require(&#39;path&#39;)
// console.log(__dirname) // 当前文件, 所在文件夹, 的绝对路径
// 盘符:/......../工程名字, 后面自己拼接 src/styles/cover.less
module.exports = &#123;
  css: &#123;
    loaderOptions: &#123;
      less: &#123;
        modifyVars: &#123;
          // 直接覆盖变量
          // &#39;nav-bar-background-color&#39;: &#39;#007bff&#39;,
          // &#39;nav-bar-title-text-color&#39;: &#39;white&#39;,
          // 或者可以通过 less 文件覆盖（文件路径为绝对路径）
          hack: `true; @import &quot;$&#123;path.resolve(__dirname, &#39;src/styles/cover.less&#39;)&#125;&quot;;`
        &#125;
      &#125;
    &#125;
  &#125;
&#125;
</code></pre><p>一定要重启webpack开发服务器, 然后观察效果</p><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><p>PC端一般都是1:1用px还原UI设计图, 靠内容撑开高度</p><p>移动端一般都是<strong>rem单位进行适配</strong></p><p>步骤：</p><ul><li>下载amfe-flexible 根据网页宽度, 设置html的font-size</li></ul><pre><code class="js">yarn add amfe-flexible
</code></pre><ul><li>到main.js引入</li></ul><pre><code class="js">import &quot;amfe-flexible&quot;
</code></pre><ul><li>下载postcss和<a href="mailto:&#112;&#111;&#115;&#116;&#99;&#115;&#x73;&#x2d;&#x70;&#120;&#x74;&#111;&#x72;&#101;&#x6d;&#x40;&#x35;&#46;&#x31;&#x2e;&#49;">&#112;&#111;&#115;&#116;&#99;&#115;&#x73;&#x2d;&#x70;&#120;&#x74;&#111;&#x72;&#101;&#x6d;&#x40;&#x35;&#46;&#x31;&#x2e;&#49;</a></li></ul><p>postcss: 后处理css, 编译翻译css代码</p><p>postcss-pxtorem: 把css代码里所有px计算转换成rem</p><pre><code>yarn add postcss postcss-pxtorem@5.1.1
</code></pre><ul><li>根目录下创建postcss.config.js文件</li></ul><pre><code class="js">module.exports = &#123;
  plugins: &#123;
    &#39;postcss-pxtorem&#39;: &#123;
      // 能够把所有元素的px单位转成Rem
      // rootValue: 转换px的基准值。
      // 编码时, 一个元素宽是75px，则换成rem之后就是2rem
      rootValue: 37.5,
      propList: [&#39;*&#39;]
    &#125;
  &#125;
&#125;
</code></pre><p>37.5 是如何得来的?</p><p>UI移动端设计图宽度375px, 而flexible.js会&#x2F;10, 设置html的font-size为37.5</p><p><em>一般屏幕的适配方案为 1rem&#x3D;屏幕宽度的十分之一</em></p><p>总结：</p><ol><li><p>移动端适配选择哪种?</p><p>rem + flexible.js</p></li><li><p>flexible.js作用是什么?</p><p>js代码里获取网页宽度 &#x2F; 10设置html的font-size的值(px单位)</p></li><li><p>代码里px如何自动转换rem?</p><p>postcss和postcss-pxtorem插件</p></li></ol><h2 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h2><ul><li>下载axios</li></ul><pre><code class="js">yarn add axios
</code></pre><ul><li>request.js</li></ul><pre><code class="js">import ajax from &#39;axios&#39;
import router from &#39;@/router&#39;
import &#123; Notify &#125; from &#39;vant&#39;
import &#123; getToken &#125; from &#39;@/utils/token&#39;
// 创建axios实例
const axios = ajax.create(&#123;
  baseURL: &#39;http://toutiao.itheima.net&#39;,
  timeout: 20000 // 超时时间为20s
&#125;)

// 添加请求拦截器
axios.interceptors.request.use(function (config) &#123;
  // 在发送请求之前做些什么
  // 如果本地有token则携带在请求头中传给后台
  // console.log(config)
  if (getToken()?.length &gt; 0 &amp;&amp; config.headers.Authorization === undefined) &#123;
    config.headers.Authorization = `Bearer $&#123;getToken()&#125;`
  &#125;
  return config
&#125;, function (error) &#123;
  // 对请求错误做些什么
  return Promise.reject(error)
&#125;)

// 添加响应拦截器
axios.interceptors.response.use(function (response) &#123;
  // 对响应数据做点什么
  return response
&#125;, function (error) &#123;
  // 对响应错误做点什么
  /**
   * 响应401说明token失效--》跳转到登录页面
   */
  if (error.response.status === 401) &#123;
    router.push(&#39;/login&#39;)
    Notify(&#123; type: &#39;danger&#39;, message: &#39;登录已过期&#39; &#125;)
  &#125;
  return Promise.reject(error)
&#125;)

// 封装axios方法
export default (&#123; url, method = &#39;GET&#39;, data = &#123;&#125;, params = &#123;&#125;, headers = &#123;&#125; &#125;) =&gt; &#123;
  return axios(&#123;
    url,
    method,
    data,
    params,
    headers
  &#125;)
&#125;
</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>axios库中params里的值为null, 会自动忽略此参数和值, 不发给后台</p><p>axios库中data里的值为null, 会发给后台</p><p>axios可以在响应错误的拦截器中，按之前的配置重新发起请求 axios(error.config)</p><ul><li>token的续签</li></ul><p>定义刷新token的接口方法</p><pre><code class="js">// 用户 - 更新token
export const refreshTokenAPI = () =&gt; request(&#123;
  url: &#39;/v1_0/authorizations&#39;,
  method: &#39;PUT&#39;,
  headers: &#123;
    Authorization: `Bearer $&#123;store.state.refresh_token&#125;`
  &#125;
&#125;)
</code></pre><p>在响应拦截器401处, 调用重新请求token的接口, 然后同步给vuex和本地</p><pre><code class="js">axios.interceptors.response.use(function (response) &#123; 
  return response
&#125;, async function (error) &#123;
  if (error.response.status === 401) &#123; // 身份过期
    // token续签方式1:
    // store.commit(&#39;setToken&#39;, &#39;&#39;)
    // router.push(&#123; path: &#39;/login&#39; &#125;)

    // token续签方式2: refreshToken(用户无感知)
    const res = await refreshTokenAPI()
    // 再调用一次未完成的请求啊(用户无感知)
    // error.config 就是上一次axios请求的配置对象
    // console.dir(error.config)
    // 把新的token赋予到下一次axios请求的请求头中
    error.config.headers.Authorization = &#39;Bearer &#39; + res.data.data.token
    // return到await的地方
    return axios(error.config) //重点！！！：通过axios重新发起请求
  &#125; else &#123;
    return Promise.reject(error)
  &#125;
&#125;)
</code></pre><h2 id="try和catch"><a href="#try和catch" class="headerlink" title="try和catch"></a>try和catch</h2><ol><li>await用于取代then函数, 等待Promise成功结果提取在原地</li><li>await无法获取Promise失败的结果, 一旦失败Promise错误直接抛出到控制台</li></ol><p>可以利用try和catch解决上面的问题</p><pre><code class="js">try &#123;
    // 可能会报错的代码(例如await)
&#125; catch (err) &#123;
    // try里代码报错, 捕捉到这里执行
&#125;
</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li><p>$router和$route区别是?</p><ul><li><p>$router下用于跳转路由</p></li><li><p>$route是路由信息对象</p></li></ul></li><li><p>路由的push和replace方法区别?</p><ul><li>push跳转后, 可以返回</li><li>replace跳转后, 无法返回</li></ul></li><li><p>什么时候用$route.query 什么时候用$route.params</p><ul><li>$route.params —&gt;动态路由</li><li>$route.query —&gt;问号传参</li></ul></li><li><p>路由的懒加载</p></li></ol><p>路由懒加载 - 查看文档: <a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><pre><code class="js">component: Login
// 改成这个写法
component: () =&gt; import(&#39;@/views/Login.vue&#39;)
</code></pre><ol start="5"><li>路由守卫(类似后端的拦截器)</li></ol><p>方法1: 全局前置守卫判断</p><pre><code class="js">router.beforeEach((to, from, next) =&gt; &#123;
  // 有token, 不能去登录页
  // 无token, 需要用户&quot;权限&quot;的才需要去登录页
  if (store.state.token.length &gt; 0 &amp;&amp; to.path === &#39;/login&#39;) &#123;
    // 证明有token-已经登录了
    next(false) // 阻止跳转原地呆着
  &#125; else &#123;
    next()
  &#125;
&#125;)
</code></pre><p>方法2: 路由独享守卫（可以理解为局部的守卫，针对某个路由拦截）</p><pre><code class="js">&#123;
    path: &#39;/login&#39;,
    component: () =&gt; import(/* webpackChunkName: &quot;Login&quot; */ &#39;@/views/Login&#39;),
    beforeEnter (to, from, next) &#123;
      if (store.state.token.length &gt; 0) &#123; // vuex里有token(代表登录过, 但是一定要注意过期和主动退出要先清除vuex和本地的token, 让其跳转登录页)
        return next(false)
      &#125;
      next()
    &#125;
&#125;,
</code></pre><h2 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h2><p>dayjs第三方库: <a target="_blank" rel="noopener" href="https://dayjs.fenxianglu.cn/">https://dayjs.fenxianglu.cn/</a></p><ul><li>安装</li></ul><pre><code class="js">npm install dayjs --save
</code></pre><ul><li>使用</li></ul><pre><code class="js">var dayjs = require(&#39;dayjs&#39;)
//import dayjs from &#39;dayjs&#39; // ES 2015
dayjs().format()
</code></pre><p>utils&#x2F;date.js</p><pre><code class="js">import dayjs from &#39;dayjs&#39;
import relativeTime from &#39;dayjs/plugin/relativeTime&#39; // 到指定时间需要的插件
import &#39;dayjs/locale/zh&#39; // 集成中文

/**
 * .....多久之前
 * @param &#123;*&#125; 之前的时间
 * @returns 系统时间到之前指定时间的距离值
 */
export const timeAgo = (targetTime) =&gt; &#123;
  // 格式化时间
  dayjs.extend(relativeTime)
  dayjs.locale(&#39;zh&#39;)
  var a = dayjs()
  var b = dayjs(targetTime)
  return a.to(b) // 返回多久之前...
&#125;
</code></pre><p>扩展-自己写多久之前</p><pre><code class="js">relativeTime (val) &#123;
      const t = new Date(val)
      const diff = Date.now() - t.getTime()

      const year = Math.floor(diff / (1000 * 3600 * 24 * 365))
      if (year) &#123;
        return `$&#123;year&#125;年前`
      &#125;
      const month = Math.floor(diff / (1000 * 3600 * 24 * 30))
      if (month) &#123;
        return `$&#123;month&#125;月前`
      &#125;
      const day = Math.floor(diff / (1000 * 3600 * 24))
      if (day) &#123;
        return `$&#123;day&#125;天前`
      &#125;
      const hour = Math.floor(diff / (1000 * 3600))
      if (hour) &#123;
        return `$&#123;hour&#125;小时前`
      &#125;
      const minute = Math.floor(diff / (1000 * 60))
      if (minute) &#123;
        return `$&#123;minute&#125;分钟前`
      &#125; else &#123;
        return &#39;刚才&#39;
      &#125;
    &#125;
</code></pre><h2 id="自定义指令-封装"><a href="#自定义指令-封装" class="headerlink" title="自定义指令-封装"></a>自定义指令-封装</h2><ul><li>utils&#x2F;directives.js, 定义全局自定义指令插件</li></ul><pre><code class="js">import Vue from &#39;vue&#39;
// 插件对象(必须有install方法, 才可以注入到Vue.use中)
export default &#123;
  install () &#123;
    Vue.directive(&#39;fofo&#39;, &#123;
      inserted (el) &#123;//插入dom的时候执行
        fn(el)
      &#125;,
      update (el) &#123;//更新dom的时候执行
        fn(el)
      &#125;
    &#125;)
  &#125;
&#125;
function fn (el) &#123;
  if (el.nodeName === &#39;INPUT&#39; || el.nodeName === &#39;TEXTAREA&#39;) &#123;
    // 如果直接是input标签/textarea标签
    el.focus()
  &#125; else &#123;
    // 指令在van-search组件身上, 获取的是组件根标签div, 而input在标签内
    const inp = el.querySelector(&#39;input&#39;)
    const textArea = el.querySelector(&#39;textarea&#39;)
    // 如果找到了
    if (inp || textArea) &#123;
      inp &amp;&amp; inp.focus()
      textArea &amp;&amp; textArea.focus()
    &#125; else &#123;
      // 本身也不是, 子标签里也没有
      console.error(&#39;请把v-fofo用在输入框标签上&#39;)
    &#125;
  &#125;
&#125;
</code></pre><ul><li>引入到main.js注册</li></ul><pre><code class="js">import diretivesObj from &#39;@/utils/directives&#39;

Vue.use(diretivesObj)
</code></pre><p>Vue.use相关文档: <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#Vue-use">https://cn.vuejs.org/v2/api/#Vue-use</a></p><p>Vue.use(obj) 其实就是注册，内部会调用install方法</p><p>自定义指令的inserted何时执行?</p><ul><li>当指令所在组件, 第一次插入到真实DOM被调用</li></ul><h2 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h2><p>在前端可以通过meta来设置referrer policy(来源策略)，referrer设置成<code>no-referrer</code>，发送请求不会带上referrer信息，对方服务器也就无法拦截了</p><pre><code class="html">&lt;!-- 解决图片403防盗链问题 --&gt;
&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
</code></pre><p>但是如果他们做了其他判断, 我们依旧拿不到此图片</p><h2 id="给组件加原生事件"><a href="#给组件加原生事件" class="headerlink" title="给组件加原生事件"></a>给组件加原生事件</h2><p>组件默认没有click事件的时候，如果想用click事件怎么办？利用navive</p><pre><code class="html">&lt;article-item
              v-for=&quot;obj in articleList&quot;
              :key=&quot;obj.art_id&quot;
              :obj=&quot;obj&quot;
              @click.native=&quot;$router.push(`/article_detail?aid=$&#123;obj.art_id&#125;`)&quot;
              :showX=&quot;false&quot;
              &gt;&lt;/article-item&gt;
</code></pre><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><p>通过.stop来阻止</p><pre><code class="html">&lt;!-- 反馈按钮 --&gt;
&lt;van-icon name=&quot;cross&quot; @click.stop=&quot;onCloseClick&quot; /&gt;
</code></pre><h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>后面再找点资料详细看看</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>利用 Set 和 Array.from实现</p><pre><code class="js">this.history = Array.from(new Set(this.history)) // 去重
</code></pre><h2 id="文件上传-隐藏域"><a href="#文件上传-隐藏域" class="headerlink" title="文件上传-隐藏域"></a>文件上传-隐藏域</h2><p>当点击的是非 input[type&#x3D;’file’] 的时，不会弹出选择文件的框。此时可以设置一个隐藏的文件框，通过js来触发这个文件框的点击事件，从而实现文件上传。</p><pre><code class="html">&lt;van-cell title=&quot;头像&quot; is-link center&gt;
    &lt;template #default&gt;
        &lt;van-image round class=&quot;avatar&quot; :src=&quot;profile.photo&quot; 
                   &lt;!-- js触发点击事件 --&gt;
                   @click=&quot;$refs.iptFile.click()&quot;/&gt;
        &lt;!-- file 选择框 --&gt;
        &lt;input
               type=&quot;file&quot;
               ref=&quot;iptFile&quot;
               v-show=&quot;false&quot;
               accept=&quot;image/*&quot;
               @change=&quot;onFileChange&quot;
               /&gt;
    &lt;/template&gt;
&lt;/van-cell&gt;

&lt;script&gt;
export default &#123;
  methods: &#123;
    // 文件选择方法
    async onFileChange (ev) &#123;
    //   console.log(ev.target.files[0])
      if (ev.target.files.length === 0) return // 防止用户未选择图片
      const fd = new FormData()
      fd.append(&#39;photo&#39;, ev.target.files[0]) // photo在表单里参数名携带
      const res = await updatePhotoAPI(fd)
      console.log(res)
      this.profile.photo = res.data.data.photo // 更新最新头像
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre><p>接口</p><pre><code class="js">// 用户- 更新头像
// 注意: formObj的值必须是一个表单对象
// &#39;&#123;&quot;a&quot;: 10, &quot;b&quot;: 20&#125;&#39; // 对象格式的JSON字符串
// new FormData() // 表单对象
export const updatePhotoAPI = (formObj) =&gt; &#123;
  return request(&#123;
    url: &#39;/v1_0/user/photo&#39;,
    method: &#39;PATCH&#39;,
    data: formObj
    // 如果你的请求体内容是表单对象, 浏览器会自动携带请求头Content-Type为multipart/form-data
  &#125;)
&#125;
</code></pre><h2 id="api接口分文件"><a href="#api接口分文件" class="headerlink" title="api接口分文件"></a>api接口分文件</h2><ul><li>原因: 一个api&#x2F;index.js, 有几百行代码, 不便于管理</li><li>解决: 分散到多个js文件里, 再引入回到统一导出<ul><li>分散的js文件名, 尽量和页面模块同名, 方便查找</li></ul></li></ul><p>问题1: 分文件后, 逻辑页面里都是从api&#x2F;index.js导出的, 难道我们要去改逻辑代码?</p><p>解决: 在api&#x2F;index.js - 中 export * from ‘分散的文件’ (模块重定向)</p><p>意思: 在api&#x2F;index.js 作为入口, 从别的地方把接口倒回来同时导出给外面</p><blockquote><p>export 文档: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export</a></p></blockquote><p>注意; 包括reports.js文件也从统一出口导出, 去修改src&#x2F;components&#x2F;ArticleItem引数据位置</p><p>处理结果 api&#x2F;index.js如下</p><pre><code class="js">export * from &#39;./reports&#39; // 反馈列表数据
export * from &#39;./ArticleDetail&#39; // 文章详情相关
export * from &#39;./Home&#39; // 首页(频道)相关, 首页文章列表
export * from &#39;./Login&#39; // 登录相关
export * from &#39;./Search&#39; // 搜索相关
export * from &#39;./User&#39; / 用户相关
</code></pre><h2 id="大整数问题处理"><a href="#大整数问题处理" class="headerlink" title="大整数问题处理"></a>大整数问题处理</h2><p>JS安全数字范围? 16位的一个数字，超过16位也能显示, 但是精度不准确</p><ol><li><p>定义后台返回数据, 模拟大数</p><blockquote><p>后台数据库id, 生成算法是19位置</p></blockquote><pre><code class="js">const str = &#39;[&#123;&quot;id&quot;: 1302900300041101987&#125;, &#123;&quot;id&quot;: 1205340366642205763&#125;, &#123;&quot;id&quot;: 7689021398237123422&#125;]&#39;
</code></pre></li><li><p>尝试用JSON.parse转换, 发现转换后的值不对</p><blockquote><p>后面3位精度错误</p></blockquote><pre><code class="js">console.log(JSON.parse(str))
</code></pre></li><li><p>原因: JS范围的安全数打印</p><pre><code class="js">console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991
</code></pre><blockquote><p>详细原因可以看这里: <a target="_blank" rel="noopener" href="https://lidongxuwork.gitee.io/pages/webFront/javascript/run/0.1+0.2%E9%97%AE%E9%A2%98.html">https://lidongxuwork.gitee.io/pages/webFront/javascript/run/0.1+0.2%E9%97%AE%E9%A2%98.html</a></p></blockquote></li><li><p>解决方案, 可以引入第三方包叫json-bigint</p><blockquote><p>把大数转成字符串保存</p></blockquote><pre><code class="js">npm i json-bigint

const jsonBig = require(&#39;json-bigint&#39;)(&#123; storeAsString: true &#125;)
console.log(jsonBig.parse(str))
</code></pre></li></ol><h2 id="持久化存储方式"><a href="#持久化存储方式" class="headerlink" title="持久化存储方式"></a>持久化存储方式</h2><p>封装本地持久化方法,方便后期统一管理。(无限套娃，哈哈，前面的axios也是这个套路)</p><ul><li>创建utils&#x2F;storage.js文件, 定义4个方法</li></ul><pre><code class="js">// 本地存储方式
// 如果同时有sessionStorage和localStorage, 可以封装2份
// 现在我只封装一种统一的方式
export const setStorage = (key, value) =&gt; &#123;
  localStorage.setItem(key, value)
&#125;
export const getStorage = (key) =&gt; &#123;
  return localStorage.getItem(key)
&#125;
export const removeStorage = (key) =&gt; &#123;
  localStorage.removeItem(key)
&#125;
export const clearStorage = () =&gt; &#123;
  localStorage.clear()
&#125;
</code></pre><ul><li><p>把所有使用本地存储的地方, 都统一换成这里定义的方法</p><ul><li>在store&#x2F;index.js - vuex中使用过</li><li>在search&#x2F;index.vue - 搜索页面使用过</li></ul></li></ul><h2 id="抽离组件注册"><a href="#抽离组件注册" class="headerlink" title="抽离组件注册"></a>抽离组件注册</h2><p>main.js代码有些多, 分散出去</p><ul><li>创建src&#x2F;VantRegister.js, 把Vant注册的相关代码复制过来</li></ul><pre><code class="js">import Vue from &#39;vue&#39;
import &#123; NavBar, Form, Field, Button, Tabbar, TabbarItem, Icon, Tab, Tabs, Cell, List, PullRefresh, ActionSheet, Popup, Row, Col, Badge, Search, Divider, Tag, CellGroup, Image, Dialog, DatetimePicker, Loading, Lazyload &#125; from &#39;vant&#39;
Vue.use(Lazyload)

Vue.use(Loading)
Vue.use(DatetimePicker)
Vue.use(Dialog)
Vue.use(Image)
Vue.use(CellGroup)
Vue.use(Tag)
Vue.use(Divider)
//....
</code></pre><ul><li>在main.js引入一下, 让代码执行</li></ul><pre><code class="js">import &#39;./VantRegister&#39;
</code></pre><h2 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h2><ul><li>防止组件频繁创建和销毁</li><li>防止网络请求重复无用执行</li></ul><p>组件缓存, 可以实现组件的状态保持。</p><p>结合 vue 内置的 <strong>keep-alive</strong> 组件，可以实现组件的状态保持。</p><p>官方文档地址：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#keep-alive">https://cn.vuejs.org/v2/api/#keep-alive</a></p><ol><li><p>在<strong>App.vue</strong>中的router-view外层套上一个keep-alive组件</p><ul><li>缓存的一级路由页面切换不被释放, 但是首页还是会重新请求数据</li></ul></li><li><p>在<strong>Layout.vue</strong>中的router-view外层套上一个keep-alive组件</p><ul><li>这次Home和User页面都被缓存了(二级路由也要管)</li></ul></li><li><p>但发现<strong>搜索页面</strong>和<strong>详情页面</strong>多被缓存起来了 (多次进入不同的文章, 发现都是同一个文章详情)</p></li><li><p>对router-view使用exclude属性来区别, 哪些页面组件可以缓存</p><blockquote><p>特别注意exclude里是组件的name名字(跟路由没什么关系)</p></blockquote><pre><code class="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;keep-alive :exclude=&quot;[&#39;ArticleDetail&#39;, &#39;Login&#39;, &#39;Search&#39;, &#39;SearchResult&#39;]&quot;&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/keep-alive&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre></li></ol><h2 id="头像不更新问题"><a href="#头像不更新问题" class="headerlink" title="头像不更新问题"></a>头像不更新问题</h2><p>User.vue被缓存了, 所以改了头像回到User页面, created里获取用户资料接口不会执行</p><ul><li><p>解决方案1: 把created换成activated钩子函数即可</p></li><li><p>解决方案2: UserEdit.vue修改头像成功后, 更新到vuex中, User页面使用的vuex数据也受到更新</p></li></ul><h2 id="登录未遂的处理"><a href="#登录未遂的处理" class="headerlink" title="登录未遂的处理"></a>登录未遂的处理</h2><ul><li><p>要点赞的时候, 401了, 强制跳转到登录页面了, 保存未遂地址跳转到登录页面</p><blockquote><p>要把tokens续签改掉, 否则不会跳转到登录页面</p></blockquote><pre><code class="js">if (error.response.status === 401) &#123; // 身份过期
    // token续签方式1:  去登录页重新登录, token无用, 清掉-确保路由守卫if进不去
    store.commit(&#39;setToken&#39;, &#39;&#39;)
    console.log(router.currentRoute.fullPath)
    //重点1---》将未遂的路径传到登录页
    router.push(&#123; path: `/login?path=$&#123;router.currentRoute.fullPath&#125;` &#125;)

    // token续签方式2: refreshToken(用户无感知)
    // store.commit(&#39;setToken&#39;, &#39;&#39;)
    // const res = await refreshTokenAPI()
    // store.commit(&#39;setToken&#39;, res.data.data.token)
    // 再调用一次未完成的请求啊(用户无感知)
    // error.config 就是上一次axios请求的配置对象
    // console.dir(error.config)
    // 把新的token赋予到下一次axios请求的请求头中
    // error.config.headers.Authorization = &#39;Bearer &#39; + res.data.data.token
    // return到await的地方
    // return ajax(error.config)
&#125; else &#123;
    return Promise.reject(error)
&#125;
</code></pre></li></ul><ol start="2"><li><p>在Login&#x2F;index.vue, 登录后, 判断有未遂地址, 跳这里, 否则去&#x2F;路径</p><pre><code class="js">// 跳转到Layout页面
this.$router.replace(&#123;
    //重点2 登录页进行判断 有未遂地址, 跳这里, 否则去/路径
    path: this.$route.query.path || &#39;/layout&#39;
&#125;)
</code></pre></li></ol><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><blockquote><p>网页所在url的<strong>协议</strong>, <strong>域名</strong>, <strong>端口号</strong>, 和Ajax请求url的<strong>协议</strong>, <strong>域名</strong>, <strong>端口号</strong>有一个对应不上, 就发生跨域</p><p>跨域是浏览器对ajax做出的限制</p></blockquote><p>常见的跨域问题解决方式</p><h3 id="cors方式"><a href="#cors方式" class="headerlink" title="cors方式"></a>cors方式</h3><ul><li><p>前端什么也不用做</p></li><li><p>后端需要开启cors</p><blockquote><p>实际上就是在响应头添加允许跨域的源</p><p>Access-Control-Allow-Origin: 字段和值(意思就是允许去哪些源地址去请求这个服务器)</p></blockquote></li></ul><h3 id="jsonp方式"><a href="#jsonp方式" class="headerlink" title="jsonp方式"></a>jsonp方式</h3><ul><li><p>需要前端和后端同时支持</p><blockquote><p>前端用script+src属性, 发送函数名给后台, 同时准备好同名的函数, 准备接收数据</p><p>后端返回的字符串一定用方法名(数据字符串)格式返回, 到script标签中执行</p><p>调用函数名, 并传递数据</p></blockquote></li><li><p>例子代码(看看就行, 不用尝试)</p><pre><code class="vue">&lt;script&gt;
  function callBackFn(data)&#123;
    // data就是&#39;&#123;&quot;a&quot;: 10, &quot;b&quot;: 20&#125;&#39;
  &#125;
&lt;/script&gt;
&lt;script src=&quot;http://后台接口地址?callback=callBackFn&quot;&gt;&lt;/script&gt;
&lt;!-- 后台接口返回 &#39;callBackFn(&#123;&quot;a&quot;: 10, &quot;b&quot;: 20&#125;)&#39; --&gt;
</code></pre></li></ul><h3 id="代理转发"><a href="#代理转发" class="headerlink" title="代理转发"></a>代理转发</h3><p><strong>跨域是浏览器的限制</strong>，自己搭的服务器，开启cors后请求就不限制了。</p><ul><li><p>如果后端jsonp也不弄, cors也不弄, 就给你个接口地址</p><blockquote><p>我们可以在本地弄个服务器, 然后用服务器请求后台服务器接口地址</p></blockquote><p><img src="/2022/06/30/1542451686885429248/images/image-20220630174418046.png" alt="image-20220630174418046"></p></li><li><p>但是vuecli脚手架, 启动了一个webpack开发服务器, 它就能做代理转发</p><ul><li>而且前端和这个服务器是同源的都是8080端口</li></ul></li><li><p>需要修改webpack开发服务器的配置即可</p><blockquote><p>更多配置项参考这里: <a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/dev-server/#devserverproxy">https://webpack.docschina.org/configuration/dev-server/#devserverproxy</a></p></blockquote><pre><code class="js">devServer: &#123;
    proxy: &#123;
      // http://c.m.163.com/nc/article/headline/T1348647853363/0-40.html
      &#39;/api&#39;: &#123; // 请求相对路径以/api开头的, 才会走这里的配置
        target: &#39;http://c.m.163.com&#39;, // 后台接口域名
        changeOrigin: true, // 改变请求来源(欺骗后台你的请求是从http://c.m.163.com)
        pathRewrite: &#123;
          &#39;^/api&#39;: &#39;&#39; // 因为真实路径中并没有/api这段, 所以要去掉这段才能拼接正确地址转发请求
        &#125;
      &#125;
    &#125;
  &#125;
</code></pre></li><li><p>axios请求的代码</p><pre><code class="js">axios(&#123;
    url: &#39;/api/nc/article/headline/T1348647853363/0-40.html&#39;
&#125;)
</code></pre></li></ul><p>可以使用 <strong>http-server</strong> 这个node工具来搭建一个代理服务来解决跨域问题</p><pre><code>第一步：  使用win +r 打开dos面板，全局安装 npm install -g http-server

第二步：  http-server 项目路径 -P 服务器地址
</code></pre><h2 id="Hbuilder打包app"><a href="#Hbuilder打包app" class="headerlink" title="Hbuilder打包app"></a>Hbuilder打包app</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>为何要打包APP</li><li>APP分为哪几种类型</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>App有三大类型</p><ul><li><p>原生的App。手机有两大操作系统：苹果，安卓</p><blockquote><p>还有 windows Phone, 鸿蒙</p></blockquote><p>ios,安卓程序员 用各自的编程语言写的代码，只能在某一个平台上运行。分安卓版本和ios版本。</p><ul><li>优点：用户体验好 ；可以调用系统API（拍照，读内存…）。</li><li>缺点：费钱。(大公司一般会雇佣4端程序员)</li></ul></li><li><p>纯h5网站。就是一个移动站（<a target="_blank" rel="noopener" href="https://m.jd.com/%EF%BC%89">https://m.jd.com/）</a></p><ul><li>优点：省钱。就是网页。</li><li>缺点：不能调用系统API；没有统一的入口，用户不知道从哪里进来，都要通过浏览器才能访问；</li></ul></li><li><p>混合开发。</p><ul><li>先做一个网站，在网站之外套个原生的壳！能同时具备原生的优点和纯h5网站的优点。</li><li><strong>在原生的App嵌入h5 页</strong></li></ul></li></ul><h3 id="HBuilder开发版"><a href="#HBuilder开发版" class="headerlink" title="HBuilder开发版"></a>HBuilder开发版</h3><p>我们需要借助他, 帮助我们打包一个App</p><p>下载安装, 注册激活， 如果不注册激活，就不能使用它的打包功能</p><p>下载地址: <a target="_blank" rel="noopener" href="https://www.dcloud.io/hbuilderx.html">https://www.dcloud.io/hbuilderx.html</a> (下载App开发版)</p><blockquote><p>先走流程, 提示你注册再注册和激活就行了</p></blockquote><p>&#x3D;&#x3D;必须注册&#x3D;&#x3D;</p><p>&#x3D;&#x3D;必须激活邮箱&#x3D;&#x3D;</p><p>&#x3D;&#x3D;必须绑定手机号&#x3D;&#x3D;</p><h3 id="创建5-App项目"><a href="#创建5-App项目" class="headerlink" title="创建5+App项目"></a>创建5+App项目</h3><p>我们要选择5+App 项目,mui也是一套前端框架，可以选择一个mui项目。</p><ul><li>普通项目。 普通H5项目, Hbuilder内置了几套模板,作用不大,同学们基本都会自己创建</li><li>uni-app。多端应用,一套代码,复用八端,时下最火的一个跨端框架</li><li>wap2App。wap项目转 App , 原来只运在手机上的wap(无线网络协议,诺基亚,爱立信时代)项目 可转app项目</li><li><strong>5+ App</strong>。利用DCloud 的 **<code>5+ Runtime</code>**来做原生能力提供者的 项目</li><li>小程序。微信原生小程序的另外一个编辑器,比微信提供的开发者工具好用,但是现在谁还在用原生写小程序呢?</li><li>快应用 。原生快应用编辑器 , 较为冷门的生态, 目前不太热闹</li></ul><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175509578.png" alt="image-20220630175509578"></p><h3 id="准备打包"><a href="#准备打包" class="headerlink" title="准备打包"></a>准备打包</h3><ol><li><p>把我们vue项目打包好的dist下的一切复制到你刚才的项目-覆盖过来即可 (一定要保留manifest.json文件)</p><blockquote><p>mainfest.json是打包配置文件</p></blockquote><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175552604.png" alt="image-20220630175552604"></p></li><li><p>生成APPID</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175610718.png" alt="image-20220630175610718"></p></li><li><p>去掉通信录权限 (因为我的HBuilder没有身份证认证, 打包不让获取用户通讯录)</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175632784.png" alt="image-20220630175632784"></p></li><li><p>(可选), 如果上面不小心选择No了, 可以去源码处选择 - 删除</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175650163.png" alt="image-20220630175650163"></p></li></ol><h3 id="云打包"><a href="#云打包" class="headerlink" title="云打包"></a>云打包</h3><p><img src="/2022/06/30/1542451686885429248/images/image-20210407171554818.png" alt="image-20210407171554818"></p><p>如果一切正常，你将会在控制台中看到类似如下的结果：</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175836488.png" alt="image-20220630175836488"></p><p>这就是云打包成功了, 下面会出现apk下载的所在文件夹</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>把打包好的apk包, 发到安卓手机上 &#x2F; 电脑模拟器(推荐&lt;夜神模拟器&gt;) 运行即可</p><p><img src="/2022/06/30/1542451686885429248/images/image-20220630175858730.png" alt="image-20220630175858730"></p><h3 id="iOS问题"><a href="#iOS问题" class="headerlink" title="iOS问题"></a>iOS问题</h3><p>打包ios - 需要申请开发者账号(一年600元人民币): 以后打包的过程参考这个: <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34440345/article/details/99711586">https://blog.csdn.net/qq_34440345/article/details/99711586</a></p><p>也可以手机给电脑开热点 &#x2F; 只要连接在同一个wifi下, 手机浏览器访问webpack开发服务器局域网ip地址即可</p><h2 id="李老师经验分享"><a href="#李老师经验分享" class="headerlink" title="李老师经验分享"></a>李老师经验分享</h2><p>&#x2F;&#x2F; 写任何需求:<br>&#x2F;&#x2F; 章法<br>&#x2F;&#x2F; 1. html+css(标签和样式搞定)<br>&#x2F;&#x2F; 2. 铺设数据(调整内容, 可能调用接口拿到数据)<br>&#x2F;&#x2F; 3. JS(交互&#x2F;校验….效果), 前端拿到要传递给后台的值<br>&#x2F;&#x2F; 4. 与后台交互(调用后台接口, 回显返回数据提示等)</p><p>&#x2F;&#x2F; 技巧1:<br>&#x2F;&#x2F; 看到变量, 能马上反应过来这个变量里装的什么<br>&#x2F;&#x2F; 每个方法含义, 要什么参数, 返回值有无, 返回值什么意思, 都要马上反应过来<br>&#x2F;&#x2F; 每行代码的意思, 为何这么写, 先模仿老师的思路, 锻炼, 多了经验以后就能自己写了<br>&#x2F;&#x2F; 以上就多读代码多写代码多讨论积累经验</p><p>&#x2F;&#x2F; 技巧2:<br>&#x2F;&#x2F; 前端变量名可以直接跟后端 要求的参数名一致, 这样调用接口就不用再分开写了<br>&#x2F;&#x2F; 前端变量名, 如果装对象, 用obj结尾<br>&#x2F;&#x2F; 前端变量名, 如果装数组, 用arr或者list结尾<br>&#x2F;&#x2F; 前端变量名, 如果装字符串, 用str结尾<br>&#x2F;&#x2F; 这样看到变量能马上反应过来里面装的什么</p><p>&#x2F;&#x2F; 技巧3:<br>&#x2F;&#x2F; 统一判断http状态码, axios的”响应”拦截器<br>&#x2F;&#x2F; axios的”请求”拦截器, 统一给请求配置对象中加入统一的东西<br>&#x2F;&#x2F; 例如: 所有的请求都带上请求头字段Authorization和token值</p><p>&#x2F;&#x2F; 技巧4:<br>&#x2F;&#x2F; 所有状态一起变的, 一个变量控制所有人<br>&#x2F;&#x2F; 每行状态”独立”改变的, 每行对应”对象”里的属性(obj.visible&#x2F;其他属性), 显示隐藏的状态(2种值切换)</p><p>&#x2F;&#x2F; 技巧5:<br>&#x2F;&#x2F; 路由到底是几级的<br>&#x2F;&#x2F; 不要光看路径的个数<br>&#x2F;&#x2F; 实际:<br>&#x2F;&#x2F; 在路由规则数组里的层级</p><p>&#x2F;&#x2F; 技巧6: 什么时候需要提升功能封装<br>&#x2F;&#x2F; (1): 多个页面使用的相同功能<br>&#x2F;&#x2F; (2): 以后可能要扩展和修改的</p><p>&#x2F;&#x2F; 跨域问题:<br>&#x2F;&#x2F; 开发过程:<br>&#x2F;&#x2F; 1. 直接让后台开启cors&#x2F;jsonp, 直接调用(如果用jsonp你要注意你传参的格式)<br>&#x2F;&#x2F; 2. 后台不开cors&#x2F;jsonp, webpack开发服务器, vue.config.js - 代理转发<br>&#x2F;&#x2F; 3. 后台不开cors&#x2F;jsonp, 自己本地node+express搭建服务器(开cors) - 前端请求本地localhost:4005, 本地的请求转发代码(nodejs代码)</p><p>&#x2F;&#x2F; 打包上线:<br>&#x2F;&#x2F; 1. 后台开启cors, 直接用<br>&#x2F;&#x2F; 2. 后台不开cors&#x2F;jsonp, 把前端项目和后台项目放在一个服务器上(同源)<br>&#x2F;&#x2F; 3. 后台代码和前端代码不在一起, 本地自己写一个node+express服务器部署(请求自己的)</p></div><div class="post-ending"><div class="end-txt">------ 本文结束，感谢您的阅读 ------</div><blockquote class="layui-elem-quote layui-quote-nm"><div><span class="title">本文作者: </span>贺刘芳</div><div><span class="title">本文链接: </span><a target="_blank" href="https://heliufang.github.io/2022/06/30/1542451686885429248/images/">https://heliufang.github.io/2022/06/30/1542451686885429248/images/</a></div><div><span class="title">版权声明: </span>本文采用知识共享署名-非商业性使用-禁止演绎 2.5 中国大陆许可协议进行许可。</div></blockquote></div></div></div></div><ul id="toTopBtn" class="layui-fixbar" style="right:-70px" title="置顶"><div><a href="javascript:void(0)" class="icon iconfont icon-huojian"></a></div></ul><div class="qy-footer"><div class="font-Area"><p>Copyright © 2020 ~<span id="currentYear">2022</span> <span class="layui-icon layui-icon-heart-fill footer-heart"></span> HeLiuFang</p><p>由 <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a> <span style="color:red" class="layui-icon layui-icon-find-fill layui-anim layui-anim-rotate layui-anim-loop"></span> 强力驱动</p><p>访客数 <span style="color:red" id="busuanzi_value_site_uv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 人次 | 访问量 <span style="color:red" id="busuanzi_value_site_pv"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 次 | 本站已运行 <span style="color:red" id="runDaysFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span> 天 | 本站文章字数合计 <span style="color:red">200.8k</span> | 最后更新于 <span style="color:red" id="lastUpdateFooter"><i class="layui-icon layui-icon-loading layui-anim layui-anim-rotate layui-anim-loop"></i></span></p></div></div></body><script src="../../../../../js/jquery.min.js"></script><script src="../../../../../js/moment.min.js"></script><script src="../../../../../layui/layui.js"></script><script src="../../../../../js/mouse.js"></script><script src="../../../../../lib/prism/prism.js"></script><script>$("#searchBtn").click(function(){$("#searchShade").show(),$("#searchLayer").addClass("layui-anim layui-anim-scaleSpring")}),$("#closeBtn").click(function(){$("#searchShade").hide()});var searchFunc=function(e,o,a){$.ajax({url:e,dataType:"json",success:function(e){var t=document.getElementById(o),n=document.getElementById(a);t.addEventListener("input",function(){var t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(e){var n=!0,o=e.title.trim().toLowerCase(),e=e.url;""!=o&&a.forEach(function(e,t){o.indexOf(e)<0?n=!1:o=o.replace(new RegExp(e,"g"),'<span style="color:red">'+e+"</span>")}),n&&(t=t+"<li><a href='"+e+"' class='search-result-title'>"+o+"</a></li>")}),t+="</ul>",n.innerHTML=t)})}})};function DynamicLine(){function e(e,t,n){return e.getAttribute(t)||n}function t(e){return document.getElementsByTagName(e)}function n(){s=a.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,r=a.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function c(){var n,o,a,i,l;m.clearRect(0,0,s,r),y.forEach(function(e,t){for(e.x+=e.xa,e.y+=e.ya,e.xa*=e.x>s||e.x<0?-1:1,e.ya*=e.y>r||e.y<0?-1:1,m.fillRect(e.x-.5,e.y-.5,1,1),o=t+1;o<d.length;o++)null!==(n=d[o]).x&&null!==n.y&&(a=e.x-n.x,i=e.y-n.y,(l=a*a+i*i)<n.max)&&(n===h&&l>=n.max/2&&(e.x-=.03*a,e.y-=.03*i),a=(n.max-l)/n.max,m.beginPath(),m.lineWidth=a/2,m.strokeStyle="rgba("+u.c+","+(.2+a)+")",m.moveTo(e.x,e.y),m.lineTo(n.x,n.y),m.stroke())}),w(c)}var s,r,d,o,a=document.createElement("canvas"),u=(i=(o=t("script")).length,o=o[i-1],{l:i,z:e(o,"zIndex",-1),o:e(o,"opacity",.5),c:e(o,"color","0,0,50"),n:e(o,"count",99)}),i="c_n"+u.l,m=a.getContext("2d"),w=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout(e,1e3/45)},l=Math.random,h={x:null,y:null,max:2e4};a.id=i,a.style.cssText="position:fixed;top:0;left:0;z-index:"+u.z+";opacity:"+u.o,t("body")[0].appendChild(a),n(),window.onresize=n,window.onmousemove=function(e){e=e||window.event,h.x=e.clientX,h.y=e.clientY},window.onmouseout=function(){h.x=null,h.y=null};for(var y=[],p=0;p<u.n;p++){var x=l()*s,f=l()*r,$=2*l()-1,v=2*l()-1;y.push({x:x,y:f,xa:$,ya:v,max:6e3})}d=y.concat([h]),setTimeout(function(){c()},100)}searchFunc("/search.json","searchTxt","searchResult"),DynamicLine(),document.querySelector("#currentYear").innerText=(new Date).getFullYear();var days=moment().diff($("#runDays")[0].dataset.sinceDate,"days"),lastUpdate=($("#runDays").html(days),$("#runDaysFooter").html(days),moment($("#lastUpdate")[0].dataset.lastUpdate,"YYYY-MM-DD HH:mm:ss").locale("zh-CN").fromNow());$("#lastUpdate").html(lastUpdate),$("#lastUpdateFooter").html(lastUpdate),$("#toTopBtn").click(function(){var e=$(window).scrollTop(),t=parseInt(e/60),n=setInterval(function(){console.log("toTopBtn...setInterval",$(window).scrollTop()),$(window).scrollTop($(window).scrollTop()-t),0===$(window).scrollTop()&&clearInterval(n)},1)}),$.event.add(window,"scroll",function(){$("#toTopBtn").css("transform",0<$(window).scrollTop()?"translateX(-85px)":"translateX(85px)"),$("#toTopBtn").css("transition","all 0.5s")}),$("#loadingBox").hide(),$("body").css("overflow","auto")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var element=null;layui.use(["element"],function(){element=layui.element}),$(function(){var e=$("#toc-area"),t=$(e).offset().top;$.event.add(window,"scroll",function(){var o=$(".markdown-body").height(),o=(($(window).scrollTop()+t)/o*100).toFixed(2);element.progress("demo",(o=0==(o=99<o?100:o)?0:o)+"%"),$("#progressTxt").text(o),console.log("percent",o),$(e).css("position",$(window).scrollTop()>t?"fixed":"static"),$(e).css("top",$(window).scrollTop()>t?"60px":""),$("#tocMain").scrollTop($("#tocMain .toc").height()*o*.01)}),$("pre code").each(function(){var o=$(this).attr("class");o="language-"+(null==o||""==o||null==o?"plaintext":o),$(this).attr("class",o)}),$("pre").prepend('<div class="copy-to-clipboard-button"></div>')})</script></html>