<html>
<head>
	<title>贺刘芳的搬砖日记-文章页</title>
	<meta charset="utf-8">
  	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="stylesheet" href="../../../../../layui/css/layui.css"/>
	<link rel="stylesheet" href="../../../../../css/common.css"/>
	<link rel="stylesheet" href="../../../../../css/post.css"/>
	<link rel="stylesheet" href="../../../../../lib/google-code-prettify/skins/desert.css"/>
<meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="贺刘芳的搬砖日记" type="application/atom+xml">
</head>
<body>
	<!-- 导航模板 -->
	<!-- 导航 -->
<div class="qy-nav">
  <ul class="layui-nav" lay-filter="" lay-bar="disabled" lay-unselect>
    <li class="layui-nav-item">贺刘芳的搬砖日记</li>
    <li class="hide-xs layui-nav-item "><a href="/"><i class="layui-icon layui-icon-chart-screen"></i> 首页</a></li>
    <li class="hide-xs layui-nav-item "><a href="/about"><i class="layui-icon layui-icon-friends"></i> 关于</a></li>
    <li class="hide-xs layui-nav-item " id="searchBtn"><a href="javascript:void(0);"><i
          class="layui-icon layui-icon-search"></i> 搜索</a></li>
    <li id="mobileMenu" style="float: right" class="hide-sm hide-md hide-lg layui-nav-item ">
      <a href="javascript:void(0);"><i class="layui-icon layui-icon-down"></i> 菜单</a>
    </li>
  </ul>
</div>
<!-- 搜索弹框 -->
<div id="searchShade" class="searchShade">
  <div id="searchLayer">
    <div id="closeBtn" class="close"><i class="layui-icon layui-icon-close"></i></div>
    <input id="searchTxt" type="text" placeholder="搜索文章(只支持文章标题关键字)" />
    <div id="searchResult">
      <!-- <ul>
        <li>java笔记
        <li>
      </ul> -->
    </div>

  </div>
</div>
<script>
  window.onload = function () {
    //下拉菜单
    layui.use('dropdown', function () {
      var dropdown = layui.dropdown
      dropdown.render({
        elem: '#mobileMenu', //可绑定在任意元素中，此处以上述按钮为例
        data: [
          {
            title: '首页'
            , id: 11
            , href: '/'
            // , templet: '<i class="layui-icon layui-icon-chart-screen"></i>  {{d.title}}'
          },
          {
            title: '关于'
            , id: 22
            , href: '/about'
            // , templet: '<i class="layui-icon layui-icon-chart-friends"></i>  {{d.title}}'
          },
          {
            title: '搜索'
            , id: 33
            , href: '#'
            // , templet: '<i class="layui-icon layui-icon-chart-search"></i>  {{d.title}}'
          }
        ],
        click: function (data, othis) {
          var elem = $(this.elem)
            , listId = elem.data('id'); //表格列表的预埋数据
            if(data.id == 33){
              $("#searchShade").show()
            }
        }
      })

    })

    //点击搜索
    $("#searchBtn").click(function () {
      $("#searchShade").show()
    })

    //关闭弹框
    $("#closeBtn").click(function () {
      $("#searchShade").hide()
    })

    //搜索本地文章标题 https://cloud.tencent.com/developer/article/1624646
    var searchFunc = function (path, search_id, content_id) {
      $.ajax({
        url: path,
        dataType: "json",
        success: function (datas) {
          // console.log('datas :>> ', datas);
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function () {
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var data_title = data.title.trim().toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var first_occur = -1;
              if (data_title != '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  if (index_title < 0) {
                    isMatch = false;
                  }
                });
              }
              // show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                str += "</li>";
              }
            });
            str += "</ul>";
            $resultContent.innerHTML = str;
          });
        }
      });
    }
    searchFunc("/" + "search.json", 'searchTxt', 'searchResult');

  }


</script>
	<!-- 中间内容区域 -->
	<div class="layui-container  center" id="top">
		<div class="layui-row layui-col-space20">
			<div class="layui-col-md3 hide-xs hide-sm" >
				<div class="layui-card">
					<div class="layui-card-header"><i style="font-weight: bold;"
							class="layui-icon layui-icon-speaker"></i> 公告</div>
					<div class="layui-card-body">
						<!-- 个人信息模块 -->
						<div class="userinfo">
							<img src="/head.png">
							<div class="name">淡泊明志，宁静致远</div>
							<div class="other">
								<div class="item">
									<p class="num">
										39
									</p>
									<p class="title">文章</p>
								</div>
								<div class="item">
									<p class="num">
										8
									</p>
									<p class="title">分类</p>
								</div>
							</div>
						</div>
					</div>
				</div>
				<!-- 分类 -->
				<div class="layui-card">
					<div class="layui-card-header"><i class="layui-icon layui-icon-template-1"></i> 分类</div>
					<div class="layui-card-body">
						<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/java/">java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/vue/">vue</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/web%E5%89%8D%E7%AB%AF/">web前端</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/">公众号和小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/">其它技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li></ul>
					</div>
				</div>
				<!-- 归档 -->
				<div class="layui-card">
					<div class="layui-card-header"><i style="font-weight: bold;"
							class="layui-icon layui-icon-date"></i> 归档</div>
					<div class="layui-card-body">
						<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/12/">2022 十二月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/10/">2022 十月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/07/">2022 七月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/06/">2022 六月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/03/">2022 三月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/08/">2021 八月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/07/">2021 七月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/05/">2021 五月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/01/">2021 一月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/12/">2020 十二月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/11/">2020 十一月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/08/">2020 八月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/06/">2020 六月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2019/10/">2019 十月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2019/07/">2019 七月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2018/12/">2018 十二月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2018/10/">2018 十月</a><span class="archive-list-count">1</span></li></ul>
					</div>
				</div>
				
				<div style="height: 90%;width: 267px;" id="toc-area"  class="layui-card">
				  <div class="layui-card-header">本文目录</div>
				  <div class="layui-card-body" style="overflow:auto;height: calc(100% - 60px - 50px);">
				   <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">vue-cli脚手架创建项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ESLint"><span class="toc-text">ESLint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vscode%E7%9A%84eslint%E6%8F%92%E4%BB%B6"><span class="toc-text">vscode的eslint插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vant%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">vant组件库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%BA%93%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%AE%9A%E5%88%B6"><span class="toc-text">组件库样式的定制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D"><span class="toc-text">移动端适配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85axios"><span class="toc-text">封装axios</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try%E5%92%8Ccatch"><span class="toc-text">try和catch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-text">路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-text">时间处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4-%E5%B0%81%E8%A3%85"><span class="toc-text">自定义指令-封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E9%98%B2%E7%9B%97%E9%93%BE"><span class="toc-text">图片防盗链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E7%BB%84%E4%BB%B6%E5%8A%A0%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6"><span class="toc-text">给组件加原生事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">阻止事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-text">防抖和节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E9%9A%90%E8%97%8F%E5%9F%9F"><span class="toc-text">文件上传-隐藏域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api%E6%8E%A5%E5%8F%A3%E5%88%86%E6%96%87%E4%BB%B6"><span class="toc-text">api接口分文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86"><span class="toc-text">大整数问题处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">持久化存储方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E7%A6%BB%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C"><span class="toc-text">抽离组件注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98"><span class="toc-text">组件缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E5%83%8F%E4%B8%8D%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-text">头像不更新问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%9C%AA%E9%81%82%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">登录未遂的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-text">跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cors%E6%96%B9%E5%BC%8F"><span class="toc-text">cors方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsonp%E6%96%B9%E5%BC%8F"><span class="toc-text">jsonp方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91"><span class="toc-text">代理转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hbuilder%E6%89%93%E5%8C%85app"><span class="toc-text">Hbuilder打包app</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HBuilder%E5%BC%80%E5%8F%91%E7%89%88"><span class="toc-text">HBuilder开发版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA5-App%E9%A1%B9%E7%9B%AE"><span class="toc-text">创建5+App项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E6%89%93%E5%8C%85"><span class="toc-text">准备打包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E6%89%93%E5%8C%85"><span class="toc-text">云打包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C"><span class="toc-text">运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iOS%E9%97%AE%E9%A2%98"><span class="toc-text">iOS问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%8E%E8%80%81%E5%B8%88%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB"><span class="toc-text">李老师经验分享</span></a></li></ol>
				  </div>
				  <div class="readprocess">
					  <div>已阅读：<span id="progressTxt"></span>%</div>
					  <div class="layui-progress" lay-filter="demo">
						<div class="layui-progress-bar" lay-percent="10%"></div>
					  </div>
				  </div>
				</div>
				
			</div>
			<div class="layui-col-md9 markdown-body" style="background:#fff;margin-top: 10px;">
				
				<div class="article-title">
					<h1>黑马头条-vue移动端项目笔记整理</h1>
					<p>
						<i class="layui-icon layui-icon-time"></i>发表于：2022-06-30
						|
						<i class="layui-icon layui-icon-form"></i>字数统计：7k
					</p>
				</div>
				
					
				<!-- 文章内容 -->
				<div id="article">
				    <p>b站教学视频 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1D3411L7PP">Vue2_项目_黑马头条-移动端项目</a></p>
<p>视频里配套资料: <a target="_blank" rel="noopener" href="http://m6z.cn/6guyjV">http://m6z.cn/6guyjV</a><br>最新的接口基地址: <a target="_blank" rel="noopener" href="http://geek.itheima.net/">http://geek.itheima.net/</a></p>
<p>只记录自己get到的一些知识，详细的老师的配套的笔记里面都有</p>
<h2 id="vue-cli脚手架创建项目"><a href="#vue-cli脚手架创建项目" class="headerlink" title="vue-cli脚手架创建项目"></a>vue-cli脚手架创建项目</h2><ul>
<li>安装vue-cli脚手架</li>
</ul>
<pre><code class="hljs plaintext">npm install -g @vue/cli</code></pre>

<ul>
<li>创建项目  采用自定义方式去创建项目</li>
</ul>
<pre><code class="hljs plaintext">vue create hmtt</code></pre>

<p>上下箭头切换, 回车确认, 空格选中</p>
<pre><code class="hljs plaintext">? Please pick a preset:
  Default ([Vue 2] babel, eslint)
  Default (Vue 3 Preview) ([Vue 3] babel, eslint)
&gt; Manually select features</code></pre>

<p>手动选择特性:  Babel, Router, Vuex,  CSS Pre-processors, Linter</p>
<pre><code class="hljs plaintext">? Please pick a preset: Manually select features
? Check the features needed for your project:
 (*) Choose Vue version
 (*) Babel
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
 (*) Router
 (*) Vuex
&gt;(*) CSS Pre-processors
 (*) Linter / Formatter
 ( ) Unit Testing
 ( ) E2E Testing</code></pre>

<p>版本Vue2.x</p>
<pre><code class="hljs plaintext">? Choose a version of Vue.js that you want to start the project with (Use arrow keys)
&gt; 2.x
  3.x (Preview)</code></pre>

<p>路由是否使用history模式：不采用</p>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630153712490.png" alt="image-20220630153712490"></p>
<p>css 预处理器: 使用less</p>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630153737945.png" alt="image-20220630153737945"></p>
<p>eslint语法风格：Standard (一定)</p>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630153811062.png" alt="image-20220630153811062"></p>
<p>检查节点：保存时检查，提交时检查 (提交时可以不选)</p>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630153831434.png" alt="image-20220630153831434"></p>
<p>存储插件配置位置：单独放在不同的文件中 </p>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630153904318.png" alt="image-20220630153904318"></p>
<p>接下来，它会问你是否要保存前面的设置作为预设方案，以便后续创建其它项目时直接使用。</p>
<p>如果选择Y, 保存, 以后就可以一键完成以上步骤</p>
<p>经过长长的等待，创建完毕, 进入文件夹, 启动项目</p>
<h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><ol>
<li><p>什么是ESLint?</p>
<p>代码检查工具</p>
</li>
<li><p>为什么要使用ESLint?</p>
<p>规范我们写代码的格式, 看着整洁 &#x2F; 团队内成员风格统一</p>
</li>
<li><p>ESLint在哪里生效?</p>
<p>webpack开发服务器+ESLint配置检查</p>
</li>
</ol>
<p>规范文档: <a target="_blank" rel="noopener" href="http://www.verydoc.net/eslint/00003312.html">http://www.verydoc.net/eslint/00003312.html</a></p>
<p>规范文档2: <a target="_blank" rel="noopener" href="https://standardjs.com/rules-zhcn.html">https://standardjs.com/rules-zhcn.html</a></p>
<p>规范文档3: <a target="_blank" rel="noopener" href="http://eslint.cn/docs/rules/">http://eslint.cn/docs/rules/</a></p>
<h3 id="vscode的eslint插件"><a href="#vscode的eslint插件" class="headerlink" title="vscode的eslint插件"></a>vscode的eslint插件</h3><p>ctrl+s 这个插件就会修复常见的eslint抛出的错误</p>
<ul>
<li>下载这个插件到vscode中</li>
</ul>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630154354610.png" alt="image-20220630154354610"></p>
<p>注意： 一定要把脚手架工程, 作为vscode<strong>根目录</strong>, 因为eslint要使用配置文件.eslintrc</p>
<ul>
<li>一定要配置插件监测的时机, 修改ESLint插件配置</li>
</ul>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630154453277.png" alt="image-20220630154453277"></p>
<p>不用管别的, 把红框的放在{}内即可</p>
<pre><code class="hljs json"><span class="hljs-attr">&quot;eslint.run&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;onType&quot;</span><span class="hljs-punctuation">,</span>
<span class="hljs-attr">&quot;editor.codeActionsOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>
	<span class="hljs-attr">&quot;source.fixAll.eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span>
<span class="hljs-punctuation">&#125;</span></code></pre>

<p>更多的规则可以参考这里: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiaoshou/p/12218642.html">https://www.cnblogs.com/jiaoshou/p/12218642.html</a></p>
<p>.eslintrc.js 配置文件关闭驼峰命名</p>
<pre><code class="hljs js"><span class="hljs-attr">rules</span>: &#123;
    <span class="hljs-string">&#x27;no-console&#x27;</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span> ? <span class="hljs-string">&#x27;warn&#x27;</span> : <span class="hljs-string">&#x27;off&#x27;</span>,
    <span class="hljs-string">&#x27;no-debugger&#x27;</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span> ? <span class="hljs-string">&#x27;warn&#x27;</span> : <span class="hljs-string">&#x27;off&#x27;</span>,
    <span class="hljs-comment">// 取消文件和变量的驼峰命名</span>
    <span class="hljs-string">&#x27;vue/multi-word-component-names&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">camelcase</span>: <span class="hljs-string">&#x27;off&#x27;</span>
  &#125;</code></pre>

<h2 id="vant组件库"><a href="#vant组件库" class="headerlink" title="vant组件库"></a>vant组件库</h2><p>移动端组件库</p>
<p>vant官网：<a target="_blank" rel="noopener" href="https://vant-contrib.gitee.io/vant/v2/#/zh-CN/quickstart">https://vant-contrib.gitee.io/vant/v2/#/zh-CN/quickstart</a></p>
<ul>
<li>下载vant组件库</li>
</ul>
<pre><code class="hljs js">yarn add vant

# <span class="hljs-title class_">Vue</span> <span class="hljs-number">2</span> 项目，安装 <span class="hljs-title class_">Vant</span> <span class="hljs-number">2</span>：
npm i vant@latest-v2 -S</code></pre>

<ul>
<li>下载插件</li>
</ul>
<pre><code class="hljs js">yarn add babel-plugin-<span class="hljs-keyword">import</span> -D</code></pre>

<ul>
<li>在babel.config.js-添加如下配置</li>
</ul>
<pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
    <span class="hljs-comment">// ...省略了其他</span>
    <span class="hljs-attr">plugins</span>: [
        [<span class="hljs-string">&#x27;import&#x27;</span>, &#123;
            <span class="hljs-attr">libraryName</span>: <span class="hljs-string">&#x27;vant&#x27;</span>,
            <span class="hljs-attr">libraryDirectory</span>: <span class="hljs-string">&#x27;es&#x27;</span>,
            <span class="hljs-attr">style</span>: <span class="hljs-literal">true</span>
        &#125;, <span class="hljs-string">&#x27;vant&#x27;</span>]
    ]
&#125;;</code></pre>

<p>一定要重启vscode和webpack开发服务器才会生效</p>
<h3 id="组件库样式的定制"><a href="#组件库样式的定制" class="headerlink" title="组件库样式的定制"></a>组件库样式的定制</h3><p>vant组件配置 - <strong>less文件</strong></p>
<ul>
<li>src&#x2F;styles&#x2F;cover.less - vant定制less变量统一在这管理</li>
</ul>
<pre><code class="hljs css">// NavBar导航
<span class="hljs-keyword">@nav-bar-background-color</span>:#007bff;
<span class="hljs-keyword">@nav-bar-title-text-color</span>:white;</code></pre>

<ul>
<li>vue.config.js - 注释变量, 放开引入文件路径</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// 不要手动写绝对路径, 用代码来动态获取, 绝对地址</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)
<span class="hljs-comment">// console.log(__dirname) // 当前文件, 所在文件夹, 的绝对路径</span>
<span class="hljs-comment">// 盘符:/......../工程名字, 后面自己拼接 src/styles/cover.less</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  <span class="hljs-attr">css</span>: &#123;
    <span class="hljs-attr">loaderOptions</span>: &#123;
      <span class="hljs-attr">less</span>: &#123;
        <span class="hljs-attr">modifyVars</span>: &#123;
          <span class="hljs-comment">// 直接覆盖变量</span>
          <span class="hljs-comment">// &#x27;nav-bar-background-color&#x27;: &#x27;#007bff&#x27;,</span>
          <span class="hljs-comment">// &#x27;nav-bar-title-text-color&#x27;: &#x27;white&#x27;,</span>
          <span class="hljs-comment">// 或者可以通过 less 文件覆盖（文件路径为绝对路径）</span>
          <span class="hljs-attr">hack</span>: <span class="hljs-string">`true; @import &quot;<span class="hljs-subst">$&#123;path.resolve(__dirname, <span class="hljs-string">&#x27;src/styles/cover.less&#x27;</span>)&#125;</span>&quot;;`</span>
        &#125;
      &#125;
    &#125;
  &#125;
&#125;</code></pre>

<p>一定要重启webpack开发服务器, 然后观察效果</p>
<h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><p>PC端一般都是1:1用px还原UI设计图, 靠内容撑开高度</p>
<p>移动端一般都是<strong>rem单位进行适配</strong></p>
<p>步骤：</p>
<ul>
<li>下载amfe-flexible    根据网页宽度, 设置html的font-size</li>
</ul>
<pre><code class="hljs js">yarn add amfe-flexible</code></pre>

<ul>
<li>到main.js引入</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;amfe-flexible&quot;</span></code></pre>

<ul>
<li>下载postcss和<a href="mailto:&#112;&#111;&#115;&#x74;&#99;&#115;&#115;&#x2d;&#112;&#120;&#116;&#x6f;&#114;&#101;&#x6d;&#64;&#53;&#x2e;&#49;&#x2e;&#49;">&#112;&#111;&#115;&#x74;&#99;&#115;&#115;&#x2d;&#112;&#120;&#116;&#x6f;&#114;&#101;&#x6d;&#64;&#53;&#x2e;&#49;&#x2e;&#49;</a></li>
</ul>
<p>postcss: 后处理css, 编译翻译css代码</p>
<p>postcss-pxtorem: 把css代码里所有px计算转换成rem</p>
<pre><code class="hljs plaintext">yarn add postcss postcss-pxtorem@5.1.1</code></pre>

<ul>
<li>根目录下创建postcss.config.js文件</li>
</ul>
<pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  <span class="hljs-attr">plugins</span>: &#123;
    <span class="hljs-string">&#x27;postcss-pxtorem&#x27;</span>: &#123;
      <span class="hljs-comment">// 能够把所有元素的px单位转成Rem</span>
      <span class="hljs-comment">// rootValue: 转换px的基准值。</span>
      <span class="hljs-comment">// 编码时, 一个元素宽是75px，则换成rem之后就是2rem</span>
      <span class="hljs-attr">rootValue</span>: <span class="hljs-number">37.5</span>,
      <span class="hljs-attr">propList</span>: [<span class="hljs-string">&#x27;*&#x27;</span>]
    &#125;
  &#125;
&#125;</code></pre>

<p>37.5 是如何得来的?</p>
<p>UI移动端设计图宽度375px, 而flexible.js会&#x2F;10, 设置html的font-size为37.5</p>
<p><em>一般屏幕的适配方案为 1rem&#x3D;屏幕宽度的十分之一</em></p>
<p>总结：</p>
<ol>
<li><p>移动端适配选择哪种?</p>
<p>rem + flexible.js</p>
</li>
<li><p>flexible.js作用是什么?</p>
<p>js代码里获取网页宽度 &#x2F; 10设置html的font-size的值(px单位)</p>
</li>
<li><p>代码里px如何自动转换rem?</p>
<p>postcss和postcss-pxtorem插件</p>
</li>
</ol>
<h2 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h2><ul>
<li>下载axios</li>
</ul>
<pre><code class="hljs js">yarn add axios</code></pre>

<ul>
<li>request.js</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> ajax <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router&#x27;</span>
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Notify</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vant&#x27;</span>
<span class="hljs-keyword">import</span> &#123; getToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/token&#x27;</span>
<span class="hljs-comment">// 创建axios实例</span>
<span class="hljs-keyword">const</span> axios = ajax.<span class="hljs-title function_">create</span>(&#123;
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://toutiao.itheima.net&#x27;</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">20000</span> <span class="hljs-comment">// 超时时间为20s</span>
&#125;)

<span class="hljs-comment">// 添加请求拦截器</span>
axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;
  <span class="hljs-comment">// 在发送请求之前做些什么</span>
  <span class="hljs-comment">// 如果本地有token则携带在请求头中传给后台</span>
  <span class="hljs-comment">// console.log(config)</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getToken</span>()?.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> === <span class="hljs-literal">undefined</span>) &#123;
    config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;getToken()&#125;</span>`</span>
  &#125;
  <span class="hljs-keyword">return</span> config
&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;
  <span class="hljs-comment">// 对请求错误做些什么</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
&#125;)

<span class="hljs-comment">// 添加响应拦截器</span>
axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;
  <span class="hljs-comment">// 对响应数据做点什么</span>
  <span class="hljs-keyword">return</span> response
&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;
  <span class="hljs-comment">// 对响应错误做点什么</span>
  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * 响应401说明token失效--》跳转到登录页面</span>
<span class="hljs-comment">   */</span>
  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;
    router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)
    <span class="hljs-title class_">Notify</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;danger&#x27;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;登录已过期&#x27;</span> &#125;)
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
&#125;)

<span class="hljs-comment">// 封装axios方法</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (&#123; url, method = <span class="hljs-string">&#x27;GET&#x27;</span>, data = &#123;&#125;, params = &#123;&#125;, headers = &#123;&#125; &#125;) =&gt; &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(&#123;
    url,
    method,
    data,
    params,
    headers
  &#125;)
&#125;</code></pre>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>axios库中params里的值为null, 会自动忽略此参数和值, 不发给后台</p>
<p>axios库中data里的值为null, 会发给后台</p>
<p>axios可以在响应错误的拦截器中，按之前的配置重新发起请求  axios(error.config)</p>
<ul>
<li>token的续签</li>
</ul>
<p>定义刷新token的接口方法</p>
<pre><code class="hljs js"><span class="hljs-comment">// 用户 - 更新token</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">refreshTokenAPI</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">request</span>(&#123;
  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/v1_0/authorizations&#x27;</span>,
  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PUT&#x27;</span>,
  <span class="hljs-attr">headers</span>: &#123;
    <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;store.state.refresh_token&#125;</span>`</span>
  &#125;
&#125;)</code></pre>

<p>在响应拦截器401处, 调用重新请求token的接口, 然后同步给vuex和本地</p>
<pre><code class="hljs js">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123; 
  <span class="hljs-keyword">return</span> response
&#125;, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;
  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123; <span class="hljs-comment">// 身份过期</span>
    <span class="hljs-comment">// token续签方式1:</span>
    <span class="hljs-comment">// store.commit(&#x27;setToken&#x27;, &#x27;&#x27;)</span>
    <span class="hljs-comment">// router.push(&#123; path: &#x27;/login&#x27; &#125;)</span>

    <span class="hljs-comment">// token续签方式2: refreshToken(用户无感知)</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">refreshTokenAPI</span>()
    <span class="hljs-comment">// 再调用一次未完成的请求啊(用户无感知)</span>
    <span class="hljs-comment">// error.config 就是上一次axios请求的配置对象</span>
    <span class="hljs-comment">// console.dir(error.config)</span>
    <span class="hljs-comment">// 把新的token赋予到下一次axios请求的请求头中</span>
    error.<span class="hljs-property">config</span>.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">&#x27;Bearer &#x27;</span> + res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>
    <span class="hljs-comment">// return到await的地方</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">axios</span>(error.<span class="hljs-property">config</span>) <span class="hljs-comment">//重点！！！：通过axios重新发起请求</span>
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
  &#125;
&#125;)</code></pre>

<h2 id="try和catch"><a href="#try和catch" class="headerlink" title="try和catch"></a>try和catch</h2><ol>
<li>await用于取代then函数, 等待Promise成功结果提取在原地</li>
<li>await无法获取Promise失败的结果, 一旦失败Promise错误直接抛出到控制台</li>
</ol>
<p>可以利用try和catch解决上面的问题</p>
<pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;
	<span class="hljs-comment">// 可能会报错的代码(例如await)</span>
&#125; <span class="hljs-keyword">catch</span> (err) &#123;
	<span class="hljs-comment">// try里代码报错, 捕捉到这里执行</span>
&#125;</code></pre>

<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li><p>$router和$route区别是?</p>
<ul>
<li><p>$router下用于跳转路由</p>
</li>
<li><p>$route是路由信息对象</p>
</li>
</ul>
</li>
<li><p>路由的push和replace方法区别?</p>
<ul>
<li>push跳转后, 可以返回</li>
<li>replace跳转后, 无法返回</li>
</ul>
</li>
<li><p>什么时候用$route.query 什么时候用$route.params</p>
<ul>
<li>$route.params  —&gt;动态路由</li>
<li>$route.query  —&gt;问号传参</li>
</ul>
</li>
<li><p>路由的懒加载</p>
</li>
</ol>
<p>路由懒加载 - 查看文档: <a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p>
<pre><code class="hljs js"><span class="hljs-attr">component</span>: <span class="hljs-title class_">Login</span>
<span class="hljs-comment">// 改成这个写法</span>
<span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;@/views/Login.vue&#x27;</span>)</code></pre>

<ol start="5">
<li>路由守卫(类似后端的拦截器)</li>
</ol>
<p>方法1: 全局前置守卫判断</p>
<pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// 有token, 不能去登录页</span>
  <span class="hljs-comment">// 无token, 需要用户&quot;权限&quot;的才需要去登录页</span>
  <span class="hljs-keyword">if</span> (store.<span class="hljs-property">state</span>.<span class="hljs-property">token</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; to.<span class="hljs-property">path</span> === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;
    <span class="hljs-comment">// 证明有token-已经登录了</span>
    <span class="hljs-title function_">next</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 阻止跳转原地呆着</span>
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-title function_">next</span>()
  &#125;
&#125;)</code></pre>

<p>方法2: 路由独享守卫（可以理解为局部的守卫，针对某个路由拦截）</p>
<pre><code class="hljs js">&#123;
    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;Login&quot; */</span> <span class="hljs-string">&#x27;@/views/Login&#x27;</span>),
    beforeEnter (to, <span class="hljs-keyword">from</span>, next) &#123;
      <span class="hljs-keyword">if</span> (store.<span class="hljs-property">state</span>.<span class="hljs-property">token</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// vuex里有token(代表登录过, 但是一定要注意过期和主动退出要先清除vuex和本地的token, 让其跳转登录页)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(<span class="hljs-literal">false</span>)
      &#125;
      <span class="hljs-title function_">next</span>()
    &#125;
&#125;,</code></pre>



<h2 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h2><p>dayjs第三方库: <a target="_blank" rel="noopener" href="https://dayjs.fenxianglu.cn/">https://dayjs.fenxianglu.cn/</a></p>
<ul>
<li>安装</li>
</ul>
<pre><code class="hljs js">npm install dayjs --save</code></pre>

<ul>
<li>使用</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> dayjs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dayjs&#x27;</span>)
<span class="hljs-comment">//import dayjs from &#x27;dayjs&#x27; // ES 2015</span>
<span class="hljs-title function_">dayjs</span>().<span class="hljs-title function_">format</span>()</code></pre>

<p>utils&#x2F;date.js</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> dayjs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;dayjs&#x27;</span>
<span class="hljs-keyword">import</span> relativeTime <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;dayjs/plugin/relativeTime&#x27;</span> <span class="hljs-comment">// 到指定时间需要的插件</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dayjs/locale/zh&#x27;</span> <span class="hljs-comment">// 集成中文</span>

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * .....多久之前</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; 之前的时间</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> 系统时间到之前指定时间的距离值</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">timeAgo</span> = (<span class="hljs-params">targetTime</span>) =&gt; &#123;
  <span class="hljs-comment">// 格式化时间</span>
  dayjs.<span class="hljs-title function_">extend</span>(relativeTime)
  dayjs.<span class="hljs-title function_">locale</span>(<span class="hljs-string">&#x27;zh&#x27;</span>)
  <span class="hljs-keyword">var</span> a = <span class="hljs-title function_">dayjs</span>()
  <span class="hljs-keyword">var</span> b = <span class="hljs-title function_">dayjs</span>(targetTime)
  <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">to</span>(b) <span class="hljs-comment">// 返回多久之前...</span>
&#125;</code></pre>

<p>扩展-自己写多久之前</p>
<pre><code class="hljs js">relativeTime (val) &#123;
      <span class="hljs-keyword">const</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(val)
      <span class="hljs-keyword">const</span> diff = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - t.<span class="hljs-title function_">getTime</span>()

      <span class="hljs-keyword">const</span> year = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / (<span class="hljs-number">1000</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">365</span>))
      <span class="hljs-keyword">if</span> (year) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;year&#125;</span>年前`</span>
      &#125;
      <span class="hljs-keyword">const</span> month = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / (<span class="hljs-number">1000</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span>))
      <span class="hljs-keyword">if</span> (month) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;month&#125;</span>月前`</span>
      &#125;
      <span class="hljs-keyword">const</span> day = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / (<span class="hljs-number">1000</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>))
      <span class="hljs-keyword">if</span> (day) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;day&#125;</span>天前`</span>
      &#125;
      <span class="hljs-keyword">const</span> hour = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / (<span class="hljs-number">1000</span> * <span class="hljs-number">3600</span>))
      <span class="hljs-keyword">if</span> (hour) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;hour&#125;</span>小时前`</span>
      &#125;
      <span class="hljs-keyword">const</span> minute = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>))
      <span class="hljs-keyword">if</span> (minute) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;minute&#125;</span>分钟前`</span>
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;刚才&#x27;</span>
      &#125;
    &#125;</code></pre>

<h2 id="自定义指令-封装"><a href="#自定义指令-封装" class="headerlink" title="自定义指令-封装"></a>自定义指令-封装</h2><ul>
<li>utils&#x2F;directives.js, 定义全局自定义指令插件</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-comment">// 插件对象(必须有install方法, 才可以注入到Vue.use中)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;
  install () &#123;
    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;fofo&#x27;</span>, &#123;
      inserted (el) &#123;<span class="hljs-comment">//插入dom的时候执行</span>
        <span class="hljs-title function_">fn</span>(el)
      &#125;,
      update (el) &#123;<span class="hljs-comment">//更新dom的时候执行</span>
        <span class="hljs-title function_">fn</span>(el)
      &#125;
    &#125;)
  &#125;
&#125;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span> (el) &#123;
  <span class="hljs-keyword">if</span> (el.<span class="hljs-property">nodeName</span> === <span class="hljs-string">&#x27;INPUT&#x27;</span> || el.<span class="hljs-property">nodeName</span> === <span class="hljs-string">&#x27;TEXTAREA&#x27;</span>) &#123;
    <span class="hljs-comment">// 如果直接是input标签/textarea标签</span>
    el.<span class="hljs-title function_">focus</span>()
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 指令在van-search组件身上, 获取的是组件根标签div, 而input在标签内</span>
    <span class="hljs-keyword">const</span> inp = el.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;input&#x27;</span>)
    <span class="hljs-keyword">const</span> textArea = el.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;textarea&#x27;</span>)
    <span class="hljs-comment">// 如果找到了</span>
    <span class="hljs-keyword">if</span> (inp || textArea) &#123;
      inp &amp;&amp; inp.<span class="hljs-title function_">focus</span>()
      textArea &amp;&amp; textArea.<span class="hljs-title function_">focus</span>()
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// 本身也不是, 子标签里也没有</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请把v-fofo用在输入框标签上&#x27;</span>)
    &#125;
  &#125;
&#125;</code></pre>

<ul>
<li>引入到main.js注册</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> diretivesObj <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/directives&#x27;</span>

<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(diretivesObj)</code></pre>

<p>Vue.use相关文档: <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#Vue-use">https://cn.vuejs.org/v2/api/#Vue-use</a></p>
<p>Vue.use(obj)  其实就是注册，内部会调用install方法</p>
<p>自定义指令的inserted何时执行?</p>
<ul>
<li>当指令所在组件, 第一次插入到真实DOM被调用</li>
</ul>
<h2 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h2><p>在前端可以通过meta来设置referrer policy(来源策略)，referrer设置成<code>no-referrer</code>，发送请求不会带上referrer信息，对方服务器也就无法拦截了</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 解决图片403防盗链问题 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;referrer&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-referrer&quot;</span> /&gt;</span></code></pre>

<p>但是如果他们做了其他判断, 我们依旧拿不到此图片</p>
<h2 id="给组件加原生事件"><a href="#给组件加原生事件" class="headerlink" title="给组件加原生事件"></a>给组件加原生事件</h2><p>组件默认没有click事件的时候，如果想用click事件怎么办？利用navive</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article-item</span></span>
<span class="hljs-tag">              <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;obj in articleList&quot;</span></span>
<span class="hljs-tag">              <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;obj.art_id&quot;</span></span>
<span class="hljs-tag">              <span class="hljs-attr">:obj</span>=<span class="hljs-string">&quot;obj&quot;</span></span>
<span class="hljs-tag">              @<span class="hljs-attr">click.native</span>=<span class="hljs-string">&quot;$router.push(`/article_detail?aid=$&#123;obj.art_id&#125;`)&quot;</span></span>
<span class="hljs-tag">              <span class="hljs-attr">:showX</span>=<span class="hljs-string">&quot;false&quot;</span></span>
<span class="hljs-tag">              &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article-item</span>&gt;</span></code></pre>

<h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><p>通过.stop来阻止</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 反馈按钮 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">van-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cross&quot;</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;onCloseClick&quot;</span> /&gt;</span></code></pre>

<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>后面再找点资料详细看看</p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>利用 Set 和 Array.from实现</p>
<pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>)) <span class="hljs-comment">// 去重</span></code></pre>

<h2 id="文件上传-隐藏域"><a href="#文件上传-隐藏域" class="headerlink" title="文件上传-隐藏域"></a>文件上传-隐藏域</h2><p>当点击的是非 input[type&#x3D;’file’] 的时，不会弹出选择文件的框。此时可以设置一个隐藏的文件框，通过js来触发这个文件框的点击事件，从而实现文件上传。</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">van-cell</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;头像&quot;</span> <span class="hljs-attr">is-link</span> <span class="hljs-attr">center</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">van-image</span> <span class="hljs-attr">round</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;avatar&quot;</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;profile.photo&quot;</span> </span>
<span class="hljs-tag">                   &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">js</span>触发点击事件 <span class="hljs-attr">--</span>&gt;</span>
                   @click=&quot;$refs.iptFile.click()&quot;/&gt;
        <span class="hljs-comment">&lt;!-- file 选择框 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span>
<span class="hljs-tag">               <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span></span>
<span class="hljs-tag">               <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;iptFile&quot;</span></span>
<span class="hljs-tag">               <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;false&quot;</span></span>
<span class="hljs-tag">               <span class="hljs-attr">accept</span>=<span class="hljs-string">&quot;image/*&quot;</span></span>
<span class="hljs-tag">               @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;onFileChange&quot;</span></span>
<span class="hljs-tag">               /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">van-cell</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>
<span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span>
<span class="language-javascript">    <span class="hljs-comment">// 文件选择方法</span></span>
<span class="language-javascript">    <span class="hljs-keyword">async</span> onFileChange (ev) &#123;</span>
<span class="language-javascript">    <span class="hljs-comment">//   console.log(ev.target.files[0])</span></span>
<span class="language-javascript">      <span class="hljs-keyword">if</span> (ev.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// 防止用户未选择图片</span></span>
<span class="language-javascript">      <span class="hljs-keyword">const</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()</span>
<span class="language-javascript">      fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;photo&#x27;</span>, ev.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// photo在表单里参数名携带</span></span>
<span class="language-javascript">      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">updatePhotoAPI</span>(fd)</span>
<span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)</span>
<span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">profile</span>.<span class="hljs-property">photo</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">photo</span> <span class="hljs-comment">// 更新最新头像</span></span>
<span class="language-javascript">    &#125;</span>
<span class="language-javascript">  &#125;</span>
<span class="language-javascript">&#125;</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<p>接口</p>
<pre><code class="hljs js"><span class="hljs-comment">// 用户- 更新头像</span>
<span class="hljs-comment">// 注意: formObj的值必须是一个表单对象</span>
<span class="hljs-comment">// &#x27;&#123;&quot;a&quot;: 10, &quot;b&quot;: 20&#125;&#x27; // 对象格式的JSON字符串</span>
<span class="hljs-comment">// new FormData() // 表单对象</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">updatePhotoAPI</span> = (<span class="hljs-params">formObj</span>) =&gt; &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;
    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/v1_0/user/photo&#x27;</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PATCH&#x27;</span>,
    <span class="hljs-attr">data</span>: formObj
    <span class="hljs-comment">// 如果你的请求体内容是表单对象, 浏览器会自动携带请求头Content-Type为multipart/form-data</span>
  &#125;)
&#125;</code></pre>

<h2 id="api接口分文件"><a href="#api接口分文件" class="headerlink" title="api接口分文件"></a>api接口分文件</h2><ul>
<li>原因: 一个api&#x2F;index.js, 有几百行代码, 不便于管理</li>
<li>解决: 分散到多个js文件里, 再引入回到统一导出<ul>
<li>分散的js文件名, 尽量和页面模块同名, 方便查找</li>
</ul>
</li>
</ul>
<p>问题1: 分文件后, 逻辑页面里都是从api&#x2F;index.js导出的, 难道我们要去改逻辑代码?</p>
<p>解决: 在api&#x2F;index.js - 中  export * from ‘分散的文件’  (模块重定向)</p>
<p>意思: 在api&#x2F;index.js 作为入口, 从别的地方把接口倒回来同时导出给外面</p>
<blockquote>
<p>export 文档: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export</a></p>
</blockquote>
<p>注意; 包括reports.js文件也从统一出口导出, 去修改src&#x2F;components&#x2F;ArticleItem引数据位置</p>
<p>处理结果 api&#x2F;index.js如下</p>
<pre><code class="hljs js"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reports&#x27;</span> <span class="hljs-comment">// 反馈列表数据</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ArticleDetail&#x27;</span> <span class="hljs-comment">// 文章详情相关</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Home&#x27;</span> <span class="hljs-comment">// 首页(频道)相关, 首页文章列表</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Login&#x27;</span> <span class="hljs-comment">// 登录相关</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Search&#x27;</span> <span class="hljs-comment">// 搜索相关</span>
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./User&#x27;</span> / 用户相关</code></pre>

<h2 id="大整数问题处理"><a href="#大整数问题处理" class="headerlink" title="大整数问题处理"></a>大整数问题处理</h2><p>JS安全数字范围? 16位的一个数字，超过16位也能显示, 但是精度不准确</p>
<ol>
<li><p>定义后台返回数据, 模拟大数</p>
<blockquote>
<p>后台数据库id, 生成算法是19位置</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;[&#123;&quot;id&quot;: 1302900300041101987&#125;, &#123;&quot;id&quot;: 1205340366642205763&#125;, &#123;&quot;id&quot;: 7689021398237123422&#125;]&#x27;</span></code></pre>
</li>
<li><p>尝试用JSON.parse转换, 发现转换后的值不对</p>
<blockquote>
<p>后面3位精度错误</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str))</code></pre>
</li>
<li><p>原因: JS范围的安全数打印</p>
<pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>) <span class="hljs-comment">// 9007199254740991</span></code></pre>

<blockquote>
<p>详细原因可以看这里: <a target="_blank" rel="noopener" href="https://lidongxuwork.gitee.io/pages/webFront/javascript/run/0.1+0.2%E9%97%AE%E9%A2%98.html">https://lidongxuwork.gitee.io/pages/webFront/javascript/run/0.1+0.2%E9%97%AE%E9%A2%98.html</a></p>
</blockquote>
</li>
<li><p>解决方案, 可以引入第三方包叫json-bigint</p>
<blockquote>
<p>把大数转成字符串保存</p>
</blockquote>
<pre><code class="hljs js">npm i json-bigint

<span class="hljs-keyword">const</span> jsonBig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;json-bigint&#x27;</span>)(&#123; <span class="hljs-attr">storeAsString</span>: <span class="hljs-literal">true</span> &#125;)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonBig.<span class="hljs-title function_">parse</span>(str))</code></pre></li>
</ol>
<h2 id="持久化存储方式"><a href="#持久化存储方式" class="headerlink" title="持久化存储方式"></a>持久化存储方式</h2><p>封装本地持久化方法,方便后期统一管理。(无限套娃，哈哈，前面的axios也是这个套路)</p>
<ul>
<li>创建utils&#x2F;storage.js文件, 定义4个方法</li>
</ul>
<pre><code class="hljs js"><span class="hljs-comment">// 本地存储方式</span>
<span class="hljs-comment">// 如果同时有sessionStorage和localStorage, 可以封装2份</span>
<span class="hljs-comment">// 现在我只封装一种统一的方式</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">setStorage</span> = (<span class="hljs-params">key, value</span>) =&gt; &#123;
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, value)
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getStorage</span> = (<span class="hljs-params">key</span>) =&gt; &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">removeStorage</span> = (<span class="hljs-params">key</span>) =&gt; &#123;
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key)
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">clearStorage</span> = (<span class="hljs-params"></span>) =&gt; &#123;
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>()
&#125;</code></pre>

<ul>
<li><p>把所有使用本地存储的地方, 都统一换成这里定义的方法</p>
<ul>
<li>在store&#x2F;index.js - vuex中使用过</li>
<li>在search&#x2F;index.vue - 搜索页面使用过</li>
</ul>
</li>
</ul>
<h2 id="抽离组件注册"><a href="#抽离组件注册" class="headerlink" title="抽离组件注册"></a>抽离组件注册</h2><p>main.js代码有些多, 分散出去</p>
<ul>
<li>创建src&#x2F;VantRegister.js, 把Vant注册的相关代码复制过来</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NavBar</span>, <span class="hljs-title class_">Form</span>, <span class="hljs-title class_">Field</span>, <span class="hljs-title class_">Button</span>, <span class="hljs-title class_">Tabbar</span>, <span class="hljs-title class_">TabbarItem</span>, <span class="hljs-title class_">Icon</span>, <span class="hljs-title class_">Tab</span>, <span class="hljs-title class_">Tabs</span>, <span class="hljs-title class_">Cell</span>, <span class="hljs-title class_">List</span>, <span class="hljs-title class_">PullRefresh</span>, <span class="hljs-title class_">ActionSheet</span>, <span class="hljs-title class_">Popup</span>, <span class="hljs-title class_">Row</span>, <span class="hljs-title class_">Col</span>, <span class="hljs-title class_">Badge</span>, <span class="hljs-title class_">Search</span>, <span class="hljs-title class_">Divider</span>, <span class="hljs-title class_">Tag</span>, <span class="hljs-title class_">CellGroup</span>, <span class="hljs-title class_">Image</span>, <span class="hljs-title class_">Dialog</span>, <span class="hljs-title class_">DatetimePicker</span>, <span class="hljs-title class_">Loading</span>, <span class="hljs-title class_">Lazyload</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vant&#x27;</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Lazyload</span>)

<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Loading</span>)
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">DatetimePicker</span>)
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Dialog</span>)
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Image</span>)
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">CellGroup</span>)
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Tag</span>)
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Divider</span>)
<span class="hljs-comment">//....</span></code></pre>

<ul>
<li>在main.js引入一下, 让代码执行</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./VantRegister&#x27;</span></code></pre>

<h2 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h2><ul>
<li>防止组件频繁创建和销毁</li>
<li>防止网络请求重复无用执行</li>
</ul>
<p>组件缓存, 可以实现组件的状态保持。</p>
<p>结合 vue 内置的 <strong>keep-alive</strong> 组件，可以实现组件的状态保持。</p>
<p>官方文档地址：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#keep-alive">https://cn.vuejs.org/v2/api/#keep-alive</a></p>
<ol>
<li><p>在<strong>App.vue</strong>中的router-view外层套上一个keep-alive组件</p>
<ul>
<li>缓存的一级路由页面切换不被释放, 但是首页还是会重新请求数据</li>
</ul>
</li>
<li><p>在<strong>Layout.vue</strong>中的router-view外层套上一个keep-alive组件</p>
<ul>
<li>这次Home和User页面都被缓存了(二级路由也要管)</li>
</ul>
</li>
<li><p>但发现<strong>搜索页面</strong>和<strong>详情页面</strong>多被缓存起来了 (多次进入不同的文章, 发现都是同一个文章详情)</p>
</li>
<li><p>对router-view使用exclude属性来区别, 哪些页面组件可以缓存</p>
<blockquote>
<p>特别注意exclude里是组件的name名字(跟路由没什么关系)</p>
</blockquote>
<pre><code class="hljs vue">&lt;template&gt;
  &lt;div&gt;
    &lt;keep-alive :exclude=&quot;[&#x27;ArticleDetail&#x27;, &#x27;Login&#x27;, &#x27;Search&#x27;, &#x27;SearchResult&#x27;]&quot;&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/keep-alive&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre></li>
</ol>
<h2 id="头像不更新问题"><a href="#头像不更新问题" class="headerlink" title="头像不更新问题"></a>头像不更新问题</h2><p>User.vue被缓存了, 所以改了头像回到User页面, created里获取用户资料接口不会执行</p>
<ul>
<li><p>解决方案1: 把created换成activated钩子函数即可</p>
</li>
<li><p>解决方案2: UserEdit.vue修改头像成功后, 更新到vuex中, User页面使用的vuex数据也受到更新</p>
</li>
</ul>
<h2 id="登录未遂的处理"><a href="#登录未遂的处理" class="headerlink" title="登录未遂的处理"></a>登录未遂的处理</h2><ul>
<li><p>要点赞的时候, 401了, 强制跳转到登录页面了, 保存未遂地址跳转到登录页面</p>
<blockquote>
<p>要把tokens续签改掉, 否则不会跳转到登录页面</p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123; <span class="hljs-comment">// 身份过期</span>
    <span class="hljs-comment">// token续签方式1:  去登录页重新登录, token无用, 清掉-确保路由守卫if进不去</span>
    store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setToken&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(router.<span class="hljs-property">currentRoute</span>.<span class="hljs-property">fullPath</span>)
    <span class="hljs-comment">//重点1---》将未遂的路径传到登录页</span>
    router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/login?path=<span class="hljs-subst">$&#123;router.currentRoute.fullPath&#125;</span>`</span> &#125;)

    <span class="hljs-comment">// token续签方式2: refreshToken(用户无感知)</span>
    <span class="hljs-comment">// store.commit(&#x27;setToken&#x27;, &#x27;&#x27;)</span>
    <span class="hljs-comment">// const res = await refreshTokenAPI()</span>
    <span class="hljs-comment">// store.commit(&#x27;setToken&#x27;, res.data.data.token)</span>
    <span class="hljs-comment">// 再调用一次未完成的请求啊(用户无感知)</span>
    <span class="hljs-comment">// error.config 就是上一次axios请求的配置对象</span>
    <span class="hljs-comment">// console.dir(error.config)</span>
    <span class="hljs-comment">// 把新的token赋予到下一次axios请求的请求头中</span>
    <span class="hljs-comment">// error.config.headers.Authorization = &#x27;Bearer &#x27; + res.data.data.token</span>
    <span class="hljs-comment">// return到await的地方</span>
    <span class="hljs-comment">// return ajax(error.config)</span>
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)
&#125;</code></pre></li>
</ul>
<ol start="2">
<li><p>在Login&#x2F;index.vue, 登录后, 判断有未遂地址, 跳这里, 否则去&#x2F;路径</p>
<pre><code class="hljs js"><span class="hljs-comment">// 跳转到Layout页面</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(&#123;
    <span class="hljs-comment">//重点2 登录页进行判断 有未遂地址, 跳这里, 否则去/路径</span>
    <span class="hljs-attr">path</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">query</span>.<span class="hljs-property">path</span> || <span class="hljs-string">&#x27;/layout&#x27;</span>
&#125;)</code></pre></li>
</ol>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><blockquote>
<p>网页所在url的<strong>协议</strong>, <strong>域名</strong>, <strong>端口号</strong>, 和Ajax请求url的<strong>协议</strong>, <strong>域名</strong>, <strong>端口号</strong>有一个对应不上, 就发生跨域</p>
<p>跨域是浏览器对ajax做出的限制</p>
</blockquote>
<p>常见的跨域问题解决方式</p>
<h3 id="cors方式"><a href="#cors方式" class="headerlink" title="cors方式"></a>cors方式</h3><ul>
<li><p>前端什么也不用做</p>
</li>
<li><p>后端需要开启cors</p>
<blockquote>
<p>实际上就是在响应头添加允许跨域的源</p>
<p>Access-Control-Allow-Origin: 字段和值(意思就是允许去哪些源地址去请求这个服务器)</p>
</blockquote>
</li>
</ul>
<h3 id="jsonp方式"><a href="#jsonp方式" class="headerlink" title="jsonp方式"></a>jsonp方式</h3><ul>
<li><p>需要前端和后端同时支持</p>
<blockquote>
<p>前端用script+src属性, 发送函数名给后台, 同时准备好同名的函数, 准备接收数据</p>
<p>后端返回的字符串一定用方法名(数据字符串)格式返回, 到script标签中执行</p>
<p>调用函数名, 并传递数据</p>
</blockquote>
</li>
<li><p>例子代码(看看就行, 不用尝试)</p>
<pre><code class="hljs vue">&lt;script&gt;
  function callBackFn(data)&#123;
    // data就是&#x27;&#123;&quot;a&quot;: 10, &quot;b&quot;: 20&#125;&#x27;
  &#125;
&lt;/script&gt;
&lt;script src=&quot;http://后台接口地址?callback=callBackFn&quot;&gt;&lt;/script&gt;
&lt;!-- 后台接口返回 &#x27;callBackFn(&#123;&quot;a&quot;: 10, &quot;b&quot;: 20&#125;)&#x27; --&gt;</code></pre></li>
</ul>
<h3 id="代理转发"><a href="#代理转发" class="headerlink" title="代理转发"></a>代理转发</h3><p><strong>跨域是浏览器的限制</strong>，自己搭的服务器，开启cors后请求就不限制了。</p>
<ul>
<li><p>如果后端jsonp也不弄, cors也不弄, 就给你个接口地址</p>
<blockquote>
<p>我们可以在本地弄个服务器, 然后用服务器请求后台服务器接口地址</p>
</blockquote>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630174418046.png" alt="image-20220630174418046"></p>
</li>
<li><p>但是vuecli脚手架, 启动了一个webpack开发服务器, 它就能做代理转发</p>
<ul>
<li>而且前端和这个服务器是同源的都是8080端口</li>
</ul>
</li>
<li><p>需要修改webpack开发服务器的配置即可</p>
<blockquote>
<p>更多配置项参考这里: <a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/dev-server/#devserverproxy">https://webpack.docschina.org/configuration/dev-server/#devserverproxy</a></p>
</blockquote>
<pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;
    <span class="hljs-attr">proxy</span>: &#123;
      <span class="hljs-comment">// http://c.m.163.com/nc/article/headline/T1348647853363/0-40.html</span>
      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123; <span class="hljs-comment">// 请求相对路径以/api开头的, 才会走这里的配置</span>
        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://c.m.163.com&#x27;</span>, <span class="hljs-comment">// 后台接口域名</span>
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 改变请求来源(欺骗后台你的请求是从http://c.m.163.com)</span>
        <span class="hljs-attr">pathRewrite</span>: &#123;
          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 因为真实路径中并没有/api这段, 所以要去掉这段才能拼接正确地址转发请求</span>
        &#125;
      &#125;
    &#125;
  &#125;</code></pre>
</li>
<li><p>axios请求的代码</p>
<pre><code class="hljs js"><span class="hljs-title function_">axios</span>(&#123;
    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/api/nc/article/headline/T1348647853363/0-40.html&#x27;</span>
&#125;)</code></pre></li>
</ul>
<p>可以使用  <strong>http-server</strong> 这个node工具来搭建一个代理服务来解决跨域问题</p>
<pre><code class="hljs plaintext">第一步：  使用win +r 打开dos面板，全局安装 npm install -g http-server

第二步：  http-server 项目路径 -P 服务器地址</code></pre>

<h2 id="Hbuilder打包app"><a href="#Hbuilder打包app" class="headerlink" title="Hbuilder打包app"></a>Hbuilder打包app</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>为何要打包APP</li>
<li>APP分为哪几种类型</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>App有三大类型</p>
<ul>
<li><p>原生的App。手机有两大操作系统：苹果，安卓</p>
<blockquote>
<p>还有 windows Phone, 鸿蒙</p>
</blockquote>
<p>ios,安卓程序员 用各自的编程语言写的代码，只能在某一个平台上运行。分安卓版本和ios版本。</p>
<ul>
<li>优点：用户体验好 ；可以调用系统API（拍照，读内存…）。</li>
<li>缺点：费钱。(大公司一般会雇佣4端程序员)</li>
</ul>
</li>
<li><p>纯h5网站。就是一个移动站（<a target="_blank" rel="noopener" href="https://m.jd.com/%EF%BC%89">https://m.jd.com/）</a></p>
<ul>
<li>优点：省钱。就是网页。</li>
<li>缺点：不能调用系统API；没有统一的入口，用户不知道从哪里进来，都要通过浏览器才能访问；</li>
</ul>
</li>
<li><p>混合开发。</p>
<ul>
<li>先做一个网站，在网站之外套个原生的壳！能同时具备原生的优点和纯h5网站的优点。</li>
<li><strong>在原生的App嵌入h5 页</strong></li>
</ul>
</li>
</ul>
<h3 id="HBuilder开发版"><a href="#HBuilder开发版" class="headerlink" title="HBuilder开发版"></a>HBuilder开发版</h3><p>我们需要借助他, 帮助我们打包一个App</p>
<p>下载安装, 注册激活， 如果不注册激活，就不能使用它的打包功能</p>
<p>下载地址: <a target="_blank" rel="noopener" href="https://www.dcloud.io/hbuilderx.html">https://www.dcloud.io/hbuilderx.html</a>  (下载App开发版)</p>
<blockquote>
<p>先走流程, 提示你注册再注册和激活就行了</p>
</blockquote>
<p>&#x3D;&#x3D;必须注册&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;必须激活邮箱&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;必须绑定手机号&#x3D;&#x3D;</p>
<h3 id="创建5-App项目"><a href="#创建5-App项目" class="headerlink" title="创建5+App项目"></a>创建5+App项目</h3><p>我们要选择5+App 项目,mui也是一套前端框架，可以选择一个mui项目。</p>
<ul>
<li>普通项目。 普通H5项目, Hbuilder内置了几套模板,作用不大,同学们基本都会自己创建</li>
<li>uni-app。多端应用,一套代码,复用八端,时下最火的一个跨端框架</li>
<li>wap2App。wap项目转 App , 原来只运在手机上的wap(无线网络协议,诺基亚,爱立信时代)项目 可转app项目</li>
<li><strong>5+ App</strong>。利用DCloud 的 **<code>5+ Runtime</code>**来做原生能力提供者的 项目</li>
<li>小程序。微信原生小程序的另外一个编辑器,比微信提供的开发者工具好用,但是现在谁还在用原生写小程序呢?</li>
<li>快应用 。原生快应用编辑器 , 较为冷门的生态, 目前不太热闹</li>
</ul>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630175509578.png" alt="image-20220630175509578"></p>
<h3 id="准备打包"><a href="#准备打包" class="headerlink" title="准备打包"></a>准备打包</h3><ol>
<li><p>把我们vue项目打包好的dist下的一切复制到你刚才的项目-覆盖过来即可 (一定要保留manifest.json文件)</p>
<blockquote>
<p>mainfest.json是打包配置文件</p>
</blockquote>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630175552604.png" alt="image-20220630175552604"></p>
</li>
<li><p>生成APPID</p>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630175610718.png" alt="image-20220630175610718"></p>
</li>
<li><p>去掉通信录权限 (因为我的HBuilder没有身份证认证, 打包不让获取用户通讯录)</p>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630175632784.png" alt="image-20220630175632784"></p>
</li>
<li><p>(可选), 如果上面不小心选择No了, 可以去源码处选择 - 删除</p>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630175650163.png" alt="image-20220630175650163"></p>
</li>
</ol>
<h3 id="云打包"><a href="#云打包" class="headerlink" title="云打包"></a>云打包</h3><p><img src="/2022/06/30/1542451686885429248/images/image-20210407171554818.png" alt="image-20210407171554818"></p>
<p>如果一切正常，你将会在控制台中看到类似如下的结果：</p>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630175836488.png" alt="image-20220630175836488"></p>
<p>这就是云打包成功了, 下面会出现apk下载的所在文件夹</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>把打包好的apk包, 发到安卓手机上 &#x2F; 电脑模拟器(推荐&lt;夜神模拟器&gt;) 运行即可</p>
<p><img src="/2022/06/30/1542451686885429248/images/image-20220630175858730.png" alt="image-20220630175858730"></p>
<h3 id="iOS问题"><a href="#iOS问题" class="headerlink" title="iOS问题"></a>iOS问题</h3><p>打包ios - 需要申请开发者账号(一年600元人民币): 以后打包的过程参考这个: <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34440345/article/details/99711586">https://blog.csdn.net/qq_34440345/article/details/99711586</a></p>
<p>也可以手机给电脑开热点 &#x2F; 只要连接在同一个wifi下, 手机浏览器访问webpack开发服务器局域网ip地址即可</p>
<h2 id="李老师经验分享"><a href="#李老师经验分享" class="headerlink" title="李老师经验分享"></a>李老师经验分享</h2><p>&#x2F;&#x2F; 写任何需求:<br>&#x2F;&#x2F; 章法<br>&#x2F;&#x2F; 1. html+css(标签和样式搞定)<br>&#x2F;&#x2F; 2. 铺设数据(调整内容, 可能调用接口拿到数据)<br>&#x2F;&#x2F; 3. JS(交互&#x2F;校验….效果), 前端拿到要传递给后台的值<br>&#x2F;&#x2F; 4. 与后台交互(调用后台接口, 回显返回数据提示等)</p>
<p>&#x2F;&#x2F; 技巧1:<br>&#x2F;&#x2F; 看到变量, 能马上反应过来这个变量里装的什么<br>&#x2F;&#x2F; 每个方法含义, 要什么参数, 返回值有无, 返回值什么意思, 都要马上反应过来<br>&#x2F;&#x2F; 每行代码的意思, 为何这么写, 先模仿老师的思路, 锻炼, 多了经验以后就能自己写了<br>&#x2F;&#x2F; 以上就多读代码多写代码多讨论积累经验</p>
<p>&#x2F;&#x2F; 技巧2:<br>&#x2F;&#x2F; 前端变量名可以直接跟后端 要求的参数名一致, 这样调用接口就不用再分开写了<br>&#x2F;&#x2F; 前端变量名, 如果装对象, 用obj结尾<br>&#x2F;&#x2F; 前端变量名, 如果装数组, 用arr或者list结尾<br>&#x2F;&#x2F; 前端变量名, 如果装字符串, 用str结尾<br>&#x2F;&#x2F; 这样看到变量能马上反应过来里面装的什么</p>
<p>&#x2F;&#x2F; 技巧3:<br>&#x2F;&#x2F; 统一判断http状态码, axios的”响应”拦截器<br>&#x2F;&#x2F; axios的”请求”拦截器, 统一给请求配置对象中加入统一的东西<br>&#x2F;&#x2F; 例如: 所有的请求都带上请求头字段Authorization和token值</p>
<p>&#x2F;&#x2F; 技巧4:<br>&#x2F;&#x2F; 所有状态一起变的, 一个变量控制所有人<br>&#x2F;&#x2F; 每行状态”独立”改变的, 每行对应”对象”里的属性(obj.visible&#x2F;其他属性), 显示隐藏的状态(2种值切换)</p>
<p>&#x2F;&#x2F; 技巧5:<br>&#x2F;&#x2F; 路由到底是几级的<br>&#x2F;&#x2F; 不要光看路径的个数<br>&#x2F;&#x2F; 实际:<br>&#x2F;&#x2F; 在路由规则数组里的层级</p>
<p>&#x2F;&#x2F; 技巧6: 什么时候需要提升功能封装<br>&#x2F;&#x2F; (1): 多个页面使用的相同功能<br>&#x2F;&#x2F; (2): 以后可能要扩展和修改的</p>
<p>&#x2F;&#x2F; 跨域问题:<br>&#x2F;&#x2F; 开发过程:<br>&#x2F;&#x2F; 1. 直接让后台开启cors&#x2F;jsonp, 直接调用(如果用jsonp你要注意你传参的格式)<br>&#x2F;&#x2F; 2. 后台不开cors&#x2F;jsonp, webpack开发服务器, vue.config.js - 代理转发<br>&#x2F;&#x2F; 3. 后台不开cors&#x2F;jsonp, 自己本地node+express搭建服务器(开cors) - 前端请求本地localhost:4005, 本地的请求转发代码(nodejs代码)</p>
<p>&#x2F;&#x2F; 打包上线:<br>&#x2F;&#x2F; 1. 后台开启cors, 直接用<br>&#x2F;&#x2F; 2. 后台不开cors&#x2F;jsonp, 把前端项目和后台项目放在一个服务器上(同源)<br>&#x2F;&#x2F; 3. 后台代码和前端代码不在一起, 本地自己写一个node+express服务器部署(请求自己的)</p>

				</div>
		</div>
	</div>
	</div>
	
	<ul class="layui-fixbar"><a id="toTopBtn" href="javascript:void(0)"><li class="layui-icon layui-fixbar-top" lay-type="top" style="display: list-item;"></li></a></ul>
	
	<!-- 底部版权 -->
	<div class="qy-footer">
    <div class="font-Area">
        Copyright © 2018~2022 Heliufang All Rights Reserved
    </div>
</div>

<script>
    //随机背景线条 https://blog.csdn.net/qq526362801/article/details/108863458
    function DynamicLine() {
        function n(n, e, t) {
            return n.getAttribute(e) || t
        }

        function e(n) {
            return document.getElementsByTagName(n)
        }

        function t() {
            var t = e("script"),
                o = t.length,
                i = t[o - 1];
            return {
                l: o,
                z: n(i, "zIndex", -1),
                o: n(i, "opacity", .5),
                c: n(i, "color", "0,0,50"), //颜色rgb
                n: n(i, "count", 99)
            }
        }

        function o() {
            a = m.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
                c = m.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
        }

        function i() {
            r.clearRect(0, 0, a, c);
            var n, e, t, o, m, l;
            s.forEach(function (i, x) {
                for (i.x += i.xa, i.y += i.ya, i.xa *= i.x > a || i.x < 0 ? -1 : 1, i.ya *= i.y > c || i.y < 0 ? -1 : 1, r.fillRect(
                    i.x - .5, i.y - .5, 1, 1), e = x + 1; e < u.length; e++) n = u[e],
                        null !== n.x && null !== n.y && (o = i.x - n.x, m = i.y - n.y,
                            l = o * o + m * m, l < n.max && (n === y && l >= n.max / 2 && (i.x -= .03 * o, i.y -= .03 * m),
                                t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t / 2, r.strokeStyle = "rgba(" + d.c + "," + (t + .2) +
                                ")", r.moveTo(i.x, i.y), r.lineTo(n.x, n.y), r.stroke()))
            }),
                x(i)
        }
        var a, c, u, m = document.createElement("canvas"),
            d = t(),
            l = "c_n" + d.l,
            r = m.getContext("2d"),
            x = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window
                .oRequestAnimationFrame || window.msRequestAnimationFrame ||
                function (n) {
                    window.setTimeout(n, 1e3 / 45)
                },
            w = Math.random,
            y = {
                x: null,
                y: null,
                max: 2e4
            };
        m.id = l, m.style.cssText = "position:fixed;top:0;left:0;z-index:" + d.z + ";opacity:" + d.o, e("body")[0].appendChild(
            m), o(), window.onresize = o,
            window.onmousemove = function (n) {
                n = n || window.event, y.x = n.clientX, y.y = n.clientY
            },
            window.onmouseout = function () {
                y.x = null, y.y = null
            };
        for (var s = [], f = 0; d.n > f; f++) {
            var h = w() * a,
                g = w() * c,
                v = 2 * w() - 1,
                p = 2 * w() - 1;
            s.push({
                x: h,
                y: g,
                xa: v,
                ya: p,
                max: 6e3
            })
        }
        u = s.concat([y]),
            setTimeout(function () {
                i()
            }, 100)
    }
    DynamicLine()
</script>
</body>
<script src="../../../../../js/jquery.min.js"></script>
<script src="../../../../../layui/layui.js"></script>
<script src="../../../../../js/clipboard.min.js"></script>
<script src="../../../../../js/clipboard-use.js"></script>

<script src="../js/mouse.js"></script>

<!-- 谷歌代码高亮 -->
<script type="text/javascript" src="../../../../../lib/google-code-prettify/run_prettify.js"></script>
<script>
	//注意：导航 依赖 element 模块，否则无法进行功能性操作
	var element = null
	var layer = null
	layui.use(['element','layer'], function(){
	  element = layui.element;
	  layer = layui.layer
	});
	
	$(function() { 
	    var elm = $('#toc-area'); 
	    var startPos = $(elm).offset().top; 
		var totalTop = $(document).height(); 
	    $.event.add(window, "scroll", function() { 
	        var p = $(window).scrollTop(); 
			//文章阅读进度条
			var percent = ((p/totalTop)*100).toFixed(2)
			if(percent > 100){
				percent = 100
			}
			if(percent == 0){
				percent = 0
			}
			element.progress('demo', percent+"%");
			$("#progressTxt").text(percent)
			//固定文章目录
	        $(elm).css('position',((p) > startPos) ? 'fixed' : 'static'); 
	        $(elm).css('top',((p) > startPos) ? '60px' : ''); 
	    }); 
		//谷歌代码高亮
		$('pre').addClass('prettyprint').attr('style', 'overflow:auto;');

		let timer = null;
		//点击回到顶部
		//增加scrollTop的动画效果,使用定时器，将scrollTop的值每次减少50(减少六十分之一)，直到减少到0，则动画完毕
		$("#toTopBtn").click(function(){
			var oTop = document.body.scrollTop || document.documentElement.scrollTop;
			var t = parseInt(oTop / 60) //每次六十分之一
			var time = setInterval(function () {
				// document.body.scrollTop = document.body.scrollTop - 50;
				document.body.scrollTop = document.body.scrollTop - t;
				if (document.body.scrollTop === 0) {
					clearInterval(time);
				}
			}, 1);
		})

		
	});
	
</script>
</html>