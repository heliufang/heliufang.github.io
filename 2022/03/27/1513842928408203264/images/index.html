<html>

<head>
	<title>贺刘芳的搬砖日记</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="stylesheet" href="../../../../../layui/css/layui.css" />
	<link rel="stylesheet" href="../../../../../css/common.css" />
	<link rel="stylesheet" href="../../../../../css/post.css" />
	<!-- 代码高亮 -->
	<link rel="stylesheet" href="../../../../../lib/prism/prism.css" />
	<link rel="shortcut icon" href="../../../../../img/favicon.ico">
<meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="贺刘芳的搬砖日记" type="application/atom+xml">
</head>

<body data-prismjs-copy="复制" data-prismjs-copy-success="复制成功!">
	<!-- 导航模板 -->
	<!-- 导航 -->
<div class="qy-nav">
  <ul class="layui-nav" lay-filter="" lay-bar="disabled" lay-unselect>
    <li class="layui-nav-item">贺刘芳的搬砖日记</li>
    <li class="hide-xs layui-nav-item "><a href="/"><i class="layui-icon layui-icon-chart-screen"></i> 首页</a></li>
    <li class="hide-xs layui-nav-item "><a href="/about"><i class="layui-icon layui-icon-friends"></i> 关于</a></li>
    <li class="hide-xs layui-nav-item " id="searchBtn"><a href="javascript:void(0);"><i
          class="layui-icon layui-icon-search"></i> 搜索</a></li>
    <li id="mobileMenu" style="float: right" class="hide-sm hide-md hide-lg layui-nav-item ">
      <a href="javascript:void(0);"><i class="layui-icon layui-icon-down"></i> 菜单</a>
    </li>
  </ul>
</div>
<!-- 搜索弹框 -->
<div id="searchShade" class="searchShade">
  <div id="searchLayer">
    <div id="closeBtn" class="close"><i class="layui-icon layui-icon-close"></i></div>
    <input id="searchTxt" type="text" placeholder="搜索文章(只支持文章标题关键字)" />
    <div id="searchResult">
      <!-- <ul>
        <li>java笔记
        <li>
      </ul> -->
    </div>

  </div>
</div>
<script>
  window.onload = function () {
    //下拉菜单
    layui.use('dropdown', function () {
      var dropdown = layui.dropdown
      dropdown.render({
        elem: '#mobileMenu', //可绑定在任意元素中，此处以上述按钮为例
        data: [
          {
            title: '首页'
            , id: 11
            , href: '/'
            // , templet: '<i class="layui-icon layui-icon-chart-screen"></i>  {{d.title}}'
          },
          {
            title: '关于'
            , id: 22
            , href: '/about'
            // , templet: '<i class="layui-icon layui-icon-chart-friends"></i>  {{d.title}}'
          },
          {
            title: '搜索'
            , id: 33
            , href: '#'
            // , templet: '<i class="layui-icon layui-icon-chart-search"></i>  {{d.title}}'
          }
        ],
        click: function (data, othis) {
          var elem = $(this.elem)
            , listId = elem.data('id'); //表格列表的预埋数据
            if(data.id == 33){
              $("#searchShade").show()
            }
        }
      })

    })

    //点击搜索
    $("#searchBtn").click(function () {
      $("#searchShade").show()
    })

    //关闭弹框
    $("#closeBtn").click(function () {
      $("#searchShade").hide()
    })

    //搜索本地文章标题 https://cloud.tencent.com/developer/article/1624646
    var searchFunc = function (path, search_id, content_id) {
      $.ajax({
        url: path,
        dataType: "json",
        success: function (datas) {
          // console.log('datas :>> ', datas);
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function () {
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var data_title = data.title.trim().toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var first_occur = -1;
              if (data_title != '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  if (index_title < 0) {
                    isMatch = false;
                  }else{
                    data_title = data_title.replace(new RegExp(keyword,'g'),'<span style="color:red">'+keyword+'</span>')
                  }
                });
              }
              // show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                str += "</li>";
              }
            });
            str += "</ul>";
            $resultContent.innerHTML = str;
          });
        }
      });
    }
    searchFunc("/" + "search.json", 'searchTxt', 'searchResult');

  }


</script>
		<!-- 中间内容区域 -->
		<div class="layui-container  center" id="top">
			<div class="layui-row layui-col-space20">
				<div class="layui-col-md3 hide-xs hide-sm">
					<!-- 左侧的公告、分类、归档、标签 -->
					<!-- 左侧的公告、分类、归档、标签 -->

<!-- 个人信息 -->
<div class="layui-card">
    <div class="layui-card-header"><i style="font-weight: bold;" class="layui-icon layui-icon-speaker"></i> 公告</div>
    <div class="layui-card-body">
        <div class="userinfo">
            <img src="/head.png">
            <div class="name">淡泊明志，宁静致远</div>
            <div class="other">
                <div class="item">
                    <p class="num">
                        40
                    </p>
                    <p class="title">文章</p>
                </div>
                <div class="item">
                    <p class="num">
                        8
                    </p>
                    <p class="title">分类</p>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- 分类 -->
<div class="layui-card">
    <div class="layui-card-header"><i class="layui-icon layui-icon-template-1"></i> 分类</div>
    <div class="layui-card-body">
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/java/">java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/vue/">vue</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/web%E5%89%8D%E7%AB%AF/">web前端</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F/">公众号和小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%85%B6%E5%AE%83%E6%8A%80%E6%9C%AF/">其它技术</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li></ul>
    </div>
</div>
<!-- 归档 -->
<div class="layui-card">
    <div class="layui-card-header"><i style="font-weight: bold;" class="layui-icon layui-icon-date"></i> 归档</div>
    <div class="layui-card-body">
        <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/12/">2022 十二月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/10/">2022 十月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/07/">2022 七月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/06/">2022 六月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2022/03/">2022 三月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/08/">2021 八月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/07/">2021 七月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/05/">2021 五月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2021/01/">2021 一月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/12/">2020 十二月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/11/">2020 十一月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/08/">2020 八月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2020/06/">2020 六月</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2019/10/">2019 十月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2019/07/">2019 七月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2018/12/">2018 十二月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../../archives/2018/10/">2018 十月</a><span class="archive-list-count">1</span></li></ul>
    </div>
</div>
<!-- 标签 -->
<div class="layui-card">
    <div class="layui-card-header"><i style="font-weight: bold;" class="layui-icon layui-icon-note"></i> 标签</div>
    <div class="layui-card-body">
        
            
                <a class="tag-a" href="/tags/vscode/">vscode(1)</a>
                
                <a class="tag-a" href="/tags/重绘回流/">重绘回流(1)</a>
                
                <a class="tag-a" href="/tags/web性能优化/">web性能优化(1)</a>
                
                <a class="tag-a" href="/tags/swiper/">swiper(1)</a>
                
                <a class="tag-a" href="/tags/轮播图/">轮播图(1)</a>
                
                <a class="tag-a" href="/tags/css/">css(3)</a>
                
                <a class="tag-a" href="/tags/rem/">rem(1)</a>
                
                <a class="tag-a" href="/tags/MongoDB/">MongoDB(1)</a>
                
                <a class="tag-a" href="/tags/数据库/">数据库(2)</a>
                
                <a class="tag-a" href="/tags/art-template/">art-template(1)</a>
                
                <a class="tag-a" href="/tags/js模板引擎/">js模板引擎(1)</a>
                
                <a class="tag-a" href="/tags/gitee/">gitee(1)</a>
                
                <a class="tag-a" href="/tags/Hexo/">Hexo(1)</a>
                
                <a class="tag-a" href="/tags/响应式/">响应式(1)</a>
                
                <a class="tag-a" href="/tags/媒体查询/">媒体查询(1)</a>
                
                <a class="tag-a" href="/tags/swing/">swing(1)</a>
                
                <a class="tag-a" href="/tags/JTable/">JTable(1)</a>
                
                <a class="tag-a" href="/tags/java/">java(4)</a>
                
                <a class="tag-a" href="/tags/pdf/">pdf(1)</a>
                
                <a class="tag-a" href="/tags/markdown/">markdown(1)</a>
                
                <a class="tag-a" href="/tags/bootstrap-table/">bootstrap-table(1)</a>
                
                <a class="tag-a" href="/tags/bootstrap/">bootstrap(1)</a>
                
                <a class="tag-a" href="/tags/linux/">linux(1)</a>
                
                <a class="tag-a" href="/tags/ftp/">ftp(1)</a>
                
                <a class="tag-a" href="/tags/微信公众号/">微信公众号(1)</a>
                
                <a class="tag-a" href="/tags/jar/">jar(1)</a>
                
                <a class="tag-a" href="/tags/windows/">windows(1)</a>
                
                <a class="tag-a" href="/tags/vue/">vue(6)</a>
                
                <a class="tag-a" href="/tags/vue-router/">vue-router(2)</a>
                
                <a class="tag-a" href="/tags/RabbitMQ/">RabbitMQ(1)</a>
                
                <a class="tag-a" href="/tags/sublime/">sublime(1)</a>
                
                <a class="tag-a" href="/tags/springcloud/">springcloud(1)</a>
                
                <a class="tag-a" href="/tags/uniapp/">uniapp(1)</a>
                
                <a class="tag-a" href="/tags/mysql/">mysql(1)</a>
                
                <a class="tag-a" href="/tags/es6/">es6(1)</a>
                
                <a class="tag-a" href="/tags/js/">js(3)</a>
                
                <a class="tag-a" href="/tags/移动端/">移动端(1)</a>
                
                <a class="tag-a" href="/tags/less/">less(1)</a>
                
                <a class="tag-a" href="/tags/html/">html(2)</a>
                
                <a class="tag-a" href="/tags/vuex/">vuex(1)</a>
                
                <a class="tag-a" href="/tags/typescript/">typescript(1)</a>
                
                <a class="tag-a" href="/tags/node/">node(1)</a>
                
                <a class="tag-a" href="/tags/eclipse/">eclipse(1)</a>
                
                <a class="tag-a" href="/tags/react/">react(1)</a>
                
    </div>
</div>
						<!-- 文章目录 -->
						
							<div style="height: 90%;width: 267px;" id="toc-area" class="layui-card">
								<div class="layui-card-header"><i class="layui-icon layui-icon-form"></i> 本文目录</div>
								<div id="tocMain" class="layui-card-body"
									style="overflow:auto;height: calc(100% - 60px - 50px);">
									<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#springcloud%E5%A4%A7%E7%BA%B2"><span class="toc-text">springcloud大纲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9"><span class="toc-text">版本选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cloud%E5%90%84%E7%A7%8D%E7%BB%84%E4%BB%B6%E7%9A%84%E5%81%9C%E6%9B%B4-x2F-%E6%9B%BF%E6%8D%A2"><span class="toc-text">cloud各种组件的停更&#x2F;替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%89%8D"><span class="toc-text">以前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8"><span class="toc-text">现在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cloud%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3"><span class="toc-text">cloud的相关文档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A0%81-%E6%9E%84%E5%BB%BA"><span class="toc-text">微服务架构编码 构建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IDEA%E6%96%B0%E5%BB%BAproject%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4"><span class="toc-text">IDEA新建project工作空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E9%83%A8%E7%BD%B2%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">热部署的配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rest%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B7%A5%E7%A8%8B%E6%90%AD%E5%BB%BA"><span class="toc-text">Rest微服务工程搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-api-commons"><span class="toc-text">cloud-api-commons</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-provider-payment8001"><span class="toc-text">cloud-provider-payment8001</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-consumer-order80"><span class="toc-text">cloud-consumer-order80</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Eruka"><span class="toc-text">Eruka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Eruka%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">Eruka的基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%8D%95%E6%9C%BAEureka"><span class="toc-text">构建单机Eureka</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-eureka-server7001"><span class="toc-text">cloud-eureka-server7001</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-provider-payment8001-1"><span class="toc-text">cloud-provider-payment8001</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-consumer-order80-1"><span class="toc-text">cloud-consumer-order80</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BAEureka%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9B%86%E7%BE%A4"><span class="toc-text">构建Eureka服务端集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-eureka-server7002"><span class="toc-text">cloud-eureka-server7002</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-provider-payment8001-2"><span class="toc-text">cloud-provider-payment8001</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-consumer-order80-2"><span class="toc-text">cloud-consumer-order80</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BAEureka%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9B%86%E7%BE%A4"><span class="toc-text">构建Eureka客户端集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-provider-payment8002"><span class="toc-text">cloud-provider-payment8002</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B98001%E5%92%8C8002%E7%9A%84controller"><span class="toc-text">修改8001和8002的controller</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">负载均衡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#actuator%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%AE%8C%E5%96%84"><span class="toc-text">actuator微服务信息完善</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%A7%B0-%E6%9C%8D%E5%8A%A1%E5%90%8D%E7%A7%B0%E4%BF%AE%E6%94%B9"><span class="toc-text">主机名称:服务名称修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF%E6%9C%89IP%E4%BF%A1%E6%81%AF%E6%8F%90%E7%A4%BA"><span class="toc-text">访问信息有IP信息提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0Discovery"><span class="toc-text">服务发现Discovery</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cloud-provider-payment8001-3"><span class="toc-text">cloud-provider-payment8001</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4"><span class="toc-text">eureka自我保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4"><span class="toc-text">禁用自我保护</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83eurekaServer%E7%AB%AF7001"><span class="toc-text">注册中心eurekaServer端7001</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%AE%A2%E6%88%B7%E7%AB%AFeurekaClient%E7%AB%AF8001"><span class="toc-text">生产者客户端eurekaClient端8001</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="toc-text">Zookeeper服务注册与发现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="toc-text">Consul服务注册与发现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#consul%E7%AE%80%E4%BB%8B"><span class="toc-text">consul简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consul%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">consul的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consul%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="toc-text">consul的启动和访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85"><span class="toc-text">服务提供者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">服务消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%BC%82%E5%90%8C%E7%82%B9"><span class="toc-text">三个注册中心异同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP"><span class="toc-text">CAP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AP-eureka"><span class="toc-text">AP(eureka)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CP-Zookeeper-x2F-Consul"><span class="toc-text">CP(Zookeeper&#x2F;Consul)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="toc-text">Ribbon负载均衡服务调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%BC%94%E7%A4%BA"><span class="toc-text">Ribbon负载均衡演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ribbon%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6IRule"><span class="toc-text">Ribbon核心组件IRule</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E8%BD%AE%E8%AF%A2%E8%B0%83%E7%94%A8%E6%94%B9%E4%B8%BA%E9%9A%8F%E6%9C%BA%E8%B0%83%E7%94%A8"><span class="toc-text">将轮询调用改为随机调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="toc-text">Ribbon负载均衡算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenFeign%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8"><span class="toc-text">OpenFeign服务接口调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenFeign%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-text">OpenFeign使用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenFeign%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="toc-text">OpenFeign超时控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenFeign%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD"><span class="toc-text">OpenFeign日志打印功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hystrix%E6%96%AD%E8%B7%AF%E5%99%A8"><span class="toc-text">Hystrix断路器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hystrix%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-text">Hystrix重要概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hystrix%E6%A1%88%E4%BE%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">hystrix案例基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97"><span class="toc-text">构建基础模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95"><span class="toc-text">高并发测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E7%8E%B0%E8%B1%A1%E5%92%8C%E5%AF%BC%E8%87%B4%E5%8E%9F%E5%9B%A0"><span class="toc-text">故障现象和导致原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E8%AF%89%E7%BB%93%E8%AE%BA"><span class="toc-text">上诉结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E8%A7%A3%E5%86%B3%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-text">如何解决？解决的要求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-text">服务降级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%86%A8%E8%83%80%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">代码膨胀问题解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%80%A6%E5%90%88%E5%BA%A6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">代码耦合度的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="toc-text">服务熔断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-x2F-%E6%80%BB%E7%BB%93"><span class="toc-text">原理&#x2F;总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81"><span class="toc-text">服务限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hystrix%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">hystrix工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7hystrixDashboard"><span class="toc-text">服务监控hystrixDashboard</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gateway%E6%96%B0%E4%B8%80%E4%BB%A3%E7%BD%91%E5%85%B3"><span class="toc-text">Gateway新一代网关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GateWay%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">GateWay的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GateWay%E4%B8%8Ezuul%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">GateWay与zuul的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zuul1-x%E6%A8%A1%E5%9E%8B"><span class="toc-text">Zuul1.x模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GateWay%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">GateWay三大核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gateway%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">Gateway工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">入门配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%8D%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-text">通过微服务名实现动态路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicate%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Predicate的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Filter%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Filter的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Cloud-Gateway%E7%9A%84Filter"><span class="toc-text">Spring Cloud Gateway的Filter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-text">Config分布式配置中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">创建配置中心服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">读取配置文件的规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">创建配置中心客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Config%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0"><span class="toc-text">Config客户端之动态刷新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bus-%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF"><span class="toc-text">Bus 消息总线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">RabbitMQ环境配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E4%B9%8B%E5%85%A8%E5%B1%80%E5%B9%BF%E6%92%AD"><span class="toc-text">动态刷新之全局广播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E4%B9%8B%E5%AE%9A%E7%82%B9%E9%80%9A%E7%9F%A5"><span class="toc-text">动态刷新之定点通知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8"><span class="toc-text">Stream消息驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sleuth%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA"><span class="toc-text">Sleuth分布式请求链路追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7"><span class="toc-text">搭建链路监控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85zipkin"><span class="toc-text">安装zipkin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8sleuth"><span class="toc-text">使用sleuth</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Cloud-Alibaba%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B"><span class="toc-text">Spring Cloud Alibaba入门简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-text">Nacos服务注册和配置中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8CNacos"><span class="toc-text">安装运行Nacos</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-text">Nacos作为注册中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-text">Nacos作为服务配置中心</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE"><span class="toc-text">基础配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E9%85%8D%E7%BD%AE"><span class="toc-text">分类配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos%E9%9B%86%E7%BE%A4%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-text">Nacos集群和持久化配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E6%8D%A2mysql%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">切换mysql数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E7%89%88Nacos-MySQL%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">Linux版Nacos+MySQL生产环境配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sentinel"><span class="toc-text">Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel%E5%AE%89%E8%A3%85"><span class="toc-text">sentinel安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%BC%94%E7%A4%BA%E5%B7%A5%E7%A8%8B"><span class="toc-text">初始化演示工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99"><span class="toc-text">流控规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7%E8%A7%84%E5%88%99"><span class="toc-text">降级规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E7%82%B9key%E9%99%90%E6%B5%81"><span class="toc-text">热点key限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99-%E4%B8%8D%E6%8E%A8%E8%8D%90-%E5%A4%AA%E6%9A%B4%E5%8A%9B%E4%BA%86"><span class="toc-text">系统规则(不推荐,太暴力了)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SentinelResource%E6%B3%A8%E8%A7%A3"><span class="toc-text">SentinelResource注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E5%8A%9F%E8%83%BD"><span class="toc-text">服务熔断功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ribbon%E7%B3%BB%E5%88%97"><span class="toc-text">Ribbon系列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Feign%E7%B3%BB%E5%88%97"><span class="toc-text">Feign系列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E8%A7%84%E5%88%99"><span class="toc-text">持久化规则</span></a></li></ol></li></ol>
								</div>
								<div class="readprocess">
									<div><i class="layui-icon layui-icon-read"></i> 已阅读：<span id="progressTxt"></span>%
									</div>
									<div class="layui-progress" lay-filter="demo">
										<div class="layui-progress-bar" lay-percent="10%"></div>
									</div>
								</div>
							</div>
							
				</div>
				<div class="layui-col-md9 markdown-body" style="background:#fff;margin-top: 10px;">
					
						<div class="article-title">
							<h1 style="margin-top: 0;">SpringCloud学习笔记</h1>
							<p>
								<i class="layui-icon layui-icon-date"></i>发表时间 2022-03-27
									|
									<i class="layui-icon layui-icon-form"></i>累计字数 24.6k
							</p>
						</div>
						

							<!-- 文章内容 -->
							<div id="article">
								<p>本笔记是根据尚硅谷周阳老师的springcloud视频教程整理</p>
<p>B站视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18E411x7eT?p=1">尚硅谷SpringCloud框架开发教程</a></p>
<h2 id="springcloud大纲"><a href="#springcloud大纲" class="headerlink" title="springcloud大纲"></a>springcloud大纲</h2><p>学习大纲如下图</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319111107904.png" alt="image-20220319111107904"></p>
<h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p><strong>springboot</strong>：推荐2.x版本,不要去使用1.x版本了</p>
<p><strong>springboot和springcloud版本</strong>选择的对应关系如下图</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319112819884.png" alt="image-20220319112819884"></p>
<p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud#overview">springboot和springcloud版本的对应关系</a></p>
<p><strong>本课程使用的各技术版本</strong></p>
<table>
<thead>
<tr>
<th>技术</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>cloud</td>
<td>Hoxton.SR1</td>
</tr>
<tr>
<td>boot</td>
<td>2.2.RELEASE</td>
</tr>
<tr>
<td>cloud</td>
<td>alibaba 2.1.0.RELEASE</td>
</tr>
<tr>
<td>java</td>
<td>java8</td>
</tr>
<tr>
<td>Maven</td>
<td>3.5以上</td>
</tr>
<tr>
<td>mysql</td>
<td>5.7以上</td>
</tr>
</tbody></table>
<h2 id="cloud各种组件的停更-x2F-替换"><a href="#cloud各种组件的停更-x2F-替换" class="headerlink" title="cloud各种组件的停更&#x2F;替换"></a>cloud各种组件的停更&#x2F;替换</h2><h3 id="以前"><a href="#以前" class="headerlink" title="以前"></a>以前</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220319113815361.png" alt="image-20220319113815361"></p>
<h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220319114738105.png" alt="image-20220319114738105"></p>
<h3 id="cloud的相关文档"><a href="#cloud的相关文档" class="headerlink" title="cloud的相关文档"></a>cloud的相关文档</h3><p><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/">H版英文文档</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">springcloud中文文档</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/">springboot英文文档</a></p>
<h2 id="微服务架构编码-构建"><a href="#微服务架构编码-构建" class="headerlink" title="微服务架构编码 构建"></a>微服务架构编码 构建</h2><p>约定&gt;配置&gt;编码</p>
<h3 id="IDEA新建project工作空间"><a href="#IDEA新建project工作空间" class="headerlink" title="IDEA新建project工作空间"></a>IDEA新建project工作空间</h3><ul>
<li>New Project</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319153224412.png" alt="image-20220319153224412"></p>
<ul>
<li>聚合总父工程名字</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319153444695.png" alt="image-20220319153444695"></p>
<ul>
<li>maven用自己本地的</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319153603583.png" alt="image-20220319153603583"></p>
<ul>
<li>项目编码</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319154052554.png" alt="image-20220319154052554"></p>
<ul>
<li>注解生效激活</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319154300117.png" alt="image-20220319154300117"></p>
<ul>
<li>java版本选8</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319154402918.png" alt="image-20220319154402918"></p>
<ul>
<li>父pom文件：<strong>dependencyManagement</strong>主要用来锁定版本号的,锁定之后,子模块就不需要写版本号了。</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;cloud-provider-payment8001&lt;/module&gt;
        &lt;module&gt;cloud-api-commons&lt;/module&gt;
        &lt;module&gt;cloud-consumer-order80&lt;/module&gt;
    &lt;/modules&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;junit.version&gt;4.12&lt;/junit.version&gt;
        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;
        &lt;lombok.version&gt;1.18.0&lt;/lombok.version&gt;
        &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;
        &lt;druid.version&gt;1.1.16&lt;/druid.version&gt;
        &lt;!--&lt;mybatis.spring.boot.version&gt;1.3.2&lt;/mybatis.spring.boot.version&gt; --&gt;
        &lt;!--我这里用的mybatis-plus --&gt;
        &lt;mybatis.plus.boot.version&gt;3.5.1&lt;/mybatis.plus.boot.version&gt;
    &lt;/properties&gt;

    &lt;!-- 子模块继承之后，提供作用：锁定版本+子模块不用写groupId和version  --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!--  springboot 2.2.2    --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;!--  spring cloud Hoxton.SR1   --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR1&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;!--  spring cloud alibaba 2.1.0.RELEASE    --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
                &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
                &lt;artifactId&gt;druid&lt;/artifactId&gt;
                &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!--&lt;dependency&gt;
                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;$&#123;mybatis.plus.boot.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;log4j&lt;/groupId&gt;
                &lt;artifactId&gt;log4j&lt;/artifactId&gt;
                &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;junit&lt;/groupId&gt;
                &lt;artifactId&gt;junit&lt;/artifactId&gt;
                &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
                &lt;artifactId&gt;lombok&lt;/artifactId&gt;
                &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;
                &lt;optional&gt;true&lt;/optional&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;fork&gt;true&lt;/fork&gt;
                    &lt;addResources&gt;true&lt;/addResources&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>maven中跳过单元测试</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319155316100.png" alt="image-20220319155316100"></p>
<blockquote>
<p>父工程创建完成执行mvn:insall将父工程发布到仓库方便子工程继承</p>
</blockquote>
<h3 id="热部署的配置"><a href="#热部署的配置" class="headerlink" title="热部署的配置"></a>热部署的配置</h3><p>配置热部署之后,springboot项目可以自动的重启。配置步骤如下：</p>
<p>第一步：添加依赖到模块中</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>第二步：添加依赖到父项目中</p>
<pre><code class="xml">&lt;build&gt;
    &lt;fileName&gt;你自己的工程名字&lt;fileName&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;fork&gt;true&lt;/fork&gt;
                &lt;addResources&gt;true&lt;/addResources&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>第三步：idea配置 <strong>Enabling automatic build</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324141952206.png" alt="image-20220324141952206"></p>
<p>第四步：idea配置<strong>Update the value of</strong></p>
<ul>
<li><p>在idea中按下： crtl+shift+alt+&#x2F;   </p>
</li>
<li><p>选择Registry</p>
</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324142204566.png" alt="image-20220324142204566"></p>
<ul>
<li>将下图的两个配置勾上</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324142406888.png" alt="image-20220324142406888"></p>
<h3 id="Rest微服务工程搭建"><a href="#Rest微服务工程搭建" class="headerlink" title="Rest微服务工程搭建"></a>Rest微服务工程搭建</h3><h4 id="cloud-api-commons"><a href="#cloud-api-commons" class="headerlink" title="cloud-api-commons"></a>cloud-api-commons</h4><p>此模块为公共模块</p>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;
            &lt;!--            &lt;optional&gt;true&lt;/optional&gt;--&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
            &lt;version&gt;5.1.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>结构如图</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220322111050141.png" alt="image-20220322111050141"></p>
<ul>
<li>CommonResult类：公共的json返回结果类</li>
</ul>
<pre><code class="java">import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@AllArgsConstructor
@NoArgsConstructor
public class CommonResult&lt;T&gt; &#123;
    private Integer code;
    private String message;
    private T data;
    public CommonResult(Integer code, String message) &#123;
        this(code, message, null);
    &#125;
&#125;
</code></pre>
<ul>
<li>payment类：支付类</li>
</ul>
<pre><code class="java">import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.io.Serializable;

/**
 * (Payment)实体类
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Payment implements Serializable &#123;
    private Long id;
    private String serial;
&#125;
</code></pre>
<ul>
<li>Order类</li>
</ul>
<pre><code class="java">import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.io.Serializable;
import java.math.BigDecimal;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Order implements Serializable &#123;
    private Long id;
    private Long userId;
    private Long productId;
    private Integer count;
    private BigDecimal money;
    private Integer status; //订单状态：0：创建中，1：已创建
&#125;
</code></pre>
<h4 id="cloud-provider-payment8001"><a href="#cloud-provider-payment8001" class="headerlink" title="cloud-provider-payment8001"></a>cloud-provider-payment8001</h4><p> 微服务提供者-支付模块</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319161847316.png" alt="image-20220319161847316"></p>
<p>完整项目结构如下</p>
<p>​       <img src="/2022/03/27/1513842928408203264/images/image-20220322112053163.png" alt="image-20220322112053163"></p>
<p> 创建完成后回到父工程查看pom文件变化</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220319163010993.png" alt="image-20220319163010993"></p>
<ul>
<li>cloud-provider-payment8001 的pom文件</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-provider-payment8001&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--引入cloud-api-commons公共依赖模块--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<ul>
<li>cloud-provider-payment8001 的application.yml文件</li>
</ul>
<pre><code class="yml">server:
  port: 8001

spring:
  application:
    name: cloud-payment-service
  datasource:
    username: root
    password: root
    url: jdbc:mysql://localhost:3306/db2020_cloud
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    
mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.atguigu.springcloud.entities
</code></pre>
<ul>
<li>cloud-provider-payment8001 的启动类：PaymentMain8001</li>
</ul>
<pre><code class="java">import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(&quot;com.atguigu.springcloud.dao&quot;)
public class PaymentMain8001 &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8001.class,args);
    &#125;
&#125;
</code></pre>
<ul>
<li>cloud-provider-payment8001 的PaymentDao类</li>
</ul>
<pre><code class="java">import com.atguigu.springcloud.entities.Payment;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

public interface PaymentDao extends BaseMapper&lt;Payment&gt; &#123;
&#125;
</code></pre>
<ul>
<li>cloud-provider-payment8001 的PaymentServiceImpl</li>
</ul>
<pre><code class="java">import com.atguigu.springcloud.service.PaymentService;
import com.atguigu.springcloud.entities.Payment;
import com.atguigu.springcloud.dao.PaymentDao;
import org.springframework.stereotype.Service;
import javax.annotation.Resource;

/**
 * (Payment)表服务实现类
 */
@Service
public class PaymentServiceImpl implements PaymentService &#123;
    @Resource
    private PaymentDao paymentDao;

    /**
     * 通过ID查询单条数据
     *
     * @param id 主键
     * @return 实例对象
     */
    @Override
    public Payment queryById(Long id) &#123;
        return this.paymentDao.selectById(id);
    &#125;

    /**
     * 新增数据
     *
     * @param payment 实例对象
     * @return 实例对象
     */
    @Override
    public Payment insert(Payment payment) &#123;
        this.paymentDao.insert(payment);
        return payment;
    &#125;

    /**
     * 修改数据
     *
     * @param payment 实例对象
     * @return 实例对象
     */
    @Override
    public Payment update(Payment payment) &#123;
        this.paymentDao.updateById(payment);
        return payment;
    &#125;

    /**
     * 通过主键删除数据
     *
     * @param id 主键
     * @return 是否成功
     */
    @Override
    public boolean deleteById(Long id) &#123;
        return this.paymentDao.deleteById(id) &gt; 0;
    &#125;
&#125;
</code></pre>
<ul>
<li>cloud-provider-payment8001 的PaymentController</li>
</ul>
<pre><code class="java">import com.atguigu.springcloud.service.PaymentService;
import com.atguigu.springcloud.entities.CommonResult;
import com.atguigu.springcloud.entities.Payment;
import org.springframework.web.bind.annotation.*;
import javax.annotation.Resource;


/**
 * (Payment)表控制层
 */
@RestController
@RequestMapping(&quot;payment&quot;)
public class PaymentController &#123;
    /**
     * 服务对象
     */
    @Resource
    private PaymentService paymentService;

    /**
     * 通过主键查询单条数据
     *
     * @param id 主键
     * @return 单条数据
     */
    @GetMapping(&quot;get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; selectOne(@PathVariable(&quot;id&quot;) Long id) &#123;
        Payment payment = this.paymentService.queryById(id);
        return new CommonResult&lt;Payment&gt;(200,&quot;select success 8001 hlf2!&quot;,payment);
    &#125;

    @PostMapping(&quot;create&quot;)
    //注意：这里千万别忘了加@RequestBody,否则RestTemplate调用之后参数处理不了
    public CommonResult create(@RequestBody Payment payment) &#123;
        Payment insert = this.paymentService.insert(payment);
        System.out.println(insert);
        System.out.println(&quot;1234567890&quot;);
        return new CommonResult(200,&quot;insert success&quot; ,insert);
    &#125;
&#125;
</code></pre>
<h4 id="cloud-consumer-order80"><a href="#cloud-consumer-order80" class="headerlink" title="cloud-consumer-order80"></a>cloud-consumer-order80</h4><p>订单模块，此模块会通过RestTemplate调用payment(支付模块)。这个模块的结构和支付模块的结构类似</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220322113335114.png" alt="image-20220322113335114"></p>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-consumer-order80&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--引入公共模块--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<ul>
<li>ApplicationContextConfig：RestTemplate的配置类</li>
</ul>
<pre><code class="java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class ApplicationContextConfig &#123;

    @Bean
    public RestTemplate getRestTemplate()&#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
<ul>
<li>OrderController</li>
</ul>
<pre><code class="java">import com.atguigu.springcloud.entities.CommonResult;
import com.atguigu.springcloud.entities.Payment;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;
import javax.annotation.Resource;

@RestController
public class OrderController &#123;

    @Resource
    private RestTemplate restTemplate;

    public static final String PAYMENT_URL=&quot;http://localhost:8001&quot;;

    @RequestMapping(&quot;/consumer/payment/create&quot;)
    public CommonResult&lt;Payment&gt; create(Payment payment)&#123;
        return restTemplate.postForObject(PAYMENT_URL+&quot;/payment/create&quot;,payment,CommonResult.class);
    &#125;

    @GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; selectOne(@PathVariable(&quot;id&quot;) Long id) &#123;
        return restTemplate.getForObject(PAYMENT_URL+&quot;/payment/get/&quot;+id,CommonResult.class);
    &#125;
&#125;
</code></pre>
<ul>
<li>主启动类:OrderMain80</li>
</ul>
<pre><code class="java">import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(&quot;com.atguigu.springcloud.dao&quot;)
public class OrderMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderMain80.class,args);
    &#125;
&#125;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一部分周阳老师暂时还没有用到微服务springcloud的组件,只是方便大家熟悉代码,为后面的学习打基础用的。</p>
<h2 id="Eruka"><a href="#Eruka" class="headerlink" title="Eruka"></a>Eruka</h2><p>Eruka是一个注册中心组件</p>
<h3 id="Eruka的基础知识"><a href="#Eruka的基础知识" class="headerlink" title="Eruka的基础知识"></a>Eruka的基础知识</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220322114806433.png" alt="image-20220322114806433"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220322114833299.png" alt="image-20220322114833299"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220322114904872.png" alt="image-20220322114904872"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220322114935615.png" alt="image-20220322114935615"></p>
<h3 id="构建单机Eureka"><a href="#构建单机Eureka" class="headerlink" title="构建单机Eureka"></a>构建单机Eureka</h3><h4 id="cloud-eureka-server7001"><a href="#cloud-eureka-server7001" class="headerlink" title="cloud-eureka-server7001"></a>cloud-eureka-server7001</h4><p>这个7001模块为注册中心,属于eruka的服务端模块</p>
<ul>
<li>cloud-eureka-server7001的pom.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;artifactId&gt;cloud-eureka-server7001&lt;/artifactId&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>cloud-eureka-server7001的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 7001

spring:
  application:
    name: cloud-eureka-server7001

eureka:
  instance:
    hostname: localhost
  client:
    fetch-registry: false  #不注册自己
    register-with-eureka: false # 不检索自己
    service-url:
      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/
  server:
    #关闭自我保护机制，保证不可用服务立即被踢出 ,默认是true开启的
    enable-self-preservation: true
    eviction-interval-timer-in-ms: 2000
</code></pre>
<ul>
<li>EurekaMain7001.java    注意要加上**@EnableEurekaServer** 这个注解</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer  //EurekaServer的注解
public class EurekaMain7001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(EurekaMain7001.class,args);
    &#125;
&#125;
</code></pre>
<h4 id="cloud-provider-payment8001-1"><a href="#cloud-provider-payment8001-1" class="headerlink" title="cloud-provider-payment8001"></a>cloud-provider-payment8001</h4><p>这个模块是eruka的客户端模块</p>
<ul>
<li>cloud-provider-payment8001的pom.xml，需要加上eruka的客户端依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>cloud-provider-payment8001的application.yml，需要加上eruka的客户端配置</li>
</ul>
<pre><code class="yml">eureka:
  client:
    #表示将自己注册到eureka
    register-with-eureka: true
    # 是否从EurekaServer抓取已有的注册信息,单节点无所谓,集群必须设置为true
    fetch-registry: true
    # eureka服务端的地址
    service-url:
      defaultZone: http://localhost:7001/eureka
</code></pre>
<ul>
<li>cloud-provider-payment8001的主启动类加上**@EnableEurekaClient**注解</li>
</ul>
<h4 id="cloud-consumer-order80-1"><a href="#cloud-consumer-order80-1" class="headerlink" title="cloud-consumer-order80"></a>cloud-consumer-order80</h4><p>这个模块同样是eureka的客户端模块</p>
<ul>
<li>cloud-consumer-order80的pom.xml增加eureka的依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>cloud-consumer-order80的application.yml增加eureka的配置</li>
</ul>
<pre><code class="yml">eureka:
  client:
    #表示将自己注册到eureka
    register-with-eureka: true
    # 是否从EurekaServer抓取已有的注册信息,单节点无所谓,集群必须设置为true
    fetch-registry: true
    # eureka服务端的地址
    service-url:
      defaultZone: http://localhost:7001/eureka
</code></pre>
<ul>
<li>cloud-consumer-order80的主启动类加上**@EnableEurekaClient**注解</li>
</ul>
<p>先启动eureka的服务端,再启动两个客户端,访问7001服务端可以看到注册进去的两个服务的名称。</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324152456869.png" alt="image-20220324152456869"></p>
<h3 id="构建Eureka服务端集群"><a href="#构建Eureka服务端集群" class="headerlink" title="构建Eureka服务端集群"></a>构建Eureka服务端集群</h3><p>eureka集群原理如下</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324153046747.png" alt="image-20220324153046747"></p>
<h4 id="cloud-eureka-server7002"><a href="#cloud-eureka-server7002" class="headerlink" title="cloud-eureka-server7002"></a>cloud-eureka-server7002</h4><p>这个模块也是eureka服务端，类比cloud-eureka-server7001新建cloud-eureka-server7002。但是需要做一些修改。</p>
<ul>
<li>修改映射配置</li>
</ul>
<pre><code>1.找到C:\Windows\System32\drivers\etc路径下的hosts文件,末尾添加如下：

127.0.0.1 eureka7001.com
127.0.0.1 eureka7002.com

2.cmd命令行刷新hosts文件

ipconfig /flushdns
</code></pre>
<ul>
<li>修改7001的application.yml文件</li>
</ul>
<p>eureka服务端的集群配置特点：<strong>相互注册</strong>、<strong>相互守望</strong>。</p>
<pre><code class="yml">server:
  port: 7001
spring:
  application:
    name: cloud-eureka-service #修改1：7001和7002这里改成一致
eureka:
  instance:
    # eureka服务端的实例名称
    hostname: eureka7001.com #修改2
  client:
    # false表示不向注册中心注册自己
    register-with-eureka: false
    # false表示自己端就是注册中心,我的职责就是维护服务实例,并不需要检索服务
    fetch-registry: false
    service-url:
      # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址
      defaultZone: http://eureka7002.com:7002/eureka/ #修改3 相互注册，相互守望
</code></pre>
<ul>
<li>修改7002的application.yml文件</li>
</ul>
<pre><code class="yml">server:
  port: 7002
spring:
  application:
    name: cloud-eureka-service
eureka:
  instance:
    # eureka服务端的实例名称
    hostname: eureka7002.com
  client:
    # false表示不向注册中心注册自己
    register-with-eureka: false
    # false表示自己端就是注册中心,我的职责就是维护服务实例,并不需要检索服务
    fetch-registry: false
    service-url:
      # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址
      defaultZone: http://eureka7001.com:7001/eureka/
</code></pre>
<p>启动7001和7002两个eureka服务后发现：相互注册、相互守望</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324161530766.png" alt="image-20220324161530766"></p>
<h4 id="cloud-provider-payment8001-2"><a href="#cloud-provider-payment8001-2" class="headerlink" title="cloud-provider-payment8001"></a>cloud-provider-payment8001</h4><p>将这个服务注册到Eureka的集群，修改8001的<strong>application.yml</strong>文件</p>
<pre><code class="yml">eureka:
  client:
    #表示将自己注册到eureka
    register-with-eureka: true
    # 是否从EurekaServer抓取已有的注册信息,单节点无所谓,集群必须设置为true
    fetch-registry: true
    # eureka服务端的地址
    service-url:
      #defaultZone: http://localhost:7001/eureka # 单机版
      #主要就是修改下面这行
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka 
</code></pre>
<blockquote>
<p>然后测试，就会发现8001同时注册到7001和7002两个eureka的服务端了。</p>
</blockquote>
<h4 id="cloud-consumer-order80-2"><a href="#cloud-consumer-order80-2" class="headerlink" title="cloud-consumer-order80"></a>cloud-consumer-order80</h4><p>将这个服务注册到Eureka的集群，修改80的<strong>application.yml</strong>文件，和上面的cloud-provider-payment8001做同样的修改</p>
<pre><code class="yml">#主要就是修改下面这行
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
</code></pre>
<blockquote>
<p>然后测试，就会发现7001和7002这两个eureka的服务端中同时注册了80和8001两个服务</p>
</blockquote>
<h3 id="构建Eureka客户端集群"><a href="#构建Eureka客户端集群" class="headerlink" title="构建Eureka客户端集群"></a>构建Eureka客户端集群</h3><h4 id="cloud-provider-payment8002"><a href="#cloud-provider-payment8002" class="headerlink" title="cloud-provider-payment8002"></a>cloud-provider-payment8002</h4><p>参考cloud-provider-payment8001构建cloud-provider-payment8002</p>
<h4 id="修改8001和8002的controller"><a href="#修改8001和8002的controller" class="headerlink" title="修改8001和8002的controller"></a>修改8001和8002的controller</h4><p>目的是测试订单服务调用的到底是哪个端口的支付服务<img src="/2022/03/27/1513842928408203264/images/image-20220324165830811.png" alt="image-20220324165830811"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324165846068.png" alt="image-20220324165846068"></p>
<p>启动测试发现同一个服务名下注册了两个端口的支付服务</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324170940264.png" alt="image-20220324170940264"></p>
<blockquote>
<p>测试<a target="_blank" rel="noopener" href="http://localhost/consumer/payment/get/31%E5%8F%91%E7%8E%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%B0%B8%E8%BF%9C%E6%98%AF8001%E7%9A%84%E9%82%A3%E4%B8%AA%E5%BE%AE%E6%9C%8D%E5%8A%A1,%E6%98%BE%E7%84%B6%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%82">http://localhost/consumer/payment/get/31发现调用的永远是8001的那个微服务,显然没有实现负载均衡。</a></p>
</blockquote>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>实现订单微服务均衡的调用支付的微服务。也就是8001和8002轮流调用</p>
<ul>
<li>订单controller中的地址不能写死</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324172027959.png" alt="image-20220324172027959"></p>
<ul>
<li>ApplicationContextConfig中开启RestTemplate的负载均衡，**@LoadBalanced**注解</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324172101334.png" alt="image-20220324172101334"></p>
<blockquote>
<p>测试结果：8001&#x2F;8002端口交替出现</p>
</blockquote>
<h3 id="actuator微服务信息完善"><a href="#actuator微服务信息完善" class="headerlink" title="actuator微服务信息完善"></a>actuator微服务信息完善</h3><p>非必须,只不过完善后看起来会更加的清晰。在eureka中做如下修改即可</p>
<pre><code class="yml">instance:
    instance-id: payment8001 #修改名称
    prefer-ip-address: true  #显示ip
</code></pre>
<h4 id="主机名称-服务名称修改"><a href="#主机名称-服务名称修改" class="headerlink" title="主机名称:服务名称修改"></a>主机名称:服务名称修改</h4><p>当前问题</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324172830327.png" alt="image-20220324172830327"></p>
<p>修改application.yml即可</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324172856819.png" alt="image-20220324172856819"></p>
<p>修改之后的效果</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324173012503.png" alt="image-20220324173012503"></p>
<h4 id="访问信息有IP信息提示"><a href="#访问信息有IP信息提示" class="headerlink" title="访问信息有IP信息提示"></a>访问信息有IP信息提示</h4><p>当前问题：没有IP提示</p>
<p>修改application.yml即可</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324173146576.png" alt="image-20220324173146576"></p>
<p>修改后的效果</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324173215157.png" alt="image-20220324173215157"></p>
<h3 id="服务发现Discovery"><a href="#服务发现Discovery" class="headerlink" title="服务发现Discovery"></a>服务发现Discovery</h3><p>对于注册eureka里面的微服务,可以通过服务发现来获得该服务的信息</p>
<h4 id="cloud-provider-payment8001-3"><a href="#cloud-provider-payment8001-3" class="headerlink" title="cloud-provider-payment8001"></a>cloud-provider-payment8001</h4><ul>
<li>启动类加上注解：**@EnableDiscoveryClient**  (不加这个注解发现不了！！！)</li>
<li>修改PaymentController,加入下面的代码</li>
</ul>
<pre><code class="java">@Resource
private DiscoveryClient discoveryClient;//服务发现,获取服务信息

@GetMapping(&quot;discovery&quot;)
public Object discovery() &#123;
    //获取所有微服务
    List&lt;String&gt; services = discoveryClient.getServices();
    services.forEach(service-&gt;&#123;
        System.out.println(&quot;----service：&quot;+service);
    &#125;);
    //获取一个微服务下的全部实例
    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);
    for (ServiceInstance instance : instances) &#123;
        System.out.println(instance.getServiceId()+&quot;\t&quot; + instance.getHost()+&quot;\t&quot;+ instance.getPort()+&quot;\t&quot;+instance.getUri());;
    &#125;

    return this.discoveryClient;
&#125;
</code></pre>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324211316405.png" alt="image-20220324211316405"></p>
<h3 id="eureka自我保护"><a href="#eureka自我保护" class="headerlink" title="eureka自我保护"></a>eureka自我保护</h3><ul>
<li>故障现象</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324203712327.png" alt="image-20220324203712327"></p>
<ul>
<li>导致原因：某时刻 一个微服务不可用了,Eureka不会立刻清理,依旧会对该服务的信息进行保存。</li>
</ul>
<p>属于CAP里面的AP分支。</p>
<h4 id="禁用自我保护"><a href="#禁用自我保护" class="headerlink" title="禁用自我保护"></a>禁用自我保护</h4><p>在eurekaServer和eurekaClient分别进行配置</p>
<h5 id="注册中心eurekaServer端7001"><a href="#注册中心eurekaServer端7001" class="headerlink" title="注册中心eurekaServer端7001"></a>注册中心eurekaServer端7001</h5><p>出产默认,自我保护机制是开启的 ,可以在配置文件中关闭：</p>
<pre><code class="yml">eureka.server.enable-self-preservation: false
</code></pre>
<p>关闭效果</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324204326254.png" alt="image-20220324204326254"></p>
<h5 id="生产者客户端eurekaClient端8001"><a href="#生产者客户端eurekaClient端8001" class="headerlink" title="生产者客户端eurekaClient端8001"></a>生产者客户端eurekaClient端8001</h5><pre><code class="yml">#Eureka客户端向服务端发送心跳的时间间隔,单位为秒(默认是30秒)
lease-renewal-interval-in-seconds: 30
lease-expiration-duration-in-seconds: 90
</code></pre>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220324205202954.png" alt="image-20220324205202954"></p>
<h2 id="Zookeeper服务注册与发现"><a href="#Zookeeper服务注册与发现" class="headerlink" title="Zookeeper服务注册与发现"></a>Zookeeper服务注册与发现</h2><p>略(后面再补)</p>
<h2 id="Consul服务注册与发现"><a href="#Consul服务注册与发现" class="headerlink" title="Consul服务注册与发现"></a>Consul服务注册与发现</h2><p>官网：<a target="_blank" rel="noopener" href="https://www.consul.io/intro/index.html">https://www.consul.io/intro/index.html</a></p>
<h3 id="consul简介"><a href="#consul简介" class="headerlink" title="consul简介"></a>consul简介</h3><p>是什么</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220325102353499.png" alt="image-20220325102353499"></p>
<p>能干嘛</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220325102501076.png" alt="image-20220325102501076"></p>
<h3 id="consul的安装"><a href="#consul的安装" class="headerlink" title="consul的安装"></a>consul的安装</h3><p>下载：<a target="_blank" rel="noopener" href="https://www.consul.io/downloads.html">https://www.consul.io/downloads.html</a></p>
<p>中文文档：<a target="_blank" rel="noopener" href="https://www.springcloud.cc/spring-cloud-consul.html">https://www.springcloud.cc/spring-cloud-consul.html</a></p>
<blockquote>
<p>ps：下载很慢，可以安装迅雷之后用迅雷加速下载</p>
</blockquote>
<ul>
<li><p>下载完毕之后的压缩包中有一个<code>consul.exe</code>文件</p>
</li>
<li><p>将<code>consul.exe</code>文件的路径配置到环境变量的<code>path</code>中即可,例如下面</p>
</li>
</ul>
<pre><code>D:\springcloud_soft\consul_1.11.4
</code></pre>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220325103604551.png" alt="image-20220325103604551"></p>
<ul>
<li>配好之后cmd窗口中输入下面的指令,看到consul的版本号，表示安装成功</li>
</ul>
<pre><code>consul --version
</code></pre>
<h3 id="consul的启动和访问"><a href="#consul的启动和访问" class="headerlink" title="consul的启动和访问"></a>consul的启动和访问</h3><ul>
<li>在cmd窗口中运行启动命令 （使用开发模式启动）</li>
</ul>
<pre><code>consul agent -dev
</code></pre>
<ul>
<li>浏览器中输入网址：<a target="_blank" rel="noopener" href="http://localhost:8500/">http://localhost:8500/</a>  就可以进入到consul的界面了</li>
</ul>
<h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>新建<code>cloud-providerconsul-payment8006</code>工程</p>
<ul>
<li>cloud-providerconsul-payment8006的pom.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-providerconsul-payment8006&lt;/artifactId&gt;


    &lt;dependencies&gt;
        &lt;!--SpringCloud consul-server--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--引入公共依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>application.yml</li>
</ul>
<pre><code class="yml">server:
  # consul服务端口
  port: 8006
spring:
  application:
    name: cloud-provider-payment
  cloud:
    consul:
      # consul注册中心地址
      host: localhost
      port: 8500
      discovery:
        hostname: 127.0.0.1
        service-name: $&#123;spring.application.name&#125;
        prefer-ip-address: true
</code></pre>
<ul>
<li>主启动类PaymentMain8006,主要添加<code>@EnableDiscoveryClient</code>注解</li>
</ul>
<pre><code class="java">@SpringBootApplication
@EnableDiscoveryClient
public class PaymentMain8006 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain8006.class, args);
    &#125;
&#125;
</code></pre>
<ul>
<li>controller</li>
</ul>
<pre><code class="java">@RestController
public class PaymentController &#123;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    @RequestMapping(value = &quot;payment/consul&quot;)
    public String paymentConsul() &#123;
        return &quot;SpringCloud with consul:&quot; + serverPort + &quot;\t&quot; + UUID.randomUUID().toString();
    &#125;
&#125;
</code></pre>
<h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p>新建cloud-consumerconsul-order80模块</p>
<ul>
<li>cloud-consumerconsul-order80的pom.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;
        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;cloud-consumerconsul-order80&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;!--SpringCloud consul-server--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--引入公共依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>cloud-consumerconsul-order80的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 80
spring:
  application:
    name: cloud-consumer-order
  cloud:
    consul:
      # consul注册中心地址
      host: localhost
      port: 8500
      discovery:
        hostname: 127.0.0.1
        service-name: $&#123;spring.application.name&#125;
        prefer-ip-address: true
</code></pre>
<ul>
<li>ApplicationContextConfig,主要是为了RestTemplate的远程调用</li>
</ul>
<pre><code class="java">import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class ApplicationContextConfig &#123;

    @Bean
    @LoadBalanced //开启RestTemplate的负载均衡
    public RestTemplate getRestTemplate()&#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
<ul>
<li>OrderController</li>
</ul>
<pre><code class="java">import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;
import javax.annotation.Resource;

@RestController
public class OrderController &#123;

    @Resource
    private RestTemplate restTemplate;

    //注意下面这个地址的对应
    public static final String PAYMENT_URL=&quot;http://cloud-provider-payment&quot;;

    @GetMapping(&quot;/consumer/payment/consul&quot;)
    public String consul() &#123;
        return restTemplate.getForObject(PAYMENT_URL+&quot;/payment/consul&quot;,String.class);
    &#125;
&#125;
</code></pre>
<ul>
<li>主启动类添加<code>@EnableDiscoveryClient</code>注解</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>测试consul注册中心中是否将服务提供者和消费者注册进去<img src="/2022/03/27/1513842928408203264/images/image-20220325160430199.png" alt="image-20220325160430199"></li>
<li>测试服务消费者能否成功调用服务提供者</li>
</ul>
<p>测试url：<a target="_blank" rel="noopener" href="http://localhost/consumer/payment/consul">http://localhost/consumer/payment/consul</a></p>
<p>结果成功调用</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220325160529522.png" alt="image-20220325160529522"></p>
<h3 id="三个注册中心异同点"><a href="#三个注册中心异同点" class="headerlink" title="三个注册中心异同点"></a>三个注册中心异同点</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220325160638135.png" alt="image-20220325160638135"></p>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul>
<li>CAP概念</li>
</ul>
<pre><code>C: Consistency(强一致性)

A: Availability(可用性)

P: Parttition tolerance(分区容错性)
</code></pre>
<ul>
<li><p>分区容错性要保证,所以要么是CP,要么是AP</p>
</li>
<li><p>CAP理论关注粒度是否是数据,而不是整体系统设计的策略</p>
</li>
<li><p>经典CAP图</p>
</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220325160945521.png" alt="image-20220325160945521"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220325160653008.png" alt="image-20220325160653008"></p>
<h4 id="AP-eureka"><a href="#AP-eureka" class="headerlink" title="AP(eureka)"></a>AP(eureka)</h4><p><img src="/2022/03/27/1513842928408203264/images/image-20220325161050875.png" alt="image-20220325161050875"></p>
<h4 id="CP-Zookeeper-x2F-Consul"><a href="#CP-Zookeeper-x2F-Consul" class="headerlink" title="CP(Zookeeper&#x2F;Consul)"></a>CP(Zookeeper&#x2F;Consul)</h4><p>CP架构:当网络分区出现后,为了保证一致性,就必须拒绝请求,否则无法保证一致性<br>结论:违背了可用性A的要求,只满足一致性和分区容错,即CP</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220325161332377.png" alt="image-20220325161332377"></p>
<h2 id="Ribbon负载均衡服务调用"><a href="#Ribbon负载均衡服务调用" class="headerlink" title="Ribbon负载均衡服务调用"></a>Ribbon负载均衡服务调用</h2><blockquote>
<p>和feign的功能类似主要是用来<strong>负载均衡</strong>和<strong>远程调用</strong>,Ribbon目前也进入维护模式</p>
</blockquote>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403093022665.png" alt="image-20220403093022665"></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220403092611726.png" alt="image-20220403092611726"></p>
<p>官网资料: <a target="_blank" rel="noopener" href="https://github.com/Netflix/ribbon/wiki/Getting-Started">https://github.com/Netflix/ribbon/wiki/Getting-Started</a></p>
<p>一句话：<strong>负载均衡+RestTemplate调用</strong>(前面我们讲解过了80通过轮询负载访问8001&#x2F;8002)</p>
<h3 id="Ribbon负载均衡演示"><a href="#Ribbon负载均衡演示" class="headerlink" title="Ribbon负载均衡演示"></a>Ribbon负载均衡演示</h3><p>架构说明</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403093511666.png" alt="image-20220403093511666"></p>
<p><strong>总结</strong>：</p>
<p>1.<strong>Ribbon</strong>其实就是一个<strong>软负载均衡</strong>的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。</p>
<p>2.之前没有引入Ribbon依赖也可以使用是因为,eureka的client中默认引入了Ribbon的依赖</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403093931357.png" alt="image-20220403093931357"></p>
<p>3.二说RestTemplate的使用</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate官网</a></p>
<ul>
<li>getForObject方法&#x2F;getForEntity方法</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403094225269.png" alt="image-20220403094225269"></p>
<ul>
<li>postForObject&#x2F;postForEntity</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403094408540.png" alt="image-20220403094408540"></p>
<pre><code>RestTemplate的:
    xxxForObject()方法,返回的是响应体中的数据
    xxxForEntity()方法.返回的是entity对象,这个对象不仅仅包含响应体数据,还包含响应体信息(状态码等)
    
    xxx 可以是get也可以使post
</code></pre>
<h3 id="Ribbon核心组件IRule"><a href="#Ribbon核心组件IRule" class="headerlink" title="Ribbon核心组件IRule"></a>Ribbon核心组件IRule</h3><p><strong>IRule接口,Riboon使用该接口,根据特定算法从所有服务中,选择一个服务。Rule接口有7个实现类,每个实现类代表一个负载均衡算法</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403095315885.png" alt="image-20220403095315885"></p>
<h4 id="将轮询调用改为随机调用"><a href="#将轮询调用改为随机调用" class="headerlink" title="将轮询调用改为随机调用"></a>将轮询调用改为随机调用</h4><p>此处要注意一个细节：新建的rule配置类<strong>不能放在主启动类所在的包及子包下</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403095905874.png" alt="image-20220403095905874"></p>
<p>修改cloud-consumer-order80，具体步骤如下：</p>
<p>第一步：新建package以及新建MySelfRule规则类</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403100515702.png" alt="image-20220403100515702"></p>
<p>注意：新建的rule配置类<strong>不能放在主启动类所在的包及子包下</strong></p>
<p>MySelfRule内容如下</p>
<pre><code class="java">import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.RandomRule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MySelfRule &#123;

    @Bean
    public IRule myRule()&#123;
        return new RandomRule();//定义为随机
    &#125;
&#125;
</code></pre>
<p>第二步：主启动类添加**@RibbonClient**注解</p>
<pre><code class="java">@SpringBootApplication
@MapperScan(&quot;com.atguigu.springcloud.dao&quot;)
@EnableEurekaClient
@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = MySelfRule.class)
//表示,访问CLOUD_pAYMENT_SERVICE的服务时,使用我们自定义的负载均衡算法
public class OrderMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderMain80.class,args);
    &#125;
&#125;
</code></pre>
<p>第三步：测试  <a target="_blank" rel="noopener" href="http://localhost/consumer/payment/get/31">http://localhost/consumer/payment/get/31</a></p>
<h3 id="Ribbon负载均衡算法"><a href="#Ribbon负载均衡算法" class="headerlink" title="Ribbon负载均衡算法"></a>Ribbon负载均衡算法</h3><p>略</p>
<h2 id="OpenFeign服务接口调用"><a href="#OpenFeign服务接口调用" class="headerlink" title="OpenFeign服务接口调用"></a>OpenFeign服务接口调用</h2><p>Feign是一个声明式的web服务客户端，让编写web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可（一个接口 + 一个注解）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-openfeign">GitHub</a></p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220403102948332.png" alt="image-20220403102948332"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403103319851.png" alt="image-20220403103319851"></p>
<p>Feign和OpenFeign两者区别</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403103435984.png" alt="image-20220403103435984"></p>
<h3 id="OpenFeign使用步骤"><a href="#OpenFeign使用步骤" class="headerlink" title="OpenFeign使用步骤"></a>OpenFeign使用步骤</h3><p>1.主启动加<code>@EnableFeignClients</code> 注解</p>
<p>2.新建接口+接口上加<code>@FeignClient</code>注解</p>
<p>具体案例如下：</p>
<ul>
<li><p>新建cloud-consumer-feign-order80模块</p>
</li>
<li><p>cloud-consumer-feign-order80的pom.xml</p>
</li>
</ul>
<pre><code class="xml">&lt;!--openfeign--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloud-consumer-feign-order80的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 80

spring:
  application:
    name: cloud-order-service

eureka:
  client:
    register-with-eureka: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka
</code></pre>
<ul>
<li>cloud-consumer-feign-order80的主启动</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients  //表示开启Feign
public class OrderFeignMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderFeignMain80.class,args);
    &#125;
&#125;
</code></pre>
<ul>
<li>cloud-consumer-feign-order80的PaymentFeignService</li>
</ul>
<pre><code class="java">import com.atguigu.springcloud.entities.CommonResult;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Component
@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;) //表示Feign调用哪个微服务
public interface PaymentFeignService &#123;

    @GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)
    public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);
&#125;
</code></pre>
<ul>
<li>cloud-consumer-feign-order80的OrderFeignController</li>
</ul>
<pre><code class="java">@RestController
public class OrderFeignController &#123;

    @Resource
    private PaymentFeignService paymentFeignService;

    @GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123;
        return paymentFeignService.getPaymentById(id);
    &#125;
&#125;
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code>先启动eureka7001
再启动2个微服务8001/8002
启动OpenFeign启动
测试：http://localhost/consumer/payment/get/31

测试发现：自带负载均衡(轮询)
</code></pre>
<ul>
<li>小总结</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403110312477.png" alt="image-20220403110312477"></p>
<h3 id="OpenFeign超时控制"><a href="#OpenFeign超时控制" class="headerlink" title="OpenFeign超时控制"></a>OpenFeign超时控制</h3><p>OpenFeign默认等待一秒钟，超过后报错.</p>
<p>OpenFeign默认支持Ribbon</p>
<p>因为OpenFeign的底层是ribbon进行负载均衡,所以它的超时时间是由ribbon控制。</p>
<p>YML文件里开启OpenFeign客户端的超时控制</p>
<pre><code class="yml">ribbon:
  ReadTimeout:  5000
  ConnectTimeout: 5000
</code></pre>
<p>案例如下：超时设置，故意设置超时演示出错情况</p>
<ul>
<li>服务提供方8001故意写暂停程序</li>
</ul>
<pre><code class="java">@GetMapping(value = &quot;/payment/feign/timeout&quot;)
public String paymentFeignTimeout()&#123;
    try &#123; TimeUnit.SECONDS.sleep(3); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;
    return serverPort;
&#125;
</code></pre>
<ul>
<li>服务消费方80添加超时方法PaymentFeignService</li>
</ul>
<pre><code class="java">@GetMapping(value = &quot;/payment/feign/timeout&quot;)
public String paymentFeignTimeout();
</code></pre>
<ul>
<li>服务消费方80添加超时方法OrderFeignController</li>
</ul>
<pre><code class="java">@GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;)
public String paymentFeignTimeout()&#123;
   return paymentFeignService.paymentFeignTimeout();
&#125;
</code></pre>
<ul>
<li>测试: <a target="_blank" rel="noopener" href="http://localhost/consumer/payment/feign/timeout">http://localhost/consumer/payment/feign/timeout</a></li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403114909935.png" alt="image-20220403114909935"></p>
<p>解决超时错误： YML文件里需要开启OpenFeign客户端超时控制</p>
<pre><code class="yml">ribbon:
  ReadTimeout:  5000
  ConnectTimeout: 5000
</code></pre>
<h3 id="OpenFeign日志打印功能"><a href="#OpenFeign日志打印功能" class="headerlink" title="OpenFeign日志打印功能"></a>OpenFeign日志打印功能</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220403115138866.png" alt="image-20220403115138866"></p>
<p>Feign日志级别有如下</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403115159325.png" alt="image-20220403115159325"></p>
<p>配置步骤如下：</p>
<p>第一步：配置日志bean</p>
<pre><code class="java">package com.atguigu.springcloud.config;

import feign.Logger;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FeignConfig &#123;

    @Bean
    Logger.Level feignLoggerLevel()&#123;
        return Logger.Level.FULL;
    &#125;
&#125;
</code></pre>
<p>第二步：YML文件里需要开启日志的Feign客户端</p>
<pre><code class="yml">logging:
  level:
    com.atguigu.springcloud.service.PaymentFeignService: debug
</code></pre>
<p>第三步：控制台就可以看到日志了</p>
<h2 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220403163238944.png" alt="image-20220403163238944"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403163258545.png" alt="image-20220403163258545"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403163320203.png" alt="image-20220403163320203"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403163344596.png" alt="image-20220403163344596"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403163550382.png" alt="image-20220403163550382"></p>
<p><strong>Hystrix能干嘛</strong></p>
<pre><code>服务降级
服务熔断
接近实时的监控
。。。
</code></pre>
<p><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">Hystrix官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">Hystrix官宣，停更进维</a></p>
<h3 id="Hystrix重要概念"><a href="#Hystrix重要概念" class="headerlink" title="Hystrix重要概念"></a>Hystrix重要概念</h3><p>a.服务降级: 服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示，fallback</p>
<p>哪些情况会触发降级?</p>
<pre><code>程序运行异常
超时
服务熔断触发服务降级
线程池/信号量打满也会导致服务降级
</code></pre>
<p>b.服务熔断: 类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示</p>
<pre><code>就是保险丝:      服务的降级-&gt;进而熔断-&gt;恢复调用链路
</code></pre>
<p>c.服务限流: 秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p>
<p>降级和熔断的区别与联系：</p>
<pre><code>服务降级有很多种降级方式！如开关降级、限流降级、熔断降级!
服务熔断属于降级方式的一种！
</code></pre>
<h3 id="hystrix案例基础"><a href="#hystrix案例基础" class="headerlink" title="hystrix案例基础"></a>hystrix案例基础</h3><h4 id="构建基础模块"><a href="#构建基础模块" class="headerlink" title="构建基础模块"></a>构建基础模块</h4><ul>
<li><p>新建cloud-provider-hystrix-payment8001模块</p>
</li>
<li><p>cloud-provider-hystrix-payment8001的pom.xml</p>
</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;!--新增hystrix--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
    
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloud-provider-hystrix-payment8001的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 8001

eureka:
  client:
    register-with-eureka: true    
    fetch-registry: true   
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/

spring:
  application:
    name: cloud-provider-hystrix-payment
</code></pre>
<ul>
<li>cloud-provider-hystrix-payment8001的service</li>
</ul>
<pre><code class="java">import org.springframework.stereotype.Service;
import java.util.concurrent.TimeUnit;

@Service
public class PaymentService &#123;

    //成功
    public String paymentInfo_OK(Integer id)&#123;
        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_OK,id：  &quot;+id+&quot;\t&quot;+&quot;哈哈哈&quot;  ;
    &#125;

    //失败
    public String paymentInfo_TimeOut(Integer id)&#123;
        int timeNumber = 3;
        try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;
        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_TimeOut,id：  &quot;+id+&quot;\t&quot;+&quot;呜呜呜&quot;+&quot; 耗时(秒)&quot;+timeNumber;
    &#125;

&#125;
</code></pre>
<ul>
<li>cloud-provider-hystrix-payment8001的controller</li>
</ul>
<pre><code class="java">import com.atguigu.springcloud.service.PaymentService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;

@RestController
@Slf4j
public class PaymentController &#123;

    @Resource
    private PaymentService paymentService;

    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    //ok
    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentService.paymentInfo_OK(id);
        log.info(&quot;*******result:&quot;+result);
        return result;
    &#125;
    //3秒
    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentService.paymentInfo_TimeOut(id);
        log.info(&quot;*******result:&quot;+result);
        return result;
    &#125;
&#125;
</code></pre>
<p>测试基础模块</p>
<ul>
<li>正常访问： <a target="_blank" rel="noopener" href="http://localhost:8001/payment/hystrix/ok/31">http://localhost:8001/payment/hystrix/ok/31</a></li>
<li>每次调用耗费3秒钟：<a target="_blank" rel="noopener" href="http://localhost:8001/payment/hystrix/timeout/31">http://localhost:8001/payment/hystrix/timeout/31</a></li>
</ul>
<p>以上述为根基模块，从正确-&gt;错误-&gt;降级熔断-&gt;恢复</p>
<h4 id="高并发测试"><a href="#高并发测试" class="headerlink" title="高并发测试"></a>高并发测试</h4><p>下载压力测试工具<a target="_blank" rel="noopener" href="https://jmeter.apache.org/download_jmeter.cgi">JMeter</a></p>
<blockquote>
<p>下载慢的话，可以用迅雷</p>
</blockquote>
<p>JMeter解压后运行bat文件即可</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403172357178.png" alt="image-20220403172357178"></p>
<p>运行之后默认是英文的,可以设置为中文</p>
<p>参考： <a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/b0b63dbf25733b4a4830708f.html">设置JMeter界面为中文</a></p>
<p>第一步：右键测试，添加，线程，线程组</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403173607152.png" alt="image-20220403173607152"></p>
<p>第二步：填写好线程组相关信息，这里就2000吧怕电脑带不动，视频里是20000</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403173647183.png" alt="image-20220403173647183"></p>
<p>第三步：创建http请求</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403173747234.png" alt="image-20220403173747234"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403173814986.png" alt="image-20220403173814986"></p>
<p>然后启动就可以进行压力测试了</p>
<pre><code>此时使用压测工具,并发20000个请求,请求会延迟的那个方法,
压测中,发现,另外一个方法并没有被压测,但是我们访问它时,却需要等待
这就是因为被压测的方法它占用了服务器大部分资源,导致其他请求也变慢了

tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。
</code></pre>
<p>Jmeter压测结论: 上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖死</p>
<p>看热闹不嫌弃事大，80新建加入</p>
<ul>
<li>新建cloud-consumer-feign-hystrix-order80模块</li>
<li>cloud-consumer-feign-hystrix-order80的pom.xml</li>
</ul>
<pre><code class="xml"> &lt;dependencies&gt;
        &lt;!--新增hystrix--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloud-consumer-feign-hystrix-order80的application.yml</li>
</ul>
<pre><code class="yml">cloud-consumer-feign-hystrix-order80的application.ymlserver:
  port: 80

eureka:
  client:
    register-with-eureka: true    
    fetch-registry: true  
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/

spring:
  application:
    name: cloud-provider-hystrix-order
</code></pre>
<ul>
<li>cloud-consumer-feign-hystrix-order80的主启动</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class OrderHystrixMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderHystrixMain80.class,args);
    &#125;
&#125;
</code></pre>
<ul>
<li>cloud-consumer-feign-hystrix-order80的service</li>
</ul>
<pre><code class="java">import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Component
@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)
public interface PaymentHystrixService &#123;
    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);

    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);
&#125;
</code></pre>
<ul>
<li>cloud-consumer-feign-hystrix-order80的controller</li>
</ul>
<pre><code class="java">import com.atguigu.springcloud.service.PaymentHystrixService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;
@RestController
@Slf4j
public class OrderHystrixController &#123;

    @Resource
    private PaymentHystrixService paymentHystrixService;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentHystrixService.paymentInfo_OK(id);
        log.info(&quot;*******result:&quot;+result);
        return result;
    &#125;
    //feigh默认是1s得做出响应,这个远程调用肯定会报超时错误
    @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentHystrixService.paymentInfo_TimeOut(id);
        log.info(&quot;*******result:&quot;+result);
        return result;
    &#125;

&#125;
</code></pre>
<p>正常测试：<a target="_blank" rel="noopener" href="http://localhost/consumer/payment/hystrix/ok/31">http://localhost/consumer/payment/hystrix/ok/31</a></p>
<p>高并发测试</p>
<pre><code>2W个线程压8001
消费端80微服务再去访问正常的OK微服务8001地址

http://localhost/consumer/payment/hystrix/timeout/31
要么转圈圈等待
要么消费端报超时错误
</code></pre>
<h4 id="故障现象和导致原因"><a href="#故障现象和导致原因" class="headerlink" title="故障现象和导致原因"></a>故障现象和导致原因</h4><p>现象：80此时调用8001，客户端访问响应缓慢，转圈圈</p>
<p>原因：8001同一层次的其他接口服务被困死，因为tomcat线程里面的工作线程已经被挤占完毕</p>
<h4 id="上诉结论"><a href="#上诉结论" class="headerlink" title="上诉结论"></a>上诉结论</h4><p>正因为有上述故障或不佳表现，才有我们的降级&#x2F;容错&#x2F;限流等技术诞生</p>
<h4 id="如何解决？解决的要求"><a href="#如何解决？解决的要求" class="headerlink" title="如何解决？解决的要求"></a>如何解决？解决的要求</h4><p><img src="/2022/03/27/1513842928408203264/images/image-20220403181146372.png" alt="image-20220403181146372"></p>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>&lt;1&gt; <strong>cloud-provider-hystrix-payment8001</strong> 的降级配置(生产者降级)</p>
<p>先从自身找问题设置<strong>自身</strong>调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback。</p>
<ul>
<li>主启动类激活：添加新注解**@EnableCircuitBreaker**</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
@EnableCircuitBreaker  //激活hystrix
public class PaymentHystrixMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentHystrixMain8001.class,args);
    &#125;
&#125;
</code></pre>
<ul>
<li>业务类配置：一旦调用服务方法失败并抛出了错误信息后，会自动调用**@HystrixCommand**标注好的fallbackMethod调用类中的指定方法</li>
</ul>
<p>注意：配置过的热部署方式对java代码的改动明显，但<strong>对@HystrixCommand内属性的修改建议重启微服务</strong></p>
<pre><code class="java">import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;
import org.springframework.stereotype.Service;
import java.util.concurrent.TimeUnit;

@Service
public class PaymentService &#123;

    //成功
    public String paymentInfo_OK(Integer id)&#123;
        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_OK,id：  &quot;+id+&quot;\t&quot;+&quot;哈哈哈&quot;  ;
    &#125;

    //失败
    @HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;,commandProperties = &#123;
            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;)  //3秒钟以内就是正常的业务逻辑
    &#125;)
    public String paymentInfo_TimeOut(Integer id)&#123;
        //int age = 10/0;
        try &#123; TimeUnit.SECONDS.sleep(id); &#125;catch (InterruptedException e) &#123;e.printStackTrace();&#125;
        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   paymentInfo_TimeOut,id：  &quot;+id+&quot;\t&quot;+&quot;呜呜呜&quot;+&quot; 耗时(秒)&quot;;
    &#125;

    //兜底方法
    public String paymentInfo_TimeOutHandler(Integer id)&#123;
        return &quot;线程池：&quot;+Thread.currentThread().getName()+&quot;   系统繁忙或报错, 请稍候再试  ,id：  &quot;+id+&quot;\t&quot;+&quot;哭了哇呜&quot;;
    &#125;

&#125;
</code></pre>
<p>测试（注意：这里目前只是测试payment这个服务）</p>
<p>我这里是否超时，可以通过传参来控制更加方便！</p>
<pre><code>http://localhost:8001/payment/hystrix/timeout/2   //不报错 3秒以内
http://localhost:8001/payment/hystrix/timeout/5   //报错   超过3秒
</code></pre>
<p>&lt;2&gt; <strong>cloud-consumer-feign-hystrix-order80</strong>的降级配置（消费端降级）</p>
<p>一般服务降级,都是放在客户端&#x2F;消费端(order模块)</p>
<ul>
<li>cloud-consumer-feign-hystrix-order80的application.yml</li>
</ul>
<p>老师是配置下面的，但是有问题，会一直走fallback</p>
<pre><code class="yml">feign:
  hystrix:
    enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。
</code></pre>
<p>还要增加ribbon的配置</p>
<pre><code class="yml">feign:
  hystrix:
    enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。

## 巨坑只配上面的会一直走fallback
ribbon:
  ReadTimeout:  6000
  ConnectTimeout: 6000

hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 3000
</code></pre>
<ul>
<li>cloud-consumer-feign-hystrix-order80的主启动类添加**@EnableHystrix**注解</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
@EnableHystrix //消费端开启Hystrix
public class OrderHystrixMain80 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(OrderHystrixMain80.class,args);
    &#125;
&#125;
</code></pre>
<ul>
<li>cloud-consumer-feign-hystrix-order80的controller</li>
</ul>
<pre><code class="java">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)
    @HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;
            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1500&quot;)  //1.5秒钟以内就是正常的业务逻辑
    &#125;)
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentHystrixService.paymentInfo_TimeOut(id);
        return result;
    &#125;

    //兜底方法
    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123;
        return &quot;我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)&quot;;
    &#125;
</code></pre>
<p>测试：</p>
<pre><code>http://localhost/consumer/payment/hystrix/timeout/1  正常，不走fallback
http://localhost/consumer/payment/hystrix/timeout/5  超时，走fallback
</code></pre>
<h4 id="代码膨胀问题解决"><a href="#代码膨胀问题解决" class="headerlink" title="代码膨胀问题解决"></a>代码膨胀问题解决</h4><p>每个业务方法对应一个兜底的方法，代码膨胀。应该<strong>统一的和自定义的分开</strong></p>
<p>解决方案：  @DefaultProperties(defaultFallback&#x3D;””) 注解</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403230331413.png" alt="image-20220403230331413"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220403230236695.png" alt="image-20220403230236695"></p>
<p>修改cloud-consumer-feign-hystrix-order80的controller </p>
<pre><code class="java">package com.atguigu.springcloud.controller;

import com.atguigu.springcloud.service.PaymentHystrixService;
import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;

@RestController
@Slf4j
@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)
public class OrderHystrixController &#123;

    @Resource
    private PaymentHystrixService paymentHystrixService;

    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    @GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentHystrixService.paymentInfo_OK(id);
        log.info(&quot;*******result:&quot;+result);
        return result;
    &#125;

    @GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)
    /*@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;,commandProperties = &#123;
            @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1500&quot;)  //1.5秒钟以内就是正常的业务逻辑
    &#125;)*/
    @HystrixCommand //这种没有指明的就会用全局fallback
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id)&#123;
        String result = paymentHystrixService.paymentInfo_TimeOut(id);
        return result;
    &#125;

    //兜底方法
    public String paymentTimeOutFallbackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123;
        return &quot;我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)&quot;;
    &#125;

    /**
     * 全局fallback
     *
     * @return
     */
    public String payment_Global_FallbackMethod() &#123;
        return &quot;Global异常处理信息,请稍后重试.o(╥﹏╥)o&quot;;
    &#125;

&#125;
</code></pre>
<p>测试</p>
<pre><code>http://localhost/consumer/payment/hystrix/timeout/1   正常
http://localhost/consumer/payment/hystrix/timeout/3   超时，走全局fallback
</code></pre>
<h4 id="代码耦合度的问题"><a href="#代码耦合度的问题" class="headerlink" title="代码耦合度的问题"></a>代码耦合度的问题</h4><p>服务降级,客户端去调用服务端,碰上服务端宕机或关闭</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404160740103.png" alt="image-20220404160740103"></p>
<p>本次案例服务降级处理是在客户端80实现完成,与服务端8001没有关系  只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦。</p>
<blockquote>
<p> 也就是说只修改cloud-consumer-feign-hystrix-order80模块即可</p>
</blockquote>
<ul>
<li>PaymentHystrixService接口是远程调用pay模块的,我们这里创建一个类实现PaymentHystrixService接口,在实现类中统一处理异常</li>
</ul>
<pre><code class="java">package com.atguigu.springcloud.service;

import org.springframework.stereotype.Service;

@Service
public class PaymentFallbackService implements  PaymentHystrixService&#123;
    //这个类来实现fallback
    @Override
    public String paymentInfo_OK(Integer id) &#123;
        return &quot;实现类PaymentFallbackService  paymentInfo_OK&quot;;
    &#125;

    @Override
    public String paymentInfo_TimeOut(Integer id) &#123;
        return &quot;实现类PaymentFallbackService  paymentInfo_TimeOut&quot;;
    &#125;
&#125;
</code></pre>
<ul>
<li>让PayService的实现类生效</li>
</ul>
<pre><code class="java">@Component
@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = PaymentFallbackService.class) //就是在这里fallback
public interface PaymentHystrixService &#123;
    @GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)
    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);

    @GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)
    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);
&#125;
</code></pre>
<p>测试</p>
<pre><code>http://localhost/consumer/payment/hystrix/timeout/3 走PaymentFallbackService里的fallback
http://localhost/consumer/payment/hystrix/timeout/1 正常返回
</code></pre>
<p><strong>这样虽然解决了代码耦合度问题,但是又出现了过多重复代码的问题,每个方法都有一个降级方法</strong></p>
<h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>概念</p>
<ul>
<li>断路器：一句话就是家里的保险丝</li>
<li>熔断</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404163210814.png" alt="image-20220404163210814"></p>
<p>修改cloud-provider-hystrix-payment8001</p>
<ul>
<li>cloud-provider-hystrix-payment8001的PaymentService新建下面方法</li>
</ul>
<pre><code class="java">//---服务的熔断
    @HystrixCommand(
            fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;
            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;), //是否开启断路器
            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;), //请求次数
            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), //时间窗口期
            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),//失败率达到多少后跳闸

    &#125;
    )
    //这里属性整体意思是:10秒之内(窗口,会移动),如果并发==超过==10个,或者10个并发中,失败了6个,就开启熔断器
    public String paymentCircuitBreaker(Integer id) &#123;
        if (id&lt;0) &#123;
            throw new RuntimeException(&quot;******id不能为负数&quot;);
        &#125;
        //IdUtil是Hutool包下的类,这个Hutool就是整合了常用方法
        String simpleUUID = IdUtil.simpleUUID();
        return Thread.currentThread().getName()+&quot;\t&quot; + &quot;成功调用，流水号是：&quot; + simpleUUID;
    &#125;

    public String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) Integer id) &#123;
        return &quot;id不能为负数，请稍后再试............&quot;+id;
    &#125;
</code></pre>
<ul>
<li>cloud-provider-hystrix-payment8001的PaymentController新建方法</li>
</ul>
<pre><code class="java"> //测试熔断
    @GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)
    public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id) &#123;
        String result = paymentService.paymentCircuitBreaker(id);
        log.info(&quot;*******result:&quot;+result);
        return result;
    &#125;
</code></pre>
<p>测试</p>
<pre><code>http://localhost:8001/payment/circuit/31   正确
http://localhost:8001/payment/circuit/-31  错误

多次访问,并且错误率超过60%,此时服务熔断,此时即使访问正确的也会报错.
但是,当过了几秒后,又恢复了.
因为在10秒窗口期内,它自己会尝试接收部分请求,发现服务可以正常调用,慢慢的当错误率低于60%,取消熔断.
</code></pre>
<p>》Hystrix所有可配置的属性</p>
<p>**全部在这个方法中记录,以成员变量的形式记录,**以后需要什么属性,查看这个类即可</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404165558262.png" alt="image-20220404165558262"></p>
<h4 id="原理-x2F-总结"><a href="#原理-x2F-总结" class="headerlink" title="原理&#x2F;总结"></a>原理&#x2F;总结</h4><ul>
<li>大神结论</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404165630986.png" alt="image-20220404165630986"></p>
<ul>
<li>熔断类型</li>
</ul>
<pre><code>熔断打开: 请求不再调用当前服务,内部设置一般为MTTR(平均故障处理时间),当打开长达导所设时钟则进入半熔断状态

熔断关闭: 熔断关闭后不会对服务进行熔断

熔断半开: 部分请求根据规则调用当前服务,如果请求成功且符合规则则认为当前服务恢复正常,关闭熔断
</code></pre>
<ul>
<li>熔断流程(其实就是大神结论 的图)</li>
</ul>
<pre><code>断路器的打开和关闭,是按照一下5步决定的
      1,并发此时是否达到我们指定的阈值
      2,错误百分比,比如我们配置了60%,那么如果并发请求中,10次有6次是失败的,就开启断路器
      3,上面的条件符合,断路器改变状态为open(开启)
      4,这个服务的断路器开启,所有请求无法访问
      5,在我们的时间窗口期,期间,尝试让一些请求通过(半开状态),如果请求还是失败,证明断路器还是开启状态,服务没有恢复,如果请求成功了,证明服务已经恢复,断路器状态变为close关闭状态
</code></pre>
<ul>
<li>断路器开启或者关闭的条件</li>
</ul>
<pre><code>1.当满足一定的阈值的时候(默认10秒钟超过20个请求次数)
2.当失败率达到一定的时候(默认10秒内超过50%的请求次数)
3.到达以上阈值,断路器将会开启
4.当开启的时候,所有请求都不会进行转发
5.一段时间之后(默认5秒),这个时候断路器是半开状态,会让其他一个请求进行转发. 如果成功,断路器会关闭,若失败,继续开启.重复4和5
</code></pre>
<ul>
<li>断路器打开之后</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404170333355.png" alt="image-20220404170333355"></p>
<h3 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h3><p>后面高级篇讲解alibaba的Sentinel说明</p>
<h3 id="hystrix工作流程"><a href="#hystrix工作流程" class="headerlink" title="hystrix工作流程"></a>hystrix工作流程</h3><pre><code>1请求进来,首先查询缓存,如果缓存有,直接返回
      如果缓存没有,---&gt;2
2,查看断路器是否开启,如果开启的,Hystrix直接将请求转发到降级返回,然后返回
      如果断路器是关闭的,
                判断线程池等资源是否已经满了,如果已经满了
                      也会走降级方法
              如果资源没有满,判断我们使用的什么类型的Hystrix,决定调用构造方法还是run方法
        然后处理请求
        然后Hystrix将本次请求的结果信息汇报给断路器,因为断路器此时可能是开启的
                      (因为断路器开启也是可以接收请求的)
                断路器收到信息,判断是否符合开启或关闭断路器的条件,
                如果本次请求处理失败,又会进入降级方法
        如果处理成功,判断处理是否超时,如果超时了,也进入降级方法
        最后,没有超时,则本次请求处理成功,将结果返回给controller
</code></pre>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404170605986.png" alt="image-20220404170605986"></p>
<h3 id="服务监控hystrixDashboard"><a href="#服务监控hystrixDashboard" class="headerlink" title="服务监控hystrixDashboard"></a>服务监控hystrixDashboard</h3><p>概述</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404170708635.png" alt="image-20220404170708635"></p>
<p>第一步：新建cloud-consumer-hystrix-dashboard9001 监控服务</p>
<ul>
<li>cloud-consumer-hystrix-dashboard9001的pom.xml</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;!--hystrix dashboard--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--监控--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloud-consumer-hystrix-dashboard9001的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 9001
</code></pre>
<ul>
<li>cloud-consumer-hystrix-dashboard9001的主启动</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;

@SpringBootApplication
@EnableHystrixDashboard   //加上这个注解
public class HystrixDashboardMain9001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(HystrixDashboardMain9001.class);
    &#125;
&#125;
</code></pre>
<ul>
<li>所有Provider微服务提供类(8001&#x2F;8002&#x2F;8003)都需要监控依赖部署</li>
</ul>
<pre><code class="xml"> &lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>第二步：修改cloud-provider-hystrix-payment8001的主启动</p>
<pre><code class="java">import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
@EnableEurekaClient
@EnableCircuitBreaker  //激活hystrix
public class PaymentHystrixMain8001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentHystrixMain8001.class,args);
    &#125;

    /**
     * 此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑
     * ServletRegistrationBean因为springboot的默认路径不是/hystrix.stream
     * 只要在自己的项目里配置下面的Servlet就可以了
     * @return
     */
    @Bean
    public ServletRegistrationBean getServlet() &#123;
        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
        registrationBean.setLoadOnStartup(1);
        registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);
        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);
        return registrationBean;
    &#125;
&#125;
</code></pre>
<p>监控测试</p>
<pre><code>1.启动eureka
2.启动cloud-provider-hystrix-payment8001
3.启动cloud-consumer-hystrix-dashboard9001

访问地址：http://localhost:9001/hystrix
填写地址：http://localhost:8001/hystrix.stream
</code></pre>
<p>在web界面,指定9001要监控8001</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404173133297.png" alt="image-20220404173133297"></p>
<p>就可以看到监控的信息了</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404173209440.png" alt="image-20220404173209440"></p>
<p>监控说明：7色+1圈+1线</p>
<p>整图说明</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404173414768.png" alt="image-20220404173414768"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404173349194.png" alt="image-20220404173349194"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220404173440126.png" alt="image-20220404173440126"></p>
<h2 id="Gateway新一代网关"><a href="#Gateway新一代网关" class="headerlink" title="Gateway新一代网关"></a>Gateway新一代网关</h2><p><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">Gateway官网</a></p>
<h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405102713103.png" alt="image-20220405102713103"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405103022721.png" alt="image-20220405103022721"></p>
<p><strong>gateway之所以性能好,因为底层使用WebFlux,而webFlux底层使用netty通信(NIO)</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405102822498.png" alt="image-20220405102822498"></p>
<h3 id="GateWay的特性"><a href="#GateWay的特性" class="headerlink" title="GateWay的特性"></a>GateWay的特性</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405103236241.png" alt="image-20220405103236241"></p>
<h3 id="GateWay与zuul的区别"><a href="#GateWay与zuul的区别" class="headerlink" title="GateWay与zuul的区别"></a>GateWay与zuul的区别</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405103409891.png" alt="image-20220405103409891"></p>
<h3 id="Zuul1-x模型"><a href="#Zuul1-x模型" class="headerlink" title="Zuul1.x模型"></a>Zuul1.x模型</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405103533745.png" alt="image-20220405103533745"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405103553800.png" alt="image-20220405103553800"></p>
<h3 id="GateWay三大核心概念"><a href="#GateWay三大核心概念" class="headerlink" title="GateWay三大核心概念"></a>GateWay三大核心概念</h3><ul>
<li><p>Route(路由) ：路由是构建网关的基本模块,它由ID,目标URI,一系列的断言和过滤器组成,如断言为true则匹配该路由（<strong>就是根据某些规则,将请求发送到指定服务上</strong>）</p>
</li>
<li><p>Predicate(断言)： 参考的是Java8的java.util.function.Predicate。开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数),如果请求与断言相匹配则进行路由</p>
</li>
<li><p>Filter(过滤)： 指的是Spring框架中GatewayFilter的实例,使用<strong>过滤器</strong>,可以在请求被路由前或者之后对请求进行修改.</p>
</li>
</ul>
<h3 id="Gateway工作流程"><a href="#Gateway工作流程" class="headerlink" title="Gateway工作流程"></a>Gateway工作流程</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405104258807.png" alt="image-20220405104258807"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405104309788.png" alt="image-20220405104309788"></p>
<p>核心逻辑：<strong>路由转发+执行过滤器链</strong></p>
<h3 id="入门配置"><a href="#入门配置" class="headerlink" title="入门配置"></a>入门配置</h3><p>需求：目前不想暴露8001端口，希望在8001外面套一层9527，通过访问9527来间接的访问8001.</p>
<p>新建Module     cloud-gateway-gateway9527</p>
<ul>
<li>cloud-gateway-gateway9527的pom.xml</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--引入公共依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloud-gateway-gateway9527的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 9527
spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      routes:
        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001   #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**   #断言,路径相匹配的进行路由

        - id: payment_routh2
          uri: http://localhost:8001
          predicates:
            - Path=/payment/lb/**   #断言,路径相匹配的进行路由

eureka:
  instance:
    hostname: cloud-gateway-service
  client:
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka
</code></pre>
<ul>
<li>cloud-gateway-gateway9527的主启动类</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class GateWayMain9527 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run( GateWayMain9527.class,args);
    &#125;
&#125;
</code></pre>
<p>测试:启动7001、8001、9527</p>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:9527/payment/get/31%E5%92%8C%E8%AE%BF%E9%97%AEhttp://localhost:8001/payment/get/31%E6%95%88%E6%9E%9C%E4%B8%80%E6%A0%B7">http://localhost:9527/payment/get/31和访问http://localhost:8001/payment/get/31效果一样</a></p>
<p>于是就可以验证网关的效果了</p>
<p>访问说明</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405110939286.png" alt="image-20220405110939286"></p>
<p>Gateway网关路由有两种配置方式</p>
<p>第一种：在配置文件yml中配置（上面的操作便是）</p>
<p>第二种：代码中注入RouteLocator的Bean(不推荐)</p>
<pre><code class="java">import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GateWayConfig &#123;

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) &#123;
        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();
        routes.route(&quot;path_rote_atguigu&quot;, r -&gt; r.path(&quot;/guonei&quot;).uri(&quot;http://news.baidu.com/guonei&quot;)).build();
        return routes.build();
    &#125;
&#125;
</code></pre>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405111446368.png" alt="image-20220405111446368"></p>
<h3 id="通过微服务名实现动态路由"><a href="#通过微服务名实现动态路由" class="headerlink" title="通过微服务名实现动态路由"></a>通过微服务名实现动态路由</h3><p>上面的配置虽然实现了网关,但是是在配置文件中写死了要路由的地址</p>
<p>现在需要修改,不指定地址,而是根据<strong>微服务名字进行路由</strong>,我们可以在注册中心获取某组微服务的地址</p>
<p>修改网关yml的两个地方即可</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405112636796.png" alt="image-20220405112636796"></p>
<p>完整网关yml配置</p>
<pre><code class="yml">server:
  port: 9527
spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
      routes:
        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名
          #uri: http://localhost:8001   #匹配后提供服务的路由地址
          uri: lb://cloud-payment-service #需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。
          predicates:
            - Path=/payment/get/**   #断言,路径相匹配的进行路由

        - id: payment_routh2
          #uri: http://localhost:8001
          uri: lb://cloud-payment-service
          predicates:
            - Path=/payment/lb/**   #断言,路径相匹配的进行路由

eureka:
  instance:
    hostname: cloud-gateway-service
  client:
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka
</code></pre>
<blockquote>
<p>测试</p>
</blockquote>
<p>启动7001 、8001、8002、9527</p>
<p>测试地址：<a target="_blank" rel="noopener" href="http://localhost:9527/payment/get/31">http://localhost:9527/payment/get/31</a>  发现8001和8002来回调用实现了负载和动态路由</p>
<h3 id="Predicate的使用"><a href="#Predicate的使用" class="headerlink" title="Predicate的使用"></a>Predicate的使用</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405115859709.png" alt="image-20220405115859709"></p>
<p>之前在配置文件中配置了断言</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405115941620.png" alt="image-20220405115941620"></p>
<p><strong>这个断言表示,如果外部访问路径是指定路径,就路由到指定微服务上</strong></p>
<p>启动9527可以看到,这里有一个<code>Path</code>,这个是断言的一种,<code>断言的类型</code></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405120021877.png" alt="image-20220405120021877"></p>
<ul>
<li>After:    可以指定,只有在指定时间后,才可以路由到指定微服务</li>
</ul>
<pre><code>before:  与after类似,他说在指定时间之前的才可以访问
between: 需要指定两个时间,在他们之间的时间才可以访问（两个时间用逗号隔开）
</code></pre>
<p>下面配置一个After作为例子</p>
<p>9527的yml新加After的配置</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405121529030.png" alt="image-20220405121529030"></p>
<p>那么这个时间怎么得出来呢,可以通过下面的代码</p>
<pre><code class="java">public class TestDate &#123;
    public static void main(String[] args) &#123;
        ZonedDateTime zonedDateTime = ZonedDateTime.now();
        System.out.println(zonedDateTime);
    &#125;
&#125;
</code></pre>
<p>这里表示,只有在<code>2022年的4月5的12点5分5秒之后</code>访问才可以路由,在此之前的访问,都会报404</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405121444653.png" alt="image-20220405121444653"></p>
<ul>
<li>Cookie:  只有包含某些指定Cookie(key,value),的请求才可以路由</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405122108341.png" alt="image-20220405122108341"></p>
<ul>
<li>Header:  只有包含指定请求头的请求,才可以路由</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405122216820.png" alt="image-20220405122216820"></p>
<p>测试</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405122236209.png" alt="image-20220405122236209"></p>
<ul>
<li><p>Host:只有指定主机的才可以访问,</p>
<p>比如我们当前的网站的域名是<a target="_blank" rel="noopener" href="http://www.aa.com/">www.aa.com</a>  </p>
<p>那么这里就可以设置,只有用户是<a target="_blank" rel="noopener" href="http://www.aa.com的请求,才进行路由/">www.aa.com的请求,才进行路由</a></p>
<p>在application.yml配置</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405122447170.png" alt="image-20220405122447170"></p>
</li>
<li><p>Method:  只有指定请求才可以路由,比如get请求…</p>
</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405122603016.png" alt="image-20220405122603016"></p>
<ul>
<li>Path: 只有访问指定路径,才进行路由。比如访问,&#x2F;abc才路由</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405122659793.png" alt="image-20220405122659793"></p>
<ul>
<li>Query: 必须带有请求参数才可以访问</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405122753973.png" alt="image-20220405122753973"></p>
<h3 id="Filter的使用"><a href="#Filter的使用" class="headerlink" title="Filter的使用"></a>Filter的使用</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220405113408653.png" alt="image-20220405113408653"></p>
<h4 id="Spring-Cloud-Gateway的Filter"><a href="#Spring-Cloud-Gateway的Filter" class="headerlink" title="Spring Cloud Gateway的Filter"></a>Spring Cloud Gateway的Filter</h4><ul>
<li>生命周期(类比servlet的Filter)</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405113529335.png" alt="image-20220405113529335"></p>
<ul>
<li>种类</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405113611266.png" alt="image-20220405113611266"></p>
<p>GateWayFilter,单一的过滤器。<strong>与断言类似,比如闲置,请求头,只有特定的请求头才放行,反之就过滤</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405114055228.png" alt="image-20220405114055228"></p>
<ul>
<li>自定义全局GlobalFilter</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405114732641.png" alt="image-20220405114732641"></p>
<p>在cloud-gateway-gateway9527模块中新建filter包，并且新建MyLogGateWayFilter类</p>
<pre><code class="java">package com.atguigu.springcloud.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;
import java.util.Date;

@Component
@Slf4j
public class MyLogGateWayFilter implements GlobalFilter,Ordered &#123;
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;

        log.info(&quot;*********come in MyLogGateWayFilter: &quot;+new Date());
        //获取到请求参数的uname
        String uname = exchange.getRequest().getQueryParams().getFirst(&quot;uname&quot;);
        //如果uname为空就直接过滤，不走路由
        if(StringUtils.isEmpty(uname))&#123;
            log.info(&quot;*****用户名为Null 非法用户,(┬＿┬)&quot;);
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);//给人家一个回应
            return exchange.getResponse().setComplete();
        &#125;
        //uname不为空就走下一个路由
        return chain.filter(exchange);
    &#125;

    @Override
    public int getOrder() &#123;
        return 0;
    &#125;
&#125;
</code></pre>
<blockquote>
<p> 测试</p>
</blockquote>
<p>启动 7001 、8001、9527</p>
<pre><code>http://localhost:9527/payment/get/31?uname=1    带uname参数  访问正常
http://localhost:9527/payment/get/31            不带uname参数 访问不了
</code></pre>
<h2 id="Config分布式配置中心"><a href="#Config分布式配置中心" class="headerlink" title="Config分布式配置中心"></a>Config分布式配置中心</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>微服务面临的问题</p>
<pre><code>可以看到,每个微服务都需要一个配置文件,并且,如果有几个微服务都需要连接数据库
那么就需要配4次数据库相关配置,并且当数据库发生改动,那么需要同时修改4个微服务的配置文件才可以
</code></pre>
<p>所以有了springconfig配置中心</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405163736356.png" alt="image-20220405163736356"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405163800691.png" alt="image-20220405163800691"></p>
<blockquote>
<p>作用</p>
</blockquote>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405163917302.png" alt="image-20220405163917302"></p>
<h3 id="创建配置中心服务端"><a href="#创建配置中心服务端" class="headerlink" title="创建配置中心服务端"></a>创建配置中心服务端</h3><p>第一步：新建gitee仓库,提交相关文件</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405170143355.png" alt="image-20220405170143355"></p>
<p><code>config-dev.yml</code>内容(随便写点都行,主要用来区分)  prod和test的yml和下面的类似</p>
<pre><code class="yml">config:
  info: I am test,version=1
</code></pre>
<p>第二步：新建cloud-config-3344模块</p>
<ul>
<li>cloud-config-3344 的pom.xml</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloud-config-3344 的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 3344
spring:
  application:
    name: cloud-config-center
  cloud:
    config:
      server:
        git:
          uri: https://gitee.com/heliufang/springcloud-config.git # git地址
          search-paths:
            - springcloud-config #git路径
      label: master #git分支
eureka:
  client:
    service-url:
      defaultZone:  http://localhost:7001/eureka
</code></pre>
<ul>
<li>cloud-config-3344 的主启动类</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer //开启配置中心服务
public class ConfigCenterMain3344 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(ConfigCenterMain3344 .class,args);
    &#125;
&#125;
</code></pre>
<ul>
<li>配置windows的hosts</li>
</ul>
<pre><code>127.0.0.1 config-3344.com
</code></pre>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405172153643.png" alt="image-20220405172153643"></p>
<ul>
<li>测试</li>
</ul>
<pre><code>启动7001
启动3344
访问：http://config-3344.com:3344/master/config-test.yml

可以获取到git上的配置信息表示配置成功！
</code></pre>
<h4 id="读取配置文件的规则"><a href="#读取配置文件的规则" class="headerlink" title="读取配置文件的规则"></a>读取配置文件的规则</h4><p>第一种（推荐这种）</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405172901762.png" alt="image-20220405172901762"></p>
<p>第二种</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405172954026.png" alt="image-20220405172954026"></p>
<p><strong>这里默认会读取master分支,因为我们配置文件中配置了</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405173027659.png" alt="image-20220405173027659"></p>
<p>第三种：注意这个方式读取到的配置是&#x3D;&#x3D;json格式&#x3D;&#x3D;的</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405173118387.png" alt="image-20220405173118387"></p>
<p>重要配置细节总结</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220405172656195.png" alt="image-20220405172656195"></p>
<h3 id="创建配置中心客户端"><a href="#创建配置中心客户端" class="headerlink" title="创建配置中心客户端"></a>创建配置中心客户端</h3><p>新建cloud-config-client-3355模块</p>
<ul>
<li>cloud-config-client-3355的pom.xml</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;!-- 注意下面这个依赖,否则启动不了 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloud-config-client-3355的   <code>bootstrap.yml</code></li>
</ul>
<pre><code class="yml">server:
  port: 3355

spring:
  application:
    name: config-client
  cloud:
    config:
      label: master # 分支名称
      name: config # 配置文件名称
      profile: dev # 读取后缀名称    三个综合就会读取master分支上的config-dev.yml配置文件
      uri: http://localhost:3344 # 配置中心地址 地址要写对否则启动不了

eureka:
  client:
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka
</code></pre>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406140617135.png" alt="image-20220406140617135"></p>
<ul>
<li>cloud-config-client-3355的  主启动类</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class ConfigClientMain3355 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run( ConfigClientMain3355.class,args);
    &#125;
&#125;
</code></pre>
<ul>
<li>cloud-config-client-3355的  controller</li>
</ul>
<pre><code class="java">@RestController
public class ConfigClientController &#123;

    @Value(&quot;$&#123;config.info&#125;&quot;)
    private String configInfo;

    @GetMapping(&quot;/configInfo&quot;)
    public String getConfigInfo()&#123;
        return configInfo;
    &#125;
&#125;
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code>启动：7001、3344、3355
直接通过配置中心访问git上面的信息：  http://config-3344.com:3344/master/config-test.yml
3355来通过3344来访问git上面的信息： http://localhost:3355/configInfo
</code></pre>
<p>测试结论：成功实现了客户端3355访问SpringCloud Config3344通过git获取配置信息</p>
<h3 id="Config客户端之动态刷新"><a href="#Config客户端之动态刷新" class="headerlink" title="Config客户端之动态刷新"></a>Config客户端之动态刷新</h3><p>Linux运维修改git上的配置文件内容做调整</p>
<p>刷新3344，发现ConfigServer配置中心立刻响应</p>
<p>刷新3355，发现ConfigServer客户端没有任何响应</p>
<p>3355没有变化除非自己重启或者重新加载</p>
<p>难道每次运维修改配置文件，客户端都需要重启？？噩梦</p>
<ul>
<li>cloud-config-client-3355的yml增加配置</li>
</ul>
<pre><code class="yml"># 配置动态刷新
management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;
</code></pre>
<ul>
<li>cloud-config-client-3355的pom.xml中要加入下面依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>cloud-config-client-3355的<code>ConfigClientController</code>加上<code>@RefreshScope</code>注解</li>
</ul>
<pre><code class="java">import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RefreshScope //开启刷新
public class ConfigClientController &#123;

    @Value(&quot;$&#123;config.info&#125;&quot;)
    private String configInfo;

    @GetMapping(&quot;/configInfo&quot;)
    public String getConfigInfo()&#123;
        return configInfo;
    &#125;
&#125;
</code></pre>
<p>测试</p>
<pre><code>启动7001、3344、3355

http://config-3344.com:3344/master/config-dev.yml   ok

http://localhost:3355/configInfo  git上提交修改后还是没有刷新？？

需要发送一个post请求： curl -X POST &quot;http://localhost:3355/actuator/refresh&quot;

此时再测试  http://localhost:3355/configInfo 发现刷新成功了
</code></pre>
<p>具体流程就是:</p>
<p>​            我们启动好服务后</p>
<p>​            运维人员,修改了配置文件,然后发送一个post请求通知3355</p>
<p>​            3355就可以获取最新配置文件</p>
<p><strong>问题:</strong></p>
<p>​        如果有多个客户端怎么办(3355,3356,3357…..)</p>
<p>​                        虽然可以使用shell脚本,循环刷新</p>
<p>​        但是,可不可以使用广播,一次通知??</p>
<p>​                    这些springconfig做不到,需要使用springcloud Bus消息总线</p>
<h2 id="Bus-消息总线"><a href="#Bus-消息总线" class="headerlink" title="Bus 消息总线"></a>Bus 消息总线</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220406162546409.png" alt="image-20220406162546409"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406162610509.png" alt="image-20220406162610509"></p>
<p>注意：上面的两图片,就代表两种广播方式（推荐第二种）</p>
<p>​            图1:        <strong>它是Bus直接通知给其中一个客户端,由这个客户端开始蔓延,传播给其他所有客户端</strong></p>
<p>​            图2:        它<strong>是通知给配置中心的服务端,有服务端广播给所有客户端</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406162646126.png" alt="image-20220406162646126"></p>
<h3 id="RabbitMQ环境配置"><a href="#RabbitMQ环境配置" class="headerlink" title="RabbitMQ环境配置"></a>RabbitMQ环境配置</h3><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/y-web/p/13692626.html">RabbitMQ安装</a></p>
<p>访问：<a target="_blank" rel="noopener" href="http://localhost:15672/">http://localhost:15672/</a></p>
<p>账号密码都是guest</p>
<h3 id="动态刷新之全局广播"><a href="#动态刷新之全局广播" class="headerlink" title="动态刷新之全局广播"></a>动态刷新之全局广播</h3><p>必须先具备良好的RabbitMQ环境</p>
<p>演示广播效果，增加复杂度，再以3355为模板再制作一个3366</p>
<p>&lt;1&gt;给cloud-config-center-3344配置中心服务端添加消息总线支持</p>
<ul>
<li>cloud-config-center-3344的pom增加下面 依赖 amqp</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>cloud-config-center-3344的yml增加下面的配置</li>
</ul>
<pre><code class="yml">rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest

management:
  endpoints:
    web:
      exposure:
        include: &#39;bus-refresh&#39;
</code></pre>
<p>&lt;2&gt;给cloud-config-client-3355客户端添加消息总线支持</p>
<ul>
<li>cloud-config-client-3355客户端的pom 增加amqp</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>cloud-config-client-3355客户端的yml 添加rabbitmq的配置</li>
</ul>
<pre><code class="yml">rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
</code></pre>
<p>&lt;3&gt;给cloud-config-client-3366客户端添加消息总线支持  参考上面的3355</p>
<p><strong>测试</strong></p>
<p>启动7001,3344,3355,3366</p>
<p>此时修改git上的配置文件</p>
<p>此时只需要刷新3344,即可让3355,3366动态获取最新的配置文件</p>
<pre><code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh&quot;


http://localhost:3355/configInfo
http://localhost:3366/configInfo
</code></pre>
<p>其原理就是:<strong>所有客户端都监听了一个rabbitMq的topic,我们将信息放入这个topic,所有客户端都可以送到,从而实时更新</strong></p>
<h3 id="动态刷新之定点通知"><a href="#动态刷新之定点通知" class="headerlink" title="动态刷新之定点通知"></a>动态刷新之定点通知</h3><ol>
<li><p>就是只通知部分服务,比如只通知3355,不通知3366</p>
</li>
<li><p>公式：<a href="http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}">http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}</a></p>
</li>
<li><p>&#x2F;bus&#x2F;refresh请求不再发送到具体的服务实例上，而是发给config server并通过destination参数类指定需要更新配置的服务或实例</p>
</li>
</ol>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406172021082.png" alt="image-20220406172021082"></p>
<pre><code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh/config-client:3355&quot;
</code></pre>
<h2 id="Stream消息驱动"><a href="#Stream消息驱动" class="headerlink" title="Stream消息驱动"></a>Stream消息驱动</h2><p>现在一个很项目可能分为三部分:<br>            前端—&gt;后端—-&gt;大数据<br>            而后端开发使用消息中间件,可能会使用RabbitMq<br>            而大数据开发,一般都是使用Kafka,<br>            那么一个项目中有多个消息中间件,对于程序员,因为人员都不友好</p>
<p>而Spring Cloud Stream就类似jpa,屏蔽底层消息中间件的差异,程序员主要操作Spring Cloud Stream即可</p>
<p>​            不需要管底层是kafka还是rabbitMq</p>
<h2 id="Sleuth分布式请求链路追踪"><a href="#Sleuth分布式请求链路追踪" class="headerlink" title="Sleuth分布式请求链路追踪"></a>Sleuth分布式请求链路追踪</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220406173528868.png" alt="image-20220406173528868"></p>
<p>Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406180455437.png" alt="image-20220406180455437"></p>
<p><strong>可以看到,类似链表的形式</strong></p>
<h3 id="搭建链路监控"><a href="#搭建链路监控" class="headerlink" title="搭建链路监控"></a>搭建链路监控</h3><h4 id="安装zipkin"><a href="#安装zipkin" class="headerlink" title="安装zipkin"></a>安装zipkin</h4><p>下载： <a target="_blank" rel="noopener" href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/</a></p>
<p><strong>运行jar包</strong></p>
<p>​            java -jar xxxx.jar</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406180253904.png" alt="image-20220406180253904"></p>
<p><strong>然后就可以访问web界面,  默认zipkin监听的端口是9411</strong></p>
<p>​            localhost:9411&#x2F;zipkin&#x2F;</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406180341322.png" alt="image-20220406180341322"></p>
<h4 id="使用sleuth"><a href="#使用sleuth" class="headerlink" title="使用sleuth"></a>使用sleuth</h4><p>不需要额外创建项目,使用之前的8001和order的80即可</p>
<p>&lt;1&gt;修改cloud-provider-payment8001模块</p>
<ul>
<li>cloud-provider-payment8001模块pom</li>
</ul>
<pre><code class="xml">&lt;!--包含了sleuth+zipkin--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<ul>
<li>cloud-provider-payment8001模块yml 添加下面的配置</li>
</ul>
<pre><code class="yml">zipkin:
    base-url: http://localhost:9411 #指定zipkin地址
  sleuth:
    sampler:
      probability: 1 # 采样率介于0-1之间，1表示全部采集
</code></pre>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406182402336.png" alt="image-20220406182402336"></p>
<p>&lt;2&gt;修改cloud-consumer-order80模块</p>
<p>和上面的&lt;1&gt;一样</p>
<p>&lt;3&gt;测试</p>
<p>启动7001.8001,80,9411</p>
<p>先访问：<a target="_blank" rel="noopener" href="http://localhost/consumer/payment/get/31">http://localhost/consumer/payment/get/31</a>  调用一次</p>
<p>然后在zipkin中就可以看到相关信息了</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406182618713.png" alt="image-20220406182618713"></p>
<h2 id="Spring-Cloud-Alibaba入门简介"><a href="#Spring-Cloud-Alibaba入门简介" class="headerlink" title="Spring Cloud Alibaba入门简介"></a>Spring Cloud Alibaba入门简介</h2><p>之所以有Spring Cloud Alibaba,是因为Spring Cloud Netflix项目进入维护模式</p>
<p>​        <strong>也就是,就不是不更新了,不会开发新组件了</strong></p>
<p>​        <strong>所以,某些组件都有代替版了,比如Ribbon由Loadbalancer代替,等等</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406205040717.png" alt="image-20220406205040717"></p>
<p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-alibaba#overview">Spring Cloud Alibaba官网</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">Spring Cloud Alibaba官网中文</a></p>
<p>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<p>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>
<p>RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p>
<p>Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。</p>
<p>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p>
<p>Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</p>
<p>Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p>
<p>Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</p>
<p>Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</p>
<h2 id="Nacos服务注册和配置中心"><a href="#Nacos服务注册和配置中心" class="headerlink" title="Nacos服务注册和配置中心"></a>Nacos服务注册和配置中心</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&lt;1&gt;前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service</p>
<p>&lt;2&gt;一个更易于构建云原生应用的动态服务发现，配置管理和服务管理中心</p>
<p>&lt;3&gt;Nacos就是注册中心+配置中心的组合，  Nacos &#x3D; Eureka+Config+Bus</p>
<p>&lt;4&gt;替代Eureka做服务注册中心,替代Config做服务配置中心</p>
<p>下载nacos</p>
<p><a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/index.html">https://nacos.io/zh-cn/index.html</a></p>
<h3 id="安装运行Nacos"><a href="#安装运行Nacos" class="headerlink" title="安装运行Nacos"></a>安装运行Nacos</h3><p>本地Java8+Maven环境已经OK</p>
<p>先从官网下载Nacos：<a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases/tag/1.1.4">https://github.com/alibaba/nacos/releases/tag/1.1.4</a></p>
<p>解压安装包，直接运行bin目录下的startup.cmd</p>
<p>命令运行成功后直接访问<a target="_blank" rel="noopener" href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> （默认账号密码都是nacos）</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406211600106.png" alt="image-20220406211600106"></p>
<h3 id="Nacos作为注册中心"><a href="#Nacos作为注册中心" class="headerlink" title="Nacos作为注册中心"></a>Nacos作为注册中心</h3><p>​    <strong>现在不需要额外的服务注册模块了,Nacos单独启动了</strong></p>
<p>&lt;1&gt;新建cloudalibaba-provider-payment9001模块 (服务提供者)</p>
<ul>
<li>父工程的pom引入下面的依赖</li>
</ul>
<pre><code class="xml">&lt;!--  spring cloud alibaba 2.1.0.RELEASE    --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
    &lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>cloudalibaba-provider-payment9001模块的pom</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
         &lt;!--服务的注册与发现--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;&lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.62&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloudalibaba-provider-payment9001模块的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 9001

spring:
  application:
    name: nacos-payment-provider
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #配置Nacos地址

management:
  endpoints:
    web:
      exposure:
        include: &#39;*&#39;
</code></pre>
<ul>
<li>cloudalibaba-provider-payment9001模块的主启动类</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication
public class PaymentMain9001 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain9001.class,args);
    &#125;
&#125;
</code></pre>
<ul>
<li>cloudalibaba-provider-payment9001模块的controller</li>
</ul>
<pre><code class="java">import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;


@RestController
public class PaymentController
&#123;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    @GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)
    public String getPayment(@PathVariable(&quot;id&quot;) Integer id)
    &#123;
        return &quot;nacos registry, serverPort: &quot;+ serverPort+&quot;\t id&quot;+id;
    &#125;
&#125;
</code></pre>
<p><strong>测试</strong></p>
<p>启动9001,然后查看Nacos的web界面,可以看到9001已经注册成功</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406214745738.png" alt="image-20220406214745738">为了下面演示nacos的负载均衡，参考上面的9001模块,新建cloudalibaba-provider-payment9002模块</p>
<p>&lt;2&gt;新建cloudalibaba-consumer-nacos-order83模块 </p>
<ul>
<li>cloudalibaba-consumer-nacos-order83模块的 pom.xml</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!--SpringCloud ailibaba nacos --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
    &lt;/dependency&gt;
        &lt;dependency&gt;
        &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;
        &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order83模块的 application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 83

spring:
  application:
    name: nacos-order-consumer
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848

service-url:
  nacos-user-service: http://nacos-payment-provider # 远程调用地址
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order83模块的 主启动</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication
public class OrderNacosMain83
&#123;
    public static void main(String[] args)
    &#123;
        SpringApplication.run(OrderNacosMain83.class,args);
    &#125;
&#125;
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order83模块的 ApplicationContextConfig</li>
</ul>
<pre><code class="java">package com.atguigu.springcloud.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;


@Configuration
public class ApplicationContextConfig
&#123;
    @Bean
    @LoadBalanced //负载均衡
    public RestTemplate getRestTemplate()
    &#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order83模块的 OrderNacosController</li>
</ul>
<pre><code class="java">import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;
import javax.annotation.Resource;

@RestController
@Slf4j
public class OrderNacosController
&#123;
    @Resource
    private RestTemplate restTemplate;//远程调用

    @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)
    private String serverURL;

    @GetMapping(value = &quot;/consumer/payment/nacos/&#123;id&#125;&quot;)
    public String paymentInfo(@PathVariable(&quot;id&quot;) Long id)
    &#123;
        return restTemplate.getForObject(serverURL+&quot;/payment/nacos/&quot;+id,String.class);
    &#125;

&#125;
</code></pre>
<p><strong>测试</strong></p>
<p>启动83,访问9001,9002</p>
<p>访问：<a target="_blank" rel="noopener" href="http://localhost:83/consumer/payment/nacos/13">http://localhost:83/consumer/payment/nacos/13</a></p>
<p>可以看到,实现了轮询负载均衡</p>
<p>&lt;3&gt;Nacos与其他服务注册的对比</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406221523144.png" alt="image-20220406221523144"></p>
<p>Nacos支持AP和CP模式的切换</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220406221624134.png" alt="image-20220406221624134"></p>
<p>上面这个curl命令,就是切换模式</p>
<h3 id="Nacos作为服务配置中心"><a href="#Nacos作为服务配置中心" class="headerlink" title="Nacos作为服务配置中心"></a>Nacos作为服务配置中心</h3><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p>新建cloudalibaba-config-nacos-client3377模块</p>
<ul>
<li>cloudalibaba-config-nacos-client3377模块的pom</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!--nacos-config--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--nacos-discovery--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--web + actuator--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--一般基础配置--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloudalibaba-config-nacos-client3377模块的application.yml</li>
</ul>
<pre><code class="yml">spring:
  profiles:
    active: dev
</code></pre>
<ul>
<li>cloudalibaba-config-nacos-client3377模块的bootstrap.yml</li>
</ul>
<pre><code class="yml">server:
  port: 3377

spring:
  application:
    name: nacos-config-client
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #服务注册中心地址
      config:
        server-addr: localhost:8848 #配置中心地址
        file-extension: yaml #指定yaml格式的配置
</code></pre>
<ul>
<li>cloudalibaba-config-nacos-client3377模块的主启动类</li>
</ul>
<pre><code class="java">@EnableDiscoveryClient
@SpringBootApplication
public class NacosConfigClientMain3377 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(NacosConfigClientMain3377.class, args);
    &#125;
&#125;
</code></pre>
<ul>
<li>cloudalibaba-config-nacos-client3377模块的controller</li>
</ul>
<pre><code class="java">import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RefreshScope //开启配置自动刷新
public class ConfigClientController
&#123;
    @Value(&quot;$&#123;config.info&#125;&quot;)
    private String configInfo;

    @GetMapping(&quot;/config/info&quot;)
    public String getConfigInfo() &#123;
        return configInfo;
    &#125;
&#125;
</code></pre>
<ul>
<li>在Nacos中添加配置信息</li>
</ul>
<p><strong>配置规则,就是我们在客户端如何指定读取配置文件,配置文件的命名的规则</strong></p>
<p>默认的命名方式:</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407105231059.png" alt="image-20220407105231059"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407105243474.png" alt="image-20220407105243474"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407105557290.png" alt="image-20220407105557290"></p>
<p>在nacos的web界面上创建配置文件</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407105727354.png" alt="image-20220407105727354"></p>
<p><strong>注意</strong>: DataId就是配置文件名字,名字一定要按照上面的规则命名,否则客户端会读取不到配置文件</p>
<p><strong>测试</strong>： 重启3377客户端</p>
<pre><code>测试一： 访问：http://localhost:3377/config/info 可以成功读取到nacos上面的配置信息

测试二： 然后修改nacos上面的配置文件，发现客户端是可以立即更新的，这是因为Nacos支持Bus总线,会自动发送命令更新所有客户端
</code></pre>
<h4 id="分类配置"><a href="#分类配置" class="headerlink" title="分类配置"></a>分类配置</h4><p><img src="/2022/03/27/1513842928408203264/images/image-20220407110953525.png" alt="image-20220407110953525"></p>
<p>Nacos的图形化管理界面</p>
<p>配置管理</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407111135409.png" alt="image-20220407111135409"></p>
<p>命名空间</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407111208957.png" alt="image-20220407111208957"></p>
<p>Namespace+Group+Data ID三者关系？为什么这么设计？</p>
<p>NameSpace默认有一个:  public名称空间</p>
<p>这三个类似java的: 包名 + 类名 + 方法名</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407111346267.png" alt="image-20220407111346267"></p>
<p>&lt;1&gt;DataID方案</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407210059609.png" alt="image-20220407210059609"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407210242676.png" alt="image-20220407210242676"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407210154361.png" alt="image-20220407210154361"></p>
<p>通过配置文件,实现多环境的读取</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407210312764.png" alt="image-20220407210312764"></p>
<p><strong>测试</strong>：<a target="_blank" rel="noopener" href="http://localhost:3377/config/info">http://localhost:3377/config/info</a>  看能否成功获取到配置信息</p>
<blockquote>
<p>此时,改为dev,就会读取dev的配置文件,改为test,就会读取test的配置文件</p>
</blockquote>
<p>&lt;2&gt;Group方案</p>
<ul>
<li>通过Group实现环境区分,新建Group</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407211618099.png" alt="image-20220407211618099"></p>
<ul>
<li>在nacos图形界面控制台上面新建配置文件DataID</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407211717910.png" alt="image-20220407211717910"></p>
<ul>
<li>3377模块的bootstrap+application</li>
</ul>
<p>在config下增加一条group的配置即可。可配置为DEV_GROUP或TEST_GROUP</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407211849932.png" alt="image-20220407211849932"></p>
<p><strong>测试</strong>：<a target="_blank" rel="noopener" href="http://localhost:3377/config/info">http://localhost:3377/config/info</a>  看能否成功获取到配置信息</p>
<p>&lt;3&gt;Namespace方案</p>
<ul>
<li>新建dev&#x2F;test的Namespace</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407213513504.png" alt="image-20220407213513504"></p>
<ul>
<li>回到服务管理-服务列表查看</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407213536425.png" alt="image-20220407213536425"></p>
<ul>
<li>按照域名配置填写</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407213604591.png" alt="image-20220407213604591"></p>
<ul>
<li>bootstrap.yml和application.yml   注意 application.yml填写好dev</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407213837628.png" alt="image-20220407213837628"></p>
<p><strong>测试</strong>：<a target="_blank" rel="noopener" href="http://localhost:3377/config/info">http://localhost:3377/config/info</a>  看能否成功获取到配置信息</p>
<h3 id="Nacos集群和持久化配置"><a href="#Nacos集群和持久化配置" class="headerlink" title="Nacos集群和持久化配置"></a>Nacos集群和持久化配置</h3><h4 id="切换mysql数据库"><a href="#切换mysql数据库" class="headerlink" title="切换mysql数据库"></a>切换mysql数据库</h4><p>Nacos默认自带的是嵌入式数据库derby</p>
<p>derby到我们自己的mysql切换配置步骤</p>
<p>第一步：mysql中新建nacos-config数据库，nacos-server-1.1.4\nacos\conf目录下找到sql脚本并执行</p>
<p>第二步：修改Nacos安装目录下的安排application.properties,添加</p>
<pre><code class="properties">##################################################
spring.datasource.platform=mysql
 
db.num=1
db.url.0=jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true
db.user=root
db.password=root
</code></pre>
<p>此时可以重启nacos,那么就会改为使用我们自己的mysql</p>
<p><strong>测试</strong>：在nacos上面新建一个yaml配置  发现我们自己mysql的config_info表中多了一条数据</p>
<h4 id="Linux版Nacos-MySQL生产环境配置"><a href="#Linux版Nacos-MySQL生产环境配置" class="headerlink" title="Linux版Nacos+MySQL生产环境配置"></a>Linux版Nacos+MySQL生产环境配置</h4><p>略</p>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>一句话解释，之前我们讲解过的Hystrix。<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">官网</a></p>
<h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220407220639494.png" alt="image-20220407220639494"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407220520775.png" alt="image-20220407220520775"></p>
<h3 id="sentinel安装"><a href="#sentinel安装" class="headerlink" title="sentinel安装"></a>sentinel安装</h3><p>1&gt;下载sentinel的jar包 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">下载网址</a></p>
<p>2&gt;运行sentinel</p>
<p>​        由于是一个jar包,所以可以直接java -jar运行    </p>
<p>​        注意,默认sentinel占用8080端口</p>
<p>3&gt;访问sentinel      localhost:8080     登录的账号密码均为sentinel</p>
<h3 id="初始化演示工程"><a href="#初始化演示工程" class="headerlink" title="初始化演示工程"></a>初始化演示工程</h3><p>新建cloudalibaba-sentinel-service8401模块</p>
<ul>
<li>cloudalibaba-sentinel-service8401模块的pom</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!--引入公共依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--引入nacos依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--引入nacos-sentinel依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;
        &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;
    &lt;/dependency&gt;
     &lt;!--引入sentinel依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
        &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
        &lt;version&gt;4.6.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloudalibaba-sentinel-service8401模块的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 8401

spring:
  application:
    name: cloudalibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
    sentinel:
      transport:
        dashboard: localhost:8080
        port: 8719  #默认8719，假如被占用了会自动从8719开始依次+1扫描。直至找到未被占用的端口

management:
  endpoints:
    web:
      exposure:
        include: &#39;*&#39;
</code></pre>
<ul>
<li>cloudalibaba-sentinel-service8401模块的主启动</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication
public class MainApp8401 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(MainApp8401.class, args);
    &#125;
&#125;
</code></pre>
<ul>
<li>cloudalibaba-sentinel-service8401模块的controller</li>
</ul>
<pre><code class="java">import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class FlowLimitController &#123;
    @GetMapping(&quot;/testA&quot;)
    public String testA() &#123;
        return &quot;------testA&quot;;
    &#125;
    @GetMapping(&quot;/testB&quot;)
    public String testB() &#123;
        return &quot;------testB&quot;;
    &#125;
&#125;
</code></pre>
<p><strong>测试</strong> </p>
<p>启动nacos、sentinel、以及8401</p>
<p>访问：<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080/</a>    发现什么都没有，原因是sentinel是懒加载，需要调用一次才可以</p>
<p>于是访问：<a target="_blank" rel="noopener" href="http://localhost:8401/testA">http://localhost:8401/testA</a>    <a target="_blank" rel="noopener" href="http://localhost:8401/testB">http://localhost:8401/testB</a></p>
<p>此时再查看sentinel就有信息了,说明sentinel8080正在监控微服务8401</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220407223444396.png"></p>
<h3 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220408113311475.png" alt="image-20220408113311475"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408113536235.png" alt="image-20220408113536235"></p>
<p>&lt;1&gt;直接快速失败-<strong>QPS</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408172915366.png" alt="image-20220408172915366"></p>
<p>测试：1s发一个请求没事，快速的刷就被限流了</p>
<p>测试地址：<a target="_blank" rel="noopener" href="http://localhost:8401/testA">http://localhost:8401/testA</a></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408173132950.png" alt="image-20220408173132950"></p>
<p>&lt;2&gt;直接-<strong>线程数</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408173442690.png" alt="image-20220408173442690"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408173558591.png" alt="image-20220408173558591"></p>
<p>修改8401的controller</p>
<pre><code class="java">@GetMapping(&quot;/testA&quot;)
public String testA() &#123;
    try &#123; TimeUnit.SECONDS.sleep(2); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;
    return &quot;------testA&quot;;
&#125;
</code></pre>
<p><strong>测试</strong>：浏览器和postman各个发一个  <a target="_blank" rel="noopener" href="http://localhost:8401/testA">http://localhost:8401/testA</a>  请求，就会出现限流了</p>
<pre><code>比如a请求过来,处理很慢,在一直处理,此时b请求又过来了
        此时因为a占用一个线程,此时要处理b请求就只有额外开启一个线程
        那么就会报错
</code></pre>
<p>&lt;3&gt;关联-<strong>快速失败</strong></p>
<p>应用场景:  比如<strong>支付接口</strong>达到阈值,就要限流下<strong>订单的接口</strong>,防止一直有订单</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408174255511.png" alt="image-20220408174255511"></p>
<p><strong>当testB达到阈值,qps大于1,就让testA之后的请求直接失败</strong></p>
<p>可以使用postman压测</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408174520683.png" alt="image-20220408174520683"></p>
<p>&lt;4&gt;链路</p>
<p>多个请求调用了同一个微服务</p>
<p>&lt;5&gt;预热Warm up</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408180006425.png" alt="image-20220408180006425"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408180021903.png" alt="image-20220408180021903"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408180042637.png" alt="image-20220408180042637"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408180104783.png" alt="image-20220408180104783"></p>
<p>应用场景</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408180157218.png" alt="image-20220408180157218"></p>
<p><strong>测试</strong>:  前5s阈值是3，所以浏览器快速的刷  <a target="_blank" rel="noopener" href="http://localhost:8401/testB">http://localhost:8401/testB</a> 被限流了，经过5s后阈值慢慢的加到10了就不报限流错误，除非阈值超过10.</p>
<p>&lt;6&gt;排队等待</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408181813746.png" alt="image-20220408181813746"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408181844849.png" alt="image-20220408181844849"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408181921992.png" alt="image-20220408181921992"></p>
<h3 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h3><p><strong>就是熔断降级</strong> </p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408183707198.png" alt="image-20220408183707198"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408183740371.png" alt="image-20220408183740371"></p>
<p>&lt;1&gt;RT配置（秒级）</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408184419499.png" alt="image-20220408184419499"></p>
<p>第一步：8401的controller新增一个请求方法用于测试</p>
<pre><code class="java">@GetMapping(&quot;/testD&quot;)
public String testD() &#123;
    try &#123; TimeUnit.SECONDS.sleep(1); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;
    return &quot;------testD&quot;;
&#125;
</code></pre>
<p>第二步：配置的PT,默认是秒级的平均响应时间</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408185256797.png" alt="image-20220408185256797"></p>
<p>默认计算平均时间是: 1秒类进入5个请求,并且响应的平均值超过阈值(这里的200ms),就报错</p>
<p>1秒5请求是Sentinel默认设置的</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408185344799.png" alt="image-20220408185344799"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408185401867.png" alt="image-20220408185401867"></p>
<p>默认熔断后.就直接抛出异常</p>
<p>&lt;2&gt;异常比例(秒级)</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408205303408.png" alt="image-20220408205303408"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408205310655.png" alt="image-20220408205310655"></p>
<p>修改8401的controller方法</p>
<pre><code class="java">@GetMapping(&quot;/testD&quot;)
public String testD() &#123;
    //try &#123; TimeUnit.SECONDS.sleep(1); &#125;catch (Exception e) &#123;e.printStackTrace();&#125;
    int i = 1/0;//异常比例为100%
    return &quot;------testD&quot;;
&#125;
</code></pre>
<p>配置sentinel</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408205555725.png" alt="image-20220408205555725"></p>
<p>配置jMeter</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408211201573.png" alt="image-20220408211201573"></p>
<p><strong>测试</strong></p>
<p>没触发熔断,正常抛出异常(先不开jmeter就是这样)</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408211259778.png" alt="image-20220408211259778"></p>
<p>触发熔断(开启jmeter)</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408211340920.png" alt="image-20220408211340920"></p>
<p>测试结论</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408211505660.png" alt="image-20220408211505660"></p>
<p>&lt;3&gt;异常数</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408211534177.png" alt="image-20220408211534177"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408211545405.png" alt="image-20220408211545405"></p>
<p>8401的controller添加一个方法</p>
<pre><code class="java">@GetMapping(&quot;/testE&quot;)
public String testE()&#123;
    int age = 10/0;
    return &quot;------testE 测试异常数&quot;;
&#125;
</code></pre>
<p>配置sentinel</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408212008073.png" alt="image-20220408212008073"></p>
<h3 id="热点key限流"><a href="#热点key限流" class="headerlink" title="热点key限流"></a>热点key限流</h3><p><img src="/2022/03/27/1513842928408203264/images/image-20220408220159366.png" alt="image-20220408220159366"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408220233895.png" alt="image-20220408220233895"></p>
<p>比如:</p>
<p>​            localhost:8080&#x2F;aa?name&#x3D;aa</p>
<p>​            localhost:8080&#x2F;aa?name&#x3D;bb</p>
<p>​            加入两个请求中,带有参数aa的请求访问频次非常高,我们就现在name&#x3D;&#x3D;aa的请求,但是bb的不限制</p>
<p>如何自定义降级方法,而不是默认的抛出异常?</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408220334186.png" alt="image-20220408220334186"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408220403106.png" alt="image-20220408220403106"></p>
<pre><code class="java"> @GetMapping(&quot;/testHotKey&quot;)
@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;deal_testHotKey&quot;)
//@SentinelResource(value = &quot;testHotKey&quot;)
public String testHotKey(@RequestParam(value = &quot;p1&quot;,required = false) String p1,
                         @RequestParam(value = &quot;p2&quot;,required = false) String p2) &#123;
    //int age = 10/0;//sentinel只对sentinel热点规则处理，不会对这个处理
    return &quot;------testHotKey&quot;;
&#125;

//兜底方法
public String deal_testHotKey (String p1, String p2, BlockException exception)&#123;
    return &quot;------deal_testHotKey,o(╥﹏╥)o&quot;;
&#125;
</code></pre>
<p>定义热点规则</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408220538753.png" alt="image-20220408220538753"></p>
<p><strong>测试1.此时我们访问&#x2F;testHotkey并且带上p1参数</strong>，如果qps大于1,就会触发我们定义的降级方法</p>
<p><strong>测试2.此时我们访问&#x2F;testHotkey并且不带上p1参数</strong>，就没事</p>
<p>只有带了p1,才可能会触发热点限流</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408220834527.png" alt="image-20220408220834527"></p>
<p><strong>设置热点规则中的其他选项</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408221314106.png" alt="image-20220408221314106"></p>
<p>添加配置</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408221419827.png" alt="image-20220408221419827"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408221955917.png" alt="image-20220408221955917"></p>
<p><strong>注意:</strong> 参数类型只支持,8种基本类型+String类</p>
<p><strong>注意</strong>:</p>
<p>如果我们程序出现异常,是不会走blockHander的降级方法的,因为这个方法只配置了热点规则,没有配置限流规则</p>
<p>我们这里配置的降级方法是sentinel针对热点规则配置的</p>
<p>只有触发热点规则才会降级</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408222133092.png" alt="image-20220408222133092"></p>
<h3 id="系统规则-不推荐-太暴力了"><a href="#系统规则-不推荐-太暴力了" class="headerlink" title="系统规则(不推荐,太暴力了)"></a>系统规则(不推荐,太暴力了)</h3><p>系统自适应限流:<br>从整体维度对应用入口进行限流</p>
<p>对整体限流,比如设置qps到达100,这里限流会限制整个系统(<em>不友好，影响整体性能</em>)</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408222634882.png" alt="image-20220408222634882"></p>
<p>配置全局QPS</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408222722996.png" alt="image-20220408222722996"></p>
<p><strong>测试</strong>:  阈值超过一每个请求都被限流了</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408222938838.png" alt="image-20220408222938838"></p>
<h3 id="SentinelResource注解"><a href="#SentinelResource注解" class="headerlink" title="SentinelResource注解"></a>SentinelResource注解</h3><p>&lt;1&gt;按资源名称限流+后续处理</p>
<p>以前流控异常会抛出下面的异常，现在是想改成自定义的</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408231120098.png" alt="image-20220408231120098"></p>
<ul>
<li>8401新增一个controller</li>
</ul>
<pre><code class="java">import com.alibaba.csp.sentinel.annotation.SentinelResource;
import com.alibaba.csp.sentinel.slots.block.BlockException;
import com.atguigu.springcloud.entities.*;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;


@RestController
public class RateLimitController &#123;
    @GetMapping(&quot;/byResource&quot;)
    @SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)
    public CommonResult byResource() &#123;
        return new CommonResult(200,&quot;按资源名称限流测试OK&quot;,new Payment(2020L,&quot;serial001&quot;));
    &#125;
    //自定义流控异常处理
    public CommonResult handleException(BlockException exception) &#123;
        return new CommonResult(444,exception.getClass().getCanonicalName()+&quot;\t 服务不可用&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>sentinel中添加流控配置</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408231306581.png" alt="image-20220408231306581"></p>
<ul>
<li>测试： 可以看到已经进入自定义的降级方法了</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408231410515.png" alt="image-20220408231410515"></p>
<p>此时关闭8401服务,这些定义的规则是临时的,关闭服务,规则就没有了</p>
<p>&lt;2&gt;按照Url地址限流+后续处理</p>
<ul>
<li>8401的RateLimitController新增方法</li>
</ul>
<pre><code class="java">@GetMapping(&quot;/rateLimit/byUrl&quot;)
@SentinelResource(value = &quot;byUrl&quot;)
public CommonResult byUrl()&#123;
    return new CommonResult(200,&quot;按url限流测试OK&quot;,new Payment(2020L,&quot;serial002&quot;));
&#125;
</code></pre>
<ul>
<li>sentinel配置： 前面配置的是@SentinelResource的value值，而这里配置的是url，同样有效。</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220408233237294.png" alt="image-20220408233237294"></p>
<ul>
<li>测试： <a target="_blank" rel="noopener" href="http://localhost:8401/rateLimit/byUrl">http://localhost:8401/rateLimit/byUrl</a></li>
</ul>
<p><strong>可以看到,上面两个配置的降级方法,又出现Hystrix遇到的问题了</strong></p>
<p>​            降级方法与业务方法耦合</p>
<p>​            每个业务方法都需要对应一个降级方法</p>
<p>&lt;3&gt;客户自定义限流处理逻辑</p>
<ul>
<li>8401的新增CustomerBlockHandler方法</li>
</ul>
<pre><code class="java">package com.atguigu.springcloud.myhandler;

import com.alibaba.csp.sentinel.slots.block.BlockException;
import com.atguigu.springcloud.entities.*;

public class CustomerBlockHandler &#123;

    public static CommonResult handleException(BlockException exception) &#123;
        return new CommonResult(2020, &quot;自定义限流处理信息....CustomerBlockHandler&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>8401的新增RateLimitController新建下面的方法</li>
</ul>
<pre><code class="java">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)
@SentinelResource(value = &quot;customerBlockHandler&quot;,
                  blockHandlerClass = CustomerBlockHandler.class,
                  blockHandler = &quot;handleException&quot;)
public CommonResult customerBlockHandler()&#123;
    return new CommonResult(200,&quot;按客戶自定义&quot;,new Payment(2020L,&quot;serial003&quot;));
&#125;
</code></pre>
<ul>
<li>sentinel配置</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409000306772.png" alt="image-20220409000306772"></p>
<p>测试： <a target="_blank" rel="noopener" href="http://localhost:8401/rateLimit/customerBlockHandler">http://localhost:8401/rateLimit/customerBlockHandler</a></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409000344210.png" alt="image-20220409000344210"></p>
<p>配置对应的图示</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409000425790.png" alt="image-20220409000425790"></p>
<p>&lt;4&gt;SentinelResource注解的其他属性</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409000554700.png" alt="image-20220409000554700"></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409000626440.png" alt="image-20220409000626440"></p>
<h3 id="服务熔断功能"><a href="#服务熔断功能" class="headerlink" title="服务熔断功能"></a>服务熔断功能</h3><p>sentinel整合ribbon+openFeign+fallback</p>
<h4 id="Ribbon系列"><a href="#Ribbon系列" class="headerlink" title="Ribbon系列"></a>Ribbon系列</h4><p>&lt;1&gt;新建cloudalibaba-provider-payment9003模块</p>
<ul>
<li>cloudalibaba-provider-payment9003的pom</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!--SpringCloud ailibaba nacos --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;
        &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- SpringBoot整合Web组件 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--日常通用jar包配置--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloudalibaba-provider-payment9003的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 9003

spring:
  application:
    name: nacos-payment-provider
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #配置Nacos地址

management:
  endpoints:
    web:
      exposure:
        include: &#39;*&#39;
</code></pre>
<ul>
<li>cloudalibaba-provider-payment9003的controller</li>
</ul>
<pre><code class="java">import com.atguigu.springcloud.entities.CommonResult;
import com.atguigu.springcloud.entities.Payment;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import java.util.HashMap;

@RestController
public class PaymentController &#123;
    @Value(&quot;$&#123;server.port&#125;&quot;)
    private String serverPort;

    public static HashMap&lt;Long, Payment&gt; hashMap = new HashMap&lt;&gt;();
    static&#123;
        hashMap.put(1L,new Payment(1L,&quot;28a8c1e3bc2742d8848569891fb42181&quot;));
        hashMap.put(2L,new Payment(2L,&quot;bba8c1e3bc2742d8848569891ac32182&quot;));
        hashMap.put(3L,new Payment(3L,&quot;6ua8c1e3bc2742d8848569891xt92183&quot;));
    &#125;

    @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id)&#123;
        Payment payment = hashMap.get(id);
        CommonResult&lt;Payment&gt; result = new CommonResult(200,&quot;from mysql,serverPort:  &quot;+serverPort,payment);
        return result;
    &#125;

&#125;
</code></pre>
<ul>
<li>cloudalibaba-provider-payment9003的主启动</li>
</ul>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class PaymentMain9003 &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(PaymentMain9003.class, args);
    &#125;
&#125;
</code></pre>
<p>同理，参考cloudalibaba-provider-payment9003，新建cloudalibaba-provider-payment9004</p>
<p>&lt;2&gt;新建cloudalibaba-consumer-nacos-order84模块</p>
<ul>
<li>cloudalibaba-consumer-nacos-order84模块的pom</li>
</ul>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.atguigu.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;
            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order84模块的application.yml</li>
</ul>
<pre><code class="yml">server:
  port: 84

spring:
  application:
    name: nacos-order-consumer
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
    sentinel:
      transport:
        dashboard: localhost:8080
        port: 8719

service-url:
  nacos-user-service: http://nacos-payment-provider
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order84模块的config</li>
</ul>
<pre><code class="java">package com.atguigu.springcloud.config;

import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class ApplicationContextConfig &#123;
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate() &#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order84模块的controller</li>
</ul>
<pre><code class="java">import com.alibaba.csp.sentinel.annotation.SentinelResource;
import com.alibaba.csp.sentinel.slots.block.BlockException;
import com.atguigu.springcloud.entities.CommonResult;
import com.atguigu.springcloud.entities.Payment;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;
import javax.annotation.Resource;

@RestController
@Slf4j
public class CircleBreakerController &#123;

    public static final String SERVICE_URL = &quot;http://nacos-payment-provider&quot;;

    @Resource
    private RestTemplate restTemplate;

    @RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)
    //@SentinelResource(value = &quot;fallback&quot;) //没有配置-抛出错误给用户,不友好
    //@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback只负责业务异常
    //@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler只负责sentinel控制台配置违规
    @SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;,
            exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;)
    public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id) &#123;
        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + &quot;/paymentSQL/&quot;+id, CommonResult.class,id);
        if (id == 4) &#123;
            throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;);
        &#125;else if (result.getData() == null) &#123;
            throw new NullPointerException (&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;);
        &#125;
        return result;
    &#125;

    //fallback 处理业务异常
    public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) &#123;
        Payment payment = new Payment(id,&quot;null&quot;);
        return new CommonResult&lt;&gt;(444,&quot;兜底异常handlerFallback,exception内容  &quot;+e.getMessage(),payment);
    &#125;

    //blockHandler 处理sentinel控制台配置违规
    public CommonResult blockHandler(@PathVariable  Long id,BlockException blockException) &#123;
        Payment payment = new Payment(id,&quot;null&quot;);
        return new CommonResult&lt;&gt;(445,&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;+blockException.getMessage(),payment);
    &#125;

&#125;
</code></pre>
<ul>
<li>测试：启动9003,9004,84</li>
</ul>
<p>@SentinelResource的下面五种情况进行测试（修改controller中的fallback方法上面的注解注释即可）</p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409110632070.png" alt="image-20220409110632070"></p>
<p>测试结论：</p>
<p>1&gt;fallback管运行异常</p>
<p>2&gt;blockHandler管sentinel配置违规异常</p>
<p>3&gt;<strong>两个都配置blockhandler优先生效</strong></p>
<p> 4&gt;exceptionsToIgnore指定一个异常类,<strong>表示如果当前方法抛出的是指定的异常,不降级,直接对用户抛出异常</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409111028119.png" alt="image-20220409111028119"></p>
<h4 id="Feign系列"><a href="#Feign系列" class="headerlink" title="Feign系列"></a>Feign系列</h4><p>主要是修改cloudalibaba-consumer-nacos-order84模块</p>
<ul>
<li>cloudalibaba-consumer-nacos-order84的pom.xml</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order84的application.yml 开启feign</li>
</ul>
<pre><code class="yml">#对Feign的支持
feign:
  sentinel:
    enabled: true
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order84新建PaymentService接口</li>
</ul>
<pre><code class="java">import com.atguigu.springcloud.entities.CommonResult;
import com.atguigu.springcloud.entities.Payment;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)
public interface PaymentService &#123;
    @GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)
    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id);
&#125;
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order84新建PaymentService接口实现类</li>
</ul>
<pre><code class="java">import com.atguigu.springcloud.entities.CommonResult;
import com.atguigu.springcloud.entities.Payment;
import org.springframework.stereotype.Component;

@Component //注意要加上这个注解
public class PaymentFallbackService implements PaymentService &#123;
    @Override
    public CommonResult&lt;Payment&gt; paymentSQL(Long id)&#123;
        return new CommonResult&lt;&gt;(44444,&quot;服务降级返回,---PaymentFallbackService&quot;,new Payment(id,&quot;errorSerial&quot;));
    &#125;
&#125;
</code></pre>
<ul>
<li>cloudalibaba-consumer-nacos-order84的controller添加下面方法</li>
</ul>
<pre><code class="java">// OpenFeign
@Resource
private PaymentService paymentService;

@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)
public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id) &#123;
    return paymentService.paymentSQL(id);
&#125;
</code></pre>
<p>测试： 如果关闭9003.看看84会不会降级，<strong>可以看到,正常降级了</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409112707584.png" alt="image-20220409112707584"></p>
<p><strong>熔断框架比较</strong></p>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409112740511.png" alt="image-20220409112740511"></p>
<h3 id="持久化规则"><a href="#持久化规则" class="headerlink" title="持久化规则"></a>持久化规则</h3><p><strong>问题：</strong>一旦我们重启应用，Sentinel规则将消失，生产环境需要将配置规则进行持久化</p>
<p><strong>解决</strong>：将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上Sentinel上的流控规则持续有效</p>
<p><strong>这里以之前的cloudalibaba-sentinel-service8401模块为案例进行修改:</strong></p>
<ul>
<li>cloudalibaba-sentinel-service8401的pom增加下面依赖</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;
    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>cloudalibaba-sentinel-service8401的application.yml</li>
</ul>
<pre><code class="yml">datasource:
        ds1:
          nacos:
            server-addr: localhost:8848
            dataId: cloudalibaba-sentinel-service
            groupId: DEFAULT_GROUP
            data-type: json
            rule-type: flow
</code></pre>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409121742167.png" alt="image-20220409121742167"></p>
<p><strong>实际上就是指定,我们的规则要保证在哪个名称空间的哪个分组下</strong></p>
<p>这里没有指定namespace, 但是是可以指定的</p>
<p><strong>注意,这里的dataid要与8401的服务名一致</strong></p>
<ul>
<li>在nacos中创建一个配置文件,dataId就是上面配置文件中指定的</li>
</ul>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409115909698.png" alt="image-20220409115909698"></p>
<p>注意：下面这个resource后的url一定要填写正确，否则无效</p>
<pre><code class="json">[
    &#123;
         &quot;resource&quot;: &quot;/rateLimit/byUrl&quot;,
         &quot;limitApp&quot;: &quot;default&quot;,
         &quot;grade&quot;:   1,
         &quot;count&quot;:   1,
         &quot;strategy&quot;: 0,
         &quot;controlBehavior&quot;: 0,
         &quot;clusterMode&quot;: false    
    &#125;
]
</code></pre>
<p><img src="/2022/03/27/1513842928408203264/images/image-20220409115945717.png" alt="image-20220409115945717"></p>
<p><strong>测试</strong></p>
<p>启动8401,访问localhost:8401&#x2F;rateLimit&#x2F;byUrl</p>
<p>在sentinel中可以看到,直接读取到了规则</p>
<p>此时重启8401,如果sentinel又可以正常读取到规则,那么证明持久化成功</p>

							</div>
				</div>
			</div>
		</div>
		
			<ul id="toTopBtn" class="layui-fixbar" style="display: none;"><a href="javascript:void(0)">
					<li class="layui-icon layui-fixbar-top" lay-type="top" style="display: list-item;"></li>
				</a></ul>
			
				<!-- 底部版权 -->
				<div class="qy-footer">
    <div class="font-Area">
        Copyright © 2018~<span id="currentYear">2022</span> Heliufang All Rights Reserved
    </div>
</div>

<script>
    //随机背景线条 https://blog.csdn.net/qq526362801/article/details/108863458
    function DynamicLine() {
        function n(n, e, t) {
            return n.getAttribute(e) || t
        }

        function e(n) {
            return document.getElementsByTagName(n)
        }

        function t() {
            var t = e("script"),
                o = t.length,
                i = t[o - 1];
            return {
                l: o,
                z: n(i, "zIndex", -1),
                o: n(i, "opacity", .5),
                c: n(i, "color", "0,0,50"), //颜色rgb
                n: n(i, "count", 99)
            }
        }

        function o() {
            a = m.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
                c = m.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
        }

        function i() {
            r.clearRect(0, 0, a, c);
            var n, e, t, o, m, l;
            s.forEach(function (i, x) {
                for (i.x += i.xa, i.y += i.ya, i.xa *= i.x > a || i.x < 0 ? -1 : 1, i.ya *= i.y > c || i.y < 0 ? -1 : 1, r.fillRect(
                    i.x - .5, i.y - .5, 1, 1), e = x + 1; e < u.length; e++) n = u[e],
                        null !== n.x && null !== n.y && (o = i.x - n.x, m = i.y - n.y,
                            l = o * o + m * m, l < n.max && (n === y && l >= n.max / 2 && (i.x -= .03 * o, i.y -= .03 * m),
                                t = (n.max - l) / n.max, r.beginPath(), r.lineWidth = t / 2, r.strokeStyle = "rgba(" + d.c + "," + (t + .2) +
                                ")", r.moveTo(i.x, i.y), r.lineTo(n.x, n.y), r.stroke()))
            }),
                x(i)
        }
        var a, c, u, m = document.createElement("canvas"),
            d = t(),
            l = "c_n" + d.l,
            r = m.getContext("2d"),
            x = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window
                .oRequestAnimationFrame || window.msRequestAnimationFrame ||
                function (n) {
                    window.setTimeout(n, 1e3 / 45)
                },
            w = Math.random,
            y = {
                x: null,
                y: null,
                max: 2e4
            };
        m.id = l, m.style.cssText = "position:fixed;top:0;left:0;z-index:" + d.z + ";opacity:" + d.o, e("body")[0].appendChild(
            m), o(), window.onresize = o,
            window.onmousemove = function (n) {
                n = n || window.event, y.x = n.clientX, y.y = n.clientY
            },
            window.onmouseout = function () {
                y.x = null, y.y = null
            };
        for (var s = [], f = 0; d.n > f; f++) {
            var h = w() * a,
                g = w() * c,
                v = 2 * w() - 1,
                p = 2 * w() - 1;
            s.push({
                x: h,
                y: g,
                xa: v,
                ya: p,
                max: 6e3
            })
        }
        u = s.concat([y]),
            setTimeout(function () {
                i()
            }, 100)
    }
    
    //随机背景线条
    DynamicLine()


    document.querySelector("#currentYear").innerText = new Date().getFullYear()
</script>
</body>
<script src="../../../../../js/jquery.min.js"></script>
<script src="../../../../../layui/layui.js"></script>
<!-- 鼠标点击特效 -->
<script src="../../../../../js/mouse.js"></script>
<!-- 代码高亮 -->
<script src="../../../../../lib/prism/prism.js"></script>
<script>
	//注意：导航 依赖 element 模块，否则无法进行功能性操作
	var element = null
	var layer = null
	layui.use(['element', 'layer'], function () {
		element = layui.element;
		layer = layui.layer
	});
	
		$(function () {
			var elm = $('#toc-area');
			var startPos = $(elm).offset().top;
			var totalTop = $(document).height();
			$.event.add(window, "scroll", function () {
				var p = $(window).scrollTop();
				//文章阅读进度条
				var percent = ((p / totalTop) * 100).toFixed(2)
				if (percent > 100) {
					percent = 100
				}
				if (percent == 0) {
					percent = 0
				}
				element.progress('demo', percent + "%");
				$("#progressTxt").text(percent)
				//固定文章目录
				console.log('p', p, "startPos", startPos)
				$(elm).css('position', (p > startPos) ? 'fixed' : 'static');
				$(elm).css('top', (p > startPos) ? '60px' : '');
				//文章目录随页面滚动  //https://qzy.im/blog/2020/02/generate-article-catalogs-and-switch-catalog-following-article-s-scroll-using-javascript/
				$('#tocMain').scrollTop($('#tocMain .toc').height() * percent * 0.01);
				//显示与隐藏置顶按钮
				$("#toTopBtn").css('display', p > 0 ? 'block' : 'none');
			});
			//代码高亮
			$('pre code').each(function () {
				var codeType = $(this).attr("class")
				codeType = codeType == undefined || codeType == "" || codeType == null ? "plaintext" : codeType
				codeType = "language-" + codeType
				$(this).attr("class", codeType)
			})
			//代码复制以及显示代码语言
			$("pre").prepend('<div class="copy-to-clipboard-button"></div>');
			//点击回到顶部
			//增加scrollTop的动画效果,使用定时器，将scrollTop的值每次减少50(减少六十分之一)，直到减少到0，则动画完毕
			$("#toTopBtn").click(function () {
				var oTop = document.body.scrollTop || document.documentElement.scrollTop;
				var t = parseInt(oTop / 60) //每次六十分之一
				var time = setInterval(function () {
					// document.body.scrollTop = document.body.scrollTop - 50;
					document.body.scrollTop = document.body.scrollTop - t;
					if (document.body.scrollTop === 0) {
						clearInterval(time);
					}
				}, 1);
			})
		});
	
</script>

</html>